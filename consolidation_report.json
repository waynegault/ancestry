{
  "functions": [
    {
      "module_path": "action10.py",
      "qualname": "get_cached_gedcom",
      "lineno": 92,
      "end_lineno": 102,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 11,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f4aa8cbe3e521f8e71031c3c3af406cc15bba42e",
      "simhash64": 8641136711958963203,
      "normalized": "def NAME ( ) -> NAME [ NAME ] : LIT global NAME if NAME is None : NAME = NAME . NAME . NAME if NAME and NAME . NAME . NAME else None if NAME and NAME ( NAME ) . NAME ( ) : NAME ( f\" \ud83d\udcc2 Loading GEDCOM: { NAME ( NAME ) . NAME } \" ) NAME = NAME ( NAME ( NAME ) ) if NAME : NAME ( f\" \u2705 GEDCOM loaded: { NAME ( NAME . NAME ) } individuals \" ) return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "enable_mock_mode",
      "lineno": 109,
      "end_lineno": 126,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 18,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "fb97898b257116787fc8c2668a4939b15f269065",
      "simhash64": 8640705670181983235,
      "normalized": "def NAME ( ) -> None : LIT global NAME NAME = True NAME . NAME ( LIT )"
    },
    {
      "module_path": "action10.py",
      "qualname": "disable_mock_mode",
      "lineno": 129,
      "end_lineno": 145,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 17,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7dabf6bb1d992a1b1ab5ea812f5509938b7ac268",
      "simhash64": 6299397363625006187,
      "normalized": "def NAME ( ) -> None : LIT global NAME NAME = False"
    },
    {
      "module_path": "action10.py",
      "qualname": "is_mock_mode",
      "lineno": 148,
      "end_lineno": 150,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "3140307c015cf6691ad5a38fc8fae0b0658afea9",
      "simhash64": 7492851299204895843,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_format_search_criteria",
      "lineno": 153,
      "end_lineno": 159,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:tiny"
      ],
      "signature": "(search_criteria)",
      "fingerprint": "2af11ee850c4184a82b368d42c21eeee582be0cc",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT NAME = [ LIT ] for NAME , NAME in NAME . NAME ( ) : if NAME is not None : NAME . NAME ( f\" { NAME } : { NAME } \" ) return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_format_candidate_data",
      "lineno": 162,
      "end_lineno": 172,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(candidate_data)",
      "fingerprint": "a0126f0c577d1ec306b58aadc7b2fdf897abcff2",
      "simhash64": 5146308216747365435,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT NAME = [ LIT ] NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : if NAME in NAME : NAME . NAME ( f\" { NAME } : { NAME [ NAME ] } \" ) return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_format_scoring_weights",
      "lineno": 175,
      "end_lineno": 180,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:tiny"
      ],
      "signature": "(scoring_weights)",
      "fingerprint": "558075738c3d58259ac071176ae2837809dfd588",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT NAME = [ LIT ] for NAME , NAME in NAME . NAME ( ) : NAME . NAME ( f\" { NAME } : { NAME } \" ) return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_format_field_analysis",
      "lineno": 183,
      "end_lineno": 195,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(field_scores)",
      "fingerprint": "be55a98d193c075d34b1cd4c7bb4211a52f2f140",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME ] , NAME ] : LIT NAME = [ LIT ] NAME = LIT for NAME , NAME in NAME . NAME ( ) : if NAME > LIT : NAME . NAME ( f\" \u2705 { NAME } : { NAME } points \" ) NAME += NAME else : NAME . NAME ( f\" \u274c { NAME } : 0 points \" ) return NAME , NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_format_score_verification",
      "lineno": 198,
      "end_lineno": 211,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(total_score, total_calculated)",
      "fingerprint": "4743c68cd5bdfcb8c0b43184fbc7c2ebc8b7c9df",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME ] : LIT NAME = [ LIT ] NAME . NAME ( f\" Total Score Returned: { NAME } \" ) NAME . NAME ( f\" Sum of Field Scores: { NAME } \" ) NAME . NAME ( f\" Difference: { NAME ( NAME - NAME ) } \" ) NAME = LIT if NAME ( NAME - NAME ) > NAME : NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "detailed_scoring_breakdown",
      "lineno": 214,
      "end_lineno": 256,
      "is_method": false,
      "is_async": false,
      "args_count": 8,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 43,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(test_name, search_criteria, candidate_data, scoring_weights, date_flex, total_score, field_scores, reasons)",
      "fingerprint": "adf341d5974bec1502ce327a60b1ef05033381df",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] , ) -> NAME : LIT NAME = [ ] NAME . NAME ( f\" \\n { LIT * LIT } \" ) NAME . NAME ( f\" \ud83d\udd0d DETAILED SCORING BREAKDOWN: { NAME } \" ) NAME . NAME ( f\" { LIT * LIT } \" ) # Add formatted sections NAME . NAME ( NAME ( NAME ) ) NAME . NAME ( NAME ( NAME ) ) NAME . NAME ( NAME ( NAME ) ) # Date flexibility NAME . NAME ( LIT ) for NAME , NAME in NAME . NAME ( ) : NAME . NAME ( f\" { NAME } : { NAME } \" ) # Field analysis NAME , NAME = NAME ( NAME ) NAME . NAME ( NAME ) # Match reasons NAME . NAME ( LIT ) for NAME in NAME : NAME . NAME ( f\" \u2022 { NAME } \" ) # Score verification NAME . NAME ( NAME ( NAME , NAME ) ) # Test person analysis NAME . NAME ( NAME ( NAME , NAME ) ) NAME . NAME ( f\" { LIT * LIT } \" ) return LIT . NAME ( NAME )"
    },
    {
      "module_path": "action10.py",
      "qualname": "_format_test_person_analysis",
      "lineno": 259,
      "end_lineno": 288,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 30,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "(field_scores, total_score)",
      "fingerprint": "4bcb8621168791eef8cb395e75ef6bac3ac2fecd",
      "simhash64": 7451729013564150827,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME [ NAME ] : LIT NAME = [ LIT ] # Map field codes to expected scores for test person NAME = { LIT : LIT , # Contains first name (Fraser) LIT : LIT , # Contains surname (Gault) LIT : LIT , # Gender match (M) LIT : LIT , # Birth year match (1941) LIT : LIT , # Birth place contains (Banff) LIT : LIT , # Bonus birth info (year + place) LIT : LIT , # Death dates both absent LIT : LIT , # Bonus both names contain } NAME . NAME ( LIT ) NAME = LIT for NAME , NAME in NAME . NAME ( ) : NAME = NAME . NAME ( NAME , LIT ) NAME = LIT if NAME > LIT else LIT NAME += NAME if NAME > LIT else LIT NAME . NAME ( f\" { NAME } : Expected { NAME } , Got { NAME } { NAME } \" ) NAME . NAME ( f\" Total Expected: { NAME } \" ) NAME . NAME ( f\" Total Actual: { NAME } \" ) NAME = LIT if NAME ( NAME - NAME ) <= LIT else LIT NAME . NAME ( f\" Score Match: { NAME } \" ) return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "sanitize_input",
      "lineno": 292,
      "end_lineno": 320,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 29,
      "tags": [
        "impure",
        "size:small"
      ],
      "signature": "(value)",
      "fingerprint": "5afb132ed12cf5314bed7082a288ec6569fc4a18",
      "simhash64": 7488250391791842307,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT if not NAME : return None # Remove leading/trailing whitespace NAME = NAME . NAME ( ) return NAME if NAME else None"
    },
    {
      "module_path": "action10.py",
      "qualname": "_is_valid_year",
      "lineno": 323,
      "end_lineno": 325,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(year)",
      "fingerprint": "764c9d4a9ab6b2b0c298b98da743890a5a9e1992",
      "simhash64": 5150943758910915627,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return LIT <= NAME <= LIT"
    },
    {
      "module_path": "action10.py",
      "qualname": "_try_simple_year_parsing",
      "lineno": 328,
      "end_lineno": 333,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(value)",
      "fingerprint": "6efe2062a8872abc1338cb9fc1d45224c47b91e1",
      "simhash64": 8641101531882370051,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT if NAME . NAME ( ) : NAME = NAME ( NAME ) return NAME if NAME ( NAME ) else None return None"
    },
    {
      "module_path": "action10.py",
      "qualname": "_try_dateparser_parsing",
      "lineno": 336,
      "end_lineno": 348,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(value)",
      "fingerprint": "ad6ead5cbc111c37663920d9ae44ed04fc5e1484",
      "simhash64": 8641101527586878547,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT try : import NAME NAME = NAME . NAME ( NAME ) if NAME : NAME = NAME . NAME return NAME if NAME ( NAME ) else None except NAME : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" dateparser failed to parse ' { NAME } ': { NAME } \" ) return None"
    },
    {
      "module_path": "action10.py",
      "qualname": "_try_regex_year_extraction",
      "lineno": 351,
      "end_lineno": 358,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "regex",
        "size:tiny"
      ],
      "signature": "(value)",
      "fingerprint": "ddd68c9de18f68c399e0f5a5c1f3a435a7b8ce0a",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT import NAME NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME = NAME ( NAME . NAME ( LIT ) ) return NAME if NAME ( NAME ) else None return None"
    },
    {
      "module_path": "action10.py",
      "qualname": "get_validated_year_input",
      "lineno": 361,
      "end_lineno": 381,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 21,
      "tags": [
        "impure",
        "purpose:validation",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(prompt, default)",
      "fingerprint": "02bb8cbc4993a6b307cda62aaba2e0e36a8787a4",
      "simhash64": 7488180022981071891,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] = None ) -> NAME [ NAME ] : LIT NAME = f\" [ { NAME } ] \" if NAME else LIT NAME = NAME ( f\" { NAME } { NAME } : \" ) . NAME ( ) if not NAME and NAME : return NAME if not NAME : return None # Try different parsing methods in order of preference for NAME in [ NAME , NAME , NAME ] : NAME = NAME ( NAME ) if NAME is not None : return NAME NAME . NAME ( f\" Invalid year input ' { NAME } ', ignoring. \" ) return None"
    },
    {
      "module_path": "action10.py",
      "qualname": "parse_command_line_args",
      "lineno": 384,
      "end_lineno": 393,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "994016f08491e052da6291bdbadb9ceeec8ed059",
      "simhash64": 7487757815883666443,
      "normalized": "def NAME ( ) -> NAME . NAME : LIT NAME = NAME . NAME ( NAME = LIT ) NAME . NAME ( LIT , NAME = LIT , NAME = LIT ) NAME . NAME ( LIT , NAME = LIT ) NAME . NAME ( LIT , NAME = LIT ) NAME . NAME ( LIT , NAME = NAME , NAME = LIT , NAME = LIT ) return NAME . NAME ( )"
    },
    {
      "module_path": "action10.py",
      "qualname": "_validate_gedcom_file_path",
      "lineno": 396,
      "end_lineno": 414,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 19,
      "tags": [
        "impure",
        "filesystem",
        "purpose:validation",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "42329c24baf3c80f0973a989c6df1d4bac5a0d46",
      "simhash64": 8641136711958955011,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = ( NAME . NAME . NAME if NAME else None ) if ( not NAME or not NAME ( NAME , NAME ) or not NAME . NAME ( ) ) : NAME . NAME ( f\" GEDCOM file path missing or invalid: { NAME } . Auto-enabling mock mode. \" ) NAME ( ) # Create a dummy path for mock mode NAME = NAME ( LIT ) return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_get_reference_person_info",
      "lineno": 417,
      "end_lineno": 425,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "c53c809dee23888ed0d53a27f77d99edfa87b66c",
      "simhash64": 7488180027274998851,
      "normalized": "def NAME ( ) -> NAME [ NAME [ NAME ] , NAME ] : LIT NAME = ( NAME . NAME if NAME else None ) NAME = ( NAME . NAME if NAME else LIT ) return NAME , NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_get_scoring_config",
      "lineno": 428,
      "end_lineno": 454,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 27,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "465c831b733aeb7d02198b55f191263a3ca2b3d6",
      "simhash64": 5145886005356041259,
      "normalized": "def NAME ( ) -> NAME [ NAME [ NAME , NAME ] , NAME [ NAME , NAME ] , NAME ] : LIT NAME = ( NAME . NAME if NAME else LIT ) # Default flexibility NAME = { LIT : NAME ( NAME ) } # Convert to expected dictionary structure NAME = ( NAME ( NAME . NAME ) if NAME else { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } ) NAME = ( NAME . NAME if NAME else LIT ) return NAME , NAME , NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_log_configuration",
      "lineno": 457,
      "end_lineno": 468,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "(gedcom_file_path, reference_person_id, reference_person_name)",
      "fingerprint": "712525d7e08fd09aa99188c2cfaec81c0d5fd154",
      "simhash64": 7488215207352120403,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME ) -> None : LIT NAME . NAME ( f\" Configured TREE_OWNER_NAME: { NAME . NAME if NAME else LIT } \" ) NAME . NAME ( f\" Configured REFERENCE_PERSON_ID: { NAME } \" ) NAME . NAME ( f\" Configured REFERENCE_PERSON_NAME: { NAME } \" ) NAME . NAME ( f\" Using GEDCOM file: { NAME . NAME } \" )"
    },
    {
      "module_path": "action10.py",
      "qualname": "validate_config",
      "lineno": 471,
      "end_lineno": 493,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 23,
      "tags": [
        "impure",
        "filesystem",
        "purpose:validation",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d19c7efd870fb68ca30dc9840eb802e8c656ef6d",
      "simhash64": 5162070781083956243,
      "normalized": "def NAME ( ) -> NAME [ NAME [ NAME ] , NAME [ NAME ] , NAME [ NAME ] , NAME [ NAME , NAME ] , NAME [ NAME , NAME ] , NAME , ] : LIT NAME = NAME ( ) NAME , NAME = NAME ( ) NAME , NAME , NAME = NAME ( ) NAME ( NAME , NAME , NAME ) return ( NAME , NAME , NAME , NAME , NAME , NAME , )"
    },
    {
      "module_path": "action10.py",
      "qualname": "load_gedcom_data",
      "lineno": 498,
      "end_lineno": 548,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 7,
      "loc": 51,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(gedcom_path)",
      "fingerprint": "a38836f4322e10c331e2b9a3fc9dbc9f0005fa8e",
      "simhash64": 7487617073026602003,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT # PHASE 4.2: Ultra-fast mock mode for testing if NAME ( ) : NAME . NAME ( LIT ) return NAME . NAME ( ) # Auto-enable mock mode if GEDCOM file is missing if ( not NAME or not NAME ( NAME , NAME ) or not NAME . NAME ( ) ) : NAME . NAME ( f\" GEDCOM file not found: { NAME } . Auto-enabling mock mode for testing. \" ) NAME ( ) return NAME . NAME ( ) try : NAME . NAME ( LIT ) NAME = NAME . NAME ( ) NAME = NAME ( NAME ) NAME = NAME . NAME ( ) NAME . NAME ( f\" GEDCOM data loaded & processed successfully in { NAME - NAME : .2f } s. \" ) NAME . NAME ( f\" Index size: { NAME ( NAME ( NAME , LIT , { } ) ) } \" ) NAME . NAME ( f\" Pre-processed cache size: { NAME ( NAME ( NAME , LIT , { } ) ) } \" ) NAME . NAME ( f\" Build Times: Index= { NAME . NAME : .2f } s, Maps= { NAME . NAME : .2f } s, PreProcess= { NAME . NAME : .2f } s \" ) if not NAME . NAME or not NAME . NAME : NAME . NAME ( LIT ) raise NAME ( LIT ) return NAME except NAME as NAME : NAME . NAME ( f\" Failed to load or process GEDCOM file { NAME . NAME } : { NAME } \" , NAME = True , ) raise NAME ( f\" Failed to load or process GEDCOM file { NAME . NAME } : { NAME } \" ) from NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_create_input_getter",
      "lineno": 551,
      "end_lineno": 566,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "impure",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(args)",
      "fingerprint": "54d746f5c2de6afe179236a5763299f7053eaa7c",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME [ NAME . NAME ] ) -> NAME : LIT NAME = NAME ( NAME , LIT , None ) if NAME else None NAME = LIT def NAME ( NAME : NAME ) -> NAME : LIT nonlocal NAME if NAME and NAME < NAME ( NAME ) : NAME = NAME [ NAME ] NAME += LIT NAME . NAME ( f\" { NAME } { NAME } \" ) return NAME return NAME ( NAME ) . NAME ( ) return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "get_input",
      "lineno": 556,
      "end_lineno": 564,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "impure",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(prompt)",
      "fingerprint": "51c6e1c53993be32f12dda33bf1e9094022cf480",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT nonlocal NAME if NAME and NAME < NAME ( NAME ) : NAME = NAME [ NAME ] NAME += LIT NAME . NAME ( f\" { NAME } { NAME } \" ) return NAME return NAME ( NAME ) . NAME ( )"
    },
    {
      "module_path": "action10.py",
      "qualname": "_collect_basic_criteria",
      "lineno": 569,
      "end_lineno": 599,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 31,
      "tags": [
        "impure",
        "size:medium"
      ],
      "signature": "(get_input)",
      "fingerprint": "26c45f7eef520367916785197f9020e9cc06c6c6",
      "simhash64": 7487617074167452715,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( NAME ( LIT ) ) NAME = NAME ( NAME ( LIT ) ) NAME = NAME ( NAME ( LIT ) ) NAME = ( NAME [ LIT ] . NAME ( ) if NAME and NAME [ LIT ] . NAME ( ) in [ LIT , LIT ] else None ) NAME = NAME ( LIT ) NAME = NAME ( NAME ) if NAME . NAME ( ) else None NAME = NAME ( NAME ( LIT ) ) NAME = NAME ( LIT ) NAME = NAME ( NAME ) if NAME . NAME ( ) else None NAME = NAME ( NAME ( LIT ) ) return { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , }"
    },
    {
      "module_path": "action10.py",
      "qualname": "_create_date_objects",
      "lineno": 602,
      "end_lineno": 626,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 25,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(criteria)",
      "fingerprint": "f7afb24637151576a28eec088e5364ed1ff48aea",
      "simhash64": 5146308216814482455,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT NAME : NAME [ NAME ] = None if NAME [ LIT ] : try : NAME = NAME ( NAME [ LIT ] , LIT , LIT , NAME = NAME . NAME ) except NAME : NAME . NAME ( f\" Cannot create date object for birth year { NAME [ LIT ] } . \" ) NAME [ LIT ] = None NAME : NAME [ NAME ] = None if NAME [ LIT ] : try : NAME = NAME ( NAME [ LIT ] , LIT , LIT , NAME = NAME . NAME ) except NAME : NAME . NAME ( f\" Cannot create date object for death year { NAME [ LIT ] } . \" ) NAME [ LIT ] = None NAME [ LIT ] = NAME NAME [ LIT ] = NAME return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_build_filter_criteria",
      "lineno": 629,
      "end_lineno": 637,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(scoring_criteria)",
      "fingerprint": "43f6c1f8935d369dab37120a5f2a737626b8660e",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , }"
    },
    {
      "module_path": "action10.py",
      "qualname": "get_user_criteria",
      "lineno": 640,
      "end_lineno": 651,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "impure",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(args)",
      "fingerprint": "4a5e3dce90288a36b2a6a54025c6d2646e952bd9",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME [ NAME . NAME ] = None , ) -> NAME [ NAME [ NAME , NAME ] , NAME [ NAME , NAME ] ] : LIT NAME . NAME ( LIT ) NAME = NAME ( NAME ) NAME = NAME ( NAME ) NAME = NAME ( NAME ) NAME = NAME ( NAME ) return NAME , NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "log_criteria_summary",
      "lineno": 654,
      "end_lineno": 667,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(scoring_criteria, date_flex)",
      "fingerprint": "4b6960ecc0a52623c46ad508a6b247689a1753c1",
      "simhash64": 7487617074100343843,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> None : LIT NAME . NAME ( LIT ) for NAME , NAME in NAME . NAME ( ) : if NAME is not None and NAME not in [ LIT , LIT ] : NAME . NAME ( f\" { NAME . NAME ( LIT , LIT ) . NAME ( ) } : ' { NAME } ' \" ) NAME = NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" \\n--- OR Filter Logic (Year Range: +/- { NAME } ) --- \" ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "action10.py",
      "qualname": "matches_criterion",
      "lineno": 670,
      "end_lineno": 675,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(criterion_name, filter_criteria, candidate_value)",
      "fingerprint": "8fe0d9d137b4ca447ae86c43f4a171a778558e3b",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME : LIT NAME = NAME . NAME ( NAME ) return NAME ( NAME and NAME and NAME in NAME )"
    },
    {
      "module_path": "action10.py",
      "qualname": "matches_year_criterion",
      "lineno": 678,
      "end_lineno": 688,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(criterion_name, filter_criteria, candidate_value, year_range)",
      "fingerprint": "41ac64f1408420199eecc2feed1e6f596cbc9155",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] , NAME : NAME , ) -> NAME : LIT NAME = NAME . NAME ( NAME ) return NAME ( NAME and NAME and NAME ( NAME - NAME ) <= NAME )"
    },
    {
      "module_path": "action10.py",
      "qualname": "calculate_match_score_cached",
      "lineno": 691,
      "end_lineno": 721,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 31,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(search_criteria, candidate_data, scoring_weights, date_flex, cache)",
      "fingerprint": "bf9adcab6d9522bdd7abaf196b7ae96308dc88e2",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME | NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME [ NAME , NAME ] ] = None , ) -> NAME [ NAME , NAME [ NAME , NAME ] , NAME [ NAME ] ] : LIT if NAME is None : NAME = { } # Create a hash key from the relevant parts of the inputs # We use a tuple of immutable representations of the data NAME = NAME ( NAME ( ( NAME , NAME ( NAME ) ) for NAME , NAME in NAME . NAME ( ) if NAME is not None ) ) NAME = NAME ( NAME ( ( NAME , NAME ( NAME ) ) for NAME , NAME in NAME . NAME ( ) if NAME in NAME ) ) NAME = ( NAME , NAME ) if NAME not in NAME : NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) NAME [ NAME ] = NAME return NAME [ NAME ]"
    },
    {
      "module_path": "action10.py",
      "qualname": "_get_mock_filtering_results",
      "lineno": 727,
      "end_lineno": 738,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "35d781942e3a2bda2eb5645a7f2cab8263d4f588",
      "simhash64": 5145877209317545003,
      "normalized": "def NAME ( ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME . NAME ( LIT ) return [ { LIT : LIT , # Test expects \"id\" field LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } ]"
    },
    {
      "module_path": "action10.py",
      "qualname": "_extract_individual_data",
      "lineno": 741,
      "end_lineno": 754,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(indi_data)",
      "fingerprint": "a139c0497e71443afcc1905403be351fc3b753ab",
      "simhash64": 7451729014636844075,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME ( LIT , LIT ) . NAME ( ) , LIT : NAME . NAME ( LIT , LIT ) . NAME ( ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : ( NAME . NAME ( LIT , LIT ) . NAME ( ) if NAME . NAME ( LIT ) else None ) , LIT : NAME . NAME ( LIT ) , }"
    },
    {
      "module_path": "action10.py",
      "qualname": "_evaluate_filter_criteria",
      "lineno": 757,
      "end_lineno": 789,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 33,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(extracted_data, filter_criteria, year_range)",
      "fingerprint": "09a1a98c6b30edd0f2e1db4ec954f1704aa975eb",
      "simhash64": 5182337013766337539,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME : LIT NAME = NAME ( LIT , NAME , NAME [ LIT ] ) NAME = NAME ( LIT , NAME , NAME [ LIT ] ) NAME = NAME ( NAME . NAME ( LIT ) and NAME [ LIT ] and NAME [ LIT ] == NAME [ LIT ] ) NAME = NAME ( LIT , NAME , NAME [ LIT ] ) NAME = NAME ( LIT , NAME , NAME [ LIT ] , NAME ) NAME = NAME [ LIT ] is None return ( NAME or NAME or NAME or NAME or NAME or NAME )"
    },
    {
      "module_path": "action10.py",
      "qualname": "_create_match_data",
      "lineno": 792,
      "end_lineno": 813,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 22,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(indi_id_norm, indi_data, total_score, field_scores, reasons)",
      "fingerprint": "4a255cc8166946915d747eef2a7de780cee40a2b",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] , ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME , LIT : NAME . NAME ( LIT , NAME ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME , # Store the raw data for detailed analysis }"
    },
    {
      "module_path": "action10.py",
      "qualname": "_process_individual",
      "lineno": 816,
      "end_lineno": 852,
      "is_method": false,
      "is_async": false,
      "args_count": 8,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 37,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(indi_id_norm, indi_data, filter_criteria, scoring_criteria, scoring_weights, date_flex, year_range, score_cache)",
      "fingerprint": "21cbaeb8144a968584cdff4317194d7267a86e2e",
      "simhash64": 7452151225961067539,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME : NAME [ NAME , NAME ] , ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : NAME = NAME ( NAME ) if NAME ( NAME , NAME , NAME ) : # Calculate match score with caching for performance NAME , NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) return NAME ( NAME , NAME , NAME , NAME , NAME ) except NAME as NAME : NAME . NAME ( f\" Value error processing individual { NAME } : { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Missing key for individual { NAME } : { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Error processing individual { NAME } : { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "action10.py",
      "qualname": "filter_and_score_individuals",
      "lineno": 855,
      "end_lineno": 914,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 60,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(gedcom_data, filter_criteria, scoring_criteria, scoring_weights, date_flex)",
      "fingerprint": "36bc3e7fa41f9316573cefd46a091fd10a648300",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , ) -> NAME [ NAME [ NAME , NAME ] ] : LIT # PHASE 4.2: Ultra-fast mock mode for testing if NAME ( ) : return NAME ( ) NAME . NAME ( LIT ) NAME = NAME . NAME ( ) # Get the year range for matching from configuration NAME = NAME . NAME ( LIT , LIT ) # For caching match scores NAME = { } NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] # For progress tracking NAME = NAME ( NAME . NAME ) NAME = NAME ( LIT , NAME // LIT ) # Update every 10% NAME . NAME ( f\" Processing { NAME } individuals from cache... \" ) for NAME , ( NAME , NAME ) in NAME ( NAME . NAME . NAME ( ) , NAME = LIT ) : # Show progress updates if NAME % NAME == LIT : NAME = ( NAME / NAME ) * LIT NAME . NAME ( f\" Processing: { NAME : .1f } % complete ( { NAME } / { NAME } ) \" ) NAME = NAME ( NAME , NAME , NAME , NAME , NAME , NAME , NAME , NAME , ) if NAME : NAME . NAME ( NAME ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Filtering & Scoring completed in { NAME : .2f } s. \" ) NAME . NAME ( f\" Found { NAME ( NAME ) } individual(s) matching OR criteria and scored. \" ) return NAME ( NAME , NAME = lambda NAME : NAME [ LIT ] , NAME = True )"
    },
    {
      "module_path": "action10.py",
      "qualname": "format_display_value",
      "lineno": 917,
      "end_lineno": 952,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 36,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "(value, max_width)",
      "fingerprint": "0829c904cd24abccd82f5608537708dd501517fe",
      "simhash64": 7488180024054813723,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT if NAME is None : NAME = LIT elif NAME ( NAME , ( NAME , NAME ) ) : NAME = f\" { NAME : .0f } \" else : NAME = NAME ( NAME ) if NAME ( NAME ) > NAME : NAME = NAME [ : NAME - LIT ] + LIT return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_extract_field_scores",
      "lineno": 955,
      "end_lineno": 969,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(candidate)",
      "fingerprint": "1308c08528999be165f8fbfaac7e9077931f66ac",
      "simhash64": 5145886005423150123,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME ( LIT , { } ) return { LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , }"
    },
    {
      "module_path": "action10.py",
      "qualname": "_calculate_display_bonuses",
      "lineno": 972,
      "end_lineno": 982,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(scores)",
      "fingerprint": "93b9a376caff3c678eef01a651ac7af16654c3be",
      "simhash64": 5145885996833215531,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( NAME [ LIT ] , NAME [ LIT ] ) NAME = NAME ( NAME [ LIT ] , NAME [ LIT ] ) return { LIT : NAME , LIT : NAME , LIT : LIT if ( NAME > LIT and NAME [ LIT ] > LIT ) else LIT , LIT : LIT if ( NAME > LIT and NAME [ LIT ] > LIT ) else LIT , }"
    },
    {
      "module_path": "action10.py",
      "qualname": "_format_name_display",
      "lineno": 985,
      "end_lineno": 993,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:tiny"
      ],
      "signature": "(candidate, scores)",
      "fingerprint": "2f289cac7114c77b64b83a605e048c52e50cdb2b",
      "simhash64": 7452151226028176403,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , LIT ) NAME = NAME [ : LIT ] + ( LIT if NAME ( NAME ) > LIT else LIT ) NAME = NAME [ LIT ] + NAME [ LIT ] NAME = f\" [ { NAME } ] \" if NAME [ LIT ] > LIT : NAME += f\" [+ { NAME [ LIT ] } ] \" return f\" { NAME } { NAME } \""
    },
    {
      "module_path": "action10.py",
      "qualname": "_format_gender_display",
      "lineno": 996,
      "end_lineno": 1002,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:tiny"
      ],
      "signature": "(candidate, scores)",
      "fingerprint": "1098112be4397fc3d4f0a6f2733968deaa798206",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , LIT ) NAME = ( NAME ( NAME ) . NAME ( ) if NAME is not None else LIT ) return f\" { NAME } [ { NAME [ LIT ] } ] \""
    },
    {
      "module_path": "action10.py",
      "qualname": "_format_birth_displays",
      "lineno": 1005,
      "end_lineno": 1022,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 18,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(candidate, scores, bonuses)",
      "fingerprint": "46865f0f561cd7fa6d637c09568e4f20e5393943",
      "simhash64": 7452151225961067539,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT # Birth date display NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = f\" [ { NAME [ LIT ] } ] \" NAME = f\" { NAME } { NAME } \" # Birth place display NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME ) if NAME is not None else LIT NAME = NAME [ : LIT ] + ( LIT if NAME ( NAME ) > LIT else LIT ) NAME = f\" { NAME } [ { NAME [ LIT ] } ] \" if NAME [ LIT ] > LIT : NAME += f\" [+ { NAME [ LIT ] } ] \" return NAME , NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_format_death_displays",
      "lineno": 1025,
      "end_lineno": 1042,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 18,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(candidate, scores, bonuses)",
      "fingerprint": "66caad3d9c3ae55c136986f61677cfd34ed7102e",
      "simhash64": 7452151225961067539,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT # Death date display NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = f\" [ { NAME [ LIT ] } ] \" NAME = f\" { NAME } { NAME } \" # Death place display NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME ) if NAME is not None else LIT NAME = NAME [ : LIT ] + ( LIT if NAME ( NAME ) > LIT else LIT ) NAME = f\" { NAME } [ { NAME [ LIT ] } ] \" if NAME [ LIT ] > LIT : NAME += f\" [+ { NAME [ LIT ] } ] \" return NAME , NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_create_table_row",
      "lineno": 1045,
      "end_lineno": 1066,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 22,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(candidate)",
      "fingerprint": "07a6fb892185d6a2939d89b4f688fc7c576544c1",
      "simhash64": 7488180024053761043,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT NAME = NAME ( NAME ) NAME = NAME ( NAME ) NAME = NAME ( NAME , NAME ) NAME = NAME ( NAME , NAME ) NAME , NAME = NAME ( NAME , NAME , NAME ) NAME , NAME = NAME ( NAME , NAME , NAME ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) return [ NAME ( NAME . NAME ( LIT , LIT ) ) , NAME , NAME , NAME , NAME , NAME , NAME , NAME ( NAME ) , ]"
    },
    {
      "module_path": "action10.py",
      "qualname": "_display_results_table",
      "lineno": 1069,
      "end_lineno": 1081,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 13,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(table_data, headers)",
      "fingerprint": "071588e2ba6822f9b02fb5ad31c1aaa22c7b7532",
      "simhash64": 7488180023047132163,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME ] ] , NAME : NAME [ NAME ] ) -> None : LIT if NAME is not None : # Use tabulate if available NAME = NAME ( NAME , NAME = NAME , NAME = LIT ) for NAME in NAME . NAME ( LIT ) : NAME . NAME ( NAME ) else : # Fallback to simple formatting if tabulate is not available NAME . NAME ( LIT . NAME ( NAME ) ) NAME . NAME ( LIT * LIT ) for NAME in NAME : NAME . NAME ( LIT . NAME ( NAME ) )"
    },
    {
      "module_path": "action10.py",
      "qualname": "display_top_matches",
      "lineno": 1084,
      "end_lineno": 1122,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 39,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "(scored_matches, max_results)",
      "fingerprint": "af518dfe8f5ea8e89bbb8a872a7c8563787cb8e6",
      "simhash64": 7488180022980023347,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME . NAME ( f\" \\n=== SEARCH RESULTS (Top { NAME } Matches) === \" ) if not NAME : NAME . NAME ( LIT ) return None NAME = NAME [ : NAME ] NAME . NAME ( f\" Displaying top { NAME ( NAME ) } of { NAME ( NAME ) } scored matches: \" ) # Prepare table data NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] # Process each match for display NAME = [ NAME ( NAME ) for NAME in NAME ] # Display table NAME ( NAME , NAME ) if NAME ( NAME ) > NAME ( NAME ) : NAME . NAME ( f\" ... and { NAME ( NAME ) - NAME ( NAME ) } more matches not shown. \" ) return NAME [ LIT ] if NAME else None"
    },
    {
      "module_path": "action10.py",
      "qualname": "display_relatives",
      "lineno": 1126,
      "end_lineno": 1165,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 40,
      "tags": [
        "impure",
        "logging",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "(gedcom_data, individual)",
      "fingerprint": "4f14d36ac4d9f4f6f98f5dab6ec828f3960b9810",
      "simhash64": 7487757811589747755,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT # PHASE 4.2: Ultra-fast mock mode if NAME ( ) : NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) return NAME = { LIT : NAME . NAME ( NAME , LIT ) , LIT : NAME . NAME ( NAME , LIT ) , LIT : NAME . NAME ( NAME , LIT ) , LIT : NAME . NAME ( NAME , LIT ) , } for NAME , NAME in NAME . NAME ( ) : NAME ( f\" \\n { NAME } : \" ) if not NAME : NAME ( LIT ) continue for NAME in NAME : if not NAME : continue # Use the format_relative_info function from gedcom_utils NAME = NAME ( NAME ) # Add a dash at the beginning to match action11 format if not NAME . NAME ( ) . NAME ( LIT ) : NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" { NAME } \" )"
    },
    {
      "module_path": "action10.py",
      "qualname": "_display_mock_analysis",
      "lineno": 1169,
      "end_lineno": 1178,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "impure",
        "filesystem",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(top_match, reference_person_name)",
      "fingerprint": "e7f047b746bd45d423a78a41b9337d4757d84aba",
      "simhash64": 7434136828525319227,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> None : LIT NAME . NAME ( f\" \ud83c\udfaf Top Match Analysis: { NAME . NAME ( LIT , LIT ) } \" ) NAME . NAME ( f\" Score: { NAME . NAME ( LIT , LIT ) } /100 \" ) NAME . NAME ( f\" Relationship Path: { NAME } \u2192 Great Uncle \u2192 John Smith \" ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "action10.py",
      "qualname": "_get_match_display_info",
      "lineno": 1181,
      "end_lineno": 1199,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(top_match)",
      "fingerprint": "3c99c393843b52adf8ef7260d30dab2171e90a43",
      "simhash64": 7452080858291672123,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME , NAME ] : LIT NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) # Get birth and death years for display NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT ) NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT ) # Format years display NAME = LIT if NAME and NAME : NAME = f\" ( { NAME } - { NAME } ) \" elif NAME : NAME = f\" (b. { NAME } ) \" elif NAME : NAME = f\" (d. { NAME } ) \" return NAME , NAME , NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_display_match_header",
      "lineno": 1202,
      "end_lineno": 1204,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:tiny"
      ],
      "signature": "(display_name, years_display, score)",
      "fingerprint": "355ffa717fe77e2ec187050436b26a0521bd700b",
      "simhash64": 7452221595780027451,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) -> None : LIT NAME . NAME ( f\" \\n=== { NAME } { NAME } (score: { NAME : .0f } ) ===\\n \" )"
    },
    {
      "module_path": "action10.py",
      "qualname": "_handle_same_person_case",
      "lineno": 1207,
      "end_lineno": 1212,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "impure",
        "filesystem",
        "size:tiny"
      ],
      "signature": "(display_name, reference_person_name)",
      "fingerprint": "b013139554860e39f776432a1a9ff30eb5387ff4",
      "simhash64": 8605107914941043771,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT NAME . NAME ( f\" \\n\\n===Relationship Path to { NAME } === \" ) NAME . NAME ( f\" { NAME } is the reference person ( { NAME } ). \" )"
    },
    {
      "module_path": "action10.py",
      "qualname": "_calculate_relationship_path",
      "lineno": 1215,
      "end_lineno": 1267,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 53,
      "tags": [
        "impure",
        "filesystem",
        "size:medium"
      ],
      "signature": "(gedcom_data, top_match_norm_id, reference_person_id_norm, display_name, reference_person_name)",
      "fingerprint": "257fd1aab0cbf6969cb94e1d9b66cdc8e07bac0a",
      "simhash64": 7488180022981071931,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , ) -> None : LIT # Log the API URL for debugging purposes NAME = ( NAME ( NAME , LIT , LIT ) if NAME else LIT ) NAME = f\" /family-tree/person/tree/ { NAME } /person/ { NAME } /getladder?callback=no \" NAME . NAME ( f\" API URL: { NAME } \" ) if NAME ( NAME , NAME ) and NAME ( NAME , NAME ) : # Find the relationship path using the consolidated function NAME = NAME ( NAME , NAME , NAME . NAME , NAME . NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # Convert the GEDCOM path to the unified format NAME = NAME ( NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , ) if NAME : # Format the path using the unified formatter NAME = NAME ( NAME , NAME , NAME , None ) # Print the formatted relationship path NAME . NAME ( NAME ) else : # Just log an error message if conversion failed NAME . NAME ( f\" \\n\\n===Relationship Path to { NAME } === \" ) NAME . NAME ( f\" (Error: Could not determine relationship path for { NAME } ) \" ) else : NAME . NAME ( LIT )"
    },
    {
      "module_path": "action10.py",
      "qualname": "analyze_top_match",
      "lineno": 1270,
      "end_lineno": 1312,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 43,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(gedcom_data, top_match, reference_person_id_norm, reference_person_name)",
      "fingerprint": "6091afa70cbf8a37f68fd1980635024c930a51a7",
      "simhash64": 7488180022981075987,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] , NAME : NAME , ) -> None : LIT # PHASE 4.2: Ultra-fast mock mode if NAME ( ) : NAME ( NAME , NAME ) return NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( NAME ) if not NAME : NAME . NAME ( f\" Could not retrieve Individual record for top match ID: { NAME } \" ) return NAME , NAME , NAME = NAME ( NAME ) NAME ( NAME , NAME , NAME ) # Display relatives NAME ( NAME , NAME ) # Check for relationship path if not NAME : NAME . NAME ( LIT ) return # Display relationship path if NAME == NAME : NAME ( NAME , NAME ) elif NAME : NAME ( NAME , NAME , NAME , NAME , NAME )"
    },
    {
      "module_path": "action10.py",
      "qualname": "_initialize_analysis",
      "lineno": 1315,
      "end_lineno": 1321,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "0f9aef9aaf10d1576f3a779941b9e521dee17861",
      "simhash64": 7488180027274998787,
      "normalized": "def NAME ( ) -> NAME [ NAME . NAME , NAME [ NAME , ... ] ] : LIT NAME . NAME ( LIT ) NAME = NAME ( ) NAME = NAME ( ) return NAME , NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_load_and_validate_gedcom",
      "lineno": 1324,
      "end_lineno": 1334,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "impure",
        "filesystem",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(gedcom_file_path)",
      "fingerprint": "e1545b8d46dd8ecae0684b63c0733fea0d15f65b",
      "simhash64": 7488180022980547587,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT if not NAME : return None NAME = NAME ( NAME ( NAME ) ) if not NAME : NAME . NAME ( LIT ) return None return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "_process_matches",
      "lineno": 1337,
      "end_lineno": 1362,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(gedcom_data, args, date_flex, scoring_weights, max_display_results)",
      "fingerprint": "d942c145f3409ad02828c72a1bc7b085723080f0",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME . NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME [ NAME ] : LIT # Get user criteria NAME , NAME = NAME ( NAME ) NAME ( NAME , NAME ) # Filter and score individuals NAME = NAME ( NAME , NAME , NAME , NAME , NAME , ) if not NAME : return None # Display top matches return NAME ( NAME , NAME )"
    },
    {
      "module_path": "action10.py",
      "qualname": "main",
      "lineno": 1370,
      "end_lineno": 1413,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 5,
      "loc": 44,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "0ada4d9ff4354e90faa8fa5cdebbf1448160d1e5",
      "simhash64": 7488250391724721195,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Initialize analysis NAME , NAME = NAME ( ) ( NAME , NAME , NAME , NAME , NAME , NAME , ) = NAME # Load and validate GEDCOM data NAME = NAME ( NAME ) if not NAME : return False # Process matches NAME = NAME ( NAME , NAME , NAME , NAME , NAME ) if not NAME : return False # Analyze top match NAME = ( NAME ( NAME ) if NAME else None ) NAME ( NAME , NAME , NAME , NAME or LIT , ) return True except NAME as NAME : NAME . NAME ( f\" Error in action10 main: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "action10.py",
      "qualname": "action10_module_tests",
      "lineno": 1418,
      "end_lineno": 2380,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 42,
      "yield_count": 0,
      "complexity": 59,
      "loc": 963,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "ac184c328fe9b676ad9683521368cdd647eeca8d",
      "simhash64": 7487617074101392443,
      "normalized": "def NAME ( ) -> NAME : LIT import NAME import NAME from NAME import ( NAME , NAME , NAME , NAME , NAME , NAME , ) # PHASE 4.2: Disable mock mode - use real GEDCOM data for testing NAME ( ) NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # --- TESTS --- def NAME ( NAME ) -> NAME : LIT return NAME def NAME ( ) -> None : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] NAME ( f\" \ud83d\udccb Testing availability of { NAME ( NAME ) } core functions: \" ) for NAME in NAME : NAME ( f\" \u2022 { NAME } \" ) try : NAME = [ ] NAME = [ ] for NAME in NAME : if NAME in NAME ( ) : NAME . NAME ( NAME ) if NAME ( NAME ( ) [ NAME ] ) : NAME . NAME ( NAME ) NAME ( f\" \u2705 { NAME } : Found and callable \" ) else : NAME ( f\" \u274c { NAME } : Found but not callable \" ) else : NAME ( f\" \u274c { NAME } : Not found \" ) # Test configuration NAME = NAME is not None NAME = ( NAME ( NAME , LIT ) if NAME else False ) NAME ( LIT ) NAME ( f\" Functions found: { NAME ( NAME ) } / { NAME ( NAME ) } \" ) NAME ( f\" Functions callable: { NAME ( NAME ) } / { NAME ( NAME ) } \" ) NAME ( f\" Config available: { NAME } \" ) NAME ( f\" Config has API: { NAME } \" ) assert NAME ( NAME ) == NAME ( NAME ) , f\" Missing functions: { NAME ( NAME ) - NAME ( NAME ) } \" assert NAME ( NAME ) == NAME ( NAME ) , f\" Non-callable functions: { NAME ( NAME ) - NAME ( NAME ) } \" assert NAME , LIT return True except ( NAME , NAME ) as NAME : NAME ( f\" \u274c Module initialization failed: { NAME } \" ) return True # Skip if config is missing in test env def NAME ( ) -> None : LIT NAME ( LIT ) try : # Get actual values NAME = ( NAME . NAME if NAME else LIT ) NAME = ( NAME ( NAME . NAME ) if NAME else { } ) # Expected values NAME = LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] NAME ( f\" \u2022 Date flexibility: Expected { NAME } , Got { NAME } \" ) NAME ( f\" \u2022 Scoring weights type: { NAME ( NAME ) . NAME } \" ) NAME ( f\" \u2022 Scoring weights count: { NAME ( NAME ) } keys \" ) # Check key scoring weights for NAME in NAME : NAME = NAME . NAME ( NAME , LIT ) NAME ( f\" \u2022 { NAME } : { NAME } \" ) NAME ( LIT ) NAME ( f\" Date flexibility correct: { NAME == NAME } \" ) NAME ( f\" Scoring weights is dict: { NAME ( NAME , NAME ) } \" ) NAME ( f\" Has required weight keys: { NAME ( NAME in NAME for NAME in NAME ) } \" ) assert ( NAME == NAME ) , f\" Date flexibility should be { NAME } , got { NAME } \" assert NAME ( NAME , NAME ) , f\" Scoring weights should be dict, got { NAME ( NAME ) } \" assert NAME ( NAME ) > LIT , LIT return True except NAME as NAME : NAME ( f\" \u274c Config defaults test failed: { NAME } \" ) return True def NAME ( ) -> None : LIT NAME = [ ( LIT , LIT , LIT ) , ( LIT , None , LIT ) , ( LIT , None , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME , NAME in NAME : try : NAME = NAME ( NAME ) NAME = NAME == NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" Input: ' { NAME } ' \u2192 Output: ' { NAME } ' (Expected: ' { NAME } ') \" ) NAME . NAME ( NAME ) assert ( NAME == NAME ) , f\" Failed for ' { NAME } ': expected ' { NAME } ', got ' { NAME } ' \" except NAME as NAME : NAME ( f\" \u274c { NAME } : Exception { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } test cases passed \" ) return True def NAME ( ) -> None : LIT NAME = [ ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ] NAME ( LIT ) NAME = [ ] NAME = NAME . NAME try : for NAME , NAME , NAME in NAME : try : NAME . NAME = ( lambda NAME : ( lambda NAME : NAME ) ) ( NAME ) NAME = NAME ( LIT ) NAME = NAME == NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" Input: ' { NAME } ' \u2192 Output: { NAME } (Expected: { NAME } ) \" ) NAME . NAME ( NAME ) assert ( NAME == NAME ) , f\" Failed for ' { NAME } ': expected { NAME } , got { NAME } \" except NAME as NAME : NAME ( f\" \u274c { NAME } : Exception { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } input formats validated correctly \" ) return True finally : NAME . NAME = NAME def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Get test person data from .env configuration NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) # Load real GEDCOM data and search for the test person NAME = NAME ( ) if not NAME : NAME ( f\" { NAME . NAME } \u26a0\ufe0f GEDCOM_FILE_PATH not configured or file not found, skipping test { NAME . NAME } \" ) return True # Test person's exact data from .env - using consistent test data NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME . NAME ( ) , # Use lowercase for scoring consistency LIT : NAME } NAME ( NAME ( NAME ) ) # Search for the actual person in GEDCOM data with NAME ( ) : NAME = NAME ( NAME , NAME , NAME , NAME ( NAME . NAME ) , { LIT : LIT } ) if not NAME : NAME ( f\" { NAME . NAME } \u26a0\ufe0f Test person not found in GEDCOM, skipping scoring test { NAME . NAME } \" ) return True # Use the top result for scoring analysis NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , LIT ) # Get field scores from the search result NAME = NAME . NAME ( LIT , { } ) if not NAME : # Fallback to default scoring pattern NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } NAME ( NAME ( NAME , NAME ( NAME ) ) ) # Test validation using universal expected score NAME ( f\" \\n { NAME . NAME } { NAME . NAME } \u2705 Test Validation: { NAME . NAME } \" ) NAME ( f\" Score \u2265 50: { NAME . NAME if NAME >= LIT else NAME . NAME } { NAME >= LIT } { NAME . NAME } \" ) NAME ( f\" Expected score validation: { NAME . NAME if NAME == NAME else NAME . NAME } { NAME == NAME } { NAME . NAME } (Expected: { NAME } , Actual: { NAME } ) \" ) NAME ( f\" Has field scores: { NAME . NAME if NAME else NAME . NAME } { NAME ( NAME ) } { NAME . NAME } \" ) NAME ( f\" Final Score: { NAME . NAME } { NAME . NAME } { NAME } { NAME . NAME } \" ) # Check both minimum threshold and exact expected score assert NAME >= LIT , f\" { NAME } { NAME } should score at least 50, got { NAME } \" assert NAME == NAME , f\" { NAME } { NAME } should score exactly { NAME } , got { NAME } \" NAME ( f\" { NAME . NAME } \u2705 { NAME } { NAME } scoring algorithm test passed { NAME . NAME } \" ) return True def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) NAME = ( NAME . NAME . NAME if NAME and NAME . NAME . NAME else None ) if not NAME : NAME ( LIT ) return True NAME = NAME ( NAME ( NAME ) ) if not NAME : NAME ( LIT ) return True # Use Fraser Gault for testing NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) # Search for Fraser Gault NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , } NAME = NAME . NAME ( ) NAME = ( NAME ( NAME . NAME ) if NAME else { } ) NAME = { LIT : LIT } NAME = NAME ( NAME , NAME , NAME , NAME , NAME ) if not NAME : NAME ( LIT ) return True NAME = NAME [ LIT ] NAME = NAME . NAME ( NAME . NAME ( LIT ) ) if not NAME : NAME ( LIT ) return True with NAME ( NAME ( ) ) as NAME : NAME ( NAME , NAME ) # Check that relatives information was displayed assert ( NAME ( NAME . NAME ) > LIT ) , LIT NAME ( f\" \u2705 Display relatives test completed for { NAME . NAME ( LIT , LIT ) } \" ) return True def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) try : # Load real GEDCOM data NAME = ( NAME . NAME . NAME if NAME and NAME . NAME . NAME else None ) if not NAME : NAME ( LIT ) return True NAME = NAME ( NAME ( NAME ) ) if not NAME : return True # Skip if GEDCOM not available # Search for Fraser Gault first NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , } NAME = NAME . NAME ( ) NAME = ( NAME ( NAME . NAME ) if NAME else { } ) NAME = { LIT : LIT } NAME = NAME ( NAME , NAME , NAME , NAME , NAME , ) if not NAME : return True # Skip if Fraser not found NAME = NAME [ LIT ] NAME = ( NAME . NAME if NAME else LIT ) # Test analyze_top_match with real data with NAME ( NAME ( ) ) as NAME : NAME ( NAME , NAME , NAME , LIT ) # Check that family details were logged NAME = LIT . NAME ( NAME . NAME ) assert LIT in NAME , LIT assert LIT in NAME , LIT # Check for family relationship information NAME = [ LIT , LIT , LIT , LIT , LIT , ] NAME = NAME ( NAME in NAME for NAME in NAME ) assert ( NAME ) , f\" Should contain family information. Log content: { NAME [ : LIT ] } ... \" NAME ( f\" \u2705 Analyzed Fraser Gault: { NAME . NAME ( LIT ) } successfully \" ) return True except NAME as NAME : NAME ( f\" \u274c Test person analyze test failed: { NAME } \" ) return True # Don't fail the test suite def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Get test person data from .env configuration NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME ( NAME ( LIT , LIT ) ) NAME ( f\" Test: Real GEDCOM search for { NAME } { NAME } with performance validation \" ) NAME ( LIT ) NAME ( f\" Expected: { NAME } { NAME } found with consistent scoring and good performance \" ) # Load real GEDCOM data from configuration NAME = NAME . NAME . NAME if NAME and NAME . NAME . NAME else None if not NAME or not NAME ( NAME ) . NAME ( ) : NAME ( f\" { NAME . NAME } \u26a0\ufe0f GEDCOM_FILE_PATH not configured or file not found, skipping test { NAME . NAME } \" ) return True NAME ( f\" \\n { NAME . NAME } \ud83d\udcc2 Loading GEDCOM: { NAME . NAME } { NAME . NAME } { NAME ( NAME ) . NAME } { NAME . NAME } \" ) with NAME ( ) : NAME = NAME ( NAME ) if not NAME : NAME ( LIT ) return False NAME ( f\" \u2705 GEDCOM loaded: { NAME ( NAME . NAME ) } individuals \" ) # Test person consistent search criteria (same as scoring test) NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME . NAME ( ) , # Use lowercase for scoring consistency LIT : LIT , # Search for 'Banff' within the full place name LIT : None , LIT : None } NAME ( LIT ) NAME ( f\" \u2022 First Name contains: { NAME . NAME ( ) } \" ) NAME ( f\" \u2022 Surname contains: { NAME . NAME ( ) } \" ) NAME ( f\" \u2022 Birth Year: { NAME } \" ) NAME ( f\" \u2022 Gender: { NAME . NAME ( ) } \" ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( f\" \\n\ud83d\udd0d Searching for { NAME } { NAME } ... \" ) NAME = NAME . NAME ( ) NAME = NAME ( NAME , NAME , NAME , NAME ( NAME . NAME ) , { LIT : LIT } ) NAME = NAME . NAME ( ) - NAME NAME ( LIT ) NAME ( f\" Search time: { NAME : .3f } s \" ) NAME ( f\" Total matches: { NAME ( NAME ) } \" ) if NAME : NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" Top match: { NAME . NAME ( LIT ) } (Score: { NAME } ) \" ) NAME ( f\" Score validation: { NAME >= LIT } \" ) NAME ( f\" Expected score validation: { NAME == NAME } (Expected: { NAME } , Actual: { NAME } ) \" ) # Validate performance NAME = NAME < LIT # Should complete in under 5 seconds NAME ( f\" Performance validation: { NAME } (< 5.0s) \" ) # Check both minimum threshold and exact expected score assert NAME >= LIT , f\" { NAME } should score at least 50 points, got { NAME } \" assert NAME == NAME , f\" { NAME } should score exactly { NAME } , got { NAME } \" assert NAME , f\" Search should complete in < 5s, took { NAME : .3f } s \" else : NAME ( LIT ) NAME ( LIT ) NAME ( f\" Conclusion: GEDCOM search functionality validated with { NAME ( NAME ) } matches \" ) return True def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Get test person data from .env configuration NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) # Use cached GEDCOM data (already loaded in Test 3) NAME = NAME ( ) if not NAME : NAME ( LIT ) return False NAME ( f\" \u2705 Using cached GEDCOM: { NAME ( NAME . NAME ) } individuals \" ) # Search for test person using consistent criteria (Test 5 - Family Analysis) NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , # Add gender for consistency LIT : NAME # Add birth place for consistent scoring } NAME ( f\" \\n\ud83d\udd0d Locating { NAME } { NAME } ... \" ) NAME = NAME ( NAME , NAME , NAME , NAME ( NAME . NAME ) , { LIT : LIT } ) if not NAME : NAME ( f\" \u274c Could not find { NAME } { NAME } in GEDCOM data \" ) return False NAME = NAME [ LIT ] NAME = NAME . NAME ( NAME . NAME ( LIT ) ) if not NAME : NAME ( f\" \u274c Could not retrieve { NAME } 's individual record \" ) return False NAME ( f\" \u2705 Found { NAME } : { NAME . NAME ( LIT ) } \" ) NAME ( f\" Birth year: { NAME } (as expected) \" ) # Test relationship analysis functionality try : NAME ( LIT ) # Display actual family details instead of just validating them NAME ( f\" \\n\ufffd\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66 Family Details for { NAME . NAME ( LIT ) } : \" ) # Show the family information directly NAME ( NAME , NAME ) NAME ( LIT ) NAME ( LIT ) return True except NAME as NAME : NAME ( f\" \u274c Family relationship analysis failed: { NAME } \" ) return False def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Get test person data from .env configuration NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) # Get tree owner data from configuration NAME = NAME . NAME if NAME else LIT # Use cached GEDCOM data (already loaded in Test 3) NAME = NAME ( ) if not NAME : NAME ( LIT ) return False NAME ( f\" \u2705 Using cached GEDCOM: { NAME ( NAME . NAME ) } individuals \" ) # Search for test person using consistent criteria NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , # Add gender for consistency LIT : NAME # Add birth place for consistency } NAME ( f\" \\n\ud83d\udd0d Locating { NAME } { NAME } ... \" ) NAME = NAME ( NAME , NAME , NAME , NAME ( NAME . NAME ) , { LIT : LIT } ) if not NAME : NAME ( f\" \u274c Could not find { NAME } { NAME } in GEDCOM data \" ) return False NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT ) NAME ( f\" \u2705 Found { NAME } : { NAME . NAME ( LIT ) } \" ) NAME ( f\" Person ID: { NAME } \" ) # Get reference person (tree owner) from config NAME = NAME . NAME if NAME else None if not NAME : NAME ( LIT ) return True NAME ( f\" Reference person: { NAME } (ID: { NAME } ) \" ) # Test relationship path calculation try : NAME ( LIT ) # Calculate and display only the relationship path (without family details) # Get the individual record for relationship calculation NAME = NAME . NAME ( NAME ) if not NAME : NAME ( LIT ) return False # Import the relationship calculation functions from NAME import ( NAME , NAME , NAME , ) # Find the relationship path using the consolidated function NAME = NAME ( NAME , NAME , NAME . NAME , NAME . NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # Convert the GEDCOM path to the unified format NAME = NAME ( NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , ) if NAME : # Format the path using the unified formatter NAME = NAME ( NAME , NAME . NAME ( LIT ) , NAME , None ) # Print the formatted relationship path without logger prefix NAME ( NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) ) NAME ( LIT ) NAME ( LIT ) return True NAME ( f\" \u274c Could not determine relationship path for { NAME . NAME ( LIT ) } \" ) return False except NAME as NAME : NAME ( f\" \u274c Relationship path calculation failed: { NAME } \" ) return False def NAME ( ) -> None : # Patch input and logger to simulate user flow NAME = NAME . NAME NAME . NAME = lambda NAME : LIT try : with NAME ( NAME ( ) ) : NAME = NAME ( ) assert NAME is not False finally : NAME . NAME = NAME return True def NAME ( ) -> None : LIT import NAME from NAME import NAME try : # Load expected data from .env NAME ( ) NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) # Get expected data from .env NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) . NAME ( LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) . NAME ( LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME ( LIT ) NAME ( f\" Name: { NAME } { NAME } \" ) NAME ( f\" Birth: { NAME } in { NAME } \" ) NAME ( f\" Father: { NAME } \" ) NAME ( f\" Mother: { NAME } \" ) NAME ( f\" Spouse: { NAME } \" ) NAME ( f\" Children: { LIT . NAME ( NAME ) } \" ) NAME ( f\" Relationship: { NAME } \" ) NAME ( f\" Siblings count: { NAME ( [ NAME for NAME in NAME if NAME . NAME ( ) ] ) } \" ) # Load real GEDCOM data NAME = ( NAME . NAME . NAME if NAME and NAME . NAME . NAME else None ) if not NAME : NAME ( LIT ) return True NAME = NAME ( NAME ( NAME ) ) if not NAME : NAME ( LIT ) return False NAME ( f\" \\n\u2705 GEDCOM data loaded: { NAME ( NAME . NAME ) } individuals \" ) # Search for Fraser Gault using real search NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : LIT , LIT : NAME , LIT : NAME , LIT : None , LIT : None , } NAME = NAME . NAME ( ) NAME = ( NAME ( NAME . NAME ) if NAME else { } ) NAME = { LIT : LIT } # Find Fraser Gault NAME = NAME ( NAME , NAME , NAME , NAME , NAME , ) if not NAME : NAME ( LIT ) return False # Get top match NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT ) NAME ( LIT ) NAME ( f\" ID: { NAME } \" ) NAME ( f\" Score: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" Name: { NAME . NAME ( LIT , LIT ) } \" ) # Get detailed scoring breakdown using the original result data if NAME : # Use the original candidate data from the search results NAME = NAME . NAME ( LIT , { } ) if not NAME : # Fallback to getting individual data NAME = NAME . NAME ( NAME ) if NAME and NAME ( NAME , LIT ) : NAME = NAME . NAME else : NAME = NAME # Use the top match data itself # Recalculate score for detailed breakdown NAME , NAME , NAME = NAME ( NAME , NAME , NAME , NAME , NAME = { } , ) # Display detailed scoring breakdown NAME = NAME ( LIT , NAME , NAME , NAME , NAME , NAME , NAME , NAME , ) NAME ( NAME ) # Get detailed family information using analyze_top_match NAME ( LIT ) NAME ( NAME , NAME , ( NAME . NAME if NAME else LIT ) , LIT , ) NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) return True except NAME as NAME : NAME ( f\" \u274c Test failed with error: { NAME } \" ) import NAME NAME . NAME ( ) return False # Register meaningful tests only NAME . NAME ( LIT , NAME ( NAME ) , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME ( NAME ) , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME ( NAME ) , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME ( NAME ) , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME ( NAME ) , LIT , LIT , LIT , ) # PHASE 4.2: Disable mock mode after tests complete NAME ( ) return NAME . NAME ( )"
    },
    {
      "module_path": "action10.py",
      "qualname": "debug_wrapper",
      "lineno": 1441,
      "end_lineno": 1443,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(test_func)",
      "fingerprint": "18f5bdb924ceaff5ebd40e2bb31931031ca336f3",
      "simhash64": 7488241596704916579,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "test_module_initialization",
      "lineno": 1445,
      "end_lineno": 1507,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 63,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "995f27c22a0af7be7b555092a4f0cbbeeedd3027",
      "simhash64": 7470165625545331771,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] NAME ( f\" \ud83d\udccb Testing availability of { NAME ( NAME ) } core functions: \" ) for NAME in NAME : NAME ( f\" \u2022 { NAME } \" ) try : NAME = [ ] NAME = [ ] for NAME in NAME : if NAME in NAME ( ) : NAME . NAME ( NAME ) if NAME ( NAME ( ) [ NAME ] ) : NAME . NAME ( NAME ) NAME ( f\" \u2705 { NAME } : Found and callable \" ) else : NAME ( f\" \u274c { NAME } : Found but not callable \" ) else : NAME ( f\" \u274c { NAME } : Not found \" ) # Test configuration NAME = NAME is not None NAME = ( NAME ( NAME , LIT ) if NAME else False ) NAME ( LIT ) NAME ( f\" Functions found: { NAME ( NAME ) } / { NAME ( NAME ) } \" ) NAME ( f\" Functions callable: { NAME ( NAME ) } / { NAME ( NAME ) } \" ) NAME ( f\" Config available: { NAME } \" ) NAME ( f\" Config has API: { NAME } \" ) assert NAME ( NAME ) == NAME ( NAME ) , f\" Missing functions: { NAME ( NAME ) - NAME ( NAME ) } \" assert NAME ( NAME ) == NAME ( NAME ) , f\" Non-callable functions: { NAME ( NAME ) - NAME ( NAME ) } \" assert NAME , LIT return True except ( NAME , NAME ) as NAME : NAME ( f\" \u274c Module initialization failed: { NAME } \" ) return True # Skip if config is missing in test env"
    },
    {
      "module_path": "action10.py",
      "qualname": "test_config_defaults",
      "lineno": 1509,
      "end_lineno": 1565,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 57,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "ee725f4b8fb002f129a0ba3edbdac89b8b646c74",
      "simhash64": 7488180024054814267,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) try : # Get actual values NAME = ( NAME . NAME if NAME else LIT ) NAME = ( NAME ( NAME . NAME ) if NAME else { } ) # Expected values NAME = LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] NAME ( f\" \u2022 Date flexibility: Expected { NAME } , Got { NAME } \" ) NAME ( f\" \u2022 Scoring weights type: { NAME ( NAME ) . NAME } \" ) NAME ( f\" \u2022 Scoring weights count: { NAME ( NAME ) } keys \" ) # Check key scoring weights for NAME in NAME : NAME = NAME . NAME ( NAME , LIT ) NAME ( f\" \u2022 { NAME } : { NAME } \" ) NAME ( LIT ) NAME ( f\" Date flexibility correct: { NAME == NAME } \" ) NAME ( f\" Scoring weights is dict: { NAME ( NAME , NAME ) } \" ) NAME ( f\" Has required weight keys: { NAME ( NAME in NAME for NAME in NAME ) } \" ) assert ( NAME == NAME ) , f\" Date flexibility should be { NAME } , got { NAME } \" assert NAME ( NAME , NAME ) , f\" Scoring weights should be dict, got { NAME ( NAME ) } \" assert NAME ( NAME ) > LIT , LIT return True except NAME as NAME : NAME ( f\" \u274c Config defaults test failed: { NAME } \" ) return True"
    },
    {
      "module_path": "action10.py",
      "qualname": "test_sanitize_input",
      "lineno": 1567,
      "end_lineno": 1601,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 35,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "5f1ddabbfc7f17ef959c9e80503a649a61e3c142",
      "simhash64": 7433714616061301819,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ ( LIT , LIT , LIT ) , ( LIT , None , LIT ) , ( LIT , None , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME , NAME in NAME : try : NAME = NAME ( NAME ) NAME = NAME == NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" Input: ' { NAME } ' \u2192 Output: ' { NAME } ' (Expected: ' { NAME } ') \" ) NAME . NAME ( NAME ) assert ( NAME == NAME ) , f\" Failed for ' { NAME } ': expected ' { NAME } ', got ' { NAME } ' \" except NAME as NAME : NAME ( f\" \u274c { NAME } : Exception { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } test cases passed \" ) return True"
    },
    {
      "module_path": "action10.py",
      "qualname": "test_get_validated_year_input_patch",
      "lineno": 1603,
      "end_lineno": 1645,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 43,
      "tags": [
        "impure",
        "logging",
        "purpose:validation",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "3cec77eafce0f341f0eb568b47396390632a5b9e",
      "simhash64": 7451729014570783803,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ] NAME ( LIT ) NAME = [ ] NAME = NAME . NAME try : for NAME , NAME , NAME in NAME : try : NAME . NAME = ( lambda NAME : ( lambda NAME : NAME ) ) ( NAME ) NAME = NAME ( LIT ) NAME = NAME == NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" Input: ' { NAME } ' \u2192 Output: { NAME } (Expected: { NAME } ) \" ) NAME . NAME ( NAME ) assert ( NAME == NAME ) , f\" Failed for ' { NAME } ': expected { NAME } , got { NAME } \" except NAME as NAME : NAME ( f\" \u274c { NAME } : Exception { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } input formats validated correctly \" ) return True finally : NAME . NAME = NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "test_fraser_gault_scoring_algorithm",
      "lineno": 1647,
      "end_lineno": 1714,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 68,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "d250bdbf85cef885c4244bffeef2badf6e30f1ad",
      "simhash64": 7451729014569735739,
      "normalized": "def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Get test person data from .env configuration NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) # Load real GEDCOM data and search for the test person NAME = NAME ( ) if not NAME : NAME ( f\" { NAME . NAME } \u26a0\ufe0f GEDCOM_FILE_PATH not configured or file not found, skipping test { NAME . NAME } \" ) return True # Test person's exact data from .env - using consistent test data NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME . NAME ( ) , # Use lowercase for scoring consistency LIT : NAME } NAME ( NAME ( NAME ) ) # Search for the actual person in GEDCOM data with NAME ( ) : NAME = NAME ( NAME , NAME , NAME , NAME ( NAME . NAME ) , { LIT : LIT } ) if not NAME : NAME ( f\" { NAME . NAME } \u26a0\ufe0f Test person not found in GEDCOM, skipping scoring test { NAME . NAME } \" ) return True # Use the top result for scoring analysis NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , LIT ) # Get field scores from the search result NAME = NAME . NAME ( LIT , { } ) if not NAME : # Fallback to default scoring pattern NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } NAME ( NAME ( NAME , NAME ( NAME ) ) ) # Test validation using universal expected score NAME ( f\" \\n { NAME . NAME } { NAME . NAME } \u2705 Test Validation: { NAME . NAME } \" ) NAME ( f\" Score \u2265 50: { NAME . NAME if NAME >= LIT else NAME . NAME } { NAME >= LIT } { NAME . NAME } \" ) NAME ( f\" Expected score validation: { NAME . NAME if NAME == NAME else NAME . NAME } { NAME == NAME } { NAME . NAME } (Expected: { NAME } , Actual: { NAME } ) \" ) NAME ( f\" Has field scores: { NAME . NAME if NAME else NAME . NAME } { NAME ( NAME ) } { NAME . NAME } \" ) NAME ( f\" Final Score: { NAME . NAME } { NAME . NAME } { NAME } { NAME . NAME } \" ) # Check both minimum threshold and exact expected score assert NAME >= LIT , f\" { NAME } { NAME } should score at least 50, got { NAME } \" assert NAME == NAME , f\" { NAME } { NAME } should score exactly { NAME } , got { NAME } \" NAME ( f\" { NAME . NAME } \u2705 { NAME } { NAME } scoring algorithm test passed { NAME . NAME } \" ) return True"
    },
    {
      "module_path": "action10.py",
      "qualname": "test_display_relatives_fraser",
      "lineno": 1716,
      "end_lineno": 1782,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 7,
      "loc": 67,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "3daa8923cd6d00f47ebed97e0210920e6c85ef11",
      "simhash64": 7487617078395311147,
      "normalized": "def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) NAME = ( NAME . NAME . NAME if NAME and NAME . NAME . NAME else None ) if not NAME : NAME ( LIT ) return True NAME = NAME ( NAME ( NAME ) ) if not NAME : NAME ( LIT ) return True # Use Fraser Gault for testing NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) # Search for Fraser Gault NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , } NAME = NAME . NAME ( ) NAME = ( NAME ( NAME . NAME ) if NAME else { } ) NAME = { LIT : LIT } NAME = NAME ( NAME , NAME , NAME , NAME , NAME ) if not NAME : NAME ( LIT ) return True NAME = NAME [ LIT ] NAME = NAME . NAME ( NAME . NAME ( LIT ) ) if not NAME : NAME ( LIT ) return True with NAME ( NAME ( ) ) as NAME : NAME ( NAME , NAME ) # Check that relatives information was displayed assert ( NAME ( NAME . NAME ) > LIT ) , LIT NAME ( f\" \u2705 Display relatives test completed for { NAME . NAME ( LIT , LIT ) } \" ) return True"
    },
    {
      "module_path": "action10.py",
      "qualname": "test_analyze_top_match_fraser",
      "lineno": 1784,
      "end_lineno": 1875,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 8,
      "loc": 92,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "13a3193ec040577c0188420b82f80088f8363421",
      "simhash64": 7488180024053765163,
      "normalized": "def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) try : # Load real GEDCOM data NAME = ( NAME . NAME . NAME if NAME and NAME . NAME . NAME else None ) if not NAME : NAME ( LIT ) return True NAME = NAME ( NAME ( NAME ) ) if not NAME : return True # Skip if GEDCOM not available # Search for Fraser Gault first NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , } NAME = NAME . NAME ( ) NAME = ( NAME ( NAME . NAME ) if NAME else { } ) NAME = { LIT : LIT } NAME = NAME ( NAME , NAME , NAME , NAME , NAME , ) if not NAME : return True # Skip if Fraser not found NAME = NAME [ LIT ] NAME = ( NAME . NAME if NAME else LIT ) # Test analyze_top_match with real data with NAME ( NAME ( ) ) as NAME : NAME ( NAME , NAME , NAME , LIT ) # Check that family details were logged NAME = LIT . NAME ( NAME . NAME ) assert LIT in NAME , LIT assert LIT in NAME , LIT # Check for family relationship information NAME = [ LIT , LIT , LIT , LIT , LIT , ] NAME = NAME ( NAME in NAME for NAME in NAME ) assert ( NAME ) , f\" Should contain family information. Log content: { NAME [ : LIT ] } ... \" NAME ( f\" \u2705 Analyzed Fraser Gault: { NAME . NAME ( LIT ) } successfully \" ) return True except NAME as NAME : NAME ( f\" \u274c Test person analyze test failed: { NAME } \" ) return True # Don't fail the test suite"
    },
    {
      "module_path": "action10.py",
      "qualname": "test_real_search_performance_and_accuracy",
      "lineno": 1877,
      "end_lineno": 1968,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 7,
      "loc": 92,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "f7dbfbca22faa1758c5d2f127423c480e3d53502",
      "simhash64": 7487652257398690875,
      "normalized": "def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Get test person data from .env configuration NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME ( NAME ( LIT , LIT ) ) NAME ( f\" Test: Real GEDCOM search for { NAME } { NAME } with performance validation \" ) NAME ( LIT ) NAME ( f\" Expected: { NAME } { NAME } found with consistent scoring and good performance \" ) # Load real GEDCOM data from configuration NAME = NAME . NAME . NAME if NAME and NAME . NAME . NAME else None if not NAME or not NAME ( NAME ) . NAME ( ) : NAME ( f\" { NAME . NAME } \u26a0\ufe0f GEDCOM_FILE_PATH not configured or file not found, skipping test { NAME . NAME } \" ) return True NAME ( f\" \\n { NAME . NAME } \ud83d\udcc2 Loading GEDCOM: { NAME . NAME } { NAME . NAME } { NAME ( NAME ) . NAME } { NAME . NAME } \" ) with NAME ( ) : NAME = NAME ( NAME ) if not NAME : NAME ( LIT ) return False NAME ( f\" \u2705 GEDCOM loaded: { NAME ( NAME . NAME ) } individuals \" ) # Test person consistent search criteria (same as scoring test) NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME . NAME ( ) , # Use lowercase for scoring consistency LIT : LIT , # Search for 'Banff' within the full place name LIT : None , LIT : None } NAME ( LIT ) NAME ( f\" \u2022 First Name contains: { NAME . NAME ( ) } \" ) NAME ( f\" \u2022 Surname contains: { NAME . NAME ( ) } \" ) NAME ( f\" \u2022 Birth Year: { NAME } \" ) NAME ( f\" \u2022 Gender: { NAME . NAME ( ) } \" ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( f\" \\n\ud83d\udd0d Searching for { NAME } { NAME } ... \" ) NAME = NAME . NAME ( ) NAME = NAME ( NAME , NAME , NAME , NAME ( NAME . NAME ) , { LIT : LIT } ) NAME = NAME . NAME ( ) - NAME NAME ( LIT ) NAME ( f\" Search time: { NAME : .3f } s \" ) NAME ( f\" Total matches: { NAME ( NAME ) } \" ) if NAME : NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" Top match: { NAME . NAME ( LIT ) } (Score: { NAME } ) \" ) NAME ( f\" Score validation: { NAME >= LIT } \" ) NAME ( f\" Expected score validation: { NAME == NAME } (Expected: { NAME } , Actual: { NAME } ) \" ) # Validate performance NAME = NAME < LIT # Should complete in under 5 seconds NAME ( f\" Performance validation: { NAME } (< 5.0s) \" ) # Check both minimum threshold and exact expected score assert NAME >= LIT , f\" { NAME } should score at least 50 points, got { NAME } \" assert NAME == NAME , f\" { NAME } should score exactly { NAME } , got { NAME } \" assert NAME , f\" Search should complete in < 5s, took { NAME : .3f } s \" else : NAME ( LIT ) NAME ( LIT ) NAME ( f\" Conclusion: GEDCOM search functionality validated with { NAME ( NAME ) } matches \" ) return True"
    },
    {
      "module_path": "action10.py",
      "qualname": "test_family_relationship_analysis",
      "lineno": 1970,
      "end_lineno": 2041,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 72,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "13cee7af101e4fb69f3ba2a4ec9a45416d37d604",
      "simhash64": 7487617074100343867,
      "normalized": "def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Get test person data from .env configuration NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) # Use cached GEDCOM data (already loaded in Test 3) NAME = NAME ( ) if not NAME : NAME ( LIT ) return False NAME ( f\" \u2705 Using cached GEDCOM: { NAME ( NAME . NAME ) } individuals \" ) # Search for test person using consistent criteria (Test 5 - Family Analysis) NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , # Add gender for consistency LIT : NAME # Add birth place for consistent scoring } NAME ( f\" \\n\ud83d\udd0d Locating { NAME } { NAME } ... \" ) NAME = NAME ( NAME , NAME , NAME , NAME ( NAME . NAME ) , { LIT : LIT } ) if not NAME : NAME ( f\" \u274c Could not find { NAME } { NAME } in GEDCOM data \" ) return False NAME = NAME [ LIT ] NAME = NAME . NAME ( NAME . NAME ( LIT ) ) if not NAME : NAME ( f\" \u274c Could not retrieve { NAME } 's individual record \" ) return False NAME ( f\" \u2705 Found { NAME } : { NAME . NAME ( LIT ) } \" ) NAME ( f\" Birth year: { NAME } (as expected) \" ) # Test relationship analysis functionality try : NAME ( LIT ) # Display actual family details instead of just validating them NAME ( f\" \\n\ufffd\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66 Family Details for { NAME . NAME ( LIT ) } : \" ) # Show the family information directly NAME ( NAME , NAME ) NAME ( LIT ) NAME ( LIT ) return True except NAME as NAME : NAME ( f\" \u274c Family relationship analysis failed: { NAME } \" ) return False"
    },
    {
      "module_path": "action10.py",
      "qualname": "test_relationship_path_calculation",
      "lineno": 2043,
      "end_lineno": 2162,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 7,
      "loc": 120,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "aee67f37b0b68ee636ab1d59c290689ef4e5c3a0",
      "simhash64": 7488180022981071931,
      "normalized": "def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Get test person data from .env configuration NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) # Get tree owner data from configuration NAME = NAME . NAME if NAME else LIT # Use cached GEDCOM data (already loaded in Test 3) NAME = NAME ( ) if not NAME : NAME ( LIT ) return False NAME ( f\" \u2705 Using cached GEDCOM: { NAME ( NAME . NAME ) } individuals \" ) # Search for test person using consistent criteria NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , # Add gender for consistency LIT : NAME # Add birth place for consistency } NAME ( f\" \\n\ud83d\udd0d Locating { NAME } { NAME } ... \" ) NAME = NAME ( NAME , NAME , NAME , NAME ( NAME . NAME ) , { LIT : LIT } ) if not NAME : NAME ( f\" \u274c Could not find { NAME } { NAME } in GEDCOM data \" ) return False NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT ) NAME ( f\" \u2705 Found { NAME } : { NAME . NAME ( LIT ) } \" ) NAME ( f\" Person ID: { NAME } \" ) # Get reference person (tree owner) from config NAME = NAME . NAME if NAME else None if not NAME : NAME ( LIT ) return True NAME ( f\" Reference person: { NAME } (ID: { NAME } ) \" ) # Test relationship path calculation try : NAME ( LIT ) # Calculate and display only the relationship path (without family details) # Get the individual record for relationship calculation NAME = NAME . NAME ( NAME ) if not NAME : NAME ( LIT ) return False # Import the relationship calculation functions from NAME import ( NAME , NAME , NAME , ) # Find the relationship path using the consolidated function NAME = NAME ( NAME , NAME , NAME . NAME , NAME . NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # Convert the GEDCOM path to the unified format NAME = NAME ( NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , ) if NAME : # Format the path using the unified formatter NAME = NAME ( NAME , NAME . NAME ( LIT ) , NAME , None ) # Print the formatted relationship path without logger prefix NAME ( NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) ) NAME ( LIT ) NAME ( LIT ) return True NAME ( f\" \u274c Could not determine relationship path for { NAME . NAME ( LIT ) } \" ) return False except NAME as NAME : NAME ( f\" \u274c Relationship path calculation failed: { NAME } \" ) return False"
    },
    {
      "module_path": "action10.py",
      "qualname": "test_main_patch",
      "lineno": 2164,
      "end_lineno": 2176,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "impure",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "abf6d685ddcf3a3c5d753d654ff638635014d0f4",
      "simhash64": 7488144838608459267,
      "normalized": "def NAME ( ) -> None : # Patch input and logger to simulate user flow NAME = NAME . NAME NAME . NAME = lambda NAME : LIT try : with NAME ( NAME ( ) ) : NAME = NAME ( ) assert NAME is not False finally : NAME . NAME = NAME return True"
    },
    {
      "module_path": "action10.py",
      "qualname": "test_fraser_gault_comprehensive",
      "lineno": 2178,
      "end_lineno": 2338,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 11,
      "loc": 161,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "ee8118c974bd8648615a062b726f3a7caa9776a9",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( ) -> None : LIT import NAME from NAME import NAME try : # Load expected data from .env NAME ( ) NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) # Get expected data from .env NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) . NAME ( LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) . NAME ( LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME ( LIT ) NAME ( f\" Name: { NAME } { NAME } \" ) NAME ( f\" Birth: { NAME } in { NAME } \" ) NAME ( f\" Father: { NAME } \" ) NAME ( f\" Mother: { NAME } \" ) NAME ( f\" Spouse: { NAME } \" ) NAME ( f\" Children: { LIT . NAME ( NAME ) } \" ) NAME ( f\" Relationship: { NAME } \" ) NAME ( f\" Siblings count: { NAME ( [ NAME for NAME in NAME if NAME . NAME ( ) ] ) } \" ) # Load real GEDCOM data NAME = ( NAME . NAME . NAME if NAME and NAME . NAME . NAME else None ) if not NAME : NAME ( LIT ) return True NAME = NAME ( NAME ( NAME ) ) if not NAME : NAME ( LIT ) return False NAME ( f\" \\n\u2705 GEDCOM data loaded: { NAME ( NAME . NAME ) } individuals \" ) # Search for Fraser Gault using real search NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : LIT , LIT : NAME , LIT : NAME , LIT : None , LIT : None , } NAME = NAME . NAME ( ) NAME = ( NAME ( NAME . NAME ) if NAME else { } ) NAME = { LIT : LIT } # Find Fraser Gault NAME = NAME ( NAME , NAME , NAME , NAME , NAME , ) if not NAME : NAME ( LIT ) return False # Get top match NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT ) NAME ( LIT ) NAME ( f\" ID: { NAME } \" ) NAME ( f\" Score: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" Name: { NAME . NAME ( LIT , LIT ) } \" ) # Get detailed scoring breakdown using the original result data if NAME : # Use the original candidate data from the search results NAME = NAME . NAME ( LIT , { } ) if not NAME : # Fallback to getting individual data NAME = NAME . NAME ( NAME ) if NAME and NAME ( NAME , LIT ) : NAME = NAME . NAME else : NAME = NAME # Use the top match data itself # Recalculate score for detailed breakdown NAME , NAME , NAME = NAME ( NAME , NAME , NAME , NAME , NAME = { } , ) # Display detailed scoring breakdown NAME = NAME ( LIT , NAME , NAME , NAME , NAME , NAME , NAME , NAME , ) NAME ( NAME ) # Get detailed family information using analyze_top_match NAME ( LIT ) NAME ( NAME , NAME , ( NAME . NAME if NAME else LIT ) , LIT , ) NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) return True except NAME as NAME : NAME ( f\" \u274c Test failed with error: { NAME } \" ) import NAME NAME . NAME ( ) return False"
    },
    {
      "module_path": "action10.py",
      "qualname": "compare_action10_performance",
      "lineno": 2389,
      "end_lineno": 2455,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 67,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "33350b7fb5c0d4a2acdf00c2031b418801b5111c",
      "simhash64": 7451588277082428475,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT NAME . NAME ( LIT ) NAME . NAME ( LIT * LIT ) NAME = { LIT : { } , LIT : { } , LIT : { } } # Test the optimized action10.py directly NAME . NAME ( LIT ) # First run NAME = NAME . NAME ( ) NAME = NAME ( ) NAME = NAME . NAME ( ) - NAME # Second run (should benefit from caching) NAME = NAME . NAME ( ) NAME = NAME ( ) NAME = NAME . NAME ( ) - NAME # Calculate cache speedup (handle ultra-fast times) NAME = NAME ( LIT , NAME / NAME ( NAME , LIT ) ) NAME [ LIT ] = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME and NAME , } NAME . NAME ( f\" \u2713 First run: { NAME : .3f } s \" ) NAME . NAME ( f\" \u2713 Second run: { NAME : .3f } s ( { NAME : .1f } x speedup) \" ) # Calculate overall performance metrics NAME = LIT # Original slow time from our measurements NAME = LIT # Target from implementation plan NAME = NAME ( NAME , NAME ) NAME [ LIT ] = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME / NAME ( NAME , LIT ) , LIT : NAME <= NAME , LIT : NAME - NAME , } # Summary NAME . NAME ( LIT ) NAME . NAME ( LIT * LIT ) NAME . NAME ( f\" Baseline (original): { NAME : .2f } s \" ) NAME . NAME ( f\" Optimized (current): { NAME : .3f } s \" ) NAME . NAME ( f\" Target: { NAME : .1f } s \" ) NAME . NAME ( f\" Speedup Achieved: { NAME [ LIT ] [ LIT ] : .1f } x \" ) NAME . NAME ( f\" Time Saved: { NAME [ LIT ] [ LIT ] : .2f } s \" ) if NAME [ LIT ] [ LIT ] : NAME . NAME ( LIT ) else : NAME = NAME - NAME NAME . NAME ( f\" \u26a0\ufe0f { NAME : .1f } s over target \" ) return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "validate_performance_improvements",
      "lineno": 2458,
      "end_lineno": 2507,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 50,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "59a36ecd3b63edfe7064c16947adb28f0f7faa0d",
      "simhash64": 7452151226028168219,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) try : NAME = NAME ( ) # Check targets NAME = [ ] # Target 1: Under 20 seconds total NAME = NAME [ LIT ] [ LIT ] <= LIT NAME . NAME ( NAME ) NAME . NAME ( f\" \u2713 Under 20s target: { LIT if NAME else LIT } \" ) # Target 2: At least 4x speedup NAME = NAME [ LIT ] [ LIT ] >= LIT NAME . NAME ( NAME ) NAME . NAME ( f\" \u2713 4x speedup target: { LIT if NAME else LIT } \" ) # Target 3: Cache effectiveness (handle ultra-fast times) NAME = ( NAME [ LIT ] [ LIT ] >= LIT ) # Lowered threshold for ultra-fast operations NAME . NAME ( NAME ) NAME . NAME ( f\" \u2713 Cache effectiveness: { LIT if NAME else LIT } \" ) # Target 4: All tests pass NAME = NAME [ LIT ] [ LIT ] NAME . NAME ( NAME ) NAME . NAME ( f\" \u2713 All tests pass: { LIT if NAME else LIT } \" ) # Overall result NAME = NAME ( NAME ) if NAME : NAME . NAME ( LIT ) else : NAME = NAME ( NAME ) - NAME ( NAME ) NAME . NAME ( f\" \u26a0\ufe0f { NAME } / { NAME ( NAME ) } targets failed \" ) return NAME except NAME as NAME : NAME . NAME ( f\" \u274c Performance validation failed: { NAME } \" ) return False"
    },
    {
      "module_path": "action10.py",
      "qualname": "run_performance_validation",
      "lineno": 2510,
      "end_lineno": 2532,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 23,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6bdbead0617270d72c1b9f483c13c47f4ef2408d",
      "simhash64": 8640705670173595179,
      "normalized": "def NAME ( ) -> NAME : LIT NAME ( LIT ) NAME ( LIT * LIT ) try : # Run performance comparison NAME = NAME ( ) if NAME : NAME ( LIT ) NAME ( LIT ) else : NAME ( LIT ) NAME ( LIT ) except NAME as NAME : NAME ( f\" \\n\ud83d\udca5 Performance test failed: { NAME } \" ) return False return NAME"
    },
    {
      "module_path": "action10.py",
      "qualname": "PerformanceFilter.filter",
      "lineno": 2572,
      "end_lineno": 2574,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self, record)",
      "fingerprint": "37a6d991df077fa0a011508deff766c41ab2cabc",
      "simhash64": 7488180022980019243,
      "normalized": "def NAME ( NAME , NAME ) -> NAME : NAME = NAME . NAME ( ) if NAME ( NAME , LIT ) else NAME ( NAME . NAME ) return not ( LIT in NAME and LIT in NAME )"
    },
    {
      "module_path": "action11.py",
      "qualname": "_get_tree_id",
      "lineno": 72,
      "end_lineno": 77,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(session_manager)",
      "fingerprint": "5a96ec6a11f4c350da619235a6b5b543e59d5541",
      "simhash64": 7488320761542120451,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT NAME = NAME ( NAME , LIT , None ) if not NAME : NAME = NAME ( NAME . NAME , LIT , LIT ) return NAME or None"
    },
    {
      "module_path": "action11.py",
      "qualname": "_build_treesui_url",
      "lineno": 80,
      "end_lineno": 97,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 18,
      "tags": [
        "impure",
        "network",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(session_manager, full_name)",
      "fingerprint": "899a44e3b29947615e5247103d5c04ef9365f7f8",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( NAME ) if not NAME : raise NAME ( LIT ) NAME = NAME . NAME . NAME . NAME ( LIT ) from NAME . NAME import NAME NAME = NAME ( NAME ) NAME = f\" /api/treesui-list/trees/ { NAME } /persons \" NAME = ( LIT + NAME + LIT + LIT ) return f\" { NAME } { NAME } ? { NAME } \" , NAME"
    },
    {
      "module_path": "action11.py",
      "qualname": "_parse_treesui_response",
      "lineno": 100,
      "end_lineno": 115,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 9,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(response)",
      "fingerprint": "974b27e770feeff0def75a8caf38132e195bd21b",
      "simhash64": 5182337013766337571,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] if not NAME : return NAME if NAME ( NAME , NAME ) : if LIT in NAME and NAME ( NAME [ LIT ] , NAME ) : return NAME ( NAME [ NAME [ NAME , NAME ] ] , NAME [ LIT ] ) # standard shape if LIT in NAME and NAME ( NAME [ LIT ] , NAME ) : return NAME ( NAME [ NAME [ NAME , NAME ] ] , NAME [ LIT ] ) # alt shape if NAME ( NAME , NAME ) : # defensive return NAME ( NAME [ NAME [ NAME , NAME ] ] , NAME ) return NAME if NAME ( NAME , NAME ) : return NAME ( NAME [ NAME [ NAME , NAME ] ] , NAME ) return NAME"
    },
    {
      "module_path": "action11.py",
      "qualname": "_extract_person_id",
      "lineno": 118,
      "end_lineno": 127,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(person)",
      "fingerprint": "123dfcbca057a762f68bce9e56d5adae6d0a9bbb",
      "simhash64": 7488180023047132195,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = ( NAME . NAME ( LIT ) or NAME . NAME ( LIT ) or NAME . NAME ( LIT ) or LIT ) if not NAME and LIT in NAME : NAME = NAME . NAME ( LIT ) if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT ) if NAME ( NAME , NAME ) and LIT in NAME : NAME = NAME . NAME ( LIT ) [ LIT ] return NAME ( NAME , NAME or LIT )"
    },
    {
      "module_path": "action11.py",
      "qualname": "_format_full_name",
      "lineno": 130,
      "end_lineno": 132,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(candidate)",
      "fingerprint": "851b8bc01f477b3e1b593f47bd5d44578f288ed4",
      "simhash64": 7433573878571897899,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : LIT return f\" { NAME . NAME ( LIT , LIT ) } { NAME . NAME ( LIT , LIT ) } \" . NAME ( )"
    },
    {
      "module_path": "action11.py",
      "qualname": "_initialize_scoring_config",
      "lineno": 135,
      "end_lineno": 139,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "8a1167fb5591d93824e5d37d8feccae002053e73",
      "simhash64": 7452080857216889939,
      "normalized": "def NAME ( ) -> NAME [ NAME [ NAME , NAME ] , NAME [ NAME , NAME ] ] : LIT NAME = NAME . NAME NAME = { LIT : NAME . NAME } return NAME , NAME"
    },
    {
      "module_path": "action11.py",
      "qualname": "_log_debug_info",
      "lineno": 142,
      "end_lineno": 150,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(persons_list)",
      "fingerprint": "dd19b86c450bdc8d25cd87757d49f8b90f90f3f5",
      "simhash64": 7488180022980023331,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] ) -> None : LIT if NAME ( NAME ) > LIT : NAME = NAME [ LIT ] NAME . NAME ( f\" First person structure: { NAME } \" ) NAME . NAME ( LIT + ( NAME ( NAME ( NAME . NAME ( ) ) ) if NAME ( NAME , NAME ) else LIT ) )"
    },
    {
      "module_path": "action11.py",
      "qualname": "_should_terminate_early",
      "lineno": 153,
      "end_lineno": 156,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(scored_results, max_results, start_time)",
      "fingerprint": "0bf55ff8f330ec04577da0fba6f7bf3ce0eb2b1c",
      "simhash64": 7488180022980027507,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME , NAME : NAME ) -> NAME : LIT import NAME as NAME return NAME ( NAME ) >= NAME and ( NAME . NAME ( ) - NAME ) > LIT"
    },
    {
      "module_path": "action11.py",
      "qualname": "_score_single_person",
      "lineno": 159,
      "end_lineno": 211,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 53,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(person, search_criteria, scoring_weights, date_flex)",
      "fingerprint": "f4de46da1190602f5a6ba8627c6e2d78b3b5979b",
      "simhash64": 7452151225961059355,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : if not NAME ( NAME , NAME ) : NAME . NAME ( f\" Skipping non-dict person: { NAME ( NAME ) } \" ) return None NAME = NAME ( NAME ) from NAME import NAME NAME = NAME ( NAME = [ NAME ] , NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , NAME = LIT , ) if NAME : NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , [ ] ) else : NAME , NAME , NAME = LIT , { } , [ ] # Assemble output NAME = NAME . NAME ( ) NAME = NAME ( NAME ) NAME . NAME ( { LIT : NAME ( NAME ) , LIT : NAME , LIT : NAME , LIT : NAME ( NAME ) , LIT : NAME , LIT : NAME , } ) return NAME except NAME as NAME : # defensive NAME = LIT if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , NAME . NAME ( LIT , LIT ) ) NAME . NAME ( f\" Error scoring person { NAME } : { NAME } \" ) return None"
    },
    {
      "module_path": "action11.py",
      "qualname": "_is_high_quality_match",
      "lineno": 214,
      "end_lineno": 216,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(total_score, scored_results)",
      "fingerprint": "79aecd0240f78e9ad8349c65c549680a1d14c29a",
      "simhash64": 7488180022980031603,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME : LIT return NAME >= LIT and NAME ( NAME ) >= LIT"
    },
    {
      "module_path": "action11.py",
      "qualname": "_score_persons",
      "lineno": 219,
      "end_lineno": 254,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 36,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(persons, search_criteria, max_results)",
      "fingerprint": "31ce16f9587fae9779d3119a121a2dc132f9ebaa",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ NAME , NAME ] , * , NAME : NAME , ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] NAME , NAME = NAME ( ) NAME = NAME ( NAME [ NAME [ NAME , NAME ] ] , NAME ) NAME ( NAME ) # Limit processing for performance NAME = NAME [ : NAME ] if NAME ( NAME ) > NAME else NAME import NAME as NAME NAME = NAME . NAME ( ) for NAME , NAME in NAME ( NAME ) : if NAME ( NAME , NAME , NAME ) : NAME . NAME ( f\" Early termination after processing { NAME + LIT } persons due to time limit \" ) break NAME = NAME ( NAME , NAME , NAME , NAME ) if NAME : NAME . NAME ( NAME ) if NAME ( NAME [ LIT ] , NAME ) : NAME . NAME ( f\" Found high-quality match (score: { NAME [ LIT ] } ), stopping early for performance \" ) break NAME . NAME ( NAME = lambda NAME : NAME . NAME ( LIT , LIT ) , NAME = True ) return NAME [ : NAME ]"
    },
    {
      "module_path": "action11.py",
      "qualname": "_get_tree_id",
      "lineno": 256,
      "end_lineno": 265,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 10,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "eae8cc331649c6fc59b50293040dffa6494316b9",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT NAME = NAME . NAME if not NAME : from NAME import NAME NAME = NAME ( NAME . NAME , LIT , LIT ) if not NAME : NAME . NAME ( LIT ) return None return NAME"
    },
    {
      "module_path": "action11.py",
      "qualname": "_build_search_name",
      "lineno": 268,
      "end_lineno": 272,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(search_criteria)",
      "fingerprint": "325e023c6b15487aedf1de7655fa522b8f70e076",
      "simhash64": 7452151227034801179,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) return f\" { NAME } { NAME } \" . NAME ( )"
    },
    {
      "module_path": "action11.py",
      "qualname": "_perform_treesui_request",
      "lineno": 275,
      "end_lineno": 293,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(session_manager, full_name, tree_id)",
      "fingerprint": "9dfd9f716fcadd07bb1cf9c6699038784e4952e8",
      "simhash64": 7452291964524205115,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT from NAME import NAME NAME , NAME = NAME ( NAME , NAME ) return NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = LIT , NAME = { LIT : LIT , LIT : NAME , LIT : LIT , } , NAME = LIT , # Reduced to 8 seconds for faster response NAME = False , # Don't request CSRF token for this endpoint )"
    },
    {
      "module_path": "action11.py",
      "qualname": "_process_treesui_response",
      "lineno": 296,
      "end_lineno": 310,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "(response, search_criteria, max_results)",
      "fingerprint": "754a049adfd14aab72180861c7c32f8781cb7891",
      "simhash64": 7488180022980031571,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = NAME ( NAME ) if not NAME : NAME . NAME ( LIT ) return [ ] NAME ( f\" TreesUI search found { NAME ( NAME ) } raw results \" ) NAME = NAME ( NAME , NAME , NAME = NAME ) NAME ( f\" TreesUI search returning { NAME ( NAME ) } scored results \" ) return NAME"
    },
    {
      "module_path": "action11.py",
      "qualname": "enhanced_treesui_search",
      "lineno": 313,
      "end_lineno": 340,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(session_manager, search_criteria, max_results)",
      "fingerprint": "fc4b9509048e01616b96dc81f45e630e8089ca63",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME = LIT ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : NAME = NAME ( NAME ) if not NAME : return [ ] NAME = NAME ( NAME ) NAME = NAME ( NAME , NAME , NAME ) if not NAME : NAME . NAME ( LIT ) return [ ] return NAME ( NAME , NAME , NAME ) except NAME as NAME : NAME . NAME ( f\" Enhanced TreesUI search failed: { NAME } \" ) return [ ]"
    },
    {
      "module_path": "action11.py",
      "qualname": "_extract_names_from_person",
      "lineno": 343,
      "end_lineno": 360,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(person)",
      "fingerprint": "5e04d85e232e01e1757465f777d0d581b5ffdbfa",
      "simhash64": 7487617074167452715,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT NAME = LIT NAME = LIT # Try direct fields first (gname, sname) if LIT in NAME and LIT in NAME : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) else : # Fallback to Names array NAME = NAME . NAME ( LIT , NAME . NAME ( LIT , [ ] ) ) if NAME and NAME ( NAME , NAME ) and NAME ( NAME ) > LIT : NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , NAME . NAME ( LIT , NAME . NAME ( LIT , LIT ) ) ) NAME = NAME . NAME ( LIT , NAME . NAME ( LIT , NAME . NAME ( LIT , LIT ) ) ) return NAME , NAME"
    },
    {
      "module_path": "action11.py",
      "qualname": "_extract_place_from_event",
      "lineno": 363,
      "end_lineno": 368,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(event)",
      "fingerprint": "5df116ffd4ba7e000be3ceb8a53713937ffd9ecf",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , NAME . NAME ( LIT , LIT ) ) if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) return NAME if NAME else LIT"
    },
    {
      "module_path": "action11.py",
      "qualname": "_extract_events_from_person",
      "lineno": 371,
      "end_lineno": 392,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(person)",
      "fingerprint": "01bf617f032358499a4099858a81ff1b1928d27a",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME ] , NAME [ NAME ] , NAME , NAME ] : LIT NAME = NAME . NAME ( LIT , NAME . NAME ( LIT , [ ] ) ) NAME = None NAME = None NAME = LIT NAME = LIT for NAME in NAME : NAME = NAME . NAME ( LIT , NAME . NAME ( LIT , LIT ) ) . NAME ( ) if NAME == LIT and NAME is None : # Only process first birth event NAME = NAME ( NAME ) NAME = NAME ( NAME ) if NAME : NAME = NAME elif NAME == LIT and NAME is None : # Only process first death event NAME = NAME ( NAME ) NAME = NAME ( NAME ) if NAME : NAME = NAME return NAME , NAME , NAME , NAME"
    },
    {
      "module_path": "action11.py",
      "qualname": "_extract_gender_from_person",
      "lineno": 395,
      "end_lineno": 408,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(person)",
      "fingerprint": "34df8fead59d1143dfe53bfa1f4503b83c5df4f0",
      "simhash64": 7487617074167452715,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = LIT if LIT in NAME : NAME = NAME . NAME ( LIT , LIT ) else : NAME = NAME . NAME ( LIT , [ ] ) if NAME and NAME ( NAME , NAME ) and NAME ( NAME ) > LIT : NAME = NAME [ LIT ] . NAME ( LIT , LIT ) if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) return NAME . NAME ( ) if NAME else LIT"
    },
    {
      "module_path": "action11.py",
      "qualname": "_create_default_person_data",
      "lineno": 411,
      "end_lineno": 421,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2ca3157da4888259ebada4172f1e36bee09dc849",
      "simhash64": 5727968524161160747,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return { LIT : LIT , LIT : LIT , LIT : None , LIT : None , LIT : LIT , LIT : LIT , LIT : LIT }"
    },
    {
      "module_path": "action11.py",
      "qualname": "extract_person_data_for_scoring",
      "lineno": 424,
      "end_lineno": 451,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(person)",
      "fingerprint": "7140b5246f3676c0f76a42b681ca93f1e59a1edc",
      "simhash64": 7452291964523156539,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT try : NAME , NAME = NAME ( NAME ) NAME , NAME , NAME , NAME = NAME ( NAME ) NAME = NAME ( NAME ) return { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , # Use birth_place_disp for scoring function LIT : NAME , # Use death_place_disp for scoring function LIT : NAME # Use gender_norm and lowercase for scoring } except NAME as NAME : NAME . NAME ( f\" Error extracting person data: { NAME } \" ) return NAME ( )"
    },
    {
      "module_path": "action11.py",
      "qualname": "extract_year_from_event",
      "lineno": 454,
      "end_lineno": 481,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 9,
      "loc": 28,
      "tags": [
        "pure-ish",
        "regex",
        "size:small"
      ],
      "signature": "(event)",
      "fingerprint": "1251e9bcc8443a4e38f35201782983425fad9370",
      "simhash64": 7488180023038751779,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT try : # Try various date fields from the API response NAME = None # Check for direct date fields (API format) if LIT in NAME : NAME = NAME [ LIT ] # e.g., \"15/6/1941\" elif LIT in NAME : NAME = NAME [ LIT ] # e.g., \"1941-06-15\" elif LIT in NAME : NAME = NAME [ LIT ] if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) else : NAME = NAME ( NAME ) if NAME : # Extract 4-digit year from various formats import NAME NAME = NAME . NAME ( LIT , NAME ( NAME ) ) if NAME : return NAME ( NAME . NAME ( LIT ) ) return None except NAME : return None"
    },
    {
      "module_path": "action11.py",
      "qualname": "run_action11",
      "lineno": 484,
      "end_lineno": 494,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "c89d88f88a5367d89be9f599fbb2efb9037376ce",
      "simhash64": 7488179989694551043,
      "normalized": "def NAME ( NAME : NAME [ NAME ] = None ) -> NAME : LIT return NAME ( NAME )"
    },
    {
      "module_path": "action11.py",
      "qualname": "_validate_existing_session",
      "lineno": 498,
      "end_lineno": 509,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "70a5040945e261510ec2ebf4862188a558c098e5",
      "simhash64": 7488180023047140355,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME [ NAME ] : LIT if NAME and NAME . NAME ( ) : NAME . NAME ( LIT ) return NAME if NAME : NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) return None"
    },
    {
      "module_path": "action11.py",
      "qualname": "_create_new_session_manager",
      "lineno": 512,
      "end_lineno": 522,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "83a7d39dceebb82a60e948e7a96a8db95c7c7fba",
      "simhash64": 7487757810582074403,
      "normalized": "def NAME ( ) -> NAME [ NAME ] : LIT NAME . NAME ( LIT ) NAME = NAME ( ) # Start browser session (needed for authentication) if not NAME . NAME ( LIT ) : NAME . NAME ( LIT ) return None return NAME"
    },
    {
      "module_path": "action11.py",
      "qualname": "_authenticate_session",
      "lineno": 525,
      "end_lineno": 546,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "bc94340094f4fb722434e70ff24a2a20f9849e1f",
      "simhash64": 7488215207352112131,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT from NAME import NAME , NAME NAME . NAME ( LIT ) NAME = NAME ( NAME , NAME = False ) if NAME is True : NAME . NAME ( LIT ) return True if NAME is False : NAME . NAME ( LIT ) NAME = NAME ( NAME ) if NAME == LIT : NAME . NAME ( LIT ) return True NAME . NAME ( f\" Authentication failed: { NAME } \" ) return False NAME . NAME ( LIT ) return False"
    },
    {
      "module_path": "action11.py",
      "qualname": "get_api_session",
      "lineno": 549,
      "end_lineno": 573,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 25,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "2d57781f33d7f1e17a98d736f264d04834a4875a",
      "simhash64": 7488109654237418547,
      "normalized": "def NAME ( NAME : NAME [ NAME ] = None ) -> NAME [ NAME ] : LIT # Check if existing session is valid NAME = NAME ( NAME ) if NAME : return NAME # Create a new SessionManager for standalone execution try : NAME = NAME ( ) if not NAME : return None # Authenticate the session if NAME ( NAME ) : return NAME return None except NAME as NAME : NAME . NAME ( f\" Failed to create authenticated SessionManager: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "action11.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 577,
      "end_lineno": 1170,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 13,
      "yield_count": 0,
      "complexity": 68,
      "loc": 594,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "regex",
        "json",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "(session_manager)",
      "fingerprint": "3402de5d0f31a861ec164ca32453a23e4410e1b6",
      "simhash64": 7452151227035849787,
      "normalized": "def NAME ( NAME : NAME [ NAME ] = None ) -> NAME : LIT # Temporarily increase log level to reduce noise during tests import NAME NAME = NAME . NAME ( ) . NAME NAME . NAME ( ) . NAME ( NAME . NAME ) NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # --- TESTS --- def NAME ( NAME : NAME [ [ ] , NAME ] ) -> NAME [ [ ] , NAME ] : def NAME ( ) -> NAME : return NAME ( ) # Debug timing removed for cleaner output return NAME def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Get test person name from .env configuration NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = f\" { NAME } { NAME } \" NAME ( LIT ) # Test cases with expected outputs NAME = [ ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( NAME , NAME , LIT ) , ( LIT , LIT , LIT ) ] NAME = LIT for NAME , NAME , NAME in NAME : # Use the sanitize function NAME = NAME ( NAME ) if NAME . NAME ( ) else LIT NAME = LIT if NAME == NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" Input: ' { NAME } ' \u2192 Output: ' { NAME } ' (Expected: ' { NAME } ') \" ) if NAME == NAME : NAME += LIT NAME ( f\" \ud83d\udcca Results: { NAME } / { NAME ( NAME ) } test cases passed \" ) return NAME == NAME ( NAME ) def NAME ( ) -> None : LIT NAME ( LIT ) # Test cases with expected outputs NAME = [ ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) ] NAME = LIT for NAME , NAME , NAME in NAME : # Use a simple year extraction function import NAME NAME = NAME . NAME ( LIT , NAME ) NAME = NAME ( NAME . NAME ( LIT ) ) if NAME else None NAME = LIT if NAME == NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" Input: ' { NAME } ' \u2192 Output: { NAME } (Expected: { NAME } ) \" ) if NAME == NAME : NAME += LIT NAME ( f\" \ud83d\udcca Results: { NAME } / { NAME ( NAME ) } input formats validated correctly \" ) return NAME == NAME ( NAME ) def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Get test person data from .env configuration NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) # Check if we have a valid session for API calls NAME = NAME ( NAME ) if not NAME : NAME ( f\" { NAME . NAME } \u274c Failed to create API session for search test { NAME . NAME } \" ) raise NAME ( LIT ) # Enhanced search criteria with revised format NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME . NAME ( ) , # Use lowercase for scoring consistency LIT : LIT , # Search for 'Banff' within the full place name LIT : None , LIT : None } NAME ( LIT ) NAME ( f\" \u2022 First Name contains: { NAME . NAME ( ) } \" ) NAME ( f\" \u2022 Surname contains: { NAME . NAME ( ) } \" ) NAME ( f\" \u2022 Birth Year: { NAME } \" ) NAME ( f\" \u2022 Gender: { NAME . NAME ( ) } \" ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) try : # Use enhanced TreesUI search with new endpoint and performance monitoring import NAME NAME = NAME . NAME ( ) NAME ( f\" \ud83d\udd0d Starting search at { NAME . NAME ( LIT ) } ... \" ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = LIT # Reduced from 5 to 3 for faster processing ) NAME = NAME . NAME ( ) - NAME NAME ( f\" \ud83d\udd0d Search completed at { NAME . NAME ( LIT ) } (took { NAME : .3f } s) \" ) NAME ( LIT ) NAME ( f\" Search time: { NAME : .3f } s \" ) NAME ( f\" Total matches: { NAME ( NAME ) } \" ) if NAME : NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) NAME ( f\" Top match: { NAME } (Score: { NAME } ) \" ) NAME ( f\" Score validation: { NAME >= LIT } \" ) # Lower threshold for API # Cache Fraser's data for Test 4 reuse global NAME , NAME NAME = NAME NAME = NAME # Validate expected score from .env NAME = NAME == NAME NAME ( f\" Expected score validation: { NAME } (Expected: { NAME } , Actual: { NAME } ) \" ) if not NAME : NAME ( f\" \u26a0\ufe0f WARNING: Score mismatch! Expected { NAME } but got { NAME } \" ) # Validate performance with more detailed feedback NAME = NAME < LIT # Reduced threshold for better performance NAME = LIT if NAME < LIT else LIT if NAME < LIT else LIT NAME ( f\" Performance validation: { NAME } (< 8.0s) - { NAME } \" ) if NAME > LIT : NAME ( f\" \u26a0\ufe0f WARNING: Search took { NAME : .3f } s which may indicate performance issues \" ) # Display detailed scoring breakdown exactly like Action 10 NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , { } ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) # Map field scores to Action 10 format NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } # Display each field score in Action 10 format NAME = LIT for NAME , NAME in NAME . NAME ( ) : NAME = NAME . NAME ( NAME , LIT ) NAME += NAME NAME ( f\" { NAME : <12 } { NAME : <6 } { NAME } \" ) NAME ( LIT ) NAME ( f\" Total { NAME : <6 } Final Match Score \" ) NAME ( ) # STRICT validation - must find Fraser Gault with good score NAME = f\" { NAME } { NAME } \" NAME = NAME . NAME ( LIT , LIT ) # Check if we found the right person if NAME . NAME ( ) not in NAME . NAME ( ) or NAME . NAME ( ) not in NAME . NAME ( ) : NAME ( f\" \u274c WRONG PERSON FOUND: Expected ' { NAME } ', got ' { NAME } ' \" ) raise NAME ( f\" API search found wrong person: expected ' { NAME } ', got ' { NAME } ' \" ) # Check score is adequate if NAME < LIT : NAME ( f\" \u274c SCORE TOO LOW: Expected \u226550, got { NAME } \" ) raise NAME ( f\" API search score too low: expected \u226550, got { NAME } \" ) # Check expected score matches if NAME != NAME : NAME ( f\" \u274c SCORE MISMATCH: Expected { NAME } , got { NAME } \" ) raise NAME ( f\" API search score mismatch: expected { NAME } , got { NAME } \" ) # Check performance assert NAME , f\" API search should complete in < 8s, took { NAME : .3f } s \" NAME ( f\" \u2705 Found correct person: { NAME } with score { NAME } \" ) NAME ( f\" \u2705 Score matches expected value: { NAME } \" ) else : NAME ( LIT ) raise NAME ( f\" API search must find { NAME } { NAME } but found 0 matches \" ) NAME ( LIT ) NAME ( f\" Conclusion: API search functionality validated with { NAME ( NAME ) } matches \" ) return True except NAME as NAME : NAME ( f\" \u274c API search test failed with exception: { NAME } \" ) NAME . NAME ( f\" API search test error: { NAME } \" , NAME = True ) return False def NAME ( ) -> None : LIT import NAME import NAME from NAME import NAME NAME ( ) # Check if we have cached Fraser data from Test 3 # Read-only usage; no need to declare global # Check if we have a valid session for API calls NAME = NAME ( NAME ) if not NAME : NAME ( LIT ) raise NAME ( LIT ) NAME ( LIT ) try : # Use cached Fraser data from Test 3 if available if NAME and NAME : NAME = NAME NAME = NAME NAME ( LIT ) NAME ( f\" Name: { NAME } \" ) NAME ( f\" Person ID: { NAME } \" ) else : NAME ( LIT ) # Fallback to search if no cached data NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME . NAME ( ) , LIT : LIT , LIT : None , LIT : None } NAME = NAME ( NAME = NAME , NAME = NAME , NAME = LIT ) if not NAME : NAME ( LIT ) raise NAME ( LIT ) NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" \u2705 Found Fraser: { NAME } \" ) # Step 2: Get family details using the better editrelationships API endpoint NAME ( LIT ) if not NAME : NAME ( LIT ) raise NAME ( LIT ) # Get required IDs for the API call NAME = NAME . NAME or NAME . NAME NAME = NAME . NAME if not NAME or not NAME : NAME ( f\" \u274c Missing required IDs - User ID: { NAME } , Tree ID: { NAME } \" ) raise NAME ( LIT ) # Use the editrelationships endpoint (much better than other endpoints) NAME = NAME . NAME . NAME . NAME ( LIT ) NAME = f\" { NAME } /family-tree/person/addedit/user/ { NAME } /tree/ { NAME } /person/ { NAME } /editrelationships \" NAME ( LIT ) NAME = f\" { NAME } : { NAME } : { NAME } \" NAME = NAME . NAME ( NAME ) if NAME is None : NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , NAME = False ) if NAME ( NAME , NAME ) : NAME [ NAME ] = NAME if NAME and NAME ( NAME , NAME ) and NAME . NAME ( LIT ) : # Parse the JSON data from the response NAME = NAME . NAME ( NAME [ LIT ] ) NAME = NAME . NAME ( LIT , { } ) NAME ( f\" \\n\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66 Family Details for { NAME } : \" ) # Extract and display family relationships NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME . NAME ( LIT , [ [ ] ] ) [ LIT ] if NAME . NAME ( LIT ) else [ ] NAME ( f\" \ud83d\udc68 Fathers ( { NAME ( NAME ) } ): \" ) for NAME in NAME : NAME = f\" { NAME [ LIT ] [ LIT ] } { NAME [ LIT ] [ LIT ] } \" NAME = LIT NAME = LIT if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (b. { NAME [ LIT ] [ LIT ] } \" if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" - { NAME [ LIT ] [ LIT ] } ) \" else : NAME += LIT elif NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (d. { NAME [ LIT ] [ LIT ] } ) \" NAME ( f\" \u2022 { NAME } { NAME } { NAME } \" ) NAME ( f\" \ud83d\udc69 Mothers ( { NAME ( NAME ) } ): \" ) for NAME in NAME : NAME = f\" { NAME [ LIT ] [ LIT ] } { NAME [ LIT ] [ LIT ] } \" NAME = LIT NAME = LIT if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (b. { NAME [ LIT ] [ LIT ] } \" if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" - { NAME [ LIT ] [ LIT ] } ) \" else : NAME += LIT elif NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (d. { NAME [ LIT ] [ LIT ] } ) \" NAME ( f\" \u2022 { NAME } { NAME } { NAME } \" ) NAME ( f\" \ud83d\udc91 Spouses ( { NAME ( NAME ) } ): \" ) for NAME in NAME : NAME = f\" { NAME [ LIT ] [ LIT ] } { NAME [ LIT ] [ LIT ] } \" NAME = LIT NAME = LIT if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (b. { NAME [ LIT ] [ LIT ] } \" if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" - { NAME [ LIT ] [ LIT ] } ) \" else : NAME += LIT elif NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (d. { NAME [ LIT ] [ LIT ] } ) \" NAME ( f\" \u2022 { NAME } { NAME } { NAME } \" ) NAME ( f\" \ud83d\udc76 Children ( { NAME ( NAME ) } ): \" ) for NAME in NAME : NAME = f\" { NAME [ LIT ] [ LIT ] } { NAME [ LIT ] [ LIT ] } \" NAME = LIT NAME = LIT if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (b. { NAME [ LIT ] [ LIT ] } \" if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" - { NAME [ LIT ] [ LIT ] } ) \" else : NAME += LIT elif NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (d. { NAME [ LIT ] [ LIT ] } ) \" NAME ( f\" \u2022 { NAME } { NAME } { NAME } \" ) NAME = NAME ( NAME ) + NAME ( NAME ) + NAME ( NAME ) + NAME ( NAME ) NAME ( LIT ) NAME ( f\" Total family members found: { NAME } \" ) NAME ( LIT ) return True NAME ( LIT ) raise NAME ( LIT ) except NAME as NAME : NAME ( f\" \u274c API family analysis test failed: { NAME } \" ) NAME . NAME ( f\" API family analysis error: { NAME } \" , NAME = True ) return False def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Check if we have cached Fraser data from Test 3 # Read-only usage; no need to declare global # Get tree owner data from configuration NAME = NAME . NAME if NAME else LIT # Check if we have a valid session for API calls NAME = NAME ( NAME ) if not NAME : NAME ( LIT ) raise NAME ( LIT ) try : # Use cached Fraser data from Test 3 if available if NAME and NAME : NAME = NAME NAME = NAME else : NAME ( LIT ) # Fallback to search if no cached data NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME . NAME ( ) , LIT : LIT , LIT : None , LIT : None } NAME = NAME ( NAME = NAME , NAME = NAME , NAME = LIT ) if not NAME : NAME ( LIT ) raise NAME ( LIT ) NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" \u2705 Found Fraser: { NAME } \" ) # Step 2: Get reference person information NAME = NAME . NAME if NAME else None if not NAME : NAME ( LIT ) return True if not NAME : NAME ( LIT ) raise NAME ( LIT ) # Get required IDs for the API call NAME = NAME . NAME or NAME . NAME NAME = NAME . NAME if not NAME or not NAME : NAME ( f\" \u274c Missing required IDs - User ID: { NAME } , Tree ID: { NAME } \" ) raise NAME ( LIT ) # Use the relationladderwithlabels endpoint (perfect for relationship paths) NAME = NAME . NAME . NAME . NAME ( LIT ) NAME = f\" { NAME } /family-tree/person/card/user/ { NAME } /tree/ { NAME } /person/ { NAME } /kinship/relationladderwithlabels \" NAME = f\" { NAME } : { NAME } : { NAME } \" NAME = NAME . NAME ( NAME ) if NAME is None : NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , NAME = False ) if NAME ( NAME , NAME ) : NAME [ NAME ] = NAME if NAME and NAME ( NAME , NAME ) and NAME . NAME ( LIT ) : NAME = NAME [ LIT ] # Display the relationship path like Action 10's format NAME ( f\" Relationship Path from { NAME } to { NAME } :\\n \" ) # Show the complete relationship path for NAME , NAME in NAME ( NAME ) : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) # Format the relationship display if NAME == LIT : # First person (Fraser) - show as starting point NAME ( f\" { NAME + LIT } . { NAME } ( { NAME } ) - { NAME } \" ) else : # Subsequent persons in the path NAME ( f\" { NAME + LIT } . { NAME } ( { NAME } ) - { NAME } \" ) # Check if we found the expected uncle relationship NAME = NAME ( ( NAME for NAME in NAME if LIT in NAME . NAME ( LIT , LIT ) ) , None ) if NAME and LIT in NAME . NAME ( LIT , LIT ) . NAME ( ) : NAME ( LIT ) NAME ( f\" Fraser Gault is confirmed as uncle to { NAME } \" ) else : NAME ( LIT ) NAME ( LIT ) NAME ( f\" Conclusion: Relationship path between Fraser Gault and { NAME } successfully calculated via API \" ) return True NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) return True except NAME as NAME : NAME ( f\" \u274c API relationship path test failed: { NAME } \" ) NAME . NAME ( f\" API relationship path error: { NAME } \" , NAME = True ) return False # Run tests with the same clean formatting as Action 10 NAME = [ ( LIT , LIT , LIT , LIT , NAME ) , ( LIT , LIT , LIT , LIT , NAME ) , ( LIT , LIT , LIT , LIT , NAME ) , ( LIT , LIT , LIT , LIT , NAME ) , ( LIT , LIT , LIT , LIT , NAME ) , ] for NAME , ( NAME , NAME , NAME , NAME , NAME ) in NAME ( NAME , LIT ) : NAME . NAME ( f\" \u2699\ufe0f Test { NAME } : { NAME } \" , NAME ( NAME ) , NAME , NAME , NAME , ) # Restore original log level NAME . NAME ( ) . NAME ( NAME ) return NAME . NAME ( )"
    },
    {
      "module_path": "action11.py",
      "qualname": "debug_wrapper",
      "lineno": 598,
      "end_lineno": 602,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(test_func)",
      "fingerprint": "f320df97f9b85865172e63bd9ce7131ffeff5a51",
      "simhash64": 5180085731766218791,
      "normalized": "def NAME ( NAME : NAME [ [ ] , NAME ] ) -> NAME [ [ ] , NAME ] : def NAME ( ) -> NAME : return NAME ( ) # Debug timing removed for cleaner output return NAME"
    },
    {
      "module_path": "action11.py",
      "qualname": "wrapped",
      "lineno": 599,
      "end_lineno": 600,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "029a2369e64f9c03dad5626271350f86412ad905",
      "simhash64": 8638454424890410019,
      "normalized": "def NAME ( ) -> NAME : return NAME ( )"
    },
    {
      "module_path": "action11.py",
      "qualname": "test_input_sanitization",
      "lineno": 604,
      "end_lineno": 638,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 35,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "1b0617f43bfe9f78a95c047ab7447fc7c1512c7b",
      "simhash64": 5145886005357089851,
      "normalized": "def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Get test person name from .env configuration NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = f\" { NAME } { NAME } \" NAME ( LIT ) # Test cases with expected outputs NAME = [ ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( NAME , NAME , LIT ) , ( LIT , LIT , LIT ) ] NAME = LIT for NAME , NAME , NAME in NAME : # Use the sanitize function NAME = NAME ( NAME ) if NAME . NAME ( ) else LIT NAME = LIT if NAME == NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" Input: ' { NAME } ' \u2192 Output: ' { NAME } ' (Expected: ' { NAME } ') \" ) if NAME == NAME : NAME += LIT NAME ( f\" \ud83d\udcca Results: { NAME } / { NAME ( NAME ) } test cases passed \" ) return NAME == NAME ( NAME )"
    },
    {
      "module_path": "action11.py",
      "qualname": "test_date_parsing",
      "lineno": 640,
      "end_lineno": 667,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 28,
      "tags": [
        "impure",
        "logging",
        "regex",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "199558ad7bd1809beb8a87d5cc70295c3c1eab97",
      "simhash64": 7451729014570783787,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) # Test cases with expected outputs NAME = [ ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) ] NAME = LIT for NAME , NAME , NAME in NAME : # Use a simple year extraction function import NAME NAME = NAME . NAME ( LIT , NAME ) NAME = NAME ( NAME . NAME ( LIT ) ) if NAME else None NAME = LIT if NAME == NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" Input: ' { NAME } ' \u2192 Output: { NAME } (Expected: { NAME } ) \" ) if NAME == NAME : NAME += LIT NAME ( f\" \ud83d\udcca Results: { NAME } / { NAME ( NAME ) } input formats validated correctly \" ) return NAME == NAME ( NAME )"
    },
    {
      "module_path": "action11.py",
      "qualname": "test_api_search_functionality",
      "lineno": 669,
      "end_lineno": 829,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 12,
      "loc": 161,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "af2f5207f6cf5a122daba3ca53bddf5b4f7352b2",
      "simhash64": 7487757811589748283,
      "normalized": "def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Get test person data from .env configuration NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) # Check if we have a valid session for API calls NAME = NAME ( NAME ) if not NAME : NAME ( f\" { NAME . NAME } \u274c Failed to create API session for search test { NAME . NAME } \" ) raise NAME ( LIT ) # Enhanced search criteria with revised format NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME . NAME ( ) , # Use lowercase for scoring consistency LIT : LIT , # Search for 'Banff' within the full place name LIT : None , LIT : None } NAME ( LIT ) NAME ( f\" \u2022 First Name contains: { NAME . NAME ( ) } \" ) NAME ( f\" \u2022 Surname contains: { NAME . NAME ( ) } \" ) NAME ( f\" \u2022 Birth Year: { NAME } \" ) NAME ( f\" \u2022 Gender: { NAME . NAME ( ) } \" ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) try : # Use enhanced TreesUI search with new endpoint and performance monitoring import NAME NAME = NAME . NAME ( ) NAME ( f\" \ud83d\udd0d Starting search at { NAME . NAME ( LIT ) } ... \" ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = LIT # Reduced from 5 to 3 for faster processing ) NAME = NAME . NAME ( ) - NAME NAME ( f\" \ud83d\udd0d Search completed at { NAME . NAME ( LIT ) } (took { NAME : .3f } s) \" ) NAME ( LIT ) NAME ( f\" Search time: { NAME : .3f } s \" ) NAME ( f\" Total matches: { NAME ( NAME ) } \" ) if NAME : NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) NAME ( f\" Top match: { NAME } (Score: { NAME } ) \" ) NAME ( f\" Score validation: { NAME >= LIT } \" ) # Lower threshold for API # Cache Fraser's data for Test 4 reuse global NAME , NAME NAME = NAME NAME = NAME # Validate expected score from .env NAME = NAME == NAME NAME ( f\" Expected score validation: { NAME } (Expected: { NAME } , Actual: { NAME } ) \" ) if not NAME : NAME ( f\" \u26a0\ufe0f WARNING: Score mismatch! Expected { NAME } but got { NAME } \" ) # Validate performance with more detailed feedback NAME = NAME < LIT # Reduced threshold for better performance NAME = LIT if NAME < LIT else LIT if NAME < LIT else LIT NAME ( f\" Performance validation: { NAME } (< 8.0s) - { NAME } \" ) if NAME > LIT : NAME ( f\" \u26a0\ufe0f WARNING: Search took { NAME : .3f } s which may indicate performance issues \" ) # Display detailed scoring breakdown exactly like Action 10 NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , { } ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) # Map field scores to Action 10 format NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } # Display each field score in Action 10 format NAME = LIT for NAME , NAME in NAME . NAME ( ) : NAME = NAME . NAME ( NAME , LIT ) NAME += NAME NAME ( f\" { NAME : <12 } { NAME : <6 } { NAME } \" ) NAME ( LIT ) NAME ( f\" Total { NAME : <6 } Final Match Score \" ) NAME ( ) # STRICT validation - must find Fraser Gault with good score NAME = f\" { NAME } { NAME } \" NAME = NAME . NAME ( LIT , LIT ) # Check if we found the right person if NAME . NAME ( ) not in NAME . NAME ( ) or NAME . NAME ( ) not in NAME . NAME ( ) : NAME ( f\" \u274c WRONG PERSON FOUND: Expected ' { NAME } ', got ' { NAME } ' \" ) raise NAME ( f\" API search found wrong person: expected ' { NAME } ', got ' { NAME } ' \" ) # Check score is adequate if NAME < LIT : NAME ( f\" \u274c SCORE TOO LOW: Expected \u226550, got { NAME } \" ) raise NAME ( f\" API search score too low: expected \u226550, got { NAME } \" ) # Check expected score matches if NAME != NAME : NAME ( f\" \u274c SCORE MISMATCH: Expected { NAME } , got { NAME } \" ) raise NAME ( f\" API search score mismatch: expected { NAME } , got { NAME } \" ) # Check performance assert NAME , f\" API search should complete in < 8s, took { NAME : .3f } s \" NAME ( f\" \u2705 Found correct person: { NAME } with score { NAME } \" ) NAME ( f\" \u2705 Score matches expected value: { NAME } \" ) else : NAME ( LIT ) raise NAME ( f\" API search must find { NAME } { NAME } but found 0 matches \" ) NAME ( LIT ) NAME ( f\" Conclusion: API search functionality validated with { NAME ( NAME ) } matches \" ) return True except NAME as NAME : NAME ( f\" \u274c API search test failed with exception: { NAME } \" ) NAME . NAME ( f\" API search test error: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "action11.py",
      "qualname": "test_api_family_analysis",
      "lineno": 831,
      "end_lineno": 1010,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 31,
      "loc": 180,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "json",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "d36ef9c8ecafeffd8342b0fec71a373e64afc7f4",
      "simhash64": 7452151227035849787,
      "normalized": "def NAME ( ) -> None : LIT import NAME import NAME from NAME import NAME NAME ( ) # Check if we have cached Fraser data from Test 3 # Read-only usage; no need to declare global # Check if we have a valid session for API calls NAME = NAME ( NAME ) if not NAME : NAME ( LIT ) raise NAME ( LIT ) NAME ( LIT ) try : # Use cached Fraser data from Test 3 if available if NAME and NAME : NAME = NAME NAME = NAME NAME ( LIT ) NAME ( f\" Name: { NAME } \" ) NAME ( f\" Person ID: { NAME } \" ) else : NAME ( LIT ) # Fallback to search if no cached data NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME . NAME ( ) , LIT : LIT , LIT : None , LIT : None } NAME = NAME ( NAME = NAME , NAME = NAME , NAME = LIT ) if not NAME : NAME ( LIT ) raise NAME ( LIT ) NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" \u2705 Found Fraser: { NAME } \" ) # Step 2: Get family details using the better editrelationships API endpoint NAME ( LIT ) if not NAME : NAME ( LIT ) raise NAME ( LIT ) # Get required IDs for the API call NAME = NAME . NAME or NAME . NAME NAME = NAME . NAME if not NAME or not NAME : NAME ( f\" \u274c Missing required IDs - User ID: { NAME } , Tree ID: { NAME } \" ) raise NAME ( LIT ) # Use the editrelationships endpoint (much better than other endpoints) NAME = NAME . NAME . NAME . NAME ( LIT ) NAME = f\" { NAME } /family-tree/person/addedit/user/ { NAME } /tree/ { NAME } /person/ { NAME } /editrelationships \" NAME ( LIT ) NAME = f\" { NAME } : { NAME } : { NAME } \" NAME = NAME . NAME ( NAME ) if NAME is None : NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , NAME = False ) if NAME ( NAME , NAME ) : NAME [ NAME ] = NAME if NAME and NAME ( NAME , NAME ) and NAME . NAME ( LIT ) : # Parse the JSON data from the response NAME = NAME . NAME ( NAME [ LIT ] ) NAME = NAME . NAME ( LIT , { } ) NAME ( f\" \\n\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66 Family Details for { NAME } : \" ) # Extract and display family relationships NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME . NAME ( LIT , [ [ ] ] ) [ LIT ] if NAME . NAME ( LIT ) else [ ] NAME ( f\" \ud83d\udc68 Fathers ( { NAME ( NAME ) } ): \" ) for NAME in NAME : NAME = f\" { NAME [ LIT ] [ LIT ] } { NAME [ LIT ] [ LIT ] } \" NAME = LIT NAME = LIT if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (b. { NAME [ LIT ] [ LIT ] } \" if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" - { NAME [ LIT ] [ LIT ] } ) \" else : NAME += LIT elif NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (d. { NAME [ LIT ] [ LIT ] } ) \" NAME ( f\" \u2022 { NAME } { NAME } { NAME } \" ) NAME ( f\" \ud83d\udc69 Mothers ( { NAME ( NAME ) } ): \" ) for NAME in NAME : NAME = f\" { NAME [ LIT ] [ LIT ] } { NAME [ LIT ] [ LIT ] } \" NAME = LIT NAME = LIT if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (b. { NAME [ LIT ] [ LIT ] } \" if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" - { NAME [ LIT ] [ LIT ] } ) \" else : NAME += LIT elif NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (d. { NAME [ LIT ] [ LIT ] } ) \" NAME ( f\" \u2022 { NAME } { NAME } { NAME } \" ) NAME ( f\" \ud83d\udc91 Spouses ( { NAME ( NAME ) } ): \" ) for NAME in NAME : NAME = f\" { NAME [ LIT ] [ LIT ] } { NAME [ LIT ] [ LIT ] } \" NAME = LIT NAME = LIT if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (b. { NAME [ LIT ] [ LIT ] } \" if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" - { NAME [ LIT ] [ LIT ] } ) \" else : NAME += LIT elif NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (d. { NAME [ LIT ] [ LIT ] } ) \" NAME ( f\" \u2022 { NAME } { NAME } { NAME } \" ) NAME ( f\" \ud83d\udc76 Children ( { NAME ( NAME ) } ): \" ) for NAME in NAME : NAME = f\" { NAME [ LIT ] [ LIT ] } { NAME [ LIT ] [ LIT ] } \" NAME = LIT NAME = LIT if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (b. { NAME [ LIT ] [ LIT ] } \" if NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" - { NAME [ LIT ] [ LIT ] } ) \" else : NAME += LIT elif NAME . NAME ( LIT , { } ) . NAME ( LIT ) : NAME = f\" (d. { NAME [ LIT ] [ LIT ] } ) \" NAME ( f\" \u2022 { NAME } { NAME } { NAME } \" ) NAME = NAME ( NAME ) + NAME ( NAME ) + NAME ( NAME ) + NAME ( NAME ) NAME ( LIT ) NAME ( f\" Total family members found: { NAME } \" ) NAME ( LIT ) return True NAME ( LIT ) raise NAME ( LIT ) except NAME as NAME : NAME ( f\" \u274c API family analysis test failed: { NAME } \" ) NAME . NAME ( f\" API family analysis error: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "action11.py",
      "qualname": "test_api_relationship_path",
      "lineno": 1012,
      "end_lineno": 1147,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 22,
      "loc": 136,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "16f1ee3e81d818c86d5ce3868c9f8d586b43abfd",
      "simhash64": 7488180024054813755,
      "normalized": "def NAME ( ) -> None : LIT import NAME from NAME import NAME NAME ( ) # Check if we have cached Fraser data from Test 3 # Read-only usage; no need to declare global # Get tree owner data from configuration NAME = NAME . NAME if NAME else LIT # Check if we have a valid session for API calls NAME = NAME ( NAME ) if not NAME : NAME ( LIT ) raise NAME ( LIT ) try : # Use cached Fraser data from Test 3 if available if NAME and NAME : NAME = NAME NAME = NAME else : NAME ( LIT ) # Fallback to search if no cached data NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME . NAME ( ) , LIT : LIT , LIT : None , LIT : None } NAME = NAME ( NAME = NAME , NAME = NAME , NAME = LIT ) if not NAME : NAME ( LIT ) raise NAME ( LIT ) NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" \u2705 Found Fraser: { NAME } \" ) # Step 2: Get reference person information NAME = NAME . NAME if NAME else None if not NAME : NAME ( LIT ) return True if not NAME : NAME ( LIT ) raise NAME ( LIT ) # Get required IDs for the API call NAME = NAME . NAME or NAME . NAME NAME = NAME . NAME if not NAME or not NAME : NAME ( f\" \u274c Missing required IDs - User ID: { NAME } , Tree ID: { NAME } \" ) raise NAME ( LIT ) # Use the relationladderwithlabels endpoint (perfect for relationship paths) NAME = NAME . NAME . NAME . NAME ( LIT ) NAME = f\" { NAME } /family-tree/person/card/user/ { NAME } /tree/ { NAME } /person/ { NAME } /kinship/relationladderwithlabels \" NAME = f\" { NAME } : { NAME } : { NAME } \" NAME = NAME . NAME ( NAME ) if NAME is None : NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , NAME = False ) if NAME ( NAME , NAME ) : NAME [ NAME ] = NAME if NAME and NAME ( NAME , NAME ) and NAME . NAME ( LIT ) : NAME = NAME [ LIT ] # Display the relationship path like Action 10's format NAME ( f\" Relationship Path from { NAME } to { NAME } :\\n \" ) # Show the complete relationship path for NAME , NAME in NAME ( NAME ) : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) # Format the relationship display if NAME == LIT : # First person (Fraser) - show as starting point NAME ( f\" { NAME + LIT } . { NAME } ( { NAME } ) - { NAME } \" ) else : # Subsequent persons in the path NAME ( f\" { NAME + LIT } . { NAME } ( { NAME } ) - { NAME } \" ) # Check if we found the expected uncle relationship NAME = NAME ( ( NAME for NAME in NAME if LIT in NAME . NAME ( LIT , LIT ) ) , None ) if NAME and LIT in NAME . NAME ( LIT , LIT ) . NAME ( ) : NAME ( LIT ) NAME ( f\" Fraser Gault is confirmed as uncle to { NAME } \" ) else : NAME ( LIT ) NAME ( LIT ) NAME ( f\" Conclusion: Relationship path between Fraser Gault and { NAME } successfully calculated via API \" ) return True NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) return True except NAME as NAME : NAME ( f\" \u274c API relationship path test failed: { NAME } \" ) NAME . NAME ( f\" API relationship path error: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "action11.py",
      "qualname": "PerformanceFilter.filter",
      "lineno": 1201,
      "end_lineno": 1203,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self, record)",
      "fingerprint": "2cbd8fb892428837ba6752e37fc136fffb4fa7c3",
      "simhash64": 7488180022980019235,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME ) -> NAME : NAME = NAME . NAME ( ) if NAME ( NAME , LIT ) else NAME ( NAME . NAME ) return not ( LIT in NAME and LIT in NAME )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_log_api_performance",
      "lineno": 31,
      "end_lineno": 55,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 25,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:small"
      ],
      "signature": "(api_name, start_time, response_status, session_manager)",
      "fingerprint": "5e08c727827a504857abb6e43d56206f03dca9c1",
      "simhash64": 7452221560346547231,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME = LIT , NAME = None ) -> None : LIT NAME = NAME . NAME ( ) - NAME # API performance metrics (removed verbose debug logging) # Update session manager performance tracking if NAME : NAME ( NAME , NAME ) # Log warnings for slow API calls with enhanced context - ADJUSTED: Less pessimistic thresholds if NAME > LIT : # OPTIMIZATION: Increased from 10.0s to 25.0s - more realistic for batch processing NAME . NAME ( f\" Very slow API call: { NAME } took { NAME : .3f } s - consider optimization\\n \" ) elif NAME > LIT : # OPTIMIZATION: Increased from 5.0s to 15.0s - batch processing can take 10-15s normally NAME . NAME ( f\" Slow API call detected: { NAME } took { NAME : .3f } s\\n \" ) elif NAME > LIT : # OPTIMIZATION: Increased from 2.0s to 8.0s - individual API calls can take 3-8s normally NAME . NAME ( f\" Moderate API call: { NAME } took { NAME : .3f } s\\n \" ) # Track performance metrics for optimization analysis try : from NAME import NAME NAME ( NAME , NAME , NAME ) except NAME : pass # Graceful degradation if performance monitor not available"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_update_session_performance_tracking",
      "lineno": 58,
      "end_lineno": 86,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 29,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(session_manager, duration)",
      "fingerprint": "ed8da361e1c75277623a824448f489843a25fb7a",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT try : # Initialize tracking if not exists if not NAME ( NAME , LIT ) : NAME . NAME = [ ] NAME . NAME = LIT NAME . NAME = LIT # Add response time to tracking (keep last 20 calls) NAME . NAME . NAME ( NAME ) if NAME ( NAME . NAME ) > LIT : NAME . NAME . NAME ( LIT ) # Update average response time NAME . NAME = NAME ( NAME . NAME ) / NAME ( NAME . NAME ) # Track consecutive slow calls - OPTIMIZATION: Adjusted threshold to be less aggressive if NAME > LIT : # OPTIMIZATION: Increased from 5.0s to 15.0s - align with new warning thresholds NAME . NAME += LIT else : NAME . NAME = NAME ( LIT , NAME . NAME - LIT ) # Cap slow call counter to prevent endless accumulation NAME . NAME = NAME ( NAME . NAME , LIT ) except NAME as NAME : NAME . NAME ( f\" Failed to update session performance tracking: { NAME } \" ) pass"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_progress_callback",
      "lineno": 89,
      "end_lineno": 91,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(progress)",
      "fingerprint": "8e02736442e021e4444af12c5ffdf1d7db7f5776",
      "simhash64": 8605107916014785659,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT NAME . NAME ( f\" Processing progress: { NAME : .1% } complete \" )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_a6_is_process_alive",
      "lineno": 102,
      "end_lineno": 113,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "(pid)",
      "fingerprint": "64c89bf2905b635202733d98c45efb32ccc48eee",
      "simhash64": 8064667711170847991,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : try : # Windows-safe: os.kill(pid, 0) is not available; use psutil if present import NAME # type: ignore return NAME . NAME ( NAME ) except NAME : try : # Fallback heuristic: on Windows, open process via os module is limited; # assume alive if same PID as current process return NAME == NAME . NAME ( ) except NAME : return False"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_a6_acquire_single_instance_lock",
      "lineno": 116,
      "end_lineno": 156,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 11,
      "loc": 41,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "55c2afcce7ee930b5518beae18e9dda5583e37bf",
      "simhash64": 8641136711958967299,
      "normalized": "def NAME ( ) -> NAME : try : NAME . NAME ( NAME = True , NAME = True ) if NAME . NAME ( ) : try : NAME = NAME . NAME ( NAME = LIT , NAME = LIT ) . NAME ( ) NAME = NAME . NAME ( LIT ) NAME = NAME ( NAME [ LIT ] ) if NAME and NAME [ LIT ] . NAME ( ) else None except NAME : NAME = None NAME = False if NAME and NAME ( NAME ) : # Active holder: refuse return False # Not alive \u2192 consider stale NAME = True if NAME : from NAME import NAME with NAME ( NAME ) : NAME . NAME ( NAME = True ) # Create new lock file with PID|RUN_ID|timestamp NAME = f\" { NAME . NAME ( ) } | { NAME } | { NAME . NAME ( ) } \\n \" NAME . NAME ( NAME , NAME = LIT ) # Register cleanup def NAME ( ) -> None : try : # Only the owner should remove its own lock NAME = NAME . NAME ( NAME = LIT , NAME = LIT ) . NAME ( ) if NAME . NAME ( NAME ( NAME . NAME ( ) ) ) : NAME . NAME ( NAME = True ) except NAME : pass NAME . NAME ( NAME ) return True except NAME as NAME : NAME . NAME ( f\" Single-instance lock error: { NAME } \" ) return False"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_cleanup",
      "lineno": 144,
      "end_lineno": 151,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "impure",
        "filesystem",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "fc4813dbf79bc998b51ad107253da057f6cc4038",
      "simhash64": 8641136683035563015,
      "normalized": "def NAME ( ) -> None : try : # Only the owner should remove its own lock NAME = NAME . NAME ( NAME = LIT , NAME = LIT ) . NAME ( ) if NAME . NAME ( NAME ( NAME . NAME ( ) ) ) : NAME . NAME ( NAME = True ) except NAME : pass"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_a6_release_lock",
      "lineno": 160,
      "end_lineno": 168,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 9,
      "tags": [
        "impure",
        "filesystem",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "a0306d969f96f50df8efe00d5acb3ef3e5de7129",
      "simhash64": 8641137232790852619,
      "normalized": "def NAME ( ) -> None : try : if NAME . NAME ( ) : NAME = NAME . NAME ( NAME = LIT , NAME = LIT ) . NAME ( ) if NAME . NAME ( NAME ( NAME . NAME ( ) ) ) : NAME . NAME ( NAME = True ) except NAME : # Best-effort cleanup pass"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_a6_log_run_id_prefix",
      "lineno": 170,
      "end_lineno": 171,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(msg)",
      "fingerprint": "9c33b7b5a71587b092616d5dffb0fcd097f7fea9",
      "simhash64": 7452080857217929299,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : return f\" [ { NAME } ] { NAME } \""
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "ColorLogger.__init__",
      "lineno": 180,
      "end_lineno": 181,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, base_logger)",
      "fingerprint": "0f70e91530b827d64534e5f608ec2fe7441857ef",
      "simhash64": 7488109620949853267,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "ColorLogger.debug",
      "lineno": 183,
      "end_lineno": 184,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, message, *args, **kwargs)",
      "fingerprint": "a887903de87dd0024d301a3ef78163ac8b7dae2c",
      "simhash64": 7489305922887394407,
      "normalized": "def NAME ( NAME , NAME : NAME , * NAME : NAME , ** NAME : NAME ) -> None : NAME . NAME . NAME ( NAME , * NAME , ** NAME )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "ColorLogger.info",
      "lineno": 186,
      "end_lineno": 187,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, message, *args, **kwargs)",
      "fingerprint": "a887903de87dd0024d301a3ef78163ac8b7dae2c",
      "simhash64": 7489305922887394407,
      "normalized": "def NAME ( NAME , NAME : NAME , * NAME : NAME , ** NAME : NAME ) -> None : NAME . NAME . NAME ( NAME , * NAME , ** NAME )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "ColorLogger.warning",
      "lineno": 189,
      "end_lineno": 193,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, message, *args, **kwargs)",
      "fingerprint": "058f69cd83979bd0ddccdccaee3ced23bae56279",
      "simhash64": 7488109654236365939,
      "normalized": "def NAME ( NAME , NAME : NAME , * NAME : NAME , ** NAME : NAME ) -> None : # Auto-colorize warnings in yellow unless already colored if LIT not in NAME ( NAME ) : # Check if already has ANSI codes NAME = NAME . NAME ( NAME ( NAME ) ) NAME . NAME . NAME ( NAME , * NAME , ** NAME )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "ColorLogger.error",
      "lineno": 195,
      "end_lineno": 199,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "0c9c1d5b5c29c9793906b4579eb6671102878f8b",
      "simhash64": 7487546704282944627,
      "normalized": "def NAME ( NAME , NAME : NAME , ** NAME : NAME ) -> None : # Auto-colorize errors in red unless already colored if LIT not in NAME ( NAME ) : # Check if already has ANSI codes NAME = NAME . NAME ( NAME ( NAME ) ) NAME . NAME . NAME ( NAME , ** NAME )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "ColorLogger.critical",
      "lineno": 201,
      "end_lineno": 205,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "79e5dc47b959ee9bd5e4d9b9d5cefacb69d62ffd",
      "simhash64": 7488109654236374131,
      "normalized": "def NAME ( NAME , NAME : NAME , ** NAME : NAME ) -> None : # Auto-colorize critical messages in red unless already colored if LIT not in NAME ( NAME ) : # Check if already has ANSI codes NAME = NAME . NAME ( NAME ( NAME ) ) NAME . NAME . NAME ( NAME , ** NAME )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "api_cache",
      "lineno": 223,
      "end_lineno": 260,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 38,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(cache_key_prefix, ttl_seconds)",
      "fingerprint": "5cf7a556399812905bee897ca97ec083d76663f5",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME = LIT ) : LIT def NAME ( NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) -> NAME : # Create cache key from function name and arguments NAME = NAME ( NAME [ LIT : ] ) + NAME ( NAME ) if NAME ( NAME ) > LIT else NAME ( NAME ) NAME = f\" { NAME } _ { NAME . NAME ( NAME . NAME ( ) ) . NAME ( ) } \" NAME = NAME . NAME ( ) # Check cache hit if NAME in NAME : NAME , NAME = NAME [ NAME ] if NAME - NAME < NAME : # Cache hit (removed verbose debug logging) return NAME # Remove expired entry del NAME [ NAME ] # Cache miss - execute function NAME = NAME ( * NAME , ** NAME ) # Cache successful results only if NAME is not None : NAME [ NAME ] = ( NAME , NAME ) # Cleanup old cache entries (keep max 1000 entries) if NAME ( NAME ) > LIT : # Remove oldest 200 entries NAME = NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ NAME ] [ LIT ] ) for NAME in NAME [ : LIT ] : del NAME [ NAME ] return NAME return NAME return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "decorator",
      "lineno": 225,
      "end_lineno": 259,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 35,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(func)",
      "fingerprint": "cc423e777318297ae61d61e16ce4fc843d9f042b",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) -> NAME : # Create cache key from function name and arguments NAME = NAME ( NAME [ LIT : ] ) + NAME ( NAME ) if NAME ( NAME ) > LIT else NAME ( NAME ) NAME = f\" { NAME } _ { NAME . NAME ( NAME . NAME ( ) ) . NAME ( ) } \" NAME = NAME . NAME ( ) # Check cache hit if NAME in NAME : NAME , NAME = NAME [ NAME ] if NAME - NAME < NAME : # Cache hit (removed verbose debug logging) return NAME # Remove expired entry del NAME [ NAME ] # Cache miss - execute function NAME = NAME ( * NAME , ** NAME ) # Cache successful results only if NAME is not None : NAME [ NAME ] = ( NAME , NAME ) # Cleanup old cache entries (keep max 1000 entries) if NAME ( NAME ) > LIT : # Remove oldest 200 entries NAME = NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ NAME ] [ LIT ] ) for NAME in NAME [ : LIT ] : del NAME [ NAME ] return NAME return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "wrapper",
      "lineno": 227,
      "end_lineno": 258,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 32,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "3327ca57d02063563346f5ecde30de9628af15ab",
      "simhash64": 7488109654302962771,
      "normalized": "def NAME ( * NAME , ** NAME ) -> NAME : # Create cache key from function name and arguments NAME = NAME ( NAME [ LIT : ] ) + NAME ( NAME ) if NAME ( NAME ) > LIT else NAME ( NAME ) NAME = f\" { NAME } _ { NAME . NAME ( NAME . NAME ( ) ) . NAME ( ) } \" NAME = NAME . NAME ( ) # Check cache hit if NAME in NAME : NAME , NAME = NAME [ NAME ] if NAME - NAME < NAME : # Cache hit (removed verbose debug logging) return NAME # Remove expired entry del NAME [ NAME ] # Cache miss - execute function NAME = NAME ( * NAME , ** NAME ) # Cache successful results only if NAME is not None : NAME [ NAME ] = ( NAME , NAME ) # Cleanup old cache entries (keep max 1000 entries) if NAME ( NAME ) > LIT : # Remove oldest 200 entries NAME = NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ NAME ] [ LIT ] ) for NAME in NAME [ : LIT ] : del NAME [ NAME ] return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "get_critical_api_failure_threshold",
      "lineno": 347,
      "end_lineno": 350,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(total_pages)",
      "fingerprint": "66b7ea3a45410553d0dcad8718dbcc05b3a3ae43",
      "simhash64": 8032695531224340011,
      "normalized": "def NAME ( NAME : NAME = LIT ) -> NAME : LIT # Allow 1 failure per 20 pages, minimum of 10, maximum of 100 return NAME ( LIT , NAME ( LIT , NAME // LIT ) )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_get_cached_profile",
      "lineno": 385,
      "end_lineno": 397,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 13,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(profile_id)",
      "fingerprint": "3b8d7d25eff45efc454bd034ce11f487c48a6514",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT if NAME is None : return None NAME = f\" profile_details_ { NAME } \" try : NAME = NAME . NAME ( NAME , NAME = NAME , NAME = True ) if NAME is not NAME and NAME ( NAME , NAME ) : return NAME except NAME as NAME : NAME . NAME ( f\" Error reading profile cache for { NAME } : { NAME } \" ) return None"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_cache_profile",
      "lineno": 399,
      "end_lineno": 414,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(profile_id, profile_data)",
      "fingerprint": "124f8baa40012200f421a807a750a611d16e9b82",
      "simhash64": 7452151226020824635,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT if NAME is None : return NAME = f\" profile_details_ { NAME } \" try : # Cache profile data with a reasonable TTL (24 hours - profiles don't change often) NAME . NAME ( NAME , NAME , NAME = LIT , # 24 hours in seconds NAME = True ) except NAME as NAME : NAME . NAME ( f\" Error caching profile data for { NAME } : { NAME } \" )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_apply_rate_limiting",
      "lineno": 418,
      "end_lineno": 468,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 9,
      "loc": 51,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(session_manager)",
      "fingerprint": "1f9e3f386f0a4bc81a85c46803536853b9baeb44",
      "simhash64": 5145780452307940411,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT NAME = NAME ( NAME , LIT , None ) if NAME is not None and NAME ( NAME , LIT ) : NAME = NAME . NAME ( ) # Get current limiter stats for intelligent backoff NAME = NAME ( NAME , LIT , LIT ) NAME = NAME ( NAME , LIT , LIT ) # ENHANCEMENT: Check recent API performance for adaptive delays NAME = NAME ( NAME , LIT , LIT ) NAME = NAME ( NAME , LIT , LIT ) # Calculate adaptive delay based on recent performance - OPTIMIZATION: Less aggressive thresholds NAME = LIT if NAME > LIT : # OPTIMIZATION: Increased from 8.0s to 20.0s - very slow responses NAME = NAME ( NAME * LIT , LIT ) # OPTIMIZATION: Reduced multiplier from 0.3 to 0.2, max from 4.0 to 3.0 # Very slow API responses detected - adding delay (removed verbose debug) elif NAME > LIT : # OPTIMIZATION: Increased from 5.0s to 12.0s - moderate slow responses NAME = NAME ( NAME * LIT , LIT ) # OPTIMIZATION: Reduced multiplier from 0.2 to 0.1, max from 2.0 to 1.5 # Slow API responses detected - adding delay (removed verbose debug) elif NAME > LIT : # Multiple consecutive slow calls NAME = LIT # Multiple slow calls detected - adding delay (removed verbose debug) # Apply token-based backoff if NAME < LIT : # Token bucket is nearly empty - apply smart backoff NAME = NAME ( LIT / NAME , LIT ) + NAME # Add adaptive delay NAME . NAME ( f\" Smart rate limiting: Low tokens ( { NAME : .2f } ), \" f\" total delay { NAME : .2f } s (base: { NAME : .1f } s) \" ) NAME . NAME ( ) NAME . NAME ( NAME * LIT ) # Additional smart delay else : # Normal rate limiting with adaptive component NAME . NAME ( ) if NAME > LIT : NAME . NAME ( NAME ) NAME = NAME . NAME ( ) - NAME if NAME > LIT : NAME ( ) NAME . NAME ( f\" Extended rate limiting delay: { NAME : .2f } s \" ) # Track rate limiting performance NAME ( LIT , NAME , LIT ) else : # Fallback rate limiting if no dynamic limiter available NAME . NAME ( LIT ) NAME . NAME ( LIT ) # Conservative fallback"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_initialize_gather_state",
      "lineno": 476,
      "end_lineno": 488,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "83adb9220c50ff6a33e67b730e4bc324896f3f70",
      "simhash64": 5727687049184450095,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : [ ] , LIT : None , }"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_validate_start_page",
      "lineno": 494,
      "end_lineno": 504,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(start_arg)",
      "fingerprint": "38a8ef5a33dfbe6002439e6e669ba2fe4adf293a",
      "simhash64": 8640564965979624507,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT try : NAME = NAME ( NAME ) if NAME <= LIT : NAME . NAME ( f\" Invalid start page ' { NAME } '. Using default page 1. \" ) return LIT return NAME except ( NAME , NAME ) : NAME . NAME ( f\" Invalid start page value ' { NAME } '. Using default page 1. \" ) return LIT"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_get_csrf_token",
      "lineno": 510,
      "end_lineno": 557,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 10,
      "loc": 48,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(session_manager, force_api_refresh)",
      "fingerprint": "1faed8f996e987fd88234e4b0c4a1bbbe94fe42c",
      "simhash64": 7488180023047140387,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME = False ) -> NAME [ NAME ] : LIT try : # If force refresh requested, try to get fresh token from API first if NAME : try : if NAME ( NAME , LIT ) and NAME ( NAME . NAME , LIT ) : NAME = NAME . NAME . NAME ( ) if NAME : NAME . NAME ( LIT ) return NAME NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" API CSRF token refresh failed: { NAME } , falling back to cookies \" ) # Get cookies from the browser NAME = NAME . NAME . NAME ( ) # Look for CSRF token in various cookie names NAME = [ LIT , LIT , LIT , LIT ] for NAME in NAME : for NAME in NAME : if NAME [ LIT ] == NAME : return NAME [ LIT ] NAME . NAME ( LIT ) return None except NAME as NAME : NAME . NAME ( f\" Error extracting CSRF token: { NAME } \" ) return None"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_check_and_navigate_to_matches_page",
      "lineno": 564,
      "end_lineno": 589,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 26,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "814ee3c6c58c5894efa16369da8cc25cc4be8e8a",
      "simhash64": 8641066343214789651,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT NAME = NAME . NAME NAME = NAME . NAME NAME = NAME ( NAME . NAME . NAME , f\" discoveryui-matches/list/ { NAME } \" ) try : NAME = NAME . NAME # type: ignore if not NAME . NAME ( NAME ) : if not NAME ( NAME ) : NAME . NAME ( LIT ) return False else : NAME . NAME ( f\" Already on correct DNA matches page: { NAME } \" ) return True except NAME as NAME : NAME . NAME ( f\" WebDriver error checking/navigating to match list: { NAME } \" , NAME = True , ) return False"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_get_database_session_with_retry",
      "lineno": 592,
      "end_lineno": 606,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 15,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "84d817c6fa324b146b07441477c7bcf2506a58c3",
      "simhash64": 7487617073026602043,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT for NAME in NAME ( LIT ) : # DB connection retry NAME = NAME . NAME ( ) if NAME : return NAME NAME . NAME ( f\" DB session attempt { NAME + LIT } /3 failed. Retrying in 5s... \" ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) return None"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_fetch_initial_matches_data",
      "lineno": 609,
      "end_lineno": 625,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(session_manager, db_session, start_page)",
      "fingerprint": "10b8e4129ab130d3cc91e8c7e8603e8c8b390e6a",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME [ NAME [ NAME , NAME ] ] ] , NAME [ NAME ] , NAME ] : LIT if not NAME . NAME ( ) : raise NAME ( LIT ) NAME = NAME ( NAME , NAME , NAME ) if NAME is None : NAME . NAME ( f\" Initial get_matches for page { NAME } returned None. \" ) return [ ] , None , False NAME , NAME = NAME return NAME , NAME , True"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_navigate_and_get_initial_page_data",
      "lineno": 628,
      "end_lineno": 664,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 37,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(session_manager, start_page)",
      "fingerprint": "08d0a9e853803ad61c7fd6923625d781c6082940",
      "simhash64": 7452151225961059331,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME [ NAME [ NAME , NAME ] ] ] , NAME [ NAME ] , NAME ] : LIT # Check navigation if not NAME ( NAME ) : return None , None , False NAME . NAME ( f\" Fetching initial page { NAME } to determine total pages... \" ) # Get database session NAME = NAME ( NAME ) if not NAME : return None , None , False try : return NAME ( NAME , NAME , NAME ) except NAME as NAME : NAME . NAME ( f\" ConnectionError during initial get_matches: { NAME } . \" , NAME = False , ) return None , None , False except NAME as NAME : NAME . NAME ( f\" Error during initial get_matches call on page { NAME } : { NAME } \" , NAME = True , ) return None , None , False finally : if NAME : NAME . NAME ( NAME )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_determine_page_processing_range",
      "lineno": 670,
      "end_lineno": 686,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(total_pages_from_api, start_page)",
      "fingerprint": "4110bd19d5a408c3fbc03caacc5730da2c195d97",
      "simhash64": 7488109654235841555,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME . NAME NAME . NAME ( f\" \ud83d\udd0d DEBUG MAX_PAGES config value: { NAME } (from config_schema.api.max_pages) \" ) NAME = ( NAME ( NAME , NAME ) if NAME > LIT else NAME ) NAME . NAME ( f\" \ud83d\udd0d DEBUG pages_to_process_config calculated: { NAME } \" ) NAME = NAME ( NAME + NAME - LIT , NAME ) NAME = NAME ( LIT , NAME - NAME + LIT ) return NAME , NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_main_page_processing_loop",
      "lineno": 692,
      "end_lineno": 1220,
      "is_method": false,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 101,
      "loc": 529,
      "tags": [
        "impure",
        "network",
        "time",
        "regex",
        "size:large"
      ],
      "signature": "(session_manager, start_page, last_page_to_process, total_pages_in_run, initial_matches_on_page, state)",
      "fingerprint": "c761c32d910f6b2e22fd0a06833f05dac5b2b20e",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , # Added this argument NAME : NAME [ NAME [ NAME [ NAME , NAME ] ] ] , NAME : NAME [ NAME , NAME ] , # Pass the whole state dict ) -> NAME : LIT # Calculate dynamic API failure threshold based on total pages to process global NAME NAME = NAME ( NAME ) NAME = NAME NAME = NAME NAME . NAME ( f\" \ud83d\udd27 Dynamic API failure threshold: { NAME } (was { NAME } ) for { NAME } pages \" ) NAME = NAME # Estimate total matches for the progress bar based on pages *this run* NAME = NAME * NAME if ( NAME == LIT and NAME is not None ) : # If first page data already exists NAME = NAME ( NAME , NAME ( NAME ) ) # Ensure we always have a valid total for the progress bar if NAME <= LIT : NAME = NAME # Default to one page worth NAME . NAME ( f\" Progress bar total set to: { NAME } matches \" ) NAME = True # Success flag for this loop's execution # PHASE 1 OPTIMIZATION: Enhanced progress tracking with ETA and memory monitoring # Use central ProgressIndicator as the single source of truth for the bar and stats with NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = True , NAME = True , NAME = False , NAME = False , NAME = False , ) as NAME : try : NAME : NAME [ NAME [ NAME [ NAME , NAME ] ] ] = ( NAME ) while NAME <= NAME : # Log progress every 10 pages or 10% if NAME > NAME and ( NAME % LIT == LIT or NAME % NAME ( LIT , NAME // LIT ) == LIT ) : NAME = NAME - NAME NAME . NAME ( f\" Action 6 Progress: Page { NAME } / { NAME } \" f\" ( { NAME } / { NAME } pages, \" f\" { NAME [ LIT ] } new, { NAME [ LIT ] } updated, \" f\" { NAME [ LIT ] } errors) \" ) # If a refresh is in progress, pause all processing until it completes while True : NAME = NAME . NAME . NAME ( LIT ) NAME = NAME ( NAME , LIT , None ) if NAME ( NAME ) : if not NAME ( ) : break else : break NAME . NAME ( f\" \u23f8\ufe0f Refresh in progress; pausing processing at page { NAME } ... \" ) NAME . NAME ( LIT ) # OPTION C: PROACTIVE BROWSER REFRESH - Check if browser needs refresh before processing if NAME . NAME ( ) : NAME . NAME ( f\" \ud83d\udd04 Performing proactive browser refresh at page { NAME } \" ) NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( f\" \u274c Proactive browser refresh failed at page { NAME } \" ) # SAFETY: Reset page count to prevent immediate re-trigger NAME . NAME [ LIT ] = LIT NAME . NAME [ LIT ] = NAME . NAME ( ) # SAFETY: Check if we can continue with current session if not NAME . NAME . NAME ( ) : NAME . NAME ( f\" \ud83d\udea8 Browser session invalid after failed refresh at page { NAME } \" ) # Trigger session death detection to prevent cascade NAME . NAME [ LIT ] . NAME ( ) NAME . NAME [ LIT ] = NAME . NAME ( ) break NAME . NAME ( LIT ) else : NAME . NAME ( f\" \u2705 Proactive browser refresh successful at page { NAME } \" ) # PROACTIVE SESSION REFRESH: Check if session needs refresh before processing if NAME . NAME ( ) : NAME . NAME ( f\" \ud83d\udd04 Performing proactive session refresh at page { NAME } \" ) # Let SessionManager manage its own refresh_in_progress flag internally NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( f\" \u274c Proactive session refresh failed at page { NAME } \" ) # Continue anyway - reactive recovery will handle if needed # AUTOMATIC INTERVENTION CHECK - Check for health monitor intervention requests if NAME . NAME ( ) : NAME . NAME ( f\" \ud83d\udea8 AUTOMATIC INTERVENTION TRIGGERED - Halting processing at page { NAME } \" ) NAME = False NAME = NAME ( LIT , NAME ( NAME . NAME . NAME or LIT ) - NAME . NAME . NAME ) if NAME > LIT : NAME . NAME ( NAME ) NAME [ LIT ] += NAME break # Exit while loop immediately # OPTION C: BROWSER HEALTH MONITORING - Check browser health before processing if not NAME . NAME ( ) : NAME . NAME ( f\" \ud83d\udea8 BROWSER DEATH DETECTED at page { NAME } \" ) # Attempt browser recovery if NAME . NAME ( ) : NAME . NAME ( f\" \u2705 Browser recovery successful at page { NAME } - continuing \" ) else : NAME . NAME ( f\" \u274c Browser recovery failed at page { NAME } - halting \" ) NAME = False NAME = NAME ( LIT , NAME ( NAME . NAME . NAME or LIT ) - NAME . NAME . NAME ) if NAME > LIT : NAME . NAME ( NAME ) NAME [ LIT ] += NAME break # Exit while loop # SURGICAL FIX #20: Universal Session Health Monitoring via SessionManager # Skip health halt while a refresh is in progress; block earlier until it's done NAME = NAME . NAME . NAME ( LIT ) NAME = NAME ( NAME ( NAME , LIT , lambda : False ) ( ) ) if not NAME and not NAME . NAME ( ) : NAME . NAME ( f\" \ud83d\udea8 SESSION DEATH DETECTED at page { NAME } . \" f\" Immediately halting processing to prevent cascade failures. \" ) NAME = False NAME = NAME ( LIT , NAME ( NAME . NAME . NAME or LIT ) - NAME . NAME . NAME ) if NAME > LIT : NAME . NAME ( NAME ) NAME [ LIT ] += NAME break # Exit while loop immediately # CRITICAL FIX: Check for emergency shutdown first if NAME ( NAME , LIT ) and NAME . NAME ( ) : NAME . NAME ( f\" \ud83d\udea8 EMERGENCY SHUTDOWN DETECTED at page { NAME } . \" f\" Immediate termination required. \" ) NAME = False NAME = NAME ( LIT , NAME ( NAME . NAME . NAME or LIT ) - NAME . NAME . NAME ) if NAME > LIT : NAME . NAME ( NAME ) NAME [ LIT ] += NAME break # Exit while loop immediately # CRITICAL FIX: Check for session death cascade halt signal if NAME . NAME ( ) : NAME = NAME . NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" \ud83d\udea8 SESSION DEATH CASCADE HALT SIGNAL at page { NAME } . \" f\" Cascade count: { NAME } . Emergency termination triggered. \" ) NAME = False NAME = NAME ( LIT , NAME ( NAME . NAME . NAME or LIT ) - NAME . NAME . NAME ) if NAME > LIT : NAME . NAME ( NAME ) NAME [ LIT ] += NAME break # Exit while loop immediately # CRITICAL FIX: Check emergency shutdown flag if NAME . NAME ( ) : NAME . NAME ( f\" \ud83d\udea8 EMERGENCY SHUTDOWN DETECTED at page { NAME } . \" f\" Terminating immediately to prevent infinite loops. \" ) NAME = False NAME = NAME ( LIT , NAME ( NAME . NAME . NAME or LIT ) - NAME . NAME . NAME ) if NAME > LIT : NAME . NAME ( NAME ) NAME [ LIT ] += NAME break # Exit while loop immediately # EMERGENCY FIX: Check for 303 redirect pattern (indicates dead session) # If we get multiple 303s in a row, the session is dead if NAME ( NAME , LIT ) and NAME . NAME >= LIT : NAME . NAME ( f\" \ud83d\udea8 DEAD SESSION DETECTED: { NAME . NAME } consecutive 303 redirects at page { NAME } . \" f\" Session is completely invalid. Halting immediately. \" ) # Force session death detection NAME . NAME [ LIT ] . NAME ( ) NAME . NAME [ LIT ] . NAME ( ) NAME = False NAME = NAME ( LIT , NAME ( NAME . NAME . NAME or LIT ) - NAME . NAME . NAME ) if NAME > LIT : NAME . NAME ( NAME ) NAME [ LIT ] += NAME break # Proactive session refresh to prevent 900-second timeout if NAME ( NAME , LIT ) and NAME . NAME : NAME = NAME . NAME ( ) - NAME . NAME if NAME > LIT : # 13 minutes - refresh before 15-minute timeout NAME . NAME ( f\" Proactively refreshing session after { NAME : .0f } seconds to prevent timeout \" ) if NAME . NAME ( ) : NAME . NAME ( LIT ) NAME . NAME = NAME . NAME ( ) # Reset session timer else : NAME . NAME ( LIT ) # SURGICAL FIX #12: Enhanced Connection Pool Optimization + Session Age Monitoring # Optimize database connections every 25 pages if NAME % LIT == LIT : try : # Database pool monitoring if NAME ( NAME , LIT ) and NAME . NAME : NAME = NAME . NAME if NAME ( NAME , LIT ) : NAME = NAME . NAME ( ) NAME = NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" Database pool status at page { NAME } : { NAME } active connections \" ) else : NAME . NAME ( f\" Database connection pool check at page { NAME } \" ) # Session age monitoring if NAME ( NAME , LIT ) : NAME = NAME . NAME ( ) NAME = NAME - NAME . NAME . NAME ( LIT , NAME ) NAME = NAME - NAME . NAME . NAME ( LIT , NAME ) NAME = NAME . NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" Session status at page { NAME } : \" f\" age= { NAME : .0f } s, since_refresh= { NAME : .0f } s, \" f\" max_age= { NAME } s ( { ( NAME / NAME ) * LIT : .1f } % of limit) \" ) # OPTION C: Browser age monitoring if NAME ( NAME , LIT ) : NAME = NAME - NAME . NAME . NAME ( LIT , NAME ) NAME = NAME - NAME . NAME . NAME ( LIT , NAME ) NAME = NAME . NAME . NAME ( LIT , LIT ) NAME = NAME . NAME . NAME ( LIT , LIT ) NAME = NAME . NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" Browser status at page { NAME } : \" f\" age= { NAME : .0f } s, since_refresh= { NAME : .0f } s, \" f\" max_age= { NAME } s ( { ( NAME / NAME ) * LIT : .1f } % of limit), \" f\" pages_since_refresh= { NAME } / { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Connection pool/session/browser check at page { NAME } : { NAME } \" ) # === CONTINUOUS HEALTH MONITORING (MOVED OUTSIDE 25-PAGE CONDITION) === # This runs on EVERY page to provide continuous monitoring and early intervention if NAME ( NAME , LIT ) and NAME . NAME : try : NAME = NAME . NAME # Update metrics on every page NAME . NAME ( NAME ) NAME . NAME ( ) # Get current health status NAME = NAME . NAME ( ) NAME = NAME [ LIT ] NAME = NAME [ LIT ] # COMPREHENSIVE HEALTH SUMMARY every 25 pages (now at DEBUG, green) if NAME % LIT == LIT : NAME . NAME ( NAME . NAME ( f\" \ud83d\udcca COMPREHENSIVE HEALTH SUMMARY - Page { NAME } \" ) ) NAME . NAME ( NAME . NAME ( f\" Health Score: { NAME : .1f } /100 ( { NAME [ LIT ] . NAME ( ) } ) \" ) ) NAME . NAME ( NAME . NAME ( f\" Risk Level: { NAME [ LIT ] } (Score: { NAME : .2f } ) \" ) ) NAME . NAME ( NAME . NAME ( f\" API Response: { NAME [ LIT ] [ LIT ] : .1f } s avg \" ) ) NAME . NAME ( NAME . NAME ( f\" Memory: { NAME [ LIT ] [ LIT ] : .1f } MB \" ) ) NAME . NAME ( NAME . NAME ( f\" Errors: { NAME [ LIT ] [ LIT ] } \" ) ) # Show recommended actions if NAME [ LIT ] : NAME . NAME ( NAME . NAME ( LIT ) ) for NAME in NAME [ LIT ] [ : LIT ] : NAME . NAME ( NAME . NAME ( f\" \u2022 { NAME } \" ) ) # EMERGENCY INTERVENTION - Check on every page if NAME > LIT : NAME . NAME ( f\" \ud83d\udea8 EMERGENCY INTERVENTION TRIGGERED - Page { NAME } \" ) NAME . NAME ( f\" Risk Score: { NAME : .2f } (EMERGENCY LEVEL) \" ) NAME . NAME ( f\" Health Score: { NAME : .1f } /100 \" ) NAME . NAME ( LIT ) # Force immediate session refresh try : NAME . NAME ( ) NAME . NAME ( f\" \u2705 Emergency session refresh completed at page { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" \u274c Emergency session refresh failed: { NAME } \" ) # If emergency refresh fails, halt processing to prevent cascade NAME . NAME ( LIT ) NAME = False break elif NAME > LIT : NAME . NAME ( f\" \u26a0\ufe0f HIGH RISK DETECTED - Page { NAME } \" ) NAME . NAME ( f\" Risk Score: { NAME : .2f } (HIGH RISK) \" ) NAME . NAME ( f\" Health Score: { NAME : .1f } /100 \" ) for NAME in NAME [ LIT ] [ : LIT ] : NAME . NAME ( f\" Recommended: { NAME } \" ) elif NAME > LIT : NAME . NAME ( f\" \u26a0\ufe0f MODERATE RISK - Page { NAME } (Risk: { NAME : .2f } , Health: { NAME : .1f } ) \" ) # VERIFICATION: Log that health monitoring is working if NAME % LIT == LIT : NAME . NAME ( f\" \u2705 Health monitoring active - Page { NAME } (Risk: { NAME : .2f } , Health: { NAME : .1f } ) \" ) # Additional verification every 10 pages try : from NAME import NAME NAME ( NAME , NAME ) except NAME as NAME : NAME . NAME ( f\" Health status verification failed: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" \u274c Health monitoring failed at page { NAME } : { NAME } \" ) # Don't let health monitoring failures stop processing, but log them prominently if not NAME . NAME ( ) : NAME . NAME ( f\" WebDriver session invalid/unreachable before processing page { NAME } . Aborting run. \" ) NAME = False NAME = NAME ( LIT , NAME ( NAME . NAME . NAME or LIT ) - NAME . NAME . NAME ) if NAME > LIT : NAME . NAME ( NAME ) NAME [ LIT ] += NAME break # Exit while loop # Fetch match data unless it's the first page and data is already available if not ( NAME == NAME and NAME is not None ) : NAME : NAME [ NAME ] = None for NAME in NAME ( LIT ) : NAME = NAME . NAME ( ) if NAME : NAME [ LIT ] = LIT break NAME . NAME ( f\" DB session attempt { NAME + LIT } /3 failed for page { NAME } . Retrying in 5s... \" ) NAME . NAME ( LIT ) if not NAME : NAME [ LIT ] += LIT NAME . NAME ( f\" Could not get DB session for page { NAME } after retries. Skipping page. \" ) NAME [ LIT ] += NAME NAME . NAME ( NAME ) if NAME [ LIT ] >= NAME : NAME . NAME ( f\" Aborting run due to { NAME [ LIT ] } consecutive DB connection failures. \" ) NAME = False NAME = NAME ( LIT , NAME ( NAME . NAME . NAME or LIT ) - NAME . NAME . NAME ) if NAME > LIT : NAME . NAME ( NAME ) NAME [ LIT ] += NAME break # Exit while loop NAME += LIT NAME = None # Ensure it's reset continue # Next page try : if not NAME . NAME ( ) : raise NAME ( f\" WebDriver session invalid before get_matches page { NAME } . \" ) NAME = NAME ( NAME , NAME , NAME ) if NAME is None : NAME = [ ] NAME . NAME ( f\" get_matches returned None for page { NAME } . Skipping. \" ) NAME . NAME ( NAME ) NAME [ LIT ] += NAME else : NAME , NAME = ( NAME # We don't need total_pages again ) except NAME as NAME : # CRITICAL FIX: Check if ConnectionError is from session death cascade if LIT in NAME ( NAME ) : NAME . NAME ( f\" \ud83d\udea8 SESSION DEATH CASCADE ConnectionError at page { NAME } : { NAME } . \" f\" Halting main loop to prevent infinite cascade. \" ) NAME = False NAME = NAME ( LIT , NAME ( NAME . NAME . NAME or LIT ) - NAME . NAME . NAME ) if NAME > LIT : NAME . NAME ( NAME ) NAME [ LIT ] += NAME break # Exit while loop immediately NAME . NAME ( f\" ConnectionError get_matches page { NAME } : { NAME } \" , NAME = False , ) NAME . NAME ( NAME ) NAME [ LIT ] += NAME NAME = [ ] # Ensure it's reset except NAME as NAME : NAME . NAME ( f\" Error get_matches page { NAME } : { NAME } \" , NAME = True , ) NAME . NAME ( NAME ) NAME [ LIT ] += NAME NAME = [ ] # Ensure it's reset finally : if NAME : NAME . NAME ( NAME ) if ( not NAME ) : # If fetch failed or returned empty NAME += LIT NAME . NAME ( LIT if NAME else LIT # PHASE 1: Reduced delays from 0.5/2.0 to 0.2/1.0 ) # Shorter sleep on success, longer on error path for this page continue # Next page if ( not NAME ) : # Should be populated or loop continued NAME . NAME ( f\" No matches found or processed on page { NAME } . \" ) # If it's the first page and initial fetch was empty, progress bar might not have been updated yet. if not ( NAME == NAME and NAME [ LIT ] == LIT ) : NAME . NAME ( NAME ) # Assume a full page skip if not first&empty NAME = None # Reset for next iteration NAME += LIT # OPTION C: Increment browser page count for health monitoring (empty page path) NAME . NAME ( ) NAME . NAME ( LIT ) # PHASE 1: Reduced from 0.5 to 0.2 continue # SURGICAL FIX #8: Page-Level Skip Detection # Quick check if entire page can be skipped based on existing data if NAME : # Get a quick DB session for page-level analysis NAME = NAME . NAME ( ) if NAME : try : NAME = [ NAME [ LIT ] . NAME ( ) for NAME in NAME if NAME . NAME ( LIT ) ] if NAME : NAME = NAME ( NAME , NAME ) NAME , NAME , NAME = ( NAME ( NAME , NAME ) ) # If all matches on the page can be skipped, do fast processing if NAME ( NAME ) == LIT : NAME . NAME ( f\" \ud83d\ude80 Page { NAME } : All { NAME ( NAME ) } matches unchanged - fast skip \" ) NAME . NAME ( NAME ( NAME ) ) NAME [ LIT ] += NAME NAME [ LIT ] += LIT NAME = None NAME += LIT # OPTION C: Increment browser page count for health monitoring (fast skip path) NAME . NAME ( ) continue # Skip to next page finally : NAME . NAME ( NAME ) NAME , NAME , NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) NAME [ LIT ] += NAME NAME [ LIT ] += NAME NAME [ LIT ] += NAME NAME [ LIT ] += NAME NAME [ LIT ] += LIT # Postfix disabled to preserve single-line progress stability NAME ( NAME , NAME ) NAME = NAME ( NAME , LIT , None ) if NAME is not None and NAME ( NAME , LIT ) : NAME . NAME ( ) NAME = ( None # CRITICAL: Clear for the next iteration ) NAME += LIT # OPTION C: Increment browser page count for health monitoring NAME . NAME ( ) finally : # Finalization handled by ProgressIndicator context manager; ensure stats reflect any remaining errors NAME = NAME ( NAME . NAME . NAME or LIT ) - NAME . NAME . NAME if NAME > LIT and not NAME : from NAME import NAME with NAME ( NAME ) : NAME . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_validate_session_state",
      "lineno": 1235,
      "end_lineno": 1253,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "311748ebd1913d94601aa1df99886b49576c2850",
      "simhash64": 7488742974007186443,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT if ( not NAME . NAME or not NAME . NAME or not NAME . NAME ) : raise NAME ( LIT , NAME = { LIT : NAME . NAME , LIT : NAME . NAME , } , ) if not NAME . NAME : raise NAME ( LIT , NAME = { LIT : LIT } , )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_initialize_coord_state",
      "lineno": 1256,
      "end_lineno": 1264,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(start)",
      "fingerprint": "23a60ee74f40fa15c0b7c91db3f5dc9310273a1e",
      "simhash64": 7488109654235853939,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] , NAME ] : LIT NAME = NAME ( ) NAME = NAME ( NAME ) # Record coord start timestamp for summary rate/time NAME [ LIT ] = NAME . NAME ( ) return NAME , NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_acquire_instance_lock",
      "lineno": 1267,
      "end_lineno": 1273,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "42bc579b0bee78a20c55355d658077e460d9c88b",
      "simhash64": 9217026268567868451,
      "normalized": "def NAME ( ) -> NAME : LIT if not NAME ( ) : # Graceful no-op: another run is active in this process or another. NAME . NAME ( NAME ( LIT ) ) return False return True"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_perform_session_recovery",
      "lineno": 1276,
      "end_lineno": 1291,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "regex",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "9d1ab5d81436896fc2333b4957841b125abf5622",
      "simhash64": 7488180022980027443,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT NAME . NAME ( LIT ) # Force complete session refresh NAME . NAME ( ) from NAME . NAME import NAME NAME = NAME ( ) NAME . NAME ( LIT ) # Re-authenticate from NAME import NAME if not NAME ( NAME , NAME = False ) : raise NAME ( LIT ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_verify_health_monitoring",
      "lineno": 1294,
      "end_lineno": 1301,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(session_manager)",
      "fingerprint": "0f80536821fba764fda85c9ff5833e31f1fdcdd6",
      "simhash64": 8641101493227136059,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT try : from NAME import NAME if not NAME ( NAME ) : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Health monitoring presence check failed (non-fatal): { NAME } \" )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_validate_api_connectivity",
      "lineno": 1304,
      "end_lineno": 1320,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "e7d314b611f57223adf752348fa63f0187b5d075",
      "simhash64": 8641136711958967315,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT NAME . NAME ( NAME ( LIT ) ) try : NAME = NAME . NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) NAME ( NAME ) else : NAME . NAME ( LIT ) NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" \ud83d\udea8 CRITICAL: Session validation failed: { NAME } \" ) raise NAME ( f\" Cannot proceed with invalid session: { NAME } \" ) from NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "coord",
      "lineno": 1323,
      "end_lineno": 1442,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 9,
      "loc": 120,
      "tags": [
        "impure",
        "logging",
        "size:large"
      ],
      "signature": "(session_manager, _config_schema, start)",
      "fingerprint": "ed52037994375d465e665e75a5d3550477136aac",
      "simhash64": 7452151225961067539,
      "normalized": "def NAME ( NAME : NAME , NAME : LIT , NAME : NAME = LIT ) -> NAME : # Uses config schema LIT # Step 1: Validate Session State NAME ( NAME ) # Step 2: Initialize state NAME = NAME # Suppress unused parameter warning NAME , NAME = NAME ( NAME ) # Acquire single-instance lock if not NAME ( ) : return True NAME . NAME ( NAME ( f\" --- Starting DNA Match Gathering (Action 6) from page { NAME } --- \" ) ) # Step 3: Validate API connectivity NAME ( NAME ) try : # Step 3: Initial Navigation and Total Pages Fetch NAME , NAME , NAME = ( NAME ( NAME , NAME ) ) if not NAME or NAME is None : NAME . NAME ( LIT ) NAME [ LIT ] = False return False # Critical failure if initial fetch fails NAME [ LIT ] = NAME NAME [ LIT ] = ( NAME if NAME is not None else [ ] ) NAME ( ) NAME . NAME ( f\" Total pages found: { NAME } \" ) # Step 4: Determine Page Range NAME , NAME = NAME ( NAME , NAME ) if NAME <= LIT : NAME . NAME ( f\" No pages to process (Start: { NAME } , End: { NAME } ). \" ) return True # Successful exit, nothing to do NAME = NAME * NAME NAME . NAME ( f\" Processing { NAME } pages (approx. { NAME } matches) \" f\" from page { NAME } to { NAME } .\\n \" ) # Step 5: Main Processing Loop (delegated) # Pass only relevant parts of initial_matches to the loop NAME = NAME [ LIT ] NAME = NAME ( NAME , NAME , NAME , NAME , # Correctly passing total_pages_in_run NAME , NAME , # Pass the whole state dict to be updated by the loop ) NAME [ LIT ] = ( NAME [ LIT ] and NAME ) # Update overall success # Step 6: Handle specific exceptions from coord's orchestration level except NAME : NAME . NAME ( LIT ) NAME [ LIT ] = False except NAME as NAME : # Catch ConnectionError if it bubbles up NAME . NAME ( f\" ConnectionError during coord execution: { NAME } \" , NAME = True , ) NAME [ LIT ] = False except NAME as NAME : NAME . NAME ( f\" Halting run due to excessive critical API failures: { NAME } \" , NAME = False , ) NAME [ LIT ] = False except NAME as NAME : NAME . NAME ( f\" Critical error during coord execution: { NAME } \\n \" , NAME = True ) NAME [ LIT ] = False finally : # Emit forensic debug before final summary NAME . NAME ( f\" Released lock for run [ { NAME } ] \" ) # Step 7: Final Summary Logging (uses updated state from the loop) NAME ( NAME [ LIT ] , NAME [ LIT ] , NAME [ LIT ] , NAME [ LIT ] , NAME [ LIT ] , NAME = NAME . NAME ( LIT ) , ) # Ensure lock release on completion NAME ( ) # Re-raise KeyboardInterrupt if that was the cause NAME = NAME . NAME ( ) if NAME [ LIT ] is NAME : NAME . NAME ( LIT ) if NAME [ LIT ] is not None : raise NAME [ LIT ] . NAME ( NAME [ LIT ] ) return NAME [ LIT ]"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_normalize_uuids",
      "lineno": 1452,
      "end_lineno": 1454,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(uuids_on_page)",
      "fingerprint": "52f723c98628694d10106ac2decb306a4b4827c0",
      "simhash64": 7488180022980031603,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME [ NAME ] : LIT return { NAME ( NAME ) . NAME ( ) for NAME in NAME }"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_query_existing_persons",
      "lineno": 1457,
      "end_lineno": 1465,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(session, uuids_norm)",
      "fingerprint": "f8b776a3552baa48b217ed6ed247e03baf45998f",
      "simhash64": 8622559368327898115,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] ) -> NAME [ NAME ] : LIT return ( NAME . NAME ( NAME ) . NAME ( NAME ( NAME . NAME ) , NAME ( NAME . NAME ) ) . NAME ( NAME . NAME . NAME ( None ) ) # Exclude soft-deleted . NAME ( NAME . NAME . NAME ( NAME ) ) . NAME ( ) )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_create_persons_map",
      "lineno": 1468,
      "end_lineno": 1474,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(existing_persons)",
      "fingerprint": "372bfdca7ad51b960c3131e90df5ac807df04a0c",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME [ NAME , NAME ] : LIT return { NAME ( NAME . NAME ) . NAME ( ) : NAME for NAME in NAME if NAME . NAME is not None }"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_handle_database_lookup_error",
      "lineno": 1477,
      "end_lineno": 1494,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 18,
      "tags": [
        "pure-ish",
        "regex",
        "size:small"
      ],
      "signature": "(db_lookup_err)",
      "fingerprint": "26cf17e37a5df1dd5855c47e31564aeb5bb7de02",
      "simhash64": 7451553095923177019,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT # Check specifically for Enum mismatch errors which can be critical if LIT in NAME ( NAME ) : NAME . NAME ( f\" CRITICAL ENUM MISMATCH during Person lookup. DB schema might be outdated. Error: { NAME } \" ) # Raise a specific error to halt processing if schema mismatch detected raise NAME ( LIT ) from NAME # Log other SQLAlchemy errors and re-raise NAME . NAME ( f\" Database lookup failed during prefetch: { NAME } \" , NAME = True , ) raise # Re-raise to be handled by the caller"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_lookup_existing_persons",
      "lineno": 1497,
      "end_lineno": 1518,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 22,
      "tags": [
        "impure",
        "size:small"
      ],
      "signature": "(session, uuids_on_page)",
      "fingerprint": "72fef1c584db446a735556aed4957e90f969d62c",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] ) -> NAME [ NAME , NAME ] : LIT # Handle empty input list if not NAME : return { } try : NAME = NAME ( NAME ) NAME = NAME ( NAME , NAME ) return NAME ( NAME ) except NAME as NAME : NAME ( NAME ) except NAME as NAME : # Catch any other unexpected errors NAME . NAME ( f\" Unexpected error during Person lookup: { NAME } \" , NAME = True ) raise # Re-raise to be handled by the caller"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_validate_match_uuid",
      "lineno": 1524,
      "end_lineno": 1530,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:tiny"
      ],
      "signature": "(match_api_data)",
      "fingerprint": "06769d80d8a804a58ef4807e188c504040c64dea",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT NAME = NAME . NAME ( LIT ) if not NAME : NAME . NAME ( f\" Skipping match missing UUID: { NAME } \" ) return None return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_handle_new_person",
      "lineno": 1533,
      "end_lineno": 1541,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(uuid_val, match_api_data, fetch_candidates_uuid, matches_to_process_later)",
      "fingerprint": "8af86a5cb61088e6e6b837e336019235832d2395",
      "simhash64": 7488180022980031571,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> None : LIT NAME . NAME ( NAME ) NAME . NAME ( NAME )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_check_dna_data_changes",
      "lineno": 1544,
      "end_lineno": 1579,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 36,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(uuid_val, match_api_data, existing_dna)",
      "fingerprint": "31cd00f97de71826e2c3dfe656b6595a847468fc",
      "simhash64": 7488180022980023323,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME : LIT if not NAME : NAME . NAME ( f\" Fetch needed (UUID { NAME } ): No existing DNA record. \" ) return True try : # Compare cM (integer conversion for safety) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME if NAME != NAME : NAME . NAME ( f\" Fetch needed (UUID { NAME } ): cM changed ( { NAME } -> { NAME } ) \" ) return True # Compare segments (integer conversion) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME if NAME != NAME : NAME . NAME ( f\" Fetch needed (UUID { NAME } ): Segments changed ( { NAME } -> { NAME } ) \" ) return True except ( NAME , NAME , NAME ) as NAME : NAME . NAME ( f\" Error comparing list DNA data for UUID { NAME } : { NAME } . Assuming fetch needed. \" ) return True return False"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_check_tree_status_changes",
      "lineno": 1582,
      "end_lineno": 1603,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 22,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(uuid_val, match_api_data, existing_person)",
      "fingerprint": "058c4abbe6a5aea4ab44b7a24e1d3fb9846ee870",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME : LIT NAME = NAME . NAME NAME = NAME . NAME NAME = NAME . NAME ( LIT , False ) if NAME ( NAME ) != NAME ( NAME ) : NAME . NAME ( f\" Fetch needed (UUID { NAME } ): Tree status changed ( { NAME } -> { NAME } ) \" ) return True if NAME and not NAME : NAME . NAME ( f\" Fetch needed (UUID { NAME } ): Marked in tree but no DB record. \" ) return True return False"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_process_existing_person",
      "lineno": 1606,
      "end_lineno": 1628,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(uuid_val, match_api_data, existing_person, fetch_candidates_uuid, matches_to_process_later)",
      "fingerprint": "61be608678f73a1d648f1e4527a59207fcdf6b50",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME : LIT NAME = NAME . NAME # Check for changes in core DNA list data NAME = NAME ( NAME , NAME , NAME ) # Check for changes in tree status or missing tree record if not NAME : NAME = NAME ( NAME , NAME , NAME ) # Add to fetch list or return skipped status if NAME : NAME . NAME ( NAME ) NAME . NAME ( NAME ) return False # Not skipped return True # Skipped"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_log_identification_summary",
      "lineno": 1631,
      "end_lineno": 1643,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(invalid_uuid_count, fetch_candidates_count, skipped_count)",
      "fingerprint": "1f3b73e1a17178bb8b3dd1e0623f49476dcf1cfe",
      "simhash64": 7488320761543177267,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) -> None : LIT if NAME > LIT : NAME . NAME ( f\" { NAME } matches skipped during identification due to missing UUID. \" ) NAME . NAME ( f\" Identified { NAME } candidates for API detail fetch, { NAME } skipped (no change detected from list view). \" )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_identify_fetch_candidates",
      "lineno": 1646,
      "end_lineno": 1686,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 41,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(matches_on_page, existing_persons_map)",
      "fingerprint": "de0e50824554991ac546bd99c887999eea653e73",
      "simhash64": 7488109654235853911,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME ] , NAME [ NAME [ NAME , NAME ] ] , NAME ] : LIT # Initialize results NAME : NAME [ NAME ] = NAME ( ) NAME = LIT NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] NAME = LIT # Iterate through matches fetched from the current page for NAME in NAME : # Validate UUID presence NAME = NAME ( NAME ) if not NAME : NAME += LIT continue # Check if this person exists in the database NAME = NAME . NAME ( NAME . NAME ( ) ) if not NAME : # New Person - always fetch details NAME ( NAME , NAME , NAME , NAME ) else : # Existing Person - determine if fetch is needed NAME = NAME ( NAME , NAME , NAME , NAME , NAME ) if NAME : NAME += LIT # Log summary of identification NAME ( NAME , NAME ( NAME ) , NAME ) return NAME , NAME , NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_perform_api_prefetches",
      "lineno": 1693,
      "end_lineno": 2092,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 68,
      "loc": 400,
      "tags": [
        "pure-ish",
        "time",
        "size:large"
      ],
      "signature": "(session_manager, fetch_candidates_uuid, matches_to_process_later)",
      "fingerprint": "106f9cb0a2f6fc03072fe7850903c9c62817d7e4",
      "simhash64": 7488180022981071891,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME [ NAME , NAME ] ] , ) -> NAME [ NAME , NAME [ NAME , NAME ] ] : LIT import NAME # For timing API operations NAME : NAME [ NAME , NAME [ NAME [ NAME , NAME ] ] ] = { } NAME : NAME [ NAME , NAME [ NAME [ NAME , NAME ] ] ] = ( { } ) # Changed to Optional value NAME : NAME [ NAME , NAME [ NAME ] ] = { } if not NAME : NAME . NAME ( LIT ) return { LIT : { } , LIT : { } , LIT : { } } NAME : NAME [ NAME , NAME [ NAME , NAME ] ] = { } NAME . NAME ( ) NAME = NAME ( NAME ) NAME = NAME . NAME NAME = LIT # SURGICAL FIX #13: Dynamic Worker Pool Optimization # Optimize worker count based on API load and rate limiting performance NAME = NAME NAME = NAME if NAME <= LIT : # Light load - reduce workers to avoid rate limiting overhead NAME = LIT # Light load optimization (removed verbose debug) elif NAME >= LIT : # Heavy load - increase workers but respect rate limits NAME = NAME ( LIT , NAME + LIT ) # Heavy load optimization (removed verbose debug) else : # Medium load - use configured workers NAME = NAME # Optimal load (removed verbose debug) # Starting parallel API pre-fetch (removed verbose debug) # CRITICAL FIX: Check for halt signal before starting batch processing if NAME . NAME ( ) : NAME = NAME . NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" \ud83d\udea8 HALT SIGNAL DETECTED: Stopping API batch processing immediately. \" f\" Cascade count: { NAME } . Preventing infinite loop. \" ) raise NAME ( f\" Session death cascade detected (# { NAME } ) - halting batch processing to prevent infinite loop \" ) NAME = { NAME [ LIT ] for NAME in NAME if NAME . NAME ( LIT ) and NAME . NAME ( LIT ) in NAME } # Identified candidates for Badge/Ladder fetch (removed verbose debug) with NAME ( NAME = NAME ) as NAME : # OPTIMIZATION: Conditional relationship probability fetching # Only fetch relationship probability for significant matches (configurable threshold) # to reduce API overhead for distant matches # PRIORITY 3: Smarter API Call Filtering - Enhanced priority classification NAME = NAME ( ) NAME = NAME ( ) for NAME in NAME : NAME = NAME . NAME ( LIT ) if NAME and NAME in NAME : NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , False ) NAME = NAME . NAME ( LIT , False ) # Enhanced priority classification if NAME or NAME > LIT : # Very high priority NAME . NAME ( NAME ) # High priority match (removed verbose debug) elif NAME > NAME or ( NAME > LIT and NAME ) : # Medium priority: above threshold OR low DNA but has tree NAME . NAME ( NAME ) # Medium priority match (removed verbose debug) else : NAME . NAME ( f\" Skipping relationship probability fetch for low-priority match { NAME [ : LIT ] } \" f\" ( { NAME } cM < { NAME } cM threshold, no tree) \" ) # Combined high and medium for API calls, but prioritize high NAME = NAME . NAME ( NAME ) NAME . NAME ( f\" API Call Filtering: { NAME ( NAME ) } high priority, \" f\" { NAME ( NAME ) } medium priority, \" f\" { NAME ( NAME ) - NAME ( NAME ) } low priority (skipped) \" ) # SURGICAL FIX #16: Intelligent Rate Limiting Prediction # Calculate total API calls needed and predict token requirements NAME = NAME ( NAME ) + NAME ( NAME ) + NAME ( NAME ) # EMERGENCY FIX: Ensure total_api_calls is always defined to prevent NameError if NAME is None : NAME = LIT if NAME > LIT : # Get current token count and fill rate from session manager NAME = NAME ( NAME , LIT , None ) if NAME : NAME = NAME ( NAME , LIT , LIT ) NAME = NAME ( NAME , LIT , LIT ) # Predict if we'll run out of tokens NAME = NAME * LIT # Each API call needs 1 token if NAME < NAME : # Calculate optimal pre-delay to avoid token bucket depletion NAME = NAME - NAME NAME = NAME ( NAME / NAME , LIT ) # Cap at 8 seconds if NAME > LIT : # Only apply if meaningful delay needed NAME . NAME ( f\" Predictive rate limiting: Pre-waiting { NAME : .2f } s for { NAME } API calls (current tokens: { NAME : .2f } ) \" ) import NAME NAME . NAME ( NAME ) # Use existing tiered approach for light loads elif NAME >= LIT : NAME ( NAME ) NAME . NAME ( f\" Applied full rate limiting for heavy batch: { NAME } parallel API calls \" ) elif NAME >= LIT : import NAME NAME . NAME ( LIT ) # Shorter than normal rate limiting NAME . NAME ( f\" Applied light rate limiting (1.2s) for medium batch: { NAME } parallel API calls \" ) else : import NAME NAME . NAME ( LIT ) # Just 300ms delay for light loads NAME . NAME ( f\" Applied minimal rate limiting (0.3s) for light batch: { NAME } parallel API calls \" ) else : # Sufficient tokens available - minimal delay import NAME NAME . NAME ( LIT ) # Minimal delay to prevent hammering NAME . NAME ( f\" Sufficient tokens available ( { NAME : .2f } ) for { NAME } API calls - minimal delay \" ) # Fallback to original tiered approach if rate_limiter not available elif NAME >= LIT : NAME ( NAME ) NAME . NAME ( f\" Applied full rate limiting for heavy batch: { NAME } parallel API calls \" ) elif NAME >= LIT : import NAME NAME . NAME ( LIT ) NAME . NAME ( f\" Applied light rate limiting (1.2s) for medium batch: { NAME } parallel API calls \" ) else : import NAME NAME . NAME ( LIT ) NAME . NAME ( f\" Applied minimal rate limiting (0.3s) for light batch: { NAME } parallel API calls \" ) else : NAME . NAME ( LIT ) # SURGICAL FIX #18: Batch API Call Grouping for better efficiency # Group similar API calls together to reduce context switching and improve rate limit utilization # CRITICAL FIX: Final halt check before submitting API calls if NAME . NAME ( ) : NAME = NAME . NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" \ud83d\udea8 HALT SIGNAL: Stopping before API submission. \" f\" Cascade count: { NAME } . Preventing API call submission. \" ) raise NAME ( f\" Session death cascade detected (# { NAME } ) - halting before API submission \" ) # Group 1: Submit combined details calls first (most common) NAME = [ ] for NAME in NAME : NAME = NAME . NAME ( NAME , NAME , NAME ) NAME [ NAME ] = ( LIT , NAME ) NAME . NAME ( NAME ) # Small delay between groups to avoid overwhelming the API if NAME : import NAME NAME . NAME ( LIT ) # 100ms gap between groups NAME . NAME ( f\" Submitted { NAME ( NAME ) } combined details API calls \" ) # Group 2: Relationship probability now derived from details endpoint; skip legacy endpoint NAME . NAME ( LIT ) # Group 3: Submit badge details calls last (tree-related) NAME = [ ] for NAME in NAME : NAME = NAME . NAME ( NAME , NAME , NAME ) NAME [ NAME ] = ( LIT , NAME ) NAME . NAME ( NAME ) if NAME : NAME . NAME ( f\" Submitted { NAME ( NAME ) } badge details API calls \" ) NAME : NAME [ NAME , NAME [ NAME [ NAME , NAME ] ] ] = { } NAME : NAME [ NAME , NAME [ NAME [ NAME , NAME ] ] ] = ( { } ) # For ladder results before combining # Processing initially submitted API tasks (removed verbose debug) for NAME , NAME in NAME ( NAME ( NAME ) , NAME = LIT ) : # SURGICAL FIX #20: Universal session health check during batch processing if NAME % LIT == LIT and not NAME . NAME ( ) : NAME . NAME ( f\" \ud83d\udea8 Session death detected during batch processing \" f\" (task { NAME } / { NAME ( NAME ) } ). Cancelling remaining tasks. \" ) # Cancel all remaining futures for NAME in NAME : if not NAME . NAME ( ) : NAME . NAME ( ) # Fast-fail to prevent more cascade failures raise NAME ( f\" Session death detected during batch processing - cancelled { NAME ( [ NAME for NAME in NAME if not NAME . NAME ( ) ] ) } remaining tasks \" ) NAME , NAME = NAME [ NAME ] try : NAME = NAME . NAME ( ) if NAME == LIT : NAME [ NAME ] = ( NAME # result can be None ) if ( NAME is None ) : # Treat None result as a failure for critical tracking NAME . NAME ( f\" Critical API task '_fetch_combined_details' for { NAME } returned None. \" ) NAME += LIT elif NAME == LIT : NAME [ NAME ] = NAME # result can be None elif NAME == LIT : NAME [ NAME ] = ( NAME # result can be None ) except ( NAME ) as NAME : # Includes HTTPError if raised by retry_api # CRITICAL FIX: Check if ConnectionError is from session death cascade if LIT in NAME ( NAME ) : NAME . NAME ( f\" \ud83d\udea8 SESSION DEATH CASCADE in batch processing ' { NAME } ' { NAME } : { NAME } . \" f\" Cancelling remaining batch tasks to prevent infinite cascade. \" ) # Cancel all remaining futures to stop the cascade for NAME in NAME : if not NAME . NAME ( ) : NAME . NAME ( ) # Raise exception to halt batch processing raise NAME ( LIT ) from None NAME . NAME ( f\" ConnErr prefetch ' { NAME } ' { NAME } : { NAME } \" , NAME = False , # Keep log concise ) if NAME == LIT : NAME += LIT NAME [ NAME ] = None elif NAME == LIT : NAME [ NAME ] = None elif NAME == LIT : NAME [ NAME ] = None except NAME as NAME : NAME . NAME ( f\" Exc prefetch ' { NAME } ' { NAME } : { NAME } \" , NAME = True , # Log full traceback for unexpected errors ) if NAME == LIT : # Potentially count other severe exceptions as critical if needed NAME += LIT NAME [ NAME ] = None elif NAME == LIT : NAME [ NAME ] = None elif NAME == LIT : NAME [ NAME ] = None if NAME >= NAME : # Cancel remaining futures for NAME in NAME : # Iterate over original futures dict keys if not NAME . NAME ( ) : NAME . NAME ( ) # SURGICAL FIX #20: Check if this is due to session death cascade (Universal approach) NAME = False if NAME . NAME ( ) : NAME = True NAME . NAME ( f\" \ud83d\udea8 CRITICAL FAILURE DUE TO SESSION DEATH CASCADE: \" f\" Browser session died causing { NAME } API failures. \" f\" Should have halted at session death, not after { NAME } API failures. \" ) else : NAME . NAME ( f\" Exceeded critical API failure threshold ( { NAME } / { NAME } ) for combined_details. Halting batch. \" ) NAME = ( f\" Session death cascade caused { NAME } API failures \" if NAME else f\" Critical API failure threshold reached for combined_details ( { NAME } failures). \" ) raise NAME ( NAME ) NAME : NAME [ NAME , NAME ] = { } NAME = { } if NAME and NAME : # Check temp_badge_results has items NAME : NAME [ NAME ] = [ ] for NAME , NAME in NAME . NAME ( ) : if NAME : # Ensure badge_result_data is not None NAME = NAME . NAME ( LIT ) if NAME : NAME . NAME ( NAME ) NAME [ NAME ] = NAME if NAME : NAME . NAME ( f\" Submitting Ladder tasks for { NAME ( NAME ) } CFPIDs... \" ) # SURGICAL FIX #5: Apply batch rate limiting for ladder API calls if NAME ( NAME ) > LIT : NAME ( NAME ) NAME . NAME ( f\" Applied batch rate limiting for { NAME ( NAME ) } ladder API calls \" ) for NAME in NAME : # Removed individual rate limiting - now handled at batch level NAME [ NAME . NAME ( NAME , NAME , NAME , NAME ) ] = ( LIT , NAME ) # Processing Ladder API tasks (removed verbose debug) for NAME in NAME ( NAME ) : NAME , NAME = NAME [ NAME ] NAME = NAME . NAME ( NAME ) if not NAME : NAME . NAME ( f\" Could not map ladder result for CFPID { NAME } back to UUID (task likely cancelled or map error). \" ) continue # Skip if cannot map back try : NAME = NAME . NAME ( ) NAME [ NAME ] = ( NAME # Store ladder result, can be None ) except NAME as NAME : NAME . NAME ( f\" ConnErr ladder fetch CFPID { NAME } (UUID: { NAME } ): { NAME } \" , NAME = False , ) NAME [ NAME ] = None except NAME as NAME : NAME . NAME ( f\" Exc ladder fetch CFPID { NAME } (UUID: { NAME } ): { NAME } \" , NAME = True , ) NAME [ NAME ] = None # Finished parallel API pre-fetch (removed verbose debug) for NAME , NAME in NAME . NAME ( ) : if NAME : # Badge fetch was successful and returned data NAME = NAME . NAME ( ) NAME = NAME . NAME ( NAME ) if NAME : # Ladder fetch was successful and returned data NAME . NAME ( NAME ) NAME [ NAME ] = NAME # If badge_result is None, batch_tree_data[uuid_val] will not be set, correctly defaulting to None if key missing. return { LIT : NAME , LIT : NAME , # 'rel_prob' now empty as we derive predicted_relationship from /details LIT : NAME , }"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_prepare_bulk_db_data",
      "lineno": 2098,
      "end_lineno": 2252,
      "is_method": false,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 15,
      "loc": 155,
      "tags": [
        "pure-ish",
        "time",
        "size:large"
      ],
      "signature": "(session, session_manager, matches_to_process, existing_persons_map, prefetched_data, progress)",
      "fingerprint": "0ca9a99bc2cf4489a0535b92fa435db1e095e59a",
      "simhash64": 7452151226028176435,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME [ NAME , NAME ] ] , NAME : NAME [ LIT ] , ) -> NAME [ NAME [ NAME [ NAME , NAME ] ] , NAME [ NAME , NAME ] ] : LIT # Step 1: Initialize results NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] NAME : NAME [ NAME , NAME ] = { LIT : LIT , LIT : LIT , LIT : LIT , } # Skipped handled before this function NAME = NAME ( NAME ) if not NAME : return [ ] , NAME # Return empty if nothing to process NAME . NAME ( f\" --- Preparing DB data structures for { NAME } candidates --- \" ) NAME = NAME . NAME ( ) # Step 2: Iterate through each candidate match for NAME in NAME : # Initialize state for this match NAME = NAME . NAME ( LIT ) NAME = f\" UUID= { NAME or LIT } User=' { NAME . NAME ( LIT , LIT ) } ' \" NAME : NAME [ NAME [ NAME , NAME ] ] = None NAME : NAME [ LIT , LIT , LIT , LIT ] = ( LIT # Default to error ) NAME : NAME [ NAME ] = None try : # Step 2a: Basic validation if not NAME : NAME . NAME ( LIT ) NAME = LIT NAME = LIT raise NAME ( LIT ) # Stop processing this item # Step 2b: Retrieve existing person and prefetched data NAME = NAME . NAME ( NAME . NAME ( ) ) NAME = NAME . NAME ( LIT , { } ) . NAME ( NAME ) # Can be None NAME = NAME . NAME ( LIT , { } ) . NAME ( NAME ) # Can be None NAME = NAME . NAME ( LIT , { } ) . NAME ( NAME ) # Can be None # Step 2c: Add relationship probability to match dict *before* calling _do_match # _do_match and its helpers should handle predicted_relationship potentially being None NAME [ LIT ] = NAME # Step 2d: Check WebDriver session validity before calling _do_match if not NAME . NAME ( ) : NAME . NAME ( f\" WebDriver session invalid before calling _do_match for { NAME } . Treating as error. \" ) NAME = LIT NAME = LIT # Need to raise an exception or handle this state appropriately to stop/skip # For now, let it proceed but the status is error. else : # Step 2e: Call _do_match to compare data and prepare the bulk dictionary structure ( NAME , NAME , NAME , ) = NAME ( NAME , # Pass session NAME , NAME , NAME , # Pass existing_person_arg correctly NAME , # Pass prefetched_combined_details correctly NAME , # Pass prefetched_tree_data correctly NAME , NAME , # Pass underlying logger instance for compatibility ) # Step 2f: Tally status based on _do_match result if NAME in [ LIT , LIT , LIT ] : NAME [ NAME ] += LIT elif NAME == LIT : # This path should ideally not be hit if _do_match determines status correctly based on changes NAME . NAME ( # Changed to debug as it's an expected outcome if no changes f\" _do_match returned 'skipped' for { NAME } . Not counted in page new/updated/error. \" ) else : # Handle unknown status string NAME . NAME ( f\" Unknown status ' { NAME } ' from _do_match for { NAME } . Counting as error. \" ) NAME [ LIT ] += LIT # Step 2g: Append valid prepared data to the bulk list if ( NAME not in [ LIT , LIT ] and NAME ) : NAME . NAME ( NAME ) elif NAME == LIT : NAME . NAME ( f\" Error preparing DB data for { NAME } : { NAME or LIT } \" ) # Step 3: Handle unexpected exceptions during single match processing except NAME as NAME : NAME . NAME ( f\" Critical unexpected error processing { NAME } in _prepare_bulk_db_data: { NAME } \" , NAME = True , ) NAME [ LIT ] += LIT # Count as error for this item finally : # Step 4: Update progress after processing each item (regardless of outcome) try : if NAME is not None : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Progress update error: { NAME } \" ) # Step 5: Log summary and return results NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" --- Finished preparing DB data structures. Duration: { NAME : .2f } s --- \" ) return NAME , NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_get_configured_batch_size",
      "lineno": 2295,
      "end_lineno": 2304,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "305b03bb744e17bf408ac91b2e52adad6709d664",
      "simhash64": 7469637858889217075,
      "normalized": "def NAME ( ) -> NAME : LIT try : from NAME import NAME NAME = NAME ( NAME , LIT , LIT ) # Default to 10 if not found NAME . NAME ( f\" Using configured batch size: { NAME } (from cached config) \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Failed to get configured batch size: { NAME } , using default 10 \" ) return LIT # Fallback to match .env default"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_get_adaptive_batch_size",
      "lineno": 2306,
      "end_lineno": 2331,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 26,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(session_manager, base_batch_size)",
      "fingerprint": "d3a449adb24efb7b023a2c01bbd2d5689df5a4c7",
      "simhash64": 7451517873978512955,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT if NAME is None : NAME = NAME ( ) # Get current performance metrics from session manager NAME = NAME ( NAME , LIT , LIT ) NAME = NAME ( NAME , LIT , LIT ) # Adaptive batch sizing based on server performance if NAME > LIT : # Very slow server NAME = NAME ( LIT , NAME // LIT ) NAME . NAME ( f\" Server very slow ( { NAME : .1f } s avg), reducing batch size to { NAME } \" ) elif NAME > LIT : # Slow server NAME = NAME ( LIT , NAME // LIT ) NAME . NAME ( f\" Server slow ( { NAME : .1f } s avg), reducing batch size to { NAME } \" ) elif NAME > LIT : # Multiple consecutive slow calls NAME = NAME ( LIT , NAME // LIT ) NAME . NAME ( f\" Multiple slow calls ( { NAME } ), reducing batch size to { NAME } \" ) elif NAME < LIT and NAME == LIT : # Fast server NAME = NAME ( LIT , NAME ( NAME * LIT ) ) NAME . NAME ( f\" Server fast ( { NAME : .1f } s avg), increasing batch size to { NAME } \" ) else : NAME = NAME return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "MemoryOptimizedMatchProcessor.__init__",
      "lineno": 2365,
      "end_lineno": 2374,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self, max_memory_mb)",
      "fingerprint": "5247406812fdc2a159749a07b0cde6a72c8f9a8b",
      "simhash64": 7452080857283998739,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) -> None : LIT NAME . NAME = NAME NAME . NAME = LIT NAME . NAME = [ ]"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "MemoryOptimizedMatchProcessor.process_matches_with_memory_management",
      "lineno": 2376,
      "end_lineno": 2428,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 53,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, matches)",
      "fingerprint": "f6fb0665a11138fc3ae1134feb4dc5f8cad54c33",
      "simhash64": 7452080857216889875,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT import NAME import NAME NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) . NAME / LIT / LIT # MB NAME . NAME ( f\" Phase 3: Starting memory-optimized processing (Initial: { NAME : .1f } MB, Limit: { NAME . NAME } MB) \" ) NAME = [ ] NAME = NAME . NAME * LIT # Clean up at 80% of limit for NAME , NAME in NAME ( NAME ) : # Process single match NAME = NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME += LIT # Memory check every 10 matches if NAME % LIT == LIT : NAME = NAME . NAME ( ) . NAME / LIT / LIT if NAME > NAME : NAME . NAME ( f\" Phase 3: Memory usage { NAME : .1f } MB exceeds threshold, triggering cleanup \" ) # Force garbage collection NAME . NAME ( ) # Cache cleanup now handled by core/system_cache.py NAME . NAME ( LIT ) # Memory after cleanup NAME = NAME . NAME ( ) . NAME / LIT / LIT NAME . NAME ( f\" Phase 3: Memory cleanup completed: { NAME : .1f } MB \u2192 { NAME : .1f } MB \" ) NAME = NAME . NAME ( ) . NAME / LIT / LIT NAME . NAME ( f\" Phase 3: Memory-optimized processing completed: { NAME : .1f } MB \u2192 { NAME : .1f } MB \" ) return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "MemoryOptimizedMatchProcessor._process_single_match",
      "lineno": 2430,
      "end_lineno": 2433,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, match)",
      "fingerprint": "292d9e1b30dc70ab32fc9a1b7c982f24a2a6b7fc",
      "simhash64": 7452080822857151607,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT # Placeholder - would integrate with existing match processing logic return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_deduplicate_person_creates",
      "lineno": 2436,
      "end_lineno": 2472,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 37,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(person_creates_raw)",
      "fingerprint": "600d0ee58c7815371b85e0007247c25c38cd4264",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] NAME : NAME [ NAME ] = NAME ( ) NAME = LIT if not NAME : return NAME NAME . NAME ( f\" De-duplicating { NAME ( NAME ) } raw person creates based on Profile ID... \" ) for NAME in NAME : NAME = NAME . NAME ( LIT ) # Already uppercase from prep if exists NAME = NAME . NAME ( LIT ) # For logging skipped items if NAME is None : NAME . NAME ( NAME ) # Allow creates with null profile ID elif NAME not in NAME : NAME . NAME ( NAME ) NAME . NAME ( NAME ) else : NAME . NAME ( f\" Skipping duplicate Person create in batch (ProfileID: { NAME } , UUID: { NAME } ). \" ) NAME += LIT if NAME > LIT : NAME . NAME ( f\" Skipped { NAME } duplicate person creates in this batch. \" ) NAME . NAME ( f\" Proceeding with { NAME ( NAME ) } unique person creates. \" ) return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_check_existing_records",
      "lineno": 2475,
      "end_lineno": 2516,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 12,
      "loc": 42,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(session, insert_data_raw)",
      "fingerprint": "87b6e477e405f82ada931a99e7953038b1455c42",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME [ NAME [ NAME ] , NAME [ NAME ] ] : LIT NAME = { NAME . NAME ( LIT ) for NAME in NAME if NAME . NAME ( LIT ) } NAME = { NAME ( NAME . NAME ( LIT ) or LIT ) . NAME ( ) for NAME in NAME if NAME . NAME ( LIT ) } NAME : NAME [ NAME ] = NAME ( ) NAME : NAME [ NAME ] = NAME ( ) if NAME : try : NAME . NAME ( f\" Checking database for { NAME ( NAME ) } existing profile IDs... \" ) NAME = NAME . NAME ( NAME . NAME ) . NAME ( NAME . NAME . NAME ( NAME ) ) . NAME ( ) NAME = { NAME . NAME for NAME in NAME } if NAME : NAME . NAME ( f\" Found { NAME ( NAME ) } existing profile IDs that will be skipped \" ) except NAME as NAME : NAME . NAME ( f\" Failed to check existing profile IDs: { NAME } \" ) if NAME : try : NAME . NAME ( f\" Checking database for { NAME ( NAME ) } existing UUIDs... \" ) NAME = NAME . NAME ( NAME . NAME ) . NAME ( NAME . NAME . NAME ( NAME ) ) . NAME ( ) NAME = { NAME . NAME . NAME ( ) for NAME in NAME } if NAME : NAME . NAME ( f\" Found { NAME ( NAME ) } existing UUIDs that will be skipped \" ) except NAME as NAME : NAME . NAME ( f\" Failed to check existing UUIDs: { NAME } \" ) return NAME , NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_handle_integrity_error_recovery",
      "lineno": 2519,
      "end_lineno": 2561,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 43,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(session, insert_data)",
      "fingerprint": "3a89882521451dcb5426a02d6c888121475f771f",
      "simhash64": 7488215207352112147,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME [ NAME [ NAME , NAME ] ] ] = None ) -> NAME : LIT try : NAME . NAME ( ) # Clear the failed transaction NAME . NAME ( LIT ) if not NAME : NAME . NAME ( LIT ) return True NAME . NAME ( f\" Retrying with individual inserts for { NAME ( NAME ) } records \" ) NAME = LIT for NAME in NAME : try : # Try individual insert NAME = NAME ( ** { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME ( NAME , NAME ) } ) NAME . NAME ( NAME ) NAME . NAME ( ) # Force insert attempt NAME += LIT except NAME as NAME : # This specific record already exists - skip it NAME . NAME ( f\" Skipping duplicate record UUID { NAME . NAME ( LIT , LIT ) } : { NAME } \" ) NAME . NAME ( ) # Clear this specific failure except NAME as NAME : NAME . NAME ( f\" Failed to insert individual record UUID { NAME . NAME ( LIT , LIT ) } : { NAME } \" ) NAME . NAME ( ) # Clear this specific failure NAME . NAME ( f\" Successfully inserted { NAME } of { NAME ( NAME ) } records after handling duplicates \" ) return True except NAME as NAME : NAME . NAME ( f\" Failed to handle UNIQUE constraint violation gracefully: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_prepare_person_insert_data",
      "lineno": 2564,
      "end_lineno": 2626,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 15,
      "loc": 63,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(person_creates_filtered, session, existing_persons_map)",
      "fingerprint": "45f9cc6f3df4005d6ef17fa8321fb421631d943b",
      "simhash64": 7488180022980031539,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME : return [ ] NAME . NAME ( f\" Preparing { NAME ( NAME ) } Person records for bulk insert... \" ) # Prepare list of dictionaries for bulk_insert_mappings NAME = [ { NAME : NAME for NAME , NAME in NAME . NAME ( ) if not NAME . NAME ( LIT ) } for NAME in NAME ] # Check for existing records in database NAME , NAME = NAME ( NAME , NAME ) # De-duplicate by UUID within this batch and drop existing records NAME : NAME [ NAME ] = NAME ( ) NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] for NAME in NAME : NAME = NAME ( NAME . NAME ( LIT ) or LIT ) . NAME ( ) NAME = NAME . NAME ( LIT ) if not NAME : continue if NAME in NAME : NAME . NAME ( f\" Duplicate Person in batch (UUID: { NAME } ) - skipping duplicate. \" ) continue if NAME in NAME : NAME . NAME ( f\" Person exists for UUID { NAME } ; will handle as update if changes detected. \" ) continue if NAME in NAME : NAME . NAME ( f\" Person exists in DB for UUID { NAME } ; will handle as update if needed. \" ) continue if NAME and NAME in NAME : NAME . NAME ( f\" Person exists with profile ID { NAME } (UUID: { NAME } ); will handle as update if needed. \" ) continue NAME . NAME ( NAME ) NAME [ LIT ] = NAME NAME . NAME ( NAME ) # Convert status Enum to its value for bulk insertion for NAME in NAME : if LIT in NAME and NAME ( NAME [ LIT ] , LIT ) : NAME [ LIT ] = NAME [ LIT ] . NAME return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_execute_bulk_db_operations",
      "lineno": 2629,
      "end_lineno": 3109,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 87,
      "loc": 481,
      "tags": [
        "pure-ish",
        "time",
        "size:large"
      ],
      "signature": "(session, prepared_bulk_data, existing_persons_map)",
      "fingerprint": "612b59dd1c990c3eff3fac563ea7cced95a8ee00",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ NAME , NAME ] , # Needed to potentially map existing IDs ) -> NAME : LIT # Step 1: Initialization NAME = NAME . NAME ( ) NAME = NAME ( NAME ) if NAME == LIT : return True # Nothing to do, considered success NAME . NAME ( f\" --- Starting Bulk DB Operations ( { NAME } prepared items) --- \" ) try : # Initialize variables that might be needed in exception handlers NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] # Step 2: Separate data by operation type (create/update) and table # Person Operations NAME = [ NAME [ LIT ] for NAME in NAME if NAME . NAME ( LIT ) and NAME [ LIT ] [ LIT ] == LIT ] NAME = [ NAME [ LIT ] for NAME in NAME if NAME . NAME ( LIT ) and NAME [ LIT ] [ LIT ] == LIT ] # DnaMatch/FamilyTree Operations (Assume create/update logic handled in _do_match prep) NAME = [ NAME [ LIT ] for NAME in NAME if NAME . NAME ( LIT ) ] NAME = [ NAME [ LIT ] for NAME in NAME if NAME . NAME ( LIT ) ] NAME : NAME [ NAME , NAME ] = { } # Maps UUID -> new Person ID # --- Step 3: Person Creates --- # Use helper function to de-duplicate Person creates NAME = NAME ( NAME ) # Bulk Insert Persons (if any unique creates remain) if NAME : # Use helper function to prepare insert data NAME = NAME ( NAME , NAME , NAME ) # Final check for duplicates *within the filtered list* (shouldn't happen if de-dup logic is right) NAME = { NAME . NAME ( LIT ) for NAME in NAME if NAME . NAME ( LIT ) } if NAME ( NAME ) != NAME ( LIT for NAME in NAME if NAME . NAME ( LIT ) ) : NAME . NAME ( LIT ) NAME = NAME ( NAME . NAME ( LIT ) for NAME in NAME if NAME . NAME ( LIT ) ) NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME > LIT } NAME . NAME ( f\" Duplicate Profile IDs in filtered list: { NAME } \" ) # Create a proper exception to pass as orig NAME = NAME ( f\" Duplicate profile IDs: { NAME } \" ) raise NAME ( LIT , NAME = NAME ( NAME ) , NAME = NAME , ) # Perform bulk insert NAME . NAME ( f\" Bulk inserting { NAME ( NAME ) } Person records... \" ) NAME . NAME ( NAME , NAME ) # type: ignore # --- Get newly created IDs --- NAME . NAME ( ) NAME = [ NAME [ LIT ] for NAME in NAME if NAME . NAME ( LIT ) ] if NAME : NAME . NAME ( f\" Querying IDs for { NAME ( NAME ) } inserted UUIDs... \" ) # CRITICAL FIX: Ensure database consistency before UUID->ID mapping try : NAME . NAME ( ) # Make pending changes visible to current session NAME . NAME ( ) # Commit to database for ID generation NAME = ( NAME . NAME ( NAME . NAME , NAME . NAME ) . NAME ( NAME . NAME . NAME ( NAME ) ) # type: ignore . NAME ( ) ) NAME = { NAME : NAME for NAME , NAME in NAME } NAME . NAME ( f\" Person ID Mapping: Queried { NAME ( NAME ) } UUIDs, mapped { NAME ( NAME ) } Person IDs \" ) if NAME ( NAME ) != NAME ( NAME ) : NAME = NAME ( NAME ) - NAME ( NAME ) NAME = [ NAME for NAME in NAME if NAME not in NAME ] NAME . NAME ( f\" CRITICAL: Person ID mapping failed for { NAME } UUIDs. Missing: { NAME [ : LIT ] } { LIT if NAME > LIT else LIT } \" ) # Recovery attempt: Query with broader filter NAME = ( NAME . NAME ( NAME . NAME , NAME . NAME ) . NAME ( NAME . NAME . NAME ( NAME ) ) . NAME ( NAME . NAME . NAME ( None ) ) . NAME ( ) ) NAME = { NAME : NAME for NAME , NAME in NAME } if NAME : NAME . NAME ( f\" Recovery: Found { NAME ( NAME ) } additional Person IDs \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" CRITICAL: Person ID mapping query failed: { NAME } \" ) NAME . NAME ( ) NAME = { } else : NAME . NAME ( LIT ) else : # No person creates to process NAME = [ ] # --- Step 4: Person Updates --- if NAME : NAME = [ ] for NAME in NAME : NAME = NAME . NAME ( LIT ) if not NAME : NAME . NAME ( f\" Skipping person update (UUID { NAME . NAME ( LIT ) } ): Missing '_existing_person_id'. \" ) continue NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if not NAME . NAME ( LIT ) and NAME not in [ LIT , LIT ] } if LIT in NAME and NAME ( NAME [ LIT ] , NAME ) : NAME [ LIT ] = NAME [ LIT ] . NAME NAME [ LIT ] = NAME NAME [ LIT ] = NAME . NAME ( NAME . NAME ) if NAME ( NAME ) > LIT : NAME . NAME ( NAME ) if NAME : NAME . NAME ( f\" Bulk updating { NAME ( NAME ) } Person records... \" ) NAME . NAME ( NAME , NAME ) # type: ignore NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) # --- Step 5: Create Master ID Map (for linking related records) --- NAME : NAME [ NAME , NAME ] = NAME . NAME ( ) for NAME in NAME : if NAME . NAME ( LIT ) and NAME . NAME ( LIT ) : NAME [ NAME [ LIT ] ] = NAME [ LIT ] NAME = { NAME [ LIT ] [ LIT ] for NAME in NAME if NAME . NAME ( LIT ) and NAME [ LIT ] . NAME ( LIT ) } for NAME in NAME : if NAME not in NAME and NAME . NAME ( NAME ) : NAME = NAME [ NAME ] # Get the id value directly from the SQLAlchemy object NAME = NAME ( NAME , LIT , None ) if NAME is not None : NAME [ NAME ] = NAME # --- Step 6: DnaMatch Bulk Upsert (REVISED: Separate Insert/Update) --- if NAME : NAME = [ ] NAME = [ ] # List for bulk updates # Query existing DnaMatch records for people in this batch to determine insert vs update NAME = { NAME for NAME in NAME . NAME ( ) if NAME is not None } NAME = { } if NAME : NAME = ( NAME . NAME ( NAME . NAME , NAME . NAME ) . NAME ( NAME . NAME . NAME ( NAME ) ) # type: ignore . NAME ( ) ) NAME = NAME ( NAME ) NAME . NAME ( f\" Found { NAME ( NAME ) } existing DnaMatch records for people in this batch. \" ) for NAME in NAME : # Process each prepared DNA operation NAME = NAME . NAME ( LIT ) # Use UUID to find person ID NAME = NAME . NAME ( NAME ) if NAME else None if not NAME : # ENHANCED UUID RESOLUTION: Multiple fallback strategies if NAME : # Strategy 1: Check existing_persons_map if NAME . NAME ( NAME ) : NAME = NAME [ NAME ] NAME = NAME ( NAME , LIT , None ) if NAME : # Add to mapping for future use NAME [ NAME ] = NAME NAME . NAME ( f\" Resolved Person ID { NAME } for UUID { NAME } (from existing_persons_map) \" ) else : NAME . NAME ( f\" Person exists in database for UUID { NAME } but has no ID attribute \" ) continue else : # Strategy 2: Direct database query as fallback try : NAME = NAME . NAME ( NAME . NAME ) . NAME ( NAME . NAME == NAME , NAME . NAME . NAME ( None ) ) . NAME ( ) if NAME : NAME = NAME . NAME NAME [ NAME ] = NAME NAME . NAME ( f\" Resolved Person ID { NAME } for UUID { NAME } (direct DB query) \" ) else : NAME . NAME ( f\" Person UUID { NAME } not found in database - will be created in next batch \" ) continue except NAME as NAME : NAME . NAME ( f\" Database query failed for UUID { NAME } : { NAME } \" ) continue else : NAME . NAME ( LIT ) continue # Prepare data dictionary (exclude internal keys) NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if not NAME . NAME ( LIT ) and NAME != LIT } NAME [ LIT ] = NAME # Ensure people_id is set # Check if a DnaMatch record already exists for this person_id NAME = NAME . NAME ( NAME ) if NAME : # Prepare for UPDATE NAME = NAME . NAME ( ) NAME [ LIT ] = ( NAME # Add primary key for update mapping ) NAME [ LIT ] = NAME . NAME ( NAME . NAME ) # Set update timestamp # Add to update list only if there are fields other than id/people_id/updated_at if NAME ( NAME ) > LIT : NAME . NAME ( NAME ) else : NAME . NAME ( f\" Skipping DnaMatch update for PersonID { NAME } : No changed fields. \" ) else : # Prepare for INSERT NAME = NAME . NAME ( ) # created_at/updated_at handled by defaults or set explicitly if needed NAME . NAME ( LIT , NAME . NAME ( NAME . NAME ) ) NAME . NAME ( LIT , NAME . NAME ( NAME . NAME ) ) NAME . NAME ( NAME ) # Perform Bulk Insert with per-person in-batch de-duplication (schema requires one-to-one) if NAME : # De-duplicate by people_id within this batch to avoid UNIQUE(people_id) violations NAME : NAME [ NAME , NAME [ NAME , NAME ] ] = { } for NAME in NAME : NAME = NAME . NAME ( LIT ) if NAME is None : # Safety: skip rows without resolved people_id NAME . NAME ( LIT ) continue if NAME in NAME : # Prefer the first seen; alternatively, we could choose higher cM_DNA deterministically NAME . NAME ( f\" Skipping duplicate DnaMatch insert for people_id= { NAME } within batch (one-to-one schema) \" ) continue NAME [ NAME ] = NAME NAME = NAME ( NAME . NAME ( ) ) if NAME : NAME . NAME ( f\" Bulk inserting { NAME ( NAME ) } DnaMatch records after de-dup (from { NAME ( NAME ) } )... \" ) NAME . NAME ( NAME , NAME ) # type: ignore else : NAME . NAME ( LIT ) else : pass # No new DnaMatch records to insert # Perform Bulk Update if NAME : NAME . NAME ( f\" Bulk updating { NAME ( NAME ) } DnaMatch records... \" ) NAME . NAME ( NAME , NAME ) # type: ignore NAME . NAME ( LIT ) else : pass # No existing DnaMatch records to update else : NAME . NAME ( LIT ) # --- Step 7: FamilyTree Bulk Upsert --- NAME = [ NAME for NAME in NAME if NAME . NAME ( LIT ) == LIT ] NAME = [ NAME for NAME in NAME if NAME . NAME ( LIT ) == LIT ] if NAME : NAME = [ ] for NAME in NAME : NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( NAME ) if NAME else None # ENHANCED UUID RESOLUTION: Multiple fallback strategies for FamilyTree if not NAME and NAME : # Strategy 1: Check existing_persons_map if NAME . NAME ( NAME ) : NAME = NAME [ NAME ] NAME = NAME ( NAME , LIT , None ) if NAME : # Add to mapping for future use NAME [ NAME ] = NAME NAME . NAME ( f\" Resolved Person ID { NAME } for FamilyTree UUID { NAME } (from existing_persons_map) \" ) else : NAME . NAME ( f\" Person exists for FamilyTree UUID { NAME } but has no ID attribute \" ) continue else : # Strategy 2: Direct database query as fallback try : NAME = NAME . NAME ( NAME . NAME ) . NAME ( NAME . NAME == NAME , NAME . NAME . NAME ( None ) ) . NAME ( ) if NAME : NAME = NAME . NAME NAME [ NAME ] = NAME NAME . NAME ( f\" Resolved Person ID { NAME } for FamilyTree UUID { NAME } (direct DB query) \" ) else : NAME . NAME ( f\" FamilyTree Person UUID { NAME } not found in database - will be created in next batch \" ) continue except NAME as NAME : NAME . NAME ( f\" Database query failed for FamilyTree UUID { NAME } : { NAME } \" ) continue if NAME : NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if not NAME . NAME ( LIT ) } NAME [ LIT ] = NAME NAME . NAME ( LIT , None ) # Remove uuid before insert NAME . NAME ( NAME ) else : NAME . NAME ( f\" Person with UUID { NAME } not found in database - skipping FamilyTree creation. \" ) if NAME : NAME . NAME ( f\" Bulk inserting { NAME ( NAME ) } FamilyTree records... \" ) NAME . NAME ( NAME , NAME ) # type: ignore else : pass # No valid FamilyTree records to insert else : NAME . NAME ( LIT ) if NAME : NAME = [ ] for NAME in NAME : NAME = NAME . NAME ( LIT ) if not NAME : NAME . NAME ( f\" Skipping FamilyTree update op (UUID { NAME . NAME ( LIT ) } ): Missing '_existing_tree_id'. \" ) continue NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if not NAME . NAME ( LIT ) and NAME != LIT } NAME [ LIT ] = NAME NAME [ LIT ] = NAME . NAME ( NAME . NAME ) if NAME ( NAME ) > LIT : NAME . NAME ( NAME ) if NAME : NAME . NAME ( f\" Bulk updating { NAME ( NAME ) } FamilyTree records... \" ) NAME . NAME ( NAME , NAME ) # type: ignore NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) # Step 8: Log success NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" --- Bulk DB Operations OK. Duration: { NAME : .2f } s --- \" ) return True # Step 9: Handle database errors during bulk operations except NAME as NAME : # Handle UNIQUE constraint violations gracefully NAME = NAME ( NAME ) if ( LIT in NAME or LIT in NAME or LIT in NAME ) : NAME . NAME ( LIT , NAME , ) # Always rollback the failed transaction before attempting recovery or continuing try : NAME . NAME ( ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Rollback after IntegrityError failed: { NAME } \" ) # Attempt targeted recovery for Person creates when available # insert_data contains the prepared Person create mappings (may be empty) try : return NAME ( NAME , NAME if NAME else None ) except NAME as NAME : NAME . NAME ( f\" Recovery handler failed: { NAME } \" ) return False else : # Unknown integrity error: rollback and fail try : NAME . NAME ( ) NAME . NAME ( LIT ) except NAME : pass NAME . NAME ( f\" Other IntegrityError during bulk DB operation: { NAME } \" , NAME = True ) return False # Other integrity errors should still fail except NAME as NAME : NAME . NAME ( f\" Bulk DB operation FAILED: { NAME } \" , NAME = True ) from NAME import NAME with NAME ( NAME ) : NAME . NAME ( ) return False # Indicate failure (rollback handled by db_transn) except NAME as NAME : NAME . NAME ( f\" Unexpected error during bulk DB operations: { NAME } \" , NAME = True ) return False # Indicate failure"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_do_batch",
      "lineno": 3115,
      "end_lineno": 3250,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 18,
      "loc": 136,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "(session_manager, matches_on_page, current_page, progress)",
      "fingerprint": "054e4133845635e3224c15b038d25800669e2ec8",
      "simhash64": 7452151225961059347,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME , NAME : NAME [ LIT ] = None , # Accept ProgressIndicator ) -> NAME [ NAME , NAME , NAME , NAME ] : LIT # ENHANCED: Dynamic Batch Optimization with Server Performance Integration NAME = NAME . NAME ( ) try : # Get adaptive batch size based on current server performance NAME = NAME ( NAME ) NAME = NAME ( NAME ) # Additional optimizations based on page characteristics if NAME >= LIT : # Large pages NAME = NAME ( LIT , NAME ( NAME * LIT ) ) NAME . NAME ( f\" Large page optimization: Increased batch size to { NAME } \" ) elif NAME <= LIT : # Small pages NAME = NAME ( LIT , NAME ( NAME * LIT ) ) NAME . NAME ( f\" Small page optimization: Reduced batch size to { NAME } \" ) # Memory efficiency for long runs if NAME % LIT == LIT : # Every 20 pages, use smaller batches NAME = NAME ( LIT , NAME - LIT ) NAME . NAME ( f\" Memory efficiency: Reduced batch size to { NAME } at page { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Batch size optimization failed: { NAME } , using fallback \" ) NAME = LIT # Safe fallback # If we have fewer matches than optimized batch size, process normally (no need to split) if NAME <= NAME : return NAME ( NAME , NAME , NAME , NAME ) # SURGICAL FIX #7: Create single session for all batches on this page NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( f\" Page { NAME } : Failed to get DB session for batch processing. \" ) return LIT , LIT , LIT , LIT try : # Otherwise, split into batches and process each with individual summaries NAME . NAME ( f\" Splitting page { NAME } ( { NAME } matches) into batches of { NAME } \" ) NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } for NAME in NAME ( LIT , NAME , NAME ) : NAME = NAME [ NAME : NAME + NAME ] NAME = ( NAME // NAME ) + LIT NAME = NAME . NAME ( ) # Track individual batch time # Capture the batch size BEFORE any processing/mutation for accurate summary logging NAME = NAME ( NAME ) NAME . NAME ( f\" --- Processing Page { NAME } Batch No { NAME } ( { NAME } matches) --- \" ) # Process this batch using the original logic with reused session NAME , NAME , NAME , NAME = NAME ( NAME , NAME , NAME , NAME , NAME = True , NAME = NAME ) # Accumulate totals NAME [ LIT ] += NAME NAME [ LIT ] += NAME NAME [ LIT ] += NAME NAME [ LIT ] += NAME # Log batch summary with green color; revised formatting per user preference NAME ( LIT ) NAME . NAME ( NAME . NAME ( f\" ---- Page { NAME } Batch No { NAME } Summary ---- \" ) ) NAME . NAME ( NAME . NAME ( f\" Run id: [ { NAME } ] \" ) ) NAME . NAME ( NAME . NAME ( f\" New Person/Data: { NAME } \" ) ) NAME . NAME ( NAME . NAME ( f\" Updated Person/Data: { NAME } \" ) ) NAME . NAME ( NAME . NAME ( f\" Skipped (No Change): { NAME } \" ) ) NAME . NAME ( NAME . NAME ( f\" Errors during Prep/DB: { NAME } \" ) ) # Calculate and log average duration per record for this batch NAME = NAME + NAME if NAME > LIT : NAME = NAME . NAME ( ) - NAME NAME = NAME / NAME NAME . NAME ( NAME . NAME ( f\" Average duration per record: { NAME : .2f } s \" ) ) NAME . NAME ( NAME . NAME ( f\" Batch processing time: { NAME . NAME ( ) - NAME : .2f } s \" ) ) NAME . NAME ( NAME . NAME ( LIT ) ) # PRIORITY 5: Track batch performance for future optimization NAME = NAME . NAME ( ) - NAME if not NAME ( NAME , LIT ) : NAME . NAME = [ ] # Keep recent performance history for dynamic optimization NAME . NAME . NAME ( NAME ) if NAME ( NAME . NAME ) > LIT : NAME . NAME = NAME . NAME [ - LIT : ] # Keep last 10 # Log performance metrics NAME = ( NAME [ LIT ] + NAME [ LIT ] + NAME [ LIT ] ) / NAME if NAME > LIT else LIT NAME = ( NAME + NAME - LIT ) // NAME # Ceiling division NAME . NAME ( f\" PAGE { NAME } TOTAL: { NAME : .2f } s for { NAME } matches \" f\" ( { NAME : .1% } success rate, { NAME } batches of size { NAME } ) \" ) NAME . NAME ( f\" PAGE { NAME } RESULTS: { NAME [ LIT ] } new, { NAME [ LIT ] } updated, \" f\" { NAME [ LIT ] } skipped, { NAME [ LIT ] } errors \" ) if NAME > LIT : # Log slow batch processing NAME . NAME ( f\" Slow batch processing: Page { NAME } took { NAME : .1f } s \" ) # === HEALTH MONITORING: Record batch processing time === if NAME ( NAME , LIT ) and NAME . NAME : try : NAME . NAME . NAME ( NAME ) # Record errors if any if NAME [ LIT ] > LIT : NAME . NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Health monitoring batch tracking: { NAME } \" ) # Track performance in global monitoring NAME ( LIT , NAME , f\" success_ { NAME : .0% } \" ) return NAME [ LIT ] , NAME [ LIT ] , NAME [ LIT ] , NAME [ LIT ] finally : # SURGICAL FIX #7: Clean up the reused session if NAME : NAME . NAME ( NAME ) NAME . NAME ( f\" Page { NAME } : Returned reused session to pool \" )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_process_page_matches",
      "lineno": 3255,
      "end_lineno": 3589,
      "is_method": false,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 41,
      "loc": 335,
      "tags": [
        "impure",
        "filesystem",
        "regex",
        "size:large"
      ],
      "signature": "(session_manager, matches_on_page, current_page, progress, is_batch, reused_session)",
      "fingerprint": "00ee597a8134545542bd065d7f20283bf68d45b4",
      "simhash64": 7452151225961059379,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME , NAME : NAME [ LIT ] = None , NAME : NAME = False , NAME : NAME [ NAME ] = None , # SURGICAL FIX #7: Accept reused session ) -> NAME [ NAME , NAME , NAME , NAME ] : LIT # Step 1: Initialization NAME : NAME [ NAME , NAME ] = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME ( NAME ) NAME = NAME . NAME # session: Optional[SqlAlchemySession] = None  # Removed unused variable # FINAL OPTIMIZATION 2: Memory-Optimized Data Structures Integration (disabled) # memory_processor = None # if num_matches_on_page > 20:  # Use memory optimization for larger batches #     memory_processor = MemoryOptimizedMatchProcessor(max_memory_mb=400) #     logger.debug(f\"Page {current_page}: Enabled memory optimization for {num_matches_on_page} matches\") try : # Step 2: Basic validation if not NAME : NAME . NAME ( f\" _do_batch Page { NAME } : Missing my_uuid. \" ) raise NAME ( LIT ) # This will be caught by outer try-except if not NAME : NAME . NAME ( f\" _do_batch Page { NAME } : Empty match list. \" ) return LIT , LIT , LIT , LIT NAME . NAME ( f\" --- Starting Batch Processing for Page { NAME } ( { NAME } matches) --- \" ) # CRITICAL FIX: Check emergency shutdown before batch processing if NAME . NAME ( ) : NAME . NAME ( f\" \ud83d\udea8 EMERGENCY SHUTDOWN: Stopping batch processing for page { NAME } . \" f\" Preventing further processing to avoid infinite loops. \" ) raise NAME ( f\" Emergency shutdown detected - halting batch processing for page { NAME } \" ) # Step 3: SURGICAL FIX #7 - Use reused session when available if NAME : NAME = NAME NAME . NAME ( f\" Batch { NAME } : Using reused session for batch operations \" ) else : # OPTIMIZED - Use long-lived DB Session for batch operations # Reusing the same session reduces connection overhead significantly NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( f\" _do_batch Page { NAME } : Failed DB session. \" ) raise NAME ( LIT ) # Caught by outer try-except try : # --- Data Processing Pipeline (using reused session) --- NAME . NAME ( f\" Batch { NAME } : Looking up existing persons... \" ) NAME = [ NAME [ LIT ] . NAME ( ) for NAME in NAME if NAME . NAME ( LIT ) ] NAME = NAME ( NAME , NAME ) NAME . NAME ( f\" Batch { NAME } : Identifying candidates... \" ) NAME , NAME , NAME = ( NAME ( NAME , NAME ) ) NAME [ LIT ] = NAME if NAME and NAME > LIT : # This logic updates progress for items identified as \"skipped\" (no change from list view) # It ensures the bar progresses even for items not going through full API fetch/DB prep. try : NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Progress update error for skipped items: { NAME } \" ) # SURGICAL FIX #6: Smart API Call Elimination # Early exit when no API processing needed - skip expensive operations if NAME ( NAME ) == LIT : NAME . NAME ( f\" Batch { NAME } : All matches skipped (no API processing needed) - fast path \" ) NAME = { } # Empty prefetch data else : NAME . NAME ( f\" Batch { NAME } : Performing API Prefetches... \" ) # FINAL OPTIMIZATION 3: Advanced Async Integration for large batches if NAME ( NAME ) >= LIT : # Use async orchestrator for large batches try : NAME . NAME ( f\" Batch { NAME } : Using sync API prefetches for { NAME ( NAME ) } candidates \" ) # Use sync method (async orchestrator was removed) NAME = NAME ( NAME , NAME , NAME ) NAME . NAME ( f\" Batch { NAME } : Async orchestrator completed successfully \" ) except NAME as NAME : NAME . NAME ( f\" Batch { NAME } : Async orchestrator failed: { NAME } , falling back to sync \" ) # Fallback to sync method NAME = NAME ( NAME , NAME , NAME ) else : # Use standard sync method for smaller batches NAME = NAME ( NAME , NAME , NAME ) # This exception, if raised, will be caught by coord. NAME . NAME ( f\" Batch { NAME } : Preparing DB data... \" ) NAME , NAME = NAME ( NAME , # OPTIMIZED: Reuse same session NAME , NAME , NAME , NAME , NAME , # Pass ProgressIndicator here ) NAME [ LIT ] = NAME . NAME ( LIT , LIT ) NAME [ LIT ] = NAME . NAME ( LIT , LIT ) NAME [ LIT ] = NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" Batch { NAME } : Executing DB Commit... \" ) if NAME : NAME . NAME ( f\" Attempting bulk DB operations for page { NAME } ... \" ) try : # OPTIMIZED: Use same session for transaction instead of creating new one with NAME ( NAME ) as NAME : NAME = NAME ( NAME , NAME , NAME ) if not NAME : NAME . NAME ( f\" Bulk DB ops FAILED page { NAME } . Adjusting counts. \" ) NAME = NAME ( NAME ) NAME [ LIT ] += NAME NAME [ LIT ] = LIT NAME [ LIT ] = LIT NAME . NAME ( f\" Transaction block finished page { NAME } . \" ) except ( NAME , NAME , NAME ) as NAME : NAME . NAME ( f\" Bulk DB transaction FAILED page { NAME } : { NAME } \" , NAME = True , ) NAME = NAME ( NAME ) NAME [ LIT ] += NAME NAME [ LIT ] = LIT NAME [ LIT ] = LIT except NAME as NAME : NAME . NAME ( f\" Unexpected error during bulk DB transaction page { NAME } : { NAME } \" , NAME = True , ) NAME = NAME ( NAME ) NAME [ LIT ] += NAME NAME [ LIT ] = LIT NAME [ LIT ] = LIT else : NAME . NAME ( f\" No data prepared for bulk DB operations on page { NAME } . \" ) finally : # SURGICAL FIX #7: Only return session if it wasn't reused from parent if not NAME and NAME : NAME . NAME ( NAME ) elif NAME : NAME . NAME ( f\" Batch { NAME } : Keeping reused session for parent cleanup \" ) # Only log page summary if not processing as part of a batch # (batch summaries are logged by _do_batch function) if not NAME : NAME ( NAME , NAME [ LIT ] , NAME [ LIT ] , NAME [ LIT ] , NAME [ LIT ] , ) return ( NAME [ LIT ] , NAME [ LIT ] , NAME [ LIT ] , NAME [ LIT ] , ) except NAME : # Explicitly catch and re-raise for coord raise except ( NAME , NAME , NAME , ) as NAME : # Catch other critical errors specific to this batch NAME . NAME ( f\" CRITICAL ERROR processing batch page { NAME } : { NAME } \" , NAME = True , ) # If progress is active, update it for the remaining items in this batch as errors if NAME : NAME = ( NAME [ LIT ] + NAME [ LIT ] + NAME [ LIT ] + NAME [ LIT ] ) NAME = NAME ( LIT , NAME - NAME ) if NAME > LIT : try : NAME . NAME ( f\" Updating progress by { NAME } due to critical error in _do_batch. \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Progress update error during critical exception handling: { NAME } \" ) # Calculate final error count for the page # Errors are items that hit an error in prep + items that couldn't be processed due to critical batch error NAME = NAME [ LIT ] + NAME ( LIT , NAME - ( NAME [ LIT ] + NAME [ LIT ] + NAME [ LIT ] + NAME [ LIT ] ) , ) return ( NAME [ LIT ] , NAME [ LIT ] , NAME [ LIT ] , NAME , ) except NAME as NAME : # Catch-all for any other unexpected exception NAME . NAME ( f\" CRITICAL UNHANDLED EXCEPTION processing batch page { NAME } : { NAME } \" , NAME = True , ) if NAME : NAME = ( NAME [ LIT ] + NAME [ LIT ] + NAME [ LIT ] + NAME [ LIT ] ) NAME = NAME ( LIT , NAME - NAME ) if NAME > LIT : from NAME import NAME with NAME ( NAME ) : NAME . NAME ( NAME ) # All remaining items in the batch are considered errors NAME = NAME - ( NAME [ LIT ] + NAME [ LIT ] + NAME [ LIT ] ) return ( NAME [ LIT ] , NAME [ LIT ] , NAME [ LIT ] , NAME ( LIT , NAME ) , # Ensure error count is not negative ) finally : # PRIORITY 4: Enhanced Memory Management Improvements # Clean up large objects to prevent memory accumulation try : import NAME import NAME import NAME # Get current memory usage for monitoring try : NAME = NAME . NAME ( NAME . NAME ( ) ) NAME = NAME . NAME ( ) . NAME / LIT / LIT NAME . NAME ( f\" Memory usage at page { NAME } : { NAME : .1f } MB \" ) except NAME : NAME = LIT # Fallback if psutil not available # Clear large data structures with more thorough cleanup NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : if NAME in NAME ( ) : NAME = NAME ( ) [ NAME ] if NAME ( NAME , LIT ) or NAME ( NAME , ( NAME , NAME ) ) : NAME . NAME ( ) # Set to None to free reference NAME ( ) [ NAME ] = None # Adaptive garbage collection based on memory usage and page number if NAME % LIT == LIT or NAME > LIT : # Every 5 pages or high memory NAME = NAME . NAME ( ) NAME . NAME ( f\" Memory cleanup: Forced garbage collection at page { NAME } , \" f\" collected { NAME } objects, memory: { NAME : .1f } MB \" ) # If memory is still high after GC, do more aggressive cleanup if NAME > LIT : NAME . NAME ( f\" High memory usage ( { NAME : .1f } MB) - performing aggressive cleanup \" ) NAME . NAME ( LIT ) # Gen 0 NAME . NAME ( LIT ) # Gen 1 NAME . NAME ( LIT ) # Gen 2 elif NAME % LIT == LIT : # Light cleanup every 3 pages NAME . NAME ( LIT ) # Only collect generation 0 NAME . NAME ( f\" Memory cleanup: Light garbage collection at page { NAME } \" ) # Monitor for memory growth patterns if NAME ( NAME , LIT ) : NAME = NAME - NAME . NAME if NAME > LIT : # 50MB growth is concerning NAME . NAME ( f\" Memory growth detected: + { NAME : .1f } MB since last check \" ) NAME . NAME = NAME except NAME as NAME : NAME . NAME ( f\" Memory cleanup warning at page { NAME } : { NAME } \" ) # OPTIMIZED: No need to return session here since it's handled in the main try/finally block above NAME . NAME ( f\" --- Finished Batch Processing for Page { NAME } --- \" )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_prepare_person_operation_data",
      "lineno": 3599,
      "end_lineno": 3828,
      "is_method": false,
      "is_async": false,
      "args_count": 10,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 41,
      "loc": 230,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "(match, existing_person, prefetched_combined_details, prefetched_tree_data, config_schema_arg, match_uuid, formatted_match_username, match_in_my_tree, log_ref_short, logger_instance)",
      "fingerprint": "aaa744678589493793fc1627388637f7cceafc9c",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] , NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : LIT , # Config schema argument NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME . NAME , ) -> NAME [ NAME [ NAME [ NAME , NAME ] ] , NAME ] : LIT NAME = NAME or { } NAME = NAME NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) NAME = ( NAME ( NAME ) if NAME else None ) NAME = ( NAME . NAME ( ) if NAME else None ) NAME = ( NAME . NAME ( ) if NAME else None ) NAME : NAME [ NAME ] = None NAME : NAME [ NAME ] = None NAME : NAME [ NAME ] = None if NAME and NAME : if NAME == NAME : if ( NAME and NAME and NAME . NAME ( ) == NAME . NAME ( ) ) : NAME = NAME else : NAME = NAME NAME = NAME else : NAME = NAME NAME = NAME NAME = NAME elif NAME : NAME = NAME elif NAME : NAME = NAME NAME = NAME NAME = NAME or NAME NAME = ( NAME ( NAME . NAME . NAME , f\" /messaging/?p= { NAME . NAME ( ) } \" ) # type: ignore if NAME else None ) NAME : NAME [ NAME ] = None if NAME and NAME . NAME ( LIT ) : from NAME import NAME with NAME ( NAME , NAME ) : NAME = NAME ( NAME [ LIT ] ) # type: ignore[assignment] NAME : NAME [ NAME ] = NAME . NAME ( LIT ) if NAME ( NAME , NAME ) : if NAME . NAME is None : NAME = NAME . NAME ( NAME = NAME . NAME ) else : NAME = NAME . NAME ( NAME . NAME ) NAME = { LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME . NAME ( LIT ) , LIT : NAME , LIT : NAME ( NAME . NAME ( LIT , True ) ) , LIT : NAME . NAME ( LIT ) , LIT : NAME , LIT : NAME , LIT : NAME . NAME , } if NAME is None : NAME = NAME . NAME ( ) NAME [ LIT ] = LIT return ( NAME , False , ) # False for person_fields_changed as it's a new person NAME : NAME [ NAME , NAME ] = { LIT : LIT , LIT : NAME . NAME , LIT : NAME . NAME ( ) , # Keep UUID for identification } NAME = False for NAME , NAME in NAME . NAME ( ) : if NAME == LIT : # UUID should not be changed for existing records continue NAME = NAME ( NAME , NAME , None ) NAME = False NAME = NAME # Default to new_value # Specific comparisons and transformations if NAME == LIT : # Ensure both are aware UTC datetimes for comparison, ignoring microseconds NAME = ( NAME . NAME ( NAME . NAME ) . NAME ( NAME = LIT ) if NAME ( NAME , NAME ) and NAME . NAME else ( NAME . NAME ( NAME = NAME . NAME , NAME = LIT ) if NAME ( NAME , NAME ) else None ) ) NAME = ( NAME . NAME ( NAME . NAME ) . NAME ( NAME = LIT ) if NAME ( NAME , NAME ) and NAME . NAME else ( NAME . NAME ( NAME = NAME . NAME , NAME = LIT ) if NAME ( NAME , NAME ) else None ) ) if NAME != NAME : # Handles None comparisons correctly NAME = True # value_to_set is already new_value (potentially a datetime obj) elif NAME == LIT : # Ensure comparison is between Enum types or their values NAME = ( NAME . NAME if NAME ( NAME , NAME ) else NAME ) NAME = ( NAME . NAME if NAME ( NAME , NAME ) else NAME ) if NAME != NAME : NAME = True NAME = NAME # Store the Enum object elif NAME == LIT : # Update only if new is valid and current is None if NAME is not None and NAME is None : try : NAME = NAME ( NAME ) NAME = True NAME = NAME except ( NAME , NAME ) : NAME . NAME ( f\" Invalid birth_year ' { NAME } ' for update { NAME } \" ) continue # Skip this field # No change if new_value is None or current_value exists elif ( NAME == LIT ) : # Update only if new is valid ('f'/'m') and current is None if ( NAME is not None and NAME is None and NAME ( NAME , NAME ) and NAME . NAME ( ) in ( LIT , LIT ) ) : NAME = NAME . NAME ( ) NAME = True elif NAME in ( LIT , LIT ) : # Ensure comparison of uppercase strings, handle None NAME = ( NAME ( NAME ) . NAME ( ) if NAME is not None else None ) NAME = ( NAME ( NAME ) . NAME ( ) if NAME is not None else None ) if NAME != NAME : NAME = True NAME = NAME # Store uppercase elif NAME ( NAME , NAME ) or NAME ( NAME , NAME ) : # For boolean fields if NAME ( NAME ) != NAME ( NAME ) : NAME = True NAME = NAME ( NAME ) # General comparison for other fields elif NAME != NAME : NAME = True if NAME : NAME [ NAME ] = NAME NAME = True NAME . NAME ( f\" Person change { NAME } : Field ' { NAME } ' (' { NAME } ' -> ' { NAME } ') \" ) return ( NAME if NAME else None ) , NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_prepare_dna_match_operation_data",
      "lineno": 3834,
      "end_lineno": 3986,
      "is_method": false,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 19,
      "loc": 153,
      "tags": [
        "pure-ish",
        "logging",
        "size:large"
      ],
      "signature": "(match, existing_dna_match, prefetched_combined_details, match_uuid, predicted_relationship, log_ref_short, logger_instance)",
      "fingerprint": "3092470a48f54ce7d28df9316f8e2e42f5a0fdc1",
      "simhash64": 7488180022981071931,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] , NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME . NAME , ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = False NAME = NAME or { } # Use \"N/A\" as a safe default if predicted_relationship is None for comparisons NAME = ( NAME if NAME is not None else LIT ) # Also ensure we never try to INSERT a NULL into a NOT NULL column in DB NAME = ( NAME if NAME is not None else LIT ) if NAME is None : NAME = True else : try : NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME NAME = NAME ( NAME . NAME ( LIT , NAME . NAME ( LIT , LIT ) ) ) NAME = NAME . NAME NAME = NAME . NAME ( LIT ) NAME = ( NAME ( NAME ) if NAME is not None else None ) NAME = NAME . NAME # Compare using the safe default db_predicted_rel_for_comp NAME = ( NAME . NAME if NAME . NAME is not None else LIT ) if NAME != NAME : NAME = True NAME . NAME ( f\" DNA change { NAME } : cM \" ) elif NAME != NAME : NAME = True NAME . NAME ( f\" DNA change { NAME } : Segments \" ) elif ( NAME is not None and NAME is not None and NAME ( NAME ( NAME ( NAME ) ) - NAME ( NAME ( NAME ) ) ) > LIT ) : NAME = True NAME . NAME ( f\" DNA change { NAME } : Longest Segment \" ) elif ( NAME is not None and NAME is None ) : # API lost data for longest segment NAME = True NAME . NAME ( f\" DNA change { NAME } : Longest Segment (API lost data) \" ) elif NAME ( NAME ) != NAME ( NAME ) : # Convert to strings for safe comparison NAME = True NAME . NAME ( f\" DNA change { NAME } : Predicted Rel ( { NAME } -> { NAME } ) \" ) elif NAME ( NAME . NAME ( LIT , False ) ) != NAME ( NAME . NAME ) : NAME = True NAME . NAME ( f\" DNA change { NAME } : Father Side \" ) elif NAME ( NAME . NAME ( LIT , False ) ) != NAME ( NAME . NAME ) : NAME = True NAME . NAME ( f\" DNA change { NAME } : Mother Side \" ) NAME = NAME . NAME ( LIT ) if NAME is not None and NAME != NAME . NAME : NAME = True NAME . NAME ( f\" DNA change { NAME } : Meiosis \" ) except ( NAME , NAME , NAME ) as NAME : NAME . NAME ( f\" Error comparing DNA data for { NAME } : { NAME } . Assuming update needed. \" ) NAME = True if NAME : NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( LIT ) , LIT : NAME ( NAME . NAME ( LIT , LIT ) ) , # Store non-null string; DB schema requires NOT NULL LIT : NAME , LIT : LIT , # This operation hint is for the bulk operation logic } if NAME : NAME . NAME ( { LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME ( NAME . NAME ( LIT , False ) ) , LIT : NAME ( NAME . NAME ( LIT , False ) ) , } ) else : # Fallback if details API failed (prefetched_combined_details is None or empty) NAME . NAME ( f\" { NAME } : DNA needs create/update, but no/limited combined details. Using list data for segments. \" ) NAME [ LIT ] = NAME . NAME ( LIT ) # Other detail-specific fields (longest_shared_segment, meiosis, sides) will be None if not in dna_dict_base # Remove keys with None values *except* for predicted_relationship which we want to store as NULL if it's None # Also keep internal keys like _operation and uuid return { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None or NAME == LIT # Explicitly keep predicted_relationship even if None or NAME . NAME ( LIT ) # Keep internal keys or NAME == LIT # Keep uuid } return None"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_prepare_family_tree_operation_data",
      "lineno": 3992,
      "end_lineno": 4106,
      "is_method": false,
      "is_async": false,
      "args_count": 8,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 18,
      "loc": 115,
      "tags": [
        "pure-ish",
        "logging",
        "size:large"
      ],
      "signature": "(existing_family_tree, prefetched_tree_data, match_uuid, match_in_my_tree, session_manager, config_schema_arg, log_ref_short, logger_instance)",
      "fingerprint": "5108249472df0edaee12df06f6e03bb00b5fe517",
      "simhash64": 7452291964524205115,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME , NAME : NAME , NAME : NAME , NAME : LIT , # Config schema argument NAME : NAME , NAME : NAME . NAME , ) -> NAME [ NAME [ NAME [ NAME , NAME ] ] , NAME [ LIT , LIT , LIT ] ] : LIT NAME : NAME [ LIT , LIT , LIT ] = LIT NAME , NAME = None , None NAME = None if NAME : # Ensure prefetched_tree_data is not None NAME = NAME . NAME ( LIT ) if NAME and NAME . NAME : NAME = f\" /family-tree/person/tree/ { NAME . NAME } /person/ { NAME } \" NAME = NAME ( NAME . NAME . NAME , f\" { NAME } /facts \" ) # type: ignore NAME = { LIT : NAME , LIT : LIT , LIT : NAME . NAME , } NAME = NAME ( NAME . NAME . NAME , # type: ignore f\" /family-tree/tree/ { NAME . NAME } /family \" , ) NAME = f\" { NAME } ? { NAME ( NAME ) } \" if NAME and NAME is None : NAME = LIT elif NAME and NAME is not None : if NAME : # Only check if we have new data NAME = [ ( LIT , NAME ) , ( LIT , NAME . NAME ( LIT , LIT ) , ) , ( LIT , NAME . NAME ( LIT ) , ) , ( LIT , NAME . NAME ( LIT ) ) , ( LIT , NAME ) , ( LIT , NAME ) , ] for NAME , NAME in NAME : NAME = NAME ( NAME , NAME , None ) if NAME != NAME : # Handles None comparison correctly NAME = LIT NAME . NAME ( f\" Tree change { NAME } : Field ' { NAME } ' \" ) break # else: no prefetched_tree_data, cannot determine update, tree_operation remains \"none\" elif not NAME and NAME is not None : NAME . NAME ( f\" { NAME } : Data mismatch - API says not 'in_my_tree', but FamilyTree record exists (ID: { NAME . NAME } ). Skipping. \" ) NAME = LIT if NAME != LIT : if NAME : # Can only build if data was fetched NAME = NAME . NAME ( LIT , LIT ) NAME = { LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME , LIT : ( NAME . NAME if NAME == LIT and NAME else None ) , } # Keep all keys for _operation and _existing_tree_id, otherwise only non-None values NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None or NAME in [ LIT , LIT , LIT ] # Keep uuid } return NAME , NAME NAME . NAME ( f\" { NAME } : FamilyTree needs ' { NAME } ', but tree details not fetched. Skipping. \" ) NAME = LIT return None , NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_do_match",
      "lineno": 4116,
      "end_lineno": 4313,
      "is_method": false,
      "is_async": false,
      "args_count": 8,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 21,
      "loc": 198,
      "tags": [
        "pure-ish",
        "logging",
        "size:large"
      ],
      "signature": "(session, match, session_manager, existing_person_arg, prefetched_combined_details, prefetched_tree_data, config_schema, logger_instance)",
      "fingerprint": "2340ad11814caae0af9bb76a2778dc74ee9e66c1",
      "simhash64": 7452080857217938451,
      "normalized": "def NAME ( NAME : NAME , # Required by signature but not used in current implementation NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : LIT , # Config schema for API settings NAME : NAME . NAME , ) -> NAME [ NAME [ NAME [ NAME , NAME ] ] , NAME [ LIT , LIT , LIT , LIT ] , NAME [ NAME ] , ] : LIT NAME = NAME # Suppress unused parameter warning - required by signature NAME : NAME [ NAME ] = NAME NAME : NAME [ NAME ] = ( NAME . NAME if NAME else None ) NAME : NAME [ NAME ] = ( NAME . NAME if NAME else None ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = ( NAME ( NAME ) if NAME else LIT ) # predicted_relationship can now be None if fetch failed and was set to None in _prepare_bulk_db_data NAME : NAME [ NAME ] = NAME . NAME ( LIT ) # No default \"N/A\" here yet NAME = NAME . NAME ( LIT , False ) NAME = f\" UUID= { NAME } User=' { NAME } ' \" NAME : NAME [ NAME , NAME ] = { LIT : None , LIT : None , LIT : None , } NAME : NAME [ LIT , LIT , LIT , LIT ] = ( LIT # Default status ) NAME : NAME [ NAME ] = None if not NAME : NAME = f\" _do_match Pre-check failed: Missing 'uuid' in match data: { NAME } \" NAME . NAME ( NAME ) return None , LIT , NAME try : NAME = NAME is None # Process Person data with specific error handling try : NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , # Pass config schema NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) except NAME as NAME : NAME . NAME ( f\" Error in _prepare_person_operation_data for { NAME } : { NAME } \" , NAME = True , ) # Continue with other operations but mark person data as None NAME , NAME = None , False # Process DNA Match data with specific error handling try : NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) except NAME as NAME : NAME . NAME ( f\" Error in _prepare_dna_match_operation_data for { NAME } : { NAME } \" , NAME = True , ) # Continue with other operations but mark DNA data as None NAME = None # Process Family Tree data with specific error handling try : NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , # Pass config schema NAME = NAME , NAME = NAME , ) except NAME as NAME : NAME . NAME ( f\" Error in _prepare_family_tree_operation_data for { NAME } : { NAME } \" , NAME = True , ) # Continue with other operations but mark tree data as None NAME , NAME = None , LIT # type: ignore if NAME : NAME = LIT if NAME : NAME [ LIT ] = NAME if NAME : NAME [ LIT ] = NAME if NAME and NAME == LIT : NAME [ LIT ] = NAME else : # Existing Person if NAME : NAME [ LIT ] = NAME if NAME : NAME [ LIT ] = NAME if NAME : NAME [ LIT ] = NAME if ( NAME or NAME or ( NAME and NAME != LIT ) ) : NAME = LIT else : NAME = LIT NAME = ( NAME if NAME not in [ LIT , LIT ] and NAME ( NAME for NAME in NAME . NAME ( ) ) else None ) if NAME not in [ LIT , LIT ] and not NAME : # This means status was 'new' or 'updated' but no actual data was prepared to be sent. # This could happen if, for an existing person, only tree_op_data was prepared but its status was 'none'. # Or if a new person had no person_op_data (which shouldn't happen). # It's safer to mark as skipped if no data is actually going to be bulk processed. NAME . NAME ( # Changed to debug as this can be a valid \"no material change\" state f\" Status is ' { NAME } ' for { NAME } , but no data payloads prepared. Revising to 'skipped'. \" ) NAME = LIT NAME = None # Ensure this is None for skipped return NAME , NAME , None except NAME as NAME : NAME = NAME ( NAME ) . NAME NAME = NAME ( NAME ) NAME = f\" Unexpected critical error ( { NAME } ) in _do_match for { NAME } . Details: { NAME } \" NAME . NAME ( NAME , NAME = True ) NAME = ( f\" Unexpected { NAME } during data prep for { NAME } \" ) return None , LIT , NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "get_matches",
      "lineno": 4323,
      "end_lineno": 4890,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 18,
      "yield_count": 0,
      "complexity": 88,
      "loc": 568,
      "tags": [
        "impure",
        "network",
        "logging",
        "randomness",
        "time",
        "regex",
        "json",
        "purpose:factory",
        "purpose:getter",
        "size:large"
      ],
      "signature": "(session_manager, db_session, current_page)",
      "fingerprint": "cc68efe113469156c3f7aae63f83f8cff9969a0b",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , # Required by interface but not used in this function NAME : NAME = LIT , ) -> NAME [ NAME [ NAME [ NAME [ NAME , NAME ] ] , NAME [ NAME ] ] ] : LIT # Parameter `db_session` is unused in this function. # Consider removing it if it's not planned for future use here. # For now, we'll keep it to maintain the signature as per original code. NAME = NAME # Suppress unused parameter warning if not NAME ( NAME , NAME ) : NAME . NAME ( LIT ) return None NAME = NAME . NAME if not NAME : NAME . NAME ( LIT ) return None NAME = NAME . NAME if not NAME : NAME . NAME ( LIT ) return None if not NAME . NAME ( ) : NAME . NAME ( LIT ) return None # Fetching match list page (removed verbose debug) # Validate session state before API call try : # Check if we're still on a valid Ancestry page NAME = NAME . NAME if not NAME or LIT not in NAME : NAME . NAME ( f\" Driver not on Ancestry page. Current URL: { NAME } \" ) # Try to refresh the page NAME . NAME ( ) NAME . NAME ( LIT ) # Validate session cookies are present if not NAME . NAME ( ) : NAME . NAME ( LIT ) return None # SURGICAL FIX #17: Smart Cookie Sync Optimization # Track cookie sync freshness to avoid unnecessary syncing import NAME as NAME NAME = NAME . NAME ( ) # Check if cookies were synced recently (within last 5 minutes) NAME = NAME ( NAME , LIT , LIT ) NAME = ( NAME - NAME ) > LIT # 5 minutes if NAME and NAME ( NAME , LIT ) : NAME . NAME ( ) # Track the sync time NAME . NAME = NAME if NAME : NAME . NAME ( LIT ) elif not NAME : if NAME : NAME . NAME ( LIT ) elif NAME : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Session validation error: { NAME } \" ) return None # SURGICAL FIX #19: Enhanced CSRF Token Caching # Check if we have a cached CSRF token that's still valid NAME = NAME ( NAME , LIT , None ) NAME = NAME ( NAME , LIT , LIT ) NAME = ( NAME . NAME ( ) - NAME ) < LIT # 30 minutes if NAME and NAME : if NAME : NAME . NAME ( f\" Using cached CSRF token (age: { NAME . NAME ( ) - NAME : .1f } s) \" ) NAME = NAME else : # Need to read CSRF token from cookies NAME : NAME [ NAME ] = None NAME = ( LIT , LIT , ) try : if NAME : NAME . NAME ( f\" Reading fresh CSRF token from cookies: { NAME } \" ) for NAME in NAME : try : NAME = NAME . NAME ( NAME ) if NAME and LIT in NAME and NAME [ LIT ] : NAME = NAME ( NAME [ LIT ] ) . NAME ( LIT ) [ LIT ] if NAME : NAME . NAME ( f\" Read CSRF token from cookie ' { NAME } '. \" ) # Cache the token for future use NAME . NAME = NAME NAME . NAME = NAME . NAME ( ) break except NAME : continue except NAME as NAME : NAME . NAME ( f\" WebDriver error getting cookie ' { NAME } ': { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Unexpected error getting cookie ' { NAME } ': { NAME } \" , NAME = True , ) if not NAME : if NAME : NAME . NAME ( LIT ) NAME = NAME ( NAME ) if NAME : # get_driver_cookies returns a list of cookie dictionaries for NAME in NAME : for NAME in NAME : if NAME . NAME ( LIT ) == NAME and NAME . NAME ( LIT ) : NAME = NAME ( NAME [ LIT ] ) . NAME ( LIT ) [ LIT ] if NAME : NAME . NAME ( f\" Read CSRF token via fallback from ' { NAME } '. \" ) # Cache the token for future use NAME . NAME = NAME NAME . NAME = NAME . NAME ( ) break if NAME : break elif NAME : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Critical error during CSRF token retrieval: { NAME } \" , NAME = True ) return None if not NAME : NAME . NAME ( LIT ) return None if NAME : NAME . NAME ( f\" Specific CSRF token FOUND: ' { NAME } ' \" ) # Warm-up: visit the UI list page to ensure match-list CSRF is set in browser, then sync cookies + refresh CSRF try : from NAME import NAME NAME = NAME ( NAME . NAME . NAME , LIT ) NAME ( NAME , NAME ) # Sync browser cookies to requests and refresh CSRF NAME . NAME ( ) NAME = NAME ( NAME , NAME = True ) or NAME except NAME as NAME : NAME . NAME ( f\" Match list warm-up skipped due to: { NAME } \" ) # Use the working API endpoint pattern that matches other working API calls (like matchProbabilityData, badges, etc.) NAME = NAME ( NAME . NAME . NAME , f\" discoveryui-matches/parents/list/api/matchList/ { NAME } ?currentPage= { NAME } \" , ) # Use simplified headers that were working earlier NAME = { LIT : NAME , # CRITICAL FIX: Use lowercase header LIT : LIT , LIT : NAME ( NAME . NAME . NAME , LIT ) , } NAME . NAME ( NAME ( f\" Calling Match List API for page { NAME } ... \" ) ) if NAME : NAME . NAME ( NAME ( f\" Headers being passed to _api_req for Match List: { NAME } \" ) ) # Additional debug logging for troubleshooting 303 redirects if NAME : NAME . NAME ( f\" Match List URL: { NAME } \" ) NAME . NAME ( f\" Session manager state - driver_live: { NAME . NAME } , session_ready: { NAME . NAME } \" ) # CRITICAL: Ensure cookies are synced immediately before API call # This was simpler in the working version from 6 weeks ago # Session-level cookie sync is handled by SessionManager; avoid per-call sync here try : if NAME ( NAME , LIT ) : NAME . NAME ( ) except NAME as NAME : if NAME : NAME . NAME ( f\" Session-level cookie sync hint failed (ignored): { NAME } \" ) # ROOT CAUSE FIX: Match List API REQUIRES CSRF token authentication # The Profile API works without CSRF, but Match List API needs it NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , NAME = NAME , NAME = True , # CRITICAL FIX: Enable CSRF token for Match List API NAME = LIT , NAME = True , ) NAME : NAME [ NAME ] = None NAME : NAME [ NAME ] = [ ] if NAME is None : NAME . NAME ( f\" No response/error from match list API page { NAME } . Assuming empty page. \" ) return [ ] , None if not NAME ( NAME , NAME ) : # Handle 303 See Other: retry with redirect or session refresh if NAME ( NAME , NAME . NAME ) : NAME = NAME . NAME NAME = NAME . NAME . NAME ( LIT ) if NAME == LIT : if NAME : NAME . NAME ( f\" Match List API received 303 See Other. Retrying with redirect to { NAME } . \" ) # Retry once with the new location NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , NAME = NAME , NAME = True , # CRITICAL FIX: Enable CSRF for redirected Match List API NAME = LIT , NAME = False , ) if NAME ( NAME , NAME ) : NAME = NAME else : NAME . NAME ( f\" Redirected Match List API did not return dict. Status: { NAME ( NAME , LIT , None ) } \" ) return None else : # 303 with no location usually means session expired - try session refresh NAME . NAME ( LIT LIT ) # EMERGENCY FIX: Track consecutive 303 redirects for session death detection if not NAME ( NAME , LIT ) : NAME . NAME = LIT NAME . NAME += LIT NAME . NAME ( f\" \ud83d\udea8 303 Redirect # { NAME . NAME } detected - session may be dead \" ) try : # Clear session cache for complete fresh start try : NAME = NAME . NAME ( ) NAME . NAME ( f\" \ud83e\uddf9 Cleared { NAME } session cache entries before refresh \" ) except NAME as NAME : NAME . NAME ( f\" \u26a0\ufe0f Could not clear session cache: { NAME } \" ) # Force clear readiness check cache to ensure fresh validation NAME . NAME = None NAME . NAME ( LIT ) # Force session refresh with cleared cache NAME = NAME . NAME ( NAME = LIT ) if not NAME : NAME . NAME ( LIT ) return None # Force cookie sync and CSRF token refresh NAME . NAME ( ) NAME = NAME ( NAME , NAME = True ) if NAME : # Update headers with fresh token and retry NAME [ LIT ] = NAME # CRITICAL FIX: Use lowercase header NAME . NAME ( LIT ) NAME . NAME ( f\" \ud83d\udd11 Fresh CSRF token: { NAME [ : LIT ] } ... \" ) NAME . NAME ( f\" \ud83c\udf6a Session cookies synced: { NAME ( NAME . NAME . NAME ) } cookies \" ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , NAME = NAME , NAME = True , # CRITICAL FIX: Enable CSRF for refreshed Match List API NAME = LIT , NAME = True , ) if NAME ( NAME , NAME ) : NAME = NAME else : NAME . NAME ( LIT ) return None else : NAME . NAME ( LIT ) return None except NAME as NAME : NAME . NAME ( f\" Error during session refresh: { NAME } \" ) return None else : NAME . NAME ( f\" Match List API did not return dict. Type: { NAME ( NAME ) . NAME } , \" f\" Status: { NAME ( NAME , LIT , LIT ) } \" ) return None else : NAME . NAME ( f\" Match List API did not return dict. Type: { NAME ( NAME ) . NAME } \" ) return None NAME = NAME . NAME ( LIT ) if NAME is not None : try : NAME = NAME ( NAME ) except ( NAME , NAME ) : NAME . NAME ( f\" Could not parse totalPages ' { NAME } '. \" ) else : NAME . NAME ( LIT ) # EMERGENCY FIX: Reset 303 counter on successful API response if NAME ( NAME , LIT ) and NAME . NAME > LIT : NAME . NAME ( f\" \u2705 Successful API response - resetting 303 counter (was { NAME . NAME } ) \" ) NAME . NAME = LIT NAME = NAME . NAME ( LIT , [ ] ) if not NAME : NAME . NAME ( f\" No matches found in 'matchList' array for page { NAME } . \" ) NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] NAME = LIT for NAME , NAME in NAME ( NAME ) : # Use enumerate for index if NAME ( NAME , NAME ) and NAME . NAME ( LIT ) : NAME . NAME ( NAME ) else : NAME += LIT NAME = f\" (Index: { NAME } , Data: { NAME ( NAME ) [ : LIT ] } ...) \" NAME . NAME ( f\" Skipping raw match missing 'sampleId' on page { NAME } . { NAME } \" ) if NAME > LIT : NAME . NAME ( f\" Skipped { NAME } raw matches on page { NAME } due to missing 'sampleId'. \" ) if not NAME : NAME . NAME ( f\" No valid matches (with sampleId) found on page { NAME } to process further. \" ) return [ ] , NAME NAME = [ NAME [ LIT ] . NAME ( ) for NAME in NAME ] NAME : NAME [ NAME ] = NAME ( ) NAME = f\" matches_in_tree_ { NAME ( NAME ( NAME ) ) } \" try : if NAME is not None : NAME = NAME . NAME ( NAME , NAME = NAME , NAME = True ) if NAME is not NAME : if NAME ( NAME , NAME ) : NAME = NAME NAME . NAME ( f\" Loaded { NAME ( NAME ) } in-tree IDs from cache for page { NAME } . \" ) else : # Cache miss or ENOVAL (which means miss in this context) NAME . NAME ( f\" Cache miss for in-tree status (Key: { NAME } ). Fetching from API. \" ) # Fall through to API fetch # If global_cache is None, also fall through to API fetch except NAME as NAME : NAME . NAME ( f\" Error reading in-tree status from cache: { NAME } . Fetching from API. \" , NAME = True , ) NAME = ( NAME ( ) ) # Ensure it's an empty set before API fetch if cache read fails if not NAME : # Fetch if cache miss, cache error, or cache was disabled if not NAME . NAME ( ) : NAME . NAME ( f\" In-Tree Status Check: Session invalid page { NAME } . Cannot fetch. \" ) else : NAME = NAME ( NAME . NAME . NAME , f\" discoveryui-matches/parents/list/api/badges/matchesInTree/ { NAME . NAME ( ) } \" , ) NAME = NAME ( NAME . NAME . NAME ) NAME = f\" { NAME . NAME } :// { NAME . NAME } \" NAME = None if NAME and NAME . NAME ( ) : from NAME import NAME with NAME ( NAME ) : NAME = NAME . NAME ( LIT ) NAME = NAME or NAME . NAME ( NAME . NAME . NAME ) NAME = { LIT : NAME , # CRITICAL FIX: Use lowercase header LIT : NAME ( NAME . NAME . NAME , LIT ) , LIT : NAME , LIT : LIT , LIT : LIT , LIT : NAME , } NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME } NAME . NAME ( f\" Fetching in-tree status for { NAME ( NAME ) } matches on page { NAME } ... \" ) NAME . NAME ( f\" In-Tree Check Headers FULLY set in get_matches: { NAME } \" ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , NAME = { LIT : NAME } , # This is correct - _api_req expects json_data NAME = NAME , NAME = False , NAME = LIT , ) if NAME ( NAME , NAME ) : NAME = { NAME . NAME ( ) for NAME in NAME if NAME ( NAME , NAME ) } NAME . NAME ( f\" Fetched { NAME ( NAME ) } in-tree IDs from API for page { NAME } . \" ) try : if NAME is not None : NAME . NAME ( NAME , NAME , NAME = NAME . NAME . NAME , NAME = True , ) NAME . NAME ( f\" Cached in-tree status result for page { NAME } . \" ) except NAME as NAME : NAME . NAME ( f\" Error writing in-tree status to cache: { NAME } \" ) else : NAME = ( f\" Status: { NAME . NAME } \" # type: ignore if NAME ( NAME , NAME . NAME ) else LIT ) NAME . NAME ( f\" In-Tree Status Check API failed or returned unexpected format for page { NAME } . { NAME } \" ) NAME . NAME ( f\" In-Tree check response: { NAME } \" ) NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] NAME . NAME ( f\" Refining { NAME ( NAME ) } valid matches... \" ) for NAME , NAME in NAME ( NAME ) : try : NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) NAME = NAME [ LIT ] NAME = NAME . NAME ( ) NAME = NAME . NAME ( LIT ) NAME = ( NAME ( NAME ) . NAME ( ) if NAME else None ) NAME = NAME . NAME ( LIT ) NAME = NAME ( NAME ) NAME : NAME [ NAME ] = None if NAME and NAME != LIT : NAME = NAME . NAME ( ) if NAME : NAME = NAME . NAME ( ) if NAME : NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) NAME = NAME . NAME ( LIT ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT ) NAME = NAME ( NAME . NAME . NAME , f\" discoveryui-matches/compare/ { NAME . NAME ( ) } /with/ { NAME } \" , ) NAME = NAME in NAME NAME = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : None , LIT : NAME , LIT : NAME , } NAME . NAME ( NAME ) except ( NAME , NAME , NAME , NAME ) as NAME : NAME = NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" Refinement error page { NAME } , match # { NAME + LIT } (UUID: { NAME } ): { NAME ( NAME ) . NAME } - { NAME } . Skipping match. \" , NAME = False , ) NAME . NAME ( f\" Problematic match data during refinement: { NAME } \" ) continue except NAME as NAME : NAME = NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" CRITICAL unexpected error refining match page { NAME } , match # { NAME + LIT } (UUID: { NAME } ): { NAME } \" , NAME = True , ) NAME . NAME ( f\" Problematic match data during critical error: { NAME } \" ) raise NAME NAME . NAME ( f\" Successfully refined { NAME ( NAME ) } matches on page { NAME } . \" ) return NAME , NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_fetch_combined_details",
      "lineno": 4898,
      "end_lineno": 5233,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 47,
      "loc": 336,
      "tags": [
        "impure",
        "network",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "(session_manager, match_uuid)",
      "fingerprint": "ed9b987f05e6a94860277ae0d9aaf203d08a0d19",
      "simhash64": 7452151226029216827,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT # PRIORITY 1: Performance Monitoring Integration NAME = NAME . NAME ( ) # SURGICAL FIX #14: Enhanced Smart Caching using existing global cache system if NAME is not None : NAME = f\" combined_details_ { NAME } \" try : NAME = NAME . NAME ( NAME , NAME = NAME , NAME = True ) if NAME is not NAME and NAME ( NAME , NAME ) : # Cache hit for combined details (removed verbose debug) NAME ( LIT , NAME , LIT ) return NAME except NAME as NAME : NAME . NAME ( f\" Cache check failed for { NAME } : { NAME } \" ) NAME = NAME . NAME if not NAME or not NAME : NAME . NAME ( f\" _fetch_combined_details: Missing my_uuid ( { NAME } ) or match_uuid ( { NAME } ). \" ) NAME ( LIT , NAME , LIT ) return None # SURGICAL FIX #20: Universal session validation with SessionManager death detection if NAME . NAME ( ) : NAME . NAME ( f\" _fetch_combined_details: Halting due to session death cascade for UUID { NAME } \" ) # Cancel any pending operations to prevent further cascade try : NAME . NAME ( ) # type: ignore[attr-defined] except NAME : NAME . NAME ( LIT ) raise NAME ( f\" Session death cascade detected - halting combined details fetch (UUID: { NAME } ) \" ) # Traditional session check with enhanced logging if not NAME . NAME ( ) : # Update session health monitoring in SessionManager NAME . NAME ( ) NAME . NAME ( f\" _fetch_combined_details: WebDriver session invalid for UUID { NAME } . \" ) raise NAME ( f\" WebDriver session invalid for combined details fetch (UUID: { NAME } ) \" ) NAME : NAME [ NAME , NAME ] = { } NAME = NAME ( NAME . NAME . NAME , f\" /discoveryui-matchesservice/api/samples/ { NAME } /matches/ { NAME } /details?pmparentaldata=true \" , ) # details_referer = urljoin(  # Removed unused variable #     config_schema.api.base_url, #     f\"/discoveryui-matches/compare/{my_uuid}/with/{match_uuid}\", # ) # Fetching details API (removed verbose debug) # Use headers from working cURL command NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } # Apply the same cookie sync fix that worked for Match List API # Session-level cookie sync is handled by SessionManager; avoid per-call sync here try : if NAME ( NAME , LIT ) : NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" Session-level cookie sync hint failed (ignored): { NAME } \" ) try : NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = NAME , NAME = True , # CRITICAL FIX: Enable CSRF for Match Details API NAME = LIT , ) if NAME and NAME ( NAME , NAME ) : NAME [ LIT ] = NAME . NAME ( LIT ) NAME [ LIT ] = NAME . NAME ( LIT ) NAME [ LIT ] = NAME . NAME ( LIT ) NAME [ LIT ] = NAME . NAME ( LIT ) NAME [ LIT ] = NAME . NAME ( LIT ) NAME [ LIT ] = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT , { } ) NAME [ LIT ] = NAME . NAME ( LIT ) NAME [ LIT ] = NAME . NAME ( LIT ) NAME [ LIT ] = NAME . NAME ( LIT ) NAME [ LIT ] = NAME ( NAME . NAME ( LIT , False ) ) NAME [ LIT ] = NAME ( NAME . NAME ( LIT , False ) ) # Parse predictions from details endpoint to derive a human-readable likely relationship try : NAME = NAME . NAME ( LIT ) or [ ] if NAME ( NAME , NAME ) and NAME : # Choose the prediction with the highest distributionProbability NAME = NAME ( ( NAME for NAME in NAME if NAME ( NAME , NAME ) ) , NAME = lambda NAME : NAME . NAME ( LIT , LIT ) or LIT , ) NAME = NAME . NAME ( LIT , LIT ) # Normalize percent: values may be 0-1 or already 0-100 NAME = ( NAME ( NAME ) * LIT if NAME ( NAME , ( NAME , NAME ) ) and NAME <= LIT else NAME ( NAME ) or LIT ) NAME = [ ] for NAME in NAME . NAME ( LIT , [ ] ) or [ ] : if NAME ( NAME , NAME ) and NAME . NAME ( LIT ) : NAME . NAME ( NAME ( NAME . NAME ( LIT ) ) ) if NAME : # Use up to 2 labels for readability (full words, no abbreviations) NAME = LIT . NAME ( NAME [ : LIT ] ) NAME [ LIT ] = f\" { NAME } [ { NAME : .1f } %] \" except NAME : # Don't fail details fetch if prediction parsing has issues pass elif NAME ( NAME , NAME . NAME ) : NAME . NAME ( f\" Match Details API failed for UUID { NAME } . Status: { NAME . NAME } { NAME . NAME } \" ) return None else : NAME . NAME ( f\" Match Details API did not return dict for UUID { NAME } . Type: { NAME ( NAME ) } \" ) return None except NAME as NAME : NAME . NAME ( f\" ConnectionError fetching /details for UUID { NAME } : { NAME } \" , NAME = False , ) raise except NAME as NAME : NAME . NAME ( f\" Error processing /details response for UUID { NAME } : { NAME } \" , NAME = True , ) if NAME ( NAME , NAME . NAME . NAME ) : raise return None NAME = NAME . NAME ( LIT ) # Profile ID header available from session manager if needed NAME [ LIT ] = None NAME [ LIT ] = False if not NAME : NAME . NAME ( f\" Skipping /profiles/details fetch for { NAME } : Tester profile ID not found in /details. \" ) # Removed check for my_profile_id_header as it's not used for this API call's headers. # The important part is session validity. elif not NAME . NAME ( ) : NAME . NAME ( f\" _fetch_combined_details: WebDriver session invalid before profile fetch for { NAME } . \" ) raise NAME ( f\" WebDriver session invalid before profile fetch (Profile: { NAME } ) \" ) else : # OPTIMIZATION: Check cache first to avoid redundant API calls NAME = NAME ( NAME ) if NAME is not None : # Apply cached profile data to combined_data NAME [ LIT ] = NAME . NAME ( LIT ) NAME [ LIT ] = NAME . NAME ( LIT , False ) else : # Cache miss - need to fetch from API NAME = NAME ( NAME . NAME . NAME , f\" /app-api/express/v1/profiles/details?userId= { NAME . NAME ( ) } \" , ) NAME . NAME ( f\" Fetching /profiles/details for Profile ID { NAME } (Match UUID { NAME } )... \" ) # Use the same headers as the working cURL command NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } # Apply cookie sync for Profile Details API as well # Session-level cookie sync is handled by SessionManager; avoid per-call sync here try : if NAME ( NAME , LIT ) : NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" Session-level cookie sync hint failed (ignored): { NAME } \" ) try : NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = NAME , NAME = False , NAME = LIT , ) if NAME and NAME ( NAME , NAME ) : # Successfully fetched profiles/details (removed verbose debug) # Parse last login date NAME = None NAME = NAME . NAME ( LIT ) if NAME : try : if NAME . NAME ( LIT ) : NAME = NAME . NAME ( NAME . NAME ( LIT , LIT ) ) else : # Assuming it might be naive or already have offset NAME = NAME . NAME ( NAME ) NAME = ( NAME . NAME ( NAME = NAME . NAME ) if NAME . NAME is None else NAME . NAME ( NAME . NAME ) ) except ( NAME , NAME ) as NAME : NAME . NAME ( f\" Could not parse LastLoginDate ' { NAME } ' for { NAME } : { NAME } \" ) # Parse contactable status NAME = NAME . NAME ( LIT ) NAME = ( NAME ( NAME ) if NAME is not None else False ) # Update combined_data with fetched values NAME [ LIT ] = NAME NAME [ LIT ] = NAME # OPTIMIZATION: Cache the successful response for future use NAME ( NAME , { LIT : NAME , LIT : NAME } ) elif NAME ( NAME , NAME . NAME ) : NAME . NAME ( f\" Failed /profiles/details fetch for UUID { NAME } . Status: { NAME . NAME } . \" ) else : NAME . NAME ( f\" Failed /profiles/details fetch for UUID { NAME } (Invalid response: { NAME ( NAME ) } ). \" ) except NAME as NAME : NAME . NAME ( f\" ConnectionError fetching /profiles/details for { NAME } : { NAME } \" , NAME = False , ) raise except NAME as NAME : NAME . NAME ( f\" Error processing /profiles/details for { NAME } : { NAME } \" , NAME = True , ) if NAME ( NAME , NAME . NAME . NAME ) : raise # SURGICAL FIX #14: Cache successful results using existing global cache system if NAME and NAME is not None : NAME = f\" combined_details_ { NAME } \" try : # Cache for a shorter TTL since match details can change NAME . NAME ( NAME , NAME , NAME = LIT , # 1 hour TTL for combined details NAME = True ) # Details cached successfully (reduced verbosity) except NAME as NAME : NAME . NAME ( f\" Failed to cache combined details for { NAME } : { NAME } \" ) # PRIORITY 1: Performance Monitoring - Log completion if NAME : NAME ( LIT , NAME , LIT , NAME ) else : NAME ( LIT , NAME , LIT , NAME ) return NAME if NAME else None"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_fetch_batch_badge_details",
      "lineno": 5240,
      "end_lineno": 5371,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 18,
      "loc": 132,
      "tags": [
        "impure",
        "network",
        "logging",
        "size:large"
      ],
      "signature": "(session_manager, match_uuid)",
      "fingerprint": "2f00815057d4167342f0490cf90b7f609e820737",
      "simhash64": 7488180022981071891,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT # SURGICAL FIX #14: Enhanced Smart Caching using existing global cache system if NAME is not None : NAME = f\" badge_details_ { NAME } \" try : NAME = NAME . NAME ( NAME , NAME = NAME , NAME = True ) if NAME is not NAME and NAME ( NAME , NAME ) : NAME . NAME ( f\" Cache hit for badge details: { NAME } \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Cache check failed for badge details { NAME } : { NAME } \" ) NAME = NAME . NAME if not NAME or not NAME : NAME . NAME ( LIT ) return None # SURGICAL FIX #20: Universal session validation with SessionManager death detection if NAME . NAME ( ) : NAME . NAME ( f\" _fetch_batch_badge_details: Halting due to session death cascade for UUID { NAME } \" ) raise NAME ( f\" Session death cascade detected - halting badge details fetch (UUID: { NAME } ) \" ) # Traditional session check with enhanced logging if not NAME . NAME ( ) : # Update session health monitoring in SessionManager NAME . NAME ( ) NAME . NAME ( f\" _fetch_batch_badge_details: WebDriver session invalid for UUID { NAME } . \" ) raise NAME ( f\" WebDriver session invalid for badge details fetch (UUID: { NAME } ) \" ) NAME = NAME ( NAME . NAME . NAME , f\" /discoveryui-matchesservice/api/samples/ { NAME } /matches/ { NAME } /badgedetails \" , ) NAME = NAME ( NAME . NAME . NAME , LIT ) NAME . NAME ( f\" Fetching /badgedetails API for UUID { NAME } ... \" ) try : NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = True , # CRITICAL FIX: Enable CSRF for Badge Details API NAME = LIT , NAME = NAME , ) if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , { } ) if not NAME : NAME . NAME ( f\" Badge details response for UUID { NAME } missing 'personBadged' key. \" ) return None NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) # Use format_name for consistent name handling NAME = NAME ( NAME ) NAME = ( NAME . NAME ( ) [ LIT ] if NAME and NAME != LIT else LIT ) NAME = { LIT : NAME , LIT : NAME , # Use formatted name LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , } # SURGICAL FIX #14: Cache successful badge details using existing global cache system if NAME is not None : NAME = f\" badge_details_ { NAME } \" try : # Cache for shorter TTL since badge details can change NAME . NAME ( NAME , NAME , NAME = LIT , # 1 hour TTL for badge details NAME = True ) # Badge details cached successfully (reduced verbosity) except NAME as NAME : NAME . NAME ( f\" Failed to cache badge details for { NAME } : { NAME } \" ) return NAME if NAME ( NAME , NAME . NAME ) : NAME . NAME ( f\" Failed /badgedetails fetch for UUID { NAME } . Status: { NAME . NAME } . \" ) return None NAME . NAME ( f\" Invalid badge details response for UUID { NAME } . Type: { NAME ( NAME ) } \" ) return None except NAME as NAME : NAME . NAME ( f\" ConnectionError fetching badge details for UUID { NAME } : { NAME } \" , NAME = False , ) raise except NAME as NAME : NAME . NAME ( f\" Error processing badge details for UUID { NAME } : { NAME } \" , NAME = True ) if NAME ( NAME , NAME . NAME . NAME ) : raise return None"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_fetch_batch_ladder",
      "lineno": 5378,
      "end_lineno": 5436,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 12,
      "loc": 59,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(session_manager, cfpid, tree_id)",
      "fingerprint": "c7f9a0834bf0422844c8d405c9a6b46659f56eb1",
      "simhash64": 7488320760469435451,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT # Try the new enhanced API first try : from NAME import NAME NAME = NAME ( NAME = NAME , NAME = NAME ) if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , [ ] ) if NAME : # Extract relationship information from the enhanced API for NAME in NAME : if NAME ( NAME , NAME ) and NAME . NAME ( LIT ) == NAME : NAME = NAME . NAME ( LIT , LIT ) if NAME : # Format the result to match the expected format return { LIT : NAME , LIT : f\" Enhanced API: { NAME } \" } # If we have kinship data but no direct match, use the first relationship if NAME and NAME ( NAME [ LIT ] , NAME ) : NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , LIT ) if NAME : return { LIT : NAME , LIT : f\" Enhanced API: { NAME } \" } NAME . NAME ( f\" Enhanced API didn't return usable data for { NAME } , falling back to legacy API \" ) except NAME as NAME : NAME . NAME ( f\" Enhanced API failed for { NAME } , falling back to legacy API: { NAME } \" ) # Fallback to the original implementation return NAME ( NAME , NAME , NAME )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_fetch_batch_ladder_legacy",
      "lineno": 5439,
      "end_lineno": 5618,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 12,
      "yield_count": 0,
      "complexity": 30,
      "loc": 180,
      "tags": [
        "impure",
        "network",
        "regex",
        "json",
        "size:large"
      ],
      "signature": "(session_manager, cfpid, tree_id)",
      "fingerprint": "4757e87d981c14fbe5dd825f79a9894b8dc02bf1",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME or not NAME : NAME . NAME ( LIT ) return None if not NAME . NAME ( ) : NAME . NAME ( f\" _fetch_batch_ladder_legacy: WebDriver session invalid for CFPID { NAME } . \" ) raise NAME ( f\" WebDriver session invalid for ladder fetch (CFPID: { NAME } ) \" ) NAME = NAME ( NAME . NAME . NAME , f\" family-tree/person/tree/ { NAME } /person/ { NAME } /getladder?callback=jQuery \" , ) NAME = NAME ( NAME . NAME . NAME , f\" family-tree/person/tree/ { NAME } /person/ { NAME } /facts \" , ) NAME . NAME ( f\" Fetching /getladder API for CFPID { NAME } in Tree { NAME } ... \" ) NAME : NAME [ NAME , NAME [ NAME ] ] = { LIT : None , LIT : None , } try : NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = { } , NAME = False , NAME = LIT , NAME = NAME , NAME = True , ) if NAME ( NAME , NAME . NAME ) : NAME . NAME ( f\" Get Ladder API call failed for CFPID { NAME } (Status: { NAME . NAME } ). \" ) return None if NAME is None : NAME . NAME ( f\" Get Ladder API call returned None for CFPID { NAME } . \" ) return None if not NAME ( NAME , NAME ) : NAME . NAME ( f\" _api_req returned unexpected type ' { NAME ( NAME ) . NAME } ' for Get Ladder API (CFPID { NAME } ). \" ) return None NAME = NAME NAME = NAME . NAME ( NAME ) if not NAME : NAME . NAME ( f\" Could not parse JSONP format for CFPID { NAME } . Response: { NAME [ : LIT ] } ... \" ) return None NAME = NAME . NAME ( LIT ) . NAME ( ) try : if not NAME or NAME in ( LIT , LIT ) : NAME . NAME ( f\" Empty JSON content within JSONP for CFPID { NAME } . \" ) return None NAME = NAME ( NAME ) if NAME ( NAME , NAME ) and LIT in NAME : NAME = NAME [ LIT ] if NAME : NAME = NAME ( NAME , LIT ) NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) if NAME : NAME = NAME . NAME ( NAME = True ) NAME [ LIT ] = NAME ( NAME . NAME ( ) ) else : NAME . NAME ( f\" Could not extract actual_relationship for CFPID { NAME } \" ) NAME = NAME . NAME ( LIT ) NAME = [ ] NAME = NAME ( NAME ) for NAME , NAME in NAME ( NAME ) : NAME , NAME = LIT , LIT NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) if NAME : NAME = NAME ( NAME . NAME ( NAME = True ) . NAME ( LIT , LIT ) ) if ( NAME > LIT ) : # Description is not for the first person (the target) NAME = NAME . NAME ( LIT ) if NAME : NAME = NAME . NAME ( NAME = True ) . NAME ( LIT , LIT ) # Check if it's the \"You are the...\" line if ( NAME == NAME - LIT and NAME . NAME ( ) . NAME ( LIT ) ) : NAME = NAME ( NAME [ NAME ( LIT ) : ] . NAME ( ) ) else : # Normal relationship \"of\" someone else NAME = NAME . NAME ( LIT , NAME , NAME . NAME , ) if NAME : NAME = f\" { NAME . NAME ( LIT ) . NAME ( ) . NAME ( ) } of { NAME ( NAME . NAME ( LIT ) . NAME ( ) ) } \" else : # Fallback if \"of\" not found (e.g., \"Wife\") NAME = NAME ( NAME ) if NAME : # Only add if name was found NAME . NAME ( f\" { NAME } ( { NAME } ) \" if NAME else NAME ) if NAME : NAME [ LIT ] = LIT . NAME ( NAME ) else : NAME . NAME ( f\" Could not construct relationship_path for CFPID { NAME } . \" ) NAME . NAME ( f\" Successfully parsed ladder details for CFPID { NAME } . \" ) # Return only if at least one piece of data was found if ( NAME [ LIT ] or NAME [ LIT ] ) : return NAME # No data found after parsing NAME . NAME ( f\" No actual_relationship or path found for CFPID { NAME } after parsing. \" ) return None NAME . NAME ( f\" Empty HTML in getladder response for CFPID { NAME } . \" ) return None NAME . NAME ( f\" Missing 'html' key in getladder JSON for CFPID { NAME } . JSON: { NAME } \" ) return None except NAME . NAME as NAME : NAME . NAME ( f\" Failed to decode JSONP content for CFPID { NAME } : { NAME } \" ) NAME . NAME ( f\" JSON string causing decode error: ' { NAME [ : LIT ] } ...' \" ) return None except NAME as NAME : NAME . NAME ( f\" ConnectionError fetching ladder for CFPID { NAME } : { NAME } \" , NAME = False , ) raise except NAME as NAME : NAME . NAME ( f\" Error processing ladder for CFPID { NAME } : { NAME } \" , NAME = True ) if NAME ( NAME , NAME . NAME . NAME ) : raise return None"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_log_page_summary",
      "lineno": 5634,
      "end_lineno": 5645,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(page, page_new, page_updated, page_skipped, page_errors)",
      "fingerprint": "f3f62fe51a4d8fd508b5e317085a4088364c56f1",
      "simhash64": 8622559363496051723,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) : LIT NAME . NAME ( LIT ) # Blank line above NAME . NAME ( NAME . NAME ( NAME ( f\" ---- Page { NAME } Summary ---- \" ) ) ) NAME . NAME ( NAME . NAME ( NAME ( f\" New Person/Data: { NAME } \" ) ) ) NAME . NAME ( NAME . NAME ( NAME ( f\" Updated Person/Data: { NAME } \" ) ) ) NAME . NAME ( NAME . NAME ( NAME ( f\" Skipped (No Change): { NAME } \" ) ) ) NAME . NAME ( NAME . NAME ( NAME ( f\" Errors during Prep/DB: { NAME } \" ) ) ) NAME . NAME ( NAME . NAME ( LIT ) ) NAME . NAME ( LIT ) # Blank line below"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_log_coord_summary",
      "lineno": 5651,
      "end_lineno": 5708,
      "is_method": false,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 13,
      "loc": 58,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(total_pages_processed, total_new, total_updated, total_skipped, total_errors, start_ts)",
      "fingerprint": "f06d497691adbeebc8bce7febacd815ba809be01",
      "simhash64": 8641101527586870291,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME | None = None , ) : LIT # Compute processed count from counters NAME = ( NAME or LIT ) + ( NAME or LIT ) + ( NAME or LIT ) NAME . NAME ( NAME . NAME ( LIT ) ) NAME . NAME ( NAME . NAME ( f\" Run id: [ { NAME } ] \" ) ) NAME . NAME ( NAME . NAME ( f\" Total Pages Processed: { NAME } \" ) ) NAME . NAME ( NAME . NAME ( f\" Total New Added: { NAME } \" ) ) NAME . NAME ( NAME . NAME ( f\" Total Updated: { NAME } \" ) ) NAME . NAME ( NAME . NAME ( f\" Total Skipped: { NAME } \" ) ) NAME . NAME ( NAME . NAME ( f\" Total Errors: { NAME } \" ) ) # Integrate processed count, rate and elapsed (anchor to earliest of coord_start_ts or lock-file ts) NAME = None NAME = None try : if NAME is not None : NAME = NAME ( NAME ) except NAME : NAME = None try : NAME = NAME . NAME ( NAME = LIT ) . NAME ( ) NAME = NAME . NAME ( LIT ) if NAME ( NAME ) == LIT : NAME = NAME ( NAME [ LIT ] ) except NAME : NAME = None NAME = None for NAME in ( NAME , NAME ) : if NAME is None : continue NAME = NAME if NAME is None else NAME ( NAME , NAME ) NAME = None if NAME is not None : try : NAME = NAME ( LIT , NAME . NAME ( ) - NAME ) except NAME : NAME = None if NAME is not None : from NAME import NAME as NAME NAME = ( NAME / NAME ) if NAME > LIT else LIT NAME . NAME ( NAME . NAME ( f\" Processed: { NAME } | Rate: { NAME : .1f } matches/s | Total time: { NAME ( NAME = NAME ( NAME ) ) } \" ) ) else : NAME . NAME ( NAME . NAME ( f\" Processed: { NAME } \" ) ) NAME . NAME ( NAME . NAME ( LIT ) )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_adjust_delay",
      "lineno": 5715,
      "end_lineno": 5743,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 29,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "(session_manager, current_page)",
      "fingerprint": "86f12626988a574ab28b311fe06c416a3e8cbc4f",
      "simhash64": 7487617074101392395,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT NAME = NAME ( NAME , LIT , None ) if NAME is None : return if NAME ( NAME , LIT ) and NAME . NAME ( ) : NAME . NAME ( f\" Rate limiter was throttled during processing before/during page { NAME } . Delay remains increased. \" ) else : NAME = NAME ( NAME , LIT , None ) if NAME ( NAME , LIT ) : NAME . NAME ( ) NAME = NAME ( NAME , LIT , None ) if ( NAME is not None and NAME is not None and NAME ( NAME - NAME ) > LIT and NAME > NAME ( NAME . NAME , LIT , LIT ) ) : NAME . NAME ( f\" Decreased rate limit base delay to { NAME : .2f } s after page { NAME } . \" )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "nav_to_list",
      "lineno": 5749,
      "end_lineno": 5803,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 7,
      "loc": 55,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(session_manager)",
      "fingerprint": "2022646c91e7ee9cc05c90d47fdae55fa50fac46",
      "simhash64": 8641066343214789651,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if ( not NAME or not NAME . NAME ( ) or not NAME . NAME ) : NAME . NAME ( LIT ) return False NAME = NAME . NAME NAME = NAME ( NAME . NAME . NAME , f\" discoveryui-matches/list/ { NAME } \" ) NAME . NAME ( f\" Navigating to specific match list URL: { NAME } \" ) NAME = NAME . NAME if NAME is None : NAME . NAME ( LIT ) return False NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , # type: ignore NAME = NAME , ) if NAME : try : NAME = NAME . NAME if not NAME . NAME ( NAME ) : NAME . NAME ( f\" Navigation successful (element found), but final URL unexpected: { NAME } \" ) else : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Could not verify final URL after nav_to_list success: { NAME } \" ) else : NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "action6_gather_module_tests",
      "lineno": 5819,
      "end_lineno": 6613,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 8,
      "yield_count": 0,
      "complexity": 44,
      "loc": 795,
      "tags": [
        "impure",
        "db",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "fcd26fa18b22ae72a878bf54d84ecf55ba1fdc0b",
      "simhash64": 7452291964523156539,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # INITIALIZATION TESTS def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] # Test _initialize_gather_state function NAME ( LIT ) try : NAME = NAME ( ) NAME = NAME ( NAME , NAME ) NAME = [ LIT , LIT , LIT ] NAME = NAME ( NAME in NAME for NAME in NAME ) NAME ( f\" \u2705 State dictionary created: { NAME } \" ) NAME ( f\" \u2705 Required keys present: { NAME } ( { NAME ( NAME ) } keys) \" ) NAME ( f\" \u2705 State structure: { NAME ( NAME . NAME ( ) ) } \" ) NAME . NAME ( [ NAME , NAME ] ) assert NAME , LIT assert NAME , LIT except NAME as NAME : NAME ( f\" \u274c _initialize_gather_state: Exception { NAME } \" ) NAME . NAME ( [ False , False ] ) # Test _validate_start_page function NAME ( LIT ) NAME = [ ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( None , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ] for NAME , NAME , NAME in NAME : try : NAME = NAME ( NAME ) NAME = NAME == NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } : { NAME ! NAME } \u2192 { NAME } \" ) NAME . NAME ( NAME ) assert ( NAME ) , f\" Failed for { NAME } : expected { NAME } , got { NAME } \" except NAME as NAME : NAME ( f\" \u274c { NAME } : Exception { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } initialization tests passed \" ) # CORE FUNCTIONALITY TESTS def NAME ( ) -> None : LIT from NAME . NAME import NAME # patch unused in this test # Test _lookup_existing_persons function NAME = NAME ( ) NAME . NAME . NAME . NAME . NAME . NAME . NAME . NAME . NAME = ( [ ] ) NAME = NAME ( NAME , [ LIT ] ) assert NAME ( NAME , NAME ) , LIT # Test get_matches function availability assert NAME ( NAME ) , LIT # Test coord function availability assert NAME ( NAME ) , LIT # Test navigation function assert NAME ( NAME ) , LIT def NAME ( ) -> None : LIT # from unittest.mock import MagicMock  # Unused in this test # Test _identify_fetch_candidates with correct signature NAME = [ { LIT : LIT , LIT : LIT } ] NAME = { } NAME = NAME ( NAME , NAME ) assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME ) == LIT , LIT # Test _prepare_bulk_db_data function exists assert NAME ( NAME ) , LIT # Test _execute_bulk_db_operations function exists assert NAME ( NAME ) , LIT # EDGE CASE TESTS def NAME ( ) -> None : LIT # Test _validate_start_page with edge cases NAME = NAME ( LIT ) assert NAME == LIT , LIT NAME = NAME ( - LIT ) assert NAME == LIT , LIT NAME = NAME ( LIT ) assert NAME == LIT , LIT # Test _lookup_existing_persons with empty input from NAME . NAME import NAME NAME = NAME ( ) NAME . NAME . NAME . NAME . NAME . NAME . NAME . NAME . NAME = ( [ ] ) NAME = NAME ( NAME , [ ] ) assert NAME ( NAME , NAME ) , LIT assert ( NAME ( NAME ) == LIT ) , LIT # INTEGRATION TESTS def NAME ( ) -> None : LIT from NAME . NAME import NAME # Test that core functions can work with session manager interface NAME = NAME ( ) NAME . NAME . NAME = NAME ( ) NAME . NAME = LIT # Test nav_to_list function signature and callability import NAME NAME = NAME . NAME ( NAME ) NAME = NAME ( NAME . NAME . NAME ( ) ) assert ( LIT in NAME ) , LIT assert NAME ( NAME ) , LIT # Test _lookup_existing_persons works with database session interface NAME = NAME ( ) NAME . NAME . NAME . NAME . NAME . NAME . NAME . NAME . NAME = ( [ ] ) NAME = NAME ( NAME , [ LIT ] ) assert NAME ( NAME , NAME ) , LIT # Test coord function accepts proper parameters NAME = NAME . NAME ( NAME ) NAME = NAME ( NAME . NAME . NAME ( ) ) assert NAME ( NAME ) > LIT , LIT # PERFORMANCE TESTS def NAME ( ) -> None : LIT # Test _initialize_gather_state performance NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME = NAME ( ) assert NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 100 state initializations should be fast, took { NAME : .3f } s \" # Test _validate_start_page performance NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME = NAME ( f\" page_ { NAME } _12345 \" ) assert NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 1000 page validations should be fast, took { NAME : .3f } s \" # ERROR HANDLING TESTS def NAME ( ) -> None : LIT import NAME from NAME . NAME import NAME , NAME from NAME . NAME import NAME , NAME NAME ( LIT ) # Test 1: RetryableError constructor with conflicting parameters (Bug Fix Validation) NAME ( LIT ) try : # This specific pattern caused the \"got multiple values for keyword argument\" error NAME = NAME ( LIT , NAME = LIT , NAME = { LIT : LIT , LIT : LIT } ) assert NAME . NAME == LIT assert NAME . NAME == LIT assert LIT in NAME . NAME NAME ( LIT ) except NAME as NAME : if LIT in NAME ( NAME ) : raise NAME ( f\" CRITICAL: RetryableError constructor bug still exists: { NAME } \" ) from NAME raise # Test 2: DatabaseConnectionError constructor NAME ( LIT ) try : NAME = NAME ( LIT , NAME = LIT , NAME = { LIT : LIT } ) assert NAME . NAME == LIT assert NAME . NAME and LIT in NAME . NAME NAME ( LIT ) except NAME as NAME : raise NAME ( f\" DatabaseConnectionError constructor has parameter conflicts: { NAME } \" ) # Test 3: Simulate the specific database transaction rollback scenario NAME ( LIT ) try : # Simulate the exact sequence that caused rollbacks in Action 6 with NAME ( LIT ) : # mock_logger unused # This mimics the database.py db_transn function error handling try : # Simulate UNIQUE constraint failure during bulk insert raise NAME . NAME ( LIT ) except NAME . NAME as NAME : # This is the exact code path that failed in database.py NAME = NAME ( NAME ) . NAME NAME = { LIT : LIT , LIT : LIT , LIT : NAME , } # This specific call pattern was causing the constructor bug NAME = NAME ( f\" Transaction failed: { NAME } \" , NAME = NAME ) assert LIT in NAME . NAME assert NAME . NAME [ LIT ] == LIT NAME ( LIT ) except NAME as NAME : raise NAME ( f\" Database transaction rollback simulation failed: { NAME } \" ) from NAME # Test 4: Test all error class constructors to prevent future regressions NAME ( LIT ) from NAME . NAME import ( NAME , NAME , NAME , NAME , NAME , NAME , NAME , ) NAME = [ ( NAME , { LIT : LIT } ) , ( NAME , { } ) , ( NAME , { } ) , ( NAME , { } ) , ( NAME , { } ) , ( NAME , { } ) , ( NAME , { } ) , ] for NAME , NAME in NAME : try : NAME = NAME ( f\" Test { NAME . NAME } message \" , NAME = LIT , NAME = { LIT : True } , ** NAME ) assert NAME ( NAME , LIT ) NAME ( f\" \u2705 { NAME . NAME } constructor works correctly \" ) except NAME as NAME : if LIT in NAME ( NAME ) : raise NAME ( f\" CRITICAL: { NAME . NAME } has constructor parameter conflicts: { NAME } \" ) from NAME raise # Test 5: Legacy function error handling NAME ( LIT ) # Test _lookup_existing_persons with database error NAME = NAME ( ) NAME . NAME . NAME = NAME ( LIT ) try : NAME = NAME ( NAME , [ LIT ] ) # Should handle error gracefully assert NAME ( NAME , NAME ) , LIT except NAME as NAME : assert LIT in NAME ( NAME ) , LIT # Test _validate_start_page error handling NAME = NAME ( None ) assert NAME == LIT , LIT NAME = NAME ( LIT ) assert NAME == LIT , LIT NAME ( LIT ) # Test 6: CRITICAL - Timeout and Retry Handling Tests (Action 6 Main Issue) NAME ( LIT ) # Test timeout configuration is appropriate for Action 6's runtime NAME ( LIT ) # Action 6 typically takes 12+ minutes, timeout should be at least 15 minutes (900s) NAME = LIT # 15 minutes NAME ( f\" \u2705 coord function should have timeout >= { NAME } s for 12+ min runtime \" ) # Test 7: Duplicate record handling during retries NAME ( LIT ) try : # Simulate the exact UNIQUE constraint scenario from logs import NAME NAME = LIT # From actual log # Simulate the specific IntegrityError pattern NAME = NAME . NAME ( LIT ) # Test that we can create proper error without constructor conflicts NAME = NAME ( f\" Bulk DB operation FAILED: { NAME } \" , NAME = { LIT : NAME , LIT : LIT , LIT : LIT } , NAME = LIT ) assert LIT in NAME . NAME assert NAME . NAME [ LIT ] == NAME NAME ( LIT ) except NAME as NAME : raise NAME ( f\" Duplicate record error handling failed: { NAME } \" ) # Test 8: Final Summary Accuracy Test NAME ( LIT ) # This would test that final summaries reflect actual DB state, not retry failures # For now, this is a design validation NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] # Test 1: Verify correct bulk insert condition (has records -> should insert) NAME = [ { LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT } ] # CORRECT logic (after our fix) NAME = NAME ( NAME ) # True when has records # WRONG logic (the bug we fixed) NAME = not NAME ( NAME ) # False when has records if NAME and not NAME : NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) # Test 2: Verify empty list correctly skips bulk insert NAME = [ ] NAME = not NAME ( NAME ) # True - should NOT bulk insert NAME = NAME ( NAME ) # False - correct, no bulk insert if NAME and not NAME : NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) # Test 3: Verify actual code structure contains correct condition try : import NAME NAME = NAME . NAME ( NAME ) # Look for the correct pattern: \"if person_creates_filtered:\" NAME = LIT in NAME if NAME : NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) except NAME as NAME : NAME ( f\" \u26a0\ufe0f  Could not inspect source code: { NAME } \" ) NAME . NAME ( False ) # Test 4: Verify THREAD_POOL_WORKERS optimization if NAME >= LIT : NAME ( f\" \u2705 Thread pool optimized: { NAME } workers (\u226516) \" ) NAME . NAME ( True ) else : NAME ( f\" \u274c Thread pool not optimized: { NAME } workers (<16) \" ) NAME . NAME ( False ) NAME = NAME ( NAME ) if NAME : NAME ( LIT ) return NAME def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : from NAME import NAME # Test MAX_PAGES configuration NAME = NAME ( NAME ( NAME , LIT , None ) , LIT , None ) if NAME is not None : if NAME ( NAME , NAME ) and NAME >= LIT : NAME ( f\" \u2705 MAX_PAGES configuration valid: { NAME } \" ) NAME . NAME ( True ) else : NAME ( f\" \u274c MAX_PAGES configuration invalid: { NAME } \" ) NAME . NAME ( False ) else : NAME ( LIT ) NAME . NAME ( False ) # Test that THREAD_POOL_WORKERS configuration is accessible if NAME > LIT : NAME ( f\" \u2705 THREAD_POOL_WORKERS accessible: { NAME } \" ) NAME . NAME ( True ) else : NAME ( f\" \u274c THREAD_POOL_WORKERS invalid: { NAME } \" ) NAME . NAME ( False ) except NAME as NAME : NAME ( f\" \u274c Configuration access failed: { NAME } \" ) NAME . NAME ( False ) NAME = NAME ( NAME ) if NAME : NAME ( LIT ) return NAME def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] NAME = [ ( LIT , LIT ) , # 10 pages -> minimum threshold of 10 ( LIT , LIT ) , # 100 pages -> 100/20 = 5, but minimum is 10 ( LIT , LIT ) , # 200 pages -> 200/20 = 10 ( LIT , LIT ) , # 400 pages -> 400/20 = 20 ( LIT , LIT ) , # 795 pages -> 795/20 = 39 (our actual use case) ( LIT , LIT ) , # 2000 pages -> 2000/20 = 100 (maximum) ( LIT , LIT ) , # 5000 pages -> 5000/20 = 250, but capped at 100 ] for NAME , NAME in NAME : NAME = NAME ( NAME ) NAME = LIT if NAME == NAME else LIT NAME ( f\" { NAME } { NAME } pages -> { NAME } threshold (expected { NAME } ) \" ) NAME . NAME ( NAME == NAME ) NAME ( f\" Current default threshold: { NAME } \" ) NAME = NAME ( NAME ) if NAME : NAME ( LIT ) return NAME def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : # Test SessionManager import and basic attributes from NAME . NAME import NAME # Test that SessionManager can be imported without errors NAME ( LIT ) NAME . NAME ( True ) # Test that basic SessionManager attributes exist NAME = [ LIT , LIT ] NAME = NAME ( ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME ( f\" \u2705 SessionManager has { NAME } (optimization implemented) \" ) NAME . NAME ( True ) else : NAME ( f\" \u26a0\ufe0f  SessionManager missing { NAME } \" ) NAME . NAME ( False ) except NAME as NAME : NAME ( f\" \u274c SessionManager test failed: { NAME } \" ) NAME . NAME ( False ) NAME = NAME ( NAME ) if NAME : NAME ( LIT ) return NAME # Run all tests with suppress_logging with NAME ( ) : # INITIALIZATION TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # NEW: Progress bar integration correctness (would catch 0 processed bug) def NAME ( ) -> None : LIT from NAME . NAME import NAME with NAME ( NAME = LIT , NAME = LIT , NAME = LIT , NAME = False , NAME = False , NAME = False , ) as NAME : NAME = NAME . NAME assert NAME is not None , LIT # Attach the same wrapper used in production loop def NAME ( NAME : NAME = LIT ) : try : NAME . NAME ( NAME ( NAME ) ) except NAME : NAME . NAME ( LIT ) NAME . NAME = NAME # type: ignore[attr-defined] # Simulate work NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) # After context exit, stats should show 10 processed assert NAME . NAME . NAME == LIT , ( f\" Expected 10 processed, got { NAME . NAME . NAME } \" ) return True NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # \ud83d\udee1\ufe0f REGRESSION PREVENTION TESTS - These would have caught the issues we encountered NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # 303 REDIRECT DETECTION TESTS - This would have caught the authentication issue def NAME ( ) -> None : LIT try : from NAME . NAME import NAME , NAME NAME ( LIT ) # Test 1: Verify CSRF token extraction works NAME ( LIT ) with NAME ( LIT ) : # mock_sm_class unused NAME = NAME ( ) NAME . NAME = NAME ( ) # Test CSRF token found NAME . NAME . NAME . NAME = [ { LIT : LIT , LIT : LIT } ] from NAME import NAME NAME = NAME ( NAME ) assert NAME == LIT , LIT # Test no CSRF token found NAME . NAME . NAME . NAME = [ ] NAME = NAME ( NAME ) assert NAME is None , LIT # Test 2: Verify session refresh navigation (simplified) NAME ( LIT ) # Create a simple mock without complex patching NAME = NAME ( ) NAME . NAME = NAME ( ) NAME . NAME = NAME ( ) NAME . NAME . NAME = NAME ( ) NAME . NAME . NAME . NAME = LIT NAME . NAME = NAME ( ) NAME . NAME . NAME = LIT # Test the logic without actual navigation NAME = NAME . NAME . NAME . NAME NAME = NAME . NAME . NAME # Verify our session refresh function would detect matches page NAME = LIT in NAME assert NAME , LIT # Verify base URL construction assert NAME . NAME ( LIT ) , LIT assert LIT in NAME , LIT # Test 3: Verify 303 response handling logic NAME ( LIT ) # Create mock 303 response NAME = NAME ( ) NAME . NAME = LIT NAME . NAME = { } # No Location header, simulating the actual issue NAME . NAME = LIT # This simulates the condition that was failing in Action 6 NAME = LIT in NAME . NAME assert not NAME , LIT NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) return True except NAME as NAME : NAME ( f\" \u2717 303 Redirect Detection Test failed: { NAME } \" ) import NAME NAME ( f\" Details: { NAME . NAME ( ) } \" ) return False NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # CORE FUNCTIONALITY TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # EDGE CASE TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # INTEGRATION TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # PERFORMANCE TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # ERROR HANDLING TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "test_module_initialization",
      "lineno": 5826,
      "end_lineno": 5881,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 56,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "0810f185d1c7b053b8bd683ca36db2a012e27a3c",
      "simhash64": 7434277566014723131,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] # Test _initialize_gather_state function NAME ( LIT ) try : NAME = NAME ( ) NAME = NAME ( NAME , NAME ) NAME = [ LIT , LIT , LIT ] NAME = NAME ( NAME in NAME for NAME in NAME ) NAME ( f\" \u2705 State dictionary created: { NAME } \" ) NAME ( f\" \u2705 Required keys present: { NAME } ( { NAME ( NAME ) } keys) \" ) NAME ( f\" \u2705 State structure: { NAME ( NAME . NAME ( ) ) } \" ) NAME . NAME ( [ NAME , NAME ] ) assert NAME , LIT assert NAME , LIT except NAME as NAME : NAME ( f\" \u274c _initialize_gather_state: Exception { NAME } \" ) NAME . NAME ( [ False , False ] ) # Test _validate_start_page function NAME ( LIT ) NAME = [ ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( None , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ] for NAME , NAME , NAME in NAME : try : NAME = NAME ( NAME ) NAME = NAME == NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } : { NAME ! NAME } \u2192 { NAME } \" ) NAME . NAME ( NAME ) assert ( NAME ) , f\" Failed for { NAME } : expected { NAME } , got { NAME } \" except NAME as NAME : NAME ( f\" \u274c { NAME } : Exception { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } initialization tests passed \" )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "test_core_functionality",
      "lineno": 5884,
      "end_lineno": 5904,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "de5d291ae534f172970ed28b01599d73c2044db3",
      "simhash64": 7434171977463936035,
      "normalized": "def NAME ( ) -> None : LIT from NAME . NAME import NAME # patch unused in this test # Test _lookup_existing_persons function NAME = NAME ( ) NAME . NAME . NAME . NAME . NAME . NAME . NAME . NAME . NAME = ( [ ] ) NAME = NAME ( NAME , [ LIT ] ) assert NAME ( NAME , NAME ) , LIT # Test get_matches function availability assert NAME ( NAME ) , LIT # Test coord function availability assert NAME ( NAME ) , LIT # Test navigation function assert NAME ( NAME ) , LIT"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "test_data_processing_functions",
      "lineno": 5906,
      "end_lineno": 5926,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "a0960f9f37affe91eaec9c04b51dc33908581240",
      "simhash64": 5146484105323386411,
      "normalized": "def NAME ( ) -> None : LIT # from unittest.mock import MagicMock  # Unused in this test # Test _identify_fetch_candidates with correct signature NAME = [ { LIT : LIT , LIT : LIT } ] NAME = { } NAME = NAME ( NAME , NAME ) assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME ) == LIT , LIT # Test _prepare_bulk_db_data function exists assert NAME ( NAME ) , LIT # Test _execute_bulk_db_operations function exists assert NAME ( NAME ) , LIT"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "test_edge_cases",
      "lineno": 5929,
      "end_lineno": 5953,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 25,
      "tags": [
        "impure",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d8ea01973b6a3fed0f85be575a0dd1f68ca09303",
      "simhash64": 7452151225961067539,
      "normalized": "def NAME ( ) -> None : LIT # Test _validate_start_page with edge cases NAME = NAME ( LIT ) assert NAME == LIT , LIT NAME = NAME ( - LIT ) assert NAME == LIT , LIT NAME = NAME ( LIT ) assert NAME == LIT , LIT # Test _lookup_existing_persons with empty input from NAME . NAME import NAME NAME = NAME ( ) NAME . NAME . NAME . NAME . NAME . NAME . NAME . NAME . NAME = ( [ ] ) NAME = NAME ( NAME , [ ] ) assert NAME ( NAME , NAME ) , LIT assert ( NAME ( NAME ) == LIT ) , LIT # INTEGRATION TESTS"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "test_integration",
      "lineno": 5955,
      "end_lineno": 5986,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 32,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "f76ced09a3db6ae97e9a51dd98650e8c677cc29f",
      "simhash64": 7488215211647087635,
      "normalized": "def NAME ( ) -> None : LIT from NAME . NAME import NAME # Test that core functions can work with session manager interface NAME = NAME ( ) NAME . NAME . NAME = NAME ( ) NAME . NAME = LIT # Test nav_to_list function signature and callability import NAME NAME = NAME . NAME ( NAME ) NAME = NAME ( NAME . NAME . NAME ( ) ) assert ( LIT in NAME ) , LIT assert NAME ( NAME ) , LIT # Test _lookup_existing_persons works with database session interface NAME = NAME ( ) NAME . NAME . NAME . NAME . NAME . NAME . NAME . NAME . NAME = ( [ ] ) NAME = NAME ( NAME , [ LIT ] ) assert NAME ( NAME , NAME ) , LIT # Test coord function accepts proper parameters NAME = NAME . NAME ( NAME ) NAME = NAME ( NAME . NAME . NAME ( ) ) assert NAME ( NAME ) > LIT , LIT"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "test_performance",
      "lineno": 5989,
      "end_lineno": 6012,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 24,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b22d568116a0e0ad22a4c62f0b70f0d5f620a4e8",
      "simhash64": 8641277416162890811,
      "normalized": "def NAME ( ) -> None : LIT # Test _initialize_gather_state performance NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME = NAME ( ) assert NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 100 state initializations should be fast, took { NAME : .3f } s \" # Test _validate_start_page performance NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME = NAME ( f\" page_ { NAME } _12345 \" ) assert NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 1000 page validations should be fast, took { NAME : .3f } s \""
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "test_error_handling",
      "lineno": 6015,
      "end_lineno": 6197,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 13,
      "loc": 183,
      "tags": [
        "impure",
        "db",
        "logging",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "e09507ed63847d3d8b8f60e24ba42d8dbac7c993",
      "simhash64": 7452291964523156539,
      "normalized": "def NAME ( ) -> None : LIT import NAME from NAME . NAME import NAME , NAME from NAME . NAME import NAME , NAME NAME ( LIT ) # Test 1: RetryableError constructor with conflicting parameters (Bug Fix Validation) NAME ( LIT ) try : # This specific pattern caused the \"got multiple values for keyword argument\" error NAME = NAME ( LIT , NAME = LIT , NAME = { LIT : LIT , LIT : LIT } ) assert NAME . NAME == LIT assert NAME . NAME == LIT assert LIT in NAME . NAME NAME ( LIT ) except NAME as NAME : if LIT in NAME ( NAME ) : raise NAME ( f\" CRITICAL: RetryableError constructor bug still exists: { NAME } \" ) from NAME raise # Test 2: DatabaseConnectionError constructor NAME ( LIT ) try : NAME = NAME ( LIT , NAME = LIT , NAME = { LIT : LIT } ) assert NAME . NAME == LIT assert NAME . NAME and LIT in NAME . NAME NAME ( LIT ) except NAME as NAME : raise NAME ( f\" DatabaseConnectionError constructor has parameter conflicts: { NAME } \" ) # Test 3: Simulate the specific database transaction rollback scenario NAME ( LIT ) try : # Simulate the exact sequence that caused rollbacks in Action 6 with NAME ( LIT ) : # mock_logger unused # This mimics the database.py db_transn function error handling try : # Simulate UNIQUE constraint failure during bulk insert raise NAME . NAME ( LIT ) except NAME . NAME as NAME : # This is the exact code path that failed in database.py NAME = NAME ( NAME ) . NAME NAME = { LIT : LIT , LIT : LIT , LIT : NAME , } # This specific call pattern was causing the constructor bug NAME = NAME ( f\" Transaction failed: { NAME } \" , NAME = NAME ) assert LIT in NAME . NAME assert NAME . NAME [ LIT ] == LIT NAME ( LIT ) except NAME as NAME : raise NAME ( f\" Database transaction rollback simulation failed: { NAME } \" ) from NAME # Test 4: Test all error class constructors to prevent future regressions NAME ( LIT ) from NAME . NAME import ( NAME , NAME , NAME , NAME , NAME , NAME , NAME , ) NAME = [ ( NAME , { LIT : LIT } ) , ( NAME , { } ) , ( NAME , { } ) , ( NAME , { } ) , ( NAME , { } ) , ( NAME , { } ) , ( NAME , { } ) , ] for NAME , NAME in NAME : try : NAME = NAME ( f\" Test { NAME . NAME } message \" , NAME = LIT , NAME = { LIT : True } , ** NAME ) assert NAME ( NAME , LIT ) NAME ( f\" \u2705 { NAME . NAME } constructor works correctly \" ) except NAME as NAME : if LIT in NAME ( NAME ) : raise NAME ( f\" CRITICAL: { NAME . NAME } has constructor parameter conflicts: { NAME } \" ) from NAME raise # Test 5: Legacy function error handling NAME ( LIT ) # Test _lookup_existing_persons with database error NAME = NAME ( ) NAME . NAME . NAME = NAME ( LIT ) try : NAME = NAME ( NAME , [ LIT ] ) # Should handle error gracefully assert NAME ( NAME , NAME ) , LIT except NAME as NAME : assert LIT in NAME ( NAME ) , LIT # Test _validate_start_page error handling NAME = NAME ( None ) assert NAME == LIT , LIT NAME = NAME ( LIT ) assert NAME == LIT , LIT NAME ( LIT ) # Test 6: CRITICAL - Timeout and Retry Handling Tests (Action 6 Main Issue) NAME ( LIT ) # Test timeout configuration is appropriate for Action 6's runtime NAME ( LIT ) # Action 6 typically takes 12+ minutes, timeout should be at least 15 minutes (900s) NAME = LIT # 15 minutes NAME ( f\" \u2705 coord function should have timeout >= { NAME } s for 12+ min runtime \" ) # Test 7: Duplicate record handling during retries NAME ( LIT ) try : # Simulate the exact UNIQUE constraint scenario from logs import NAME NAME = LIT # From actual log # Simulate the specific IntegrityError pattern NAME = NAME . NAME ( LIT ) # Test that we can create proper error without constructor conflicts NAME = NAME ( f\" Bulk DB operation FAILED: { NAME } \" , NAME = { LIT : NAME , LIT : LIT , LIT : LIT } , NAME = LIT ) assert LIT in NAME . NAME assert NAME . NAME [ LIT ] == NAME NAME ( LIT ) except NAME as NAME : raise NAME ( f\" Duplicate record error handling failed: { NAME } \" ) # Test 8: Final Summary Accuracy Test NAME ( LIT ) # This would test that final summaries reflect actual DB state, not retry failures # For now, this is a design validation NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "test_regression_prevention_database_bulk_insert",
      "lineno": 6199,
      "end_lineno": 6273,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 75,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "8c7eab54305b972f9307e4502bd1249b34ba7a23",
      "simhash64": 8641136677666329635,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] # Test 1: Verify correct bulk insert condition (has records -> should insert) NAME = [ { LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT } ] # CORRECT logic (after our fix) NAME = NAME ( NAME ) # True when has records # WRONG logic (the bug we fixed) NAME = not NAME ( NAME ) # False when has records if NAME and not NAME : NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) # Test 2: Verify empty list correctly skips bulk insert NAME = [ ] NAME = not NAME ( NAME ) # True - should NOT bulk insert NAME = NAME ( NAME ) # False - correct, no bulk insert if NAME and not NAME : NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) # Test 3: Verify actual code structure contains correct condition try : import NAME NAME = NAME . NAME ( NAME ) # Look for the correct pattern: \"if person_creates_filtered:\" NAME = LIT in NAME if NAME : NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) except NAME as NAME : NAME ( f\" \u26a0\ufe0f  Could not inspect source code: { NAME } \" ) NAME . NAME ( False ) # Test 4: Verify THREAD_POOL_WORKERS optimization if NAME >= LIT : NAME ( f\" \u2705 Thread pool optimized: { NAME } workers (\u226516) \" ) NAME . NAME ( True ) else : NAME ( f\" \u274c Thread pool not optimized: { NAME } workers (<16) \" ) NAME . NAME ( False ) NAME = NAME ( NAME ) if NAME : NAME ( LIT ) return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "test_regression_prevention_configuration_respect",
      "lineno": 6275,
      "end_lineno": 6317,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 43,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "c117314caeab309ac8727a054ba90fa57eda1812",
      "simhash64": 8641101527587918891,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : from NAME import NAME # Test MAX_PAGES configuration NAME = NAME ( NAME ( NAME , LIT , None ) , LIT , None ) if NAME is not None : if NAME ( NAME , NAME ) and NAME >= LIT : NAME ( f\" \u2705 MAX_PAGES configuration valid: { NAME } \" ) NAME . NAME ( True ) else : NAME ( f\" \u274c MAX_PAGES configuration invalid: { NAME } \" ) NAME . NAME ( False ) else : NAME ( LIT ) NAME . NAME ( False ) # Test that THREAD_POOL_WORKERS configuration is accessible if NAME > LIT : NAME ( f\" \u2705 THREAD_POOL_WORKERS accessible: { NAME } \" ) NAME . NAME ( True ) else : NAME ( f\" \u274c THREAD_POOL_WORKERS invalid: { NAME } \" ) NAME . NAME ( False ) except NAME as NAME : NAME ( f\" \u274c Configuration access failed: { NAME } \" ) NAME . NAME ( False ) NAME = NAME ( NAME ) if NAME : NAME ( LIT ) return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "test_dynamic_api_failure_threshold",
      "lineno": 6319,
      "end_lineno": 6350,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 32,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "05d89243baef070258f491311039b59dd50ab650",
      "simhash64": 5145885970997875771,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] NAME = [ ( LIT , LIT ) , # 10 pages -> minimum threshold of 10 ( LIT , LIT ) , # 100 pages -> 100/20 = 5, but minimum is 10 ( LIT , LIT ) , # 200 pages -> 200/20 = 10 ( LIT , LIT ) , # 400 pages -> 400/20 = 20 ( LIT , LIT ) , # 795 pages -> 795/20 = 39 (our actual use case) ( LIT , LIT ) , # 2000 pages -> 2000/20 = 100 (maximum) ( LIT , LIT ) , # 5000 pages -> 5000/20 = 250, but capped at 100 ] for NAME , NAME in NAME : NAME = NAME ( NAME ) NAME = LIT if NAME == NAME else LIT NAME ( f\" { NAME } { NAME } pages -> { NAME } threshold (expected { NAME } ) \" ) NAME . NAME ( NAME == NAME ) NAME ( f\" Current default threshold: { NAME } \" ) NAME = NAME ( NAME ) if NAME : NAME ( LIT ) return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "test_regression_prevention_session_management",
      "lineno": 6352,
      "end_lineno": 6389,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 38,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "278422e42da0370fff9d441b35fd06c872e6d34a",
      "simhash64": 7488215207353160803,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : # Test SessionManager import and basic attributes from NAME . NAME import NAME # Test that SessionManager can be imported without errors NAME ( LIT ) NAME . NAME ( True ) # Test that basic SessionManager attributes exist NAME = [ LIT , LIT ] NAME = NAME ( ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME ( f\" \u2705 SessionManager has { NAME } (optimization implemented) \" ) NAME . NAME ( True ) else : NAME ( f\" \u26a0\ufe0f  SessionManager missing { NAME } \" ) NAME . NAME ( False ) except NAME as NAME : NAME ( f\" \u274c SessionManager test failed: { NAME } \" ) NAME . NAME ( False ) NAME = NAME ( NAME ) if NAME : NAME ( LIT ) return NAME"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "test_progress_integration_counts",
      "lineno": 6403,
      "end_lineno": 6431,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 29,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "90a8d8c660a79a6731dfb4683f49e0560f043c32",
      "simhash64": 7452151225961059355,
      "normalized": "def NAME ( ) -> None : LIT from NAME . NAME import NAME with NAME ( NAME = LIT , NAME = LIT , NAME = LIT , NAME = False , NAME = False , NAME = False , ) as NAME : NAME = NAME . NAME assert NAME is not None , LIT # Attach the same wrapper used in production loop def NAME ( NAME : NAME = LIT ) : try : NAME . NAME ( NAME ( NAME ) ) except NAME : NAME . NAME ( LIT ) NAME . NAME = NAME # type: ignore[attr-defined] # Simulate work NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) # After context exit, stats should show 10 processed assert NAME . NAME . NAME == LIT , ( f\" Expected 10 processed, got { NAME . NAME . NAME } \" ) return True"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "_pb_update_wrapper",
      "lineno": 6417,
      "end_lineno": 6421,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(increment)",
      "fingerprint": "1787add21a2949bad5b600e89c34ae9ae92dec0b",
      "simhash64": 8640573728786650155,
      "normalized": "def NAME ( NAME : NAME = LIT ) : try : NAME . NAME ( NAME ( NAME ) ) except NAME : NAME . NAME ( LIT )"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "test_303_redirect_detection",
      "lineno": 6475,
      "end_lineno": 6550,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 76,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "4600d7df9629e5d5c06d2eac360c8d7a012fb4b8",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( ) -> None : LIT try : from NAME . NAME import NAME , NAME NAME ( LIT ) # Test 1: Verify CSRF token extraction works NAME ( LIT ) with NAME ( LIT ) : # mock_sm_class unused NAME = NAME ( ) NAME . NAME = NAME ( ) # Test CSRF token found NAME . NAME . NAME . NAME = [ { LIT : LIT , LIT : LIT } ] from NAME import NAME NAME = NAME ( NAME ) assert NAME == LIT , LIT # Test no CSRF token found NAME . NAME . NAME . NAME = [ ] NAME = NAME ( NAME ) assert NAME is None , LIT # Test 2: Verify session refresh navigation (simplified) NAME ( LIT ) # Create a simple mock without complex patching NAME = NAME ( ) NAME . NAME = NAME ( ) NAME . NAME = NAME ( ) NAME . NAME . NAME = NAME ( ) NAME . NAME . NAME . NAME = LIT NAME . NAME = NAME ( ) NAME . NAME . NAME = LIT # Test the logic without actual navigation NAME = NAME . NAME . NAME . NAME NAME = NAME . NAME . NAME # Verify our session refresh function would detect matches page NAME = LIT in NAME assert NAME , LIT # Verify base URL construction assert NAME . NAME ( LIT ) , LIT assert LIT in NAME , LIT # Test 3: Verify 303 response handling logic NAME ( LIT ) # Create mock 303 response NAME = NAME ( ) NAME . NAME = LIT NAME . NAME = { } # No Location header, simulating the actual issue NAME . NAME = LIT # This simulates the condition that was failing in Action 6 NAME = LIT in NAME . NAME assert not NAME , LIT NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) return True except NAME as NAME : NAME ( f\" \u2717 303 Redirect Detection Test failed: { NAME } \" ) import NAME NAME ( f\" Details: { NAME . NAME ( ) } \" ) return False"
    },
    {
      "module_path": "action6_gather.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 6616,
      "end_lineno": 6618,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "_handle_direction_enum",
      "lineno": 99,
      "end_lineno": 111,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(value, default)",
      "fingerprint": "35ed95770fd0491d5aefbfe6965b9c1b1807deb2",
      "simhash64": 7488215207353160763,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT if NAME ( NAME , NAME ) : return NAME if NAME ( NAME , NAME ) : try : return NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid direction string ' { NAME } ' \" ) return NAME else : NAME . NAME ( f\" Unexpected direction type: { NAME ( NAME ) } \" ) return NAME"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "_handle_status_enum",
      "lineno": 114,
      "end_lineno": 126,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(value, default)",
      "fingerprint": "a94d9bdf0c1bc6ddcadfda1502133db55e96fadc",
      "simhash64": 8641136711960007707,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT if NAME ( NAME , NAME ) : return NAME if NAME ( NAME , NAME ) : try : return NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid status string ' { NAME } ' \" ) return NAME else : NAME . NAME ( f\" Unexpected status type: { NAME ( NAME ) } \" ) return NAME"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "_convert_to_primitive",
      "lineno": 129,
      "end_lineno": 139,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 11,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(value)",
      "fingerprint": "9712410c823216321bd4a7232044ed9729ca122f",
      "simhash64": 7487757810516526123,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if NAME ( NAME , ( NAME , NAME , NAME ) ) : return NAME ( NAME ) if NAME ( NAME , NAME ) : return NAME ( NAME ) if NAME ( NAME , NAME ) : return NAME ( NAME ) if NAME ( NAME , LIT ) : # datetime-like return NAME return NAME ( NAME )"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "safe_column_value",
      "lineno": 142,
      "end_lineno": 174,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 6,
      "loc": 33,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(obj, attr_name, default)",
      "fingerprint": "906eab02e1bb858162a472b1ccbf24521399bc5e",
      "simhash64": 7488320760469951507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME = None ) -> NAME : LIT if not NAME ( NAME , NAME ) : return NAME NAME = NAME ( NAME , NAME ) if NAME is None : return NAME # Try to convert to Python primitive try : # Special handling for enums if NAME == LIT : return NAME ( NAME , NAME ) if NAME == LIT : return NAME ( NAME , NAME ) # For different types of attributes return NAME ( NAME ) except ( NAME , NAME , NAME ) : return NAME"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor.__init__",
      "lineno": 186,
      "end_lineno": 240,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 55,
      "tags": [
        "impure",
        "purpose:initialization",
        "size:medium"
      ],
      "signature": "(self, session_manager)",
      "fingerprint": "3913092b8d73e682692c111f56500d4778e926f1",
      "simhash64": 7451729014636844075,
      "normalized": "def NAME ( NAME , NAME : NAME ) : LIT # Step 1: Store SessionManager and Rate Limiter NAME . NAME = NAME NAME . NAME = ( NAME . NAME ) # Use manager's limiter # Step 2: Load Configuration Settings NAME . NAME = NAME ( NAME , LIT , LIT ) # Max conversations to process (0=unlimited) # Determine batch size, ensuring it doesn't exceed the overall limit if one is set NAME = NAME ( NAME ( NAME , LIT , LIT ) , LIT ) # Default batch size, capped at 50 NAME . NAME = ( NAME ( NAME , NAME . NAME ) if NAME . NAME > LIT else NAME ) # AI Context settings NAME . NAME = NAME ( NAME , LIT , LIT ) NAME . NAME = NAME ( NAME , LIT , LIT ) # Correct assignment NAME . NAME = NAME ( NAME , LIT , LIT ) # Add input validation if NAME . NAME <= LIT : NAME . NAME ( f\" AI context message count ( { NAME . NAME } ) invalid, using default of 10 \" ) NAME . NAME = LIT if NAME . NAME <= LIT : NAME . NAME ( f\" AI context max words ( { NAME . NAME } ) invalid, using default of 100 \" ) NAME . NAME = LIT # Add statistics tracking NAME . NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : None , LIT : None , }"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._get_all_conversations_api",
      "lineno": 250,
      "end_lineno": 343,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 11,
      "loc": 94,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self, session_manager, limit, cursor)",
      "fingerprint": "cc393c734fc44bd61d3cd347ab5b14e5d5d20c00",
      "simhash64": 7488180022981080083,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None ) -> NAME [ NAME [ NAME [ NAME [ NAME , NAME ] ] ] , NAME [ NAME ] ] : LIT # Step 1: Validate prerequisites if not NAME or not NAME . NAME : NAME . NAME ( LIT ) return None , None if not NAME . NAME ( ) : NAME . NAME ( LIT ) # Raise exception so retry_api can potentially handle session restart if configured raise NAME ( LIT ) # Step 2: Construct API URL with limit and optional cursor NAME = NAME . NAME NAME = NAME ( NAME ( NAME . NAME , LIT , LIT ) , LIT ) # Note: API uses 'limit', not 'batch_size' parameter name NAME = f\" { NAME } conversations?q=user: { NAME } &limit= { NAME } \" if NAME : NAME += f\" &cursor= { NAME } \" # Fetching conversation batch (removed verbose debug) # Step 3: Make API call using _api_req helper try : NAME = NAME ( NAME = NAME , NAME = NAME . NAME , # Pass driver for context/headers NAME = NAME , NAME = LIT , NAME = False , # Typically not needed for GET overviews NAME = LIT , ) # Step 4: Process API response if NAME is None : # Indicates failure in _api_req after retries NAME . NAME ( LIT ) return None , None if not NAME ( NAME , NAME ) : NAME . NAME ( f\" _get_all_conversations_api: Unexpected API response format. Type= { NAME ( NAME ) } , Expected=dict \" ) return None , None # Step 5: Extract conversation data and pagination cursor NAME = NAME . NAME ( LIT , [ ] ) NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] if NAME ( NAME , NAME ) : for NAME in NAME : # Extract and process info for each conversation NAME = NAME . NAME ( NAME , NAME ) if NAME : NAME . NAME ( NAME ) else : NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT ) # API call returned conversations (removed verbose debug) # Step 6: Return processed data and cursor return NAME , NAME # Step 7: Handle exceptions (WebDriverException caught by retry_api, others logged) except NAME as NAME : # Re-raise WebDriverException for retry_api to handle potentially NAME . NAME ( f\" WebDriverException during _get_all_conversations_api: { NAME } \" ) raise except NAME as NAME : NAME . NAME ( f\" Unexpected error in _get_all_conversations_api: { NAME } \" , NAME = True ) return None , None # Return None on unexpected errors"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._extract_conversation_info",
      "lineno": 347,
      "end_lineno": 447,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 16,
      "loc": 101,
      "tags": [
        "impure",
        "time",
        "size:large"
      ],
      "signature": "(self, conv_data, my_profile_id)",
      "fingerprint": "6e0b141a1b2a7b3ab64c21a6964eab88d2b82e53",
      "simhash64": 7488180022981071899,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT # Step 1: Enhanced validation of input structure if not NAME ( NAME , NAME ) : NAME . NAME ( f\" Invalid conversation data type: { NAME ( NAME ) } \" ) return None NAME = NAME ( NAME . NAME ( LIT , LIT ) ) . NAME ( ) # Ensure string and strip whitespace NAME = NAME . NAME ( LIT , { } ) if not NAME or not NAME ( NAME , NAME ) : NAME . NAME ( f\" Skipping conversation data due to missing ID or last_message: ID=' { NAME } ', last_message type= { NAME ( NAME ) } \" ) return None # Step 2: Enhanced timestamp validation and parsing NAME = NAME . NAME ( LIT ) NAME : NAME [ NAME ] = None if NAME ( NAME , ( NAME , NAME ) ) : try : # More restrictive timestamp validation (2000-2100) NAME , NAME = LIT , LIT # Jan 1 2000 to Jan 1 2100 if NAME <= NAME <= NAME : NAME = NAME . NAME ( NAME , NAME = NAME . NAME ) else : NAME . NAME ( f\" Timestamp { NAME } out of reasonable range for ConvID { NAME } \" ) except ( NAME , NAME , NAME ) as NAME : NAME . NAME ( f\" Error converting timestamp { NAME } for ConvID { NAME } : { NAME } \" ) elif NAME is not None : # Log if present but wrong type NAME . NAME ( f\" Invalid timestamp type for ConvID { NAME } : { NAME ( NAME ) } \" ) # Step 3: Enhanced member identification with better error handling NAME = LIT NAME = LIT NAME = False NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME ( NAME ) . NAME ( ) . NAME ( ) if not NAME ( NAME , NAME ) : NAME . NAME ( f\" Members not a list for ConvID { NAME } : { NAME ( NAME ) } \" ) return None # Return None for invalid member data if NAME ( NAME ) < LIT : NAME . NAME ( f\" Insufficient members ( { NAME ( NAME ) } ) for ConvID { NAME } \" ) return None # Return None for insufficient members for NAME in NAME : if not NAME ( NAME , NAME ) : continue NAME = NAME . NAME ( LIT ) if not NAME : continue NAME = NAME ( NAME ) . NAME ( ) . NAME ( ) # Check if this member is not the script user if NAME and NAME != NAME : NAME = NAME ( NAME ) . NAME ( ) . NAME ( ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) . NAME ( ) NAME = True break if not NAME : NAME . NAME ( f\" Could not identify other participant in ConvID { NAME } . Members count: { NAME ( NAME ) if NAME ( NAME , NAME ) else LIT } \" ) return None # Return None if we can't identify the other participant # Step 4: Return validated data return { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , }"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._fetch_conversation_context",
      "lineno": 453,
      "end_lineno": 593,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 16,
      "loc": 141,
      "tags": [
        "pure-ish",
        "time",
        "size:large"
      ],
      "signature": "(self, conversation_id)",
      "fingerprint": "00387a29b91fd7bef5f7989ef811e3d244a2eb08",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME [ NAME [ NAME , NAME ] ] ] : LIT # Step 1: Validate inputs and session state if not NAME : NAME . NAME ( LIT ) return None if not NAME . NAME or not NAME . NAME . NAME : NAME . NAME ( LIT ) return None if not NAME . NAME . NAME ( ) : NAME . NAME ( f\" _fetch_conversation_context: Session invalid fetching context for ConvID { NAME } . \" ) raise NAME ( f\" Session invalid fetching context ConvID { NAME } \" ) # Step 2: Construct API URL and Headers NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] NAME = NAME ( NAME ( NAME . NAME , LIT , LIT ) , LIT ) NAME = NAME . NAME # Get limit from config NAME = LIT # Prepare headers (using contextual headers where possible) NAME = NAME ( NAME . NAME , LIT , { } ) . NAME ( NAME , { } ) if NAME ( NAME , NAME ) : NAME = NAME . NAME ( ) else : NAME = { } NAME . NAME ( f\" Expected dict for contextual headers, got { NAME ( NAME ) } \" ) # Ensure ancestry-userid is set correctly if LIT in NAME : NAME [ LIT ] = NAME . NAME . NAME . NAME ( ) # Remove any keys with None values to ensure type Dict[str, str] NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None } # Construct URL NAME = f\" { NAME } conversations/ { NAME } /messages?limit= { NAME } \" # Fetching context for conversation (removed verbose debug) # Step 3: Make API call and apply rate limiting wait first try : # Apply rate limit wait *before* the call NAME = NAME ( NAME , NAME ( NAME , LIT , None ) ) NAME . NAME ( ) if NAME is not None else LIT # Optional: log wait time if significant # if wait_time > 0.1: logger.debug(f\"Rate limit wait for context fetch: {wait_time:.2f}s\") NAME = NAME ( NAME = NAME , NAME = NAME . NAME . NAME , NAME = NAME . NAME , NAME = LIT , NAME = NAME , NAME = False , # Not typically needed NAME = NAME , ) # Step 4: Process the response if not NAME ( NAME , NAME ) : NAME . NAME ( f\" { NAME } : Bad response type { NAME ( NAME ) } for ConvID { NAME } . \" ) return None # Failed fetch NAME = NAME . NAME ( LIT , [ ] ) if not NAME ( NAME , NAME ) : NAME . NAME ( f\" { NAME } : 'messages' key not a list for ConvID { NAME } . \" ) return None # Invalid structure # Step 5: Extract and format message details for NAME in NAME : if not NAME ( NAME , NAME ) : continue # Skip invalid entries NAME = NAME . NAME ( LIT ) NAME : NAME [ NAME ] = None if NAME ( NAME , ( NAME , NAME ) ) : try : NAME = NAME . NAME ( NAME , NAME = NAME . NAME ) # Convert to aware datetime except NAME as NAME : NAME . NAME ( f\" Error parsing timestamp { NAME } in ConvID { NAME } : { NAME } \" ) # Prepare standardized message dictionary NAME = { LIT : NAME ( NAME . NAME ( LIT , LIT ) ) , # Ensure string LIT : NAME ( NAME . NAME ( LIT , LIT ) ) . NAME ( ) , # Store author ID lowercase LIT : NAME , # Store aware datetime or None LIT : NAME , # Add conversation ID for context } NAME . NAME ( NAME ) # Step 6: Sort messages by timestamp (oldest first) for correct context order return NAME ( NAME , # Provide default datetime for sorting if timestamp is None NAME = lambda NAME : NAME . NAME ( LIT ) or NAME . NAME . NAME ( NAME = NAME . NAME ) , ) # Step 7: Handle exceptions except NAME as NAME : NAME . NAME ( f\" WebDriverException fetching context for ConvID { NAME } : { NAME } \" ) raise # Re-raise for retry_api except NAME as NAME : NAME . NAME ( f\" Unexpected error fetching context for ConvID { NAME } : { NAME } \" , NAME = True , ) return None # Return None on unexpected errors"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._format_context_for_ai",
      "lineno": 597,
      "end_lineno": 632,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 36,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "(self, context_messages, my_pid_lower)",
      "fingerprint": "3100e9b44a375ce414d538e023fcd260204afb0a",
      "simhash64": 7452080857283998739,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME ) -> NAME : LIT # Step 1: Initialize list for formatted lines NAME = [ ] # Step 1a: Limit to a sliding window of most recent messages for classification context NAME = NAME ( NAME , LIT , LIT ) NAME = NAME [ - NAME : ] if NAME ( NAME , NAME ) else [ ] # Step 2: Iterate through messages (assumed sorted oldest to newest) for NAME in NAME : # Step 2a: Determine label (SCRIPT or USER) NAME = NAME . NAME ( LIT , LIT ) NAME = LIT if NAME == NAME else LIT # Step 2b: Get and truncate message content NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( ) if NAME ( NAME ) > NAME . NAME : # Truncate by word count and add ellipsis NAME = LIT . NAME ( NAME [ : NAME . NAME ] ) + LIT else : NAME = NAME # Step 2c: Append formatted line NAME . NAME ( f\" { NAME } { NAME } \" ) # Step 3: Join lines into a single string return LIT . NAME ( NAME )"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._lookup_or_create_person",
      "lineno": 636,
      "end_lineno": 809,
      "is_method": true,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 16,
      "loc": 174,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "purpose:factory",
        "size:large"
      ],
      "signature": "(self, session, profile_id, username, conversation_id, existing_person_arg)",
      "fingerprint": "e1c03bc485f4a0e66df010c9e38a88a23486fc5e",
      "simhash64": 7452151225962107931,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME [ NAME ] , NAME [ LIT , LIT , LIT , LIT ] ] : LIT # Step 1: Basic validation if not NAME or NAME == LIT : NAME . NAME ( LIT ) return None , LIT NAME = NAME or LIT # Ensure username is not None NAME = f\" ProfileID= { NAME } /User=' { NAME } ' (ConvID: { NAME or LIT } ) \" NAME : NAME [ NAME ] = None NAME : NAME [ LIT , LIT , LIT , LIT ] = ( LIT # Default status ) # Step 2: Determine if lookup is needed or use prefetched person if NAME : NAME = NAME # Using prefetched Person (removed verbose debug) else : # If not prefetched, query DB by profile ID try : # Prefetched person not found - querying DB (removed verbose debug) # Robust lookup: match by normalized profile_id (uppercase) NAME = ( NAME . NAME ( NAME ) . NAME ( NAME . NAME ( NAME . NAME ) == NAME . NAME ( ) , NAME . NAME . NAME ( None ) , ) . NAME ( ) ) except NAME as NAME : NAME . NAME ( f\" DB error looking up Person { NAME } : { NAME } \" , NAME = True ) return None , LIT # DB error during lookup # Step 3: Process based on whether person was found if NAME : # --- Person Exists: Check for Updates --- NAME = False # Update username only if current is 'Unknown' or different (use formatted name) NAME = NAME ( NAME ) NAME = NAME ( NAME , LIT , LIT ) if NAME == LIT or NAME != NAME : NAME . NAME ( f\" Updating username for { NAME } from ' { NAME } ' to ' { NAME } '. \" ) NAME . NAME = NAME NAME = True # Update message link if missing or different NAME = NAME ( NAME ( NAME . NAME , LIT , LIT ) , f\" /messaging/?p= { NAME . NAME ( ) } \" , ) NAME = NAME ( NAME , LIT , None ) if NAME != NAME : NAME . NAME ( f\" Updating message link for { NAME } . \" ) NAME . NAME = NAME NAME = True # Optional: Add logic here to fetch details and update other fields if they are NULL if NAME : NAME . NAME = NAME . NAME ( NAME . NAME ) # Set update timestamp try : NAME . NAME ( NAME ) # Ensure updates are staged NAME . NAME ( ) # Apply update within the transaction NAME = LIT NAME . NAME ( f\" Successfully staged updates for Person { NAME } (ID: { NAME . NAME } ). \" ) except ( NAME , NAME ) as NAME : NAME . NAME ( f\" DB error flushing update for Person { NAME } : { NAME } \" ) NAME . NAME ( ) # Rollback on flush error return None , LIT else : NAME = LIT # No updates needed # logger.debug(f\"No updates needed for existing Person {log_ref} (ID: {person.id}).\") else : # --- Person Not Found: Create New --- NAME . NAME ( f\" Person { NAME } not found. Creating new record... \" ) # Skip fetching additional details via API (function no longer available) NAME = None # Prepare data for new Person object NAME = { LIT : NAME . NAME ( ) , LIT : NAME ( NAME ) , # Use formatted username LIT : NAME ( NAME ( NAME . NAME , LIT , LIT ) , f\" /messaging/?p= { NAME . NAME ( ) } \" , ) , LIT : NAME . NAME , # Default status # Initialize other fields to defaults or None LIT : None , LIT : True , LIT : None , LIT : None , LIT : None , LIT : None , LIT : None , LIT : False , LIT : None , # UUID might be added later by Action 6 } # Populate with fetched details if available if NAME : NAME . NAME ( f\" Populating new person { NAME } with fetched profile details. \" ) NAME [ LIT ] = NAME . NAME ( LIT ) NAME [ LIT ] = NAME ( NAME . NAME ( LIT , False ) ) # Default False if fetch fails NAME [ LIT ] = NAME . NAME ( LIT ) else : NAME . NAME ( f\" Could not fetch profile details for new person { NAME } . Using defaults. \" ) # Create and add the new Person try : NAME = NAME ( ** NAME ) NAME . NAME ( NAME ) NAME . NAME ( ) # Flush to get ID assigned immediately if NAME ( NAME , LIT ) is None : NAME . NAME ( f\" ID not assigned after flush for new person { NAME } ! Rolling back. \" ) NAME . NAME ( ) return None , LIT NAME = NAME # Assign the newly created person object NAME = LIT NAME . NAME ( f\" Created new Person ID { NAME . NAME } for { NAME } . \" ) except ( NAME , NAME ) as NAME : NAME . NAME ( f\" DB error creating Person { NAME } : { NAME } \" ) NAME . NAME ( ) # Rollback on creation error return None , LIT except NAME as NAME : NAME . NAME ( f\" Unexpected error creating Person { NAME } : { NAME } \" , NAME = True ) NAME . NAME ( ) return None , LIT # Step 4: Return the person object and status return NAME , NAME"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._create_comparator",
      "lineno": 813,
      "end_lineno": 877,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 65,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self, session)",
      "fingerprint": "2cfe271ba80d378f69d389b00841ec6429d78c52",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME : NAME [ NAME [ NAME , NAME ] ] = None # Creating comparator by finding latest ConversationLog entry (removed verbose debug) try : # Step 1: Query for the entry with the maximum timestamp # Order by descending timestamp, handle NULLs last, take the first result NAME = ( NAME . NAME ( NAME . NAME , NAME . NAME ) . NAME ( NAME . NAME . NAME ( ) . NAME ( ) ) . NAME ( ) ) # Step 2: Process the result if found if NAME : NAME = NAME . NAME NAME = NAME . NAME # Ensure the timestamp is timezone-aware UTC NAME : NAME [ NAME ] = None if NAME ( NAME , NAME ) : NAME = ( NAME . NAME ( NAME = NAME . NAME ) if NAME . NAME is None else NAME . NAME ( NAME . NAME ) ) # Step 3: Validate data and create comparator dictionary if NAME and NAME : NAME = { LIT : NAME , LIT : NAME , } NAME . NAME ( f\" Comparator created: ConvID= { NAME [ LIT ] } , TS= { NAME [ LIT ] } \" ) else : NAME . NAME ( f\" Found latest log entry, but data invalid/missing timestamp: ConvID= { NAME } , Raw TS= { NAME } \" ) else : # Step 4: Log if table is empty NAME . NAME ( LIT ) # Step 5: Handle errors during query except NAME as NAME : NAME . NAME ( f\" Error creating comparator from database: { NAME } \" , NAME = True ) return None # Return None on error # Step 6: Return the comparator info dictionary or None return NAME"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._initialize_search_stats",
      "lineno": 889,
      "end_lineno": 897,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "time",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "d74270e238cae292e45395494433aa79bd2ba37e",
      "simhash64": 8605072730635023447,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME [ LIT ] = NAME . NAME ( NAME . NAME ) # Clear any prior cancellation signals at the start of a new run try : from NAME . NAME import NAME NAME ( ) except NAME : pass"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._validate_session_state",
      "lineno": 899,
      "end_lineno": 904,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "54aa689ae185377e89cf24243454eb653322c7ac",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT if not NAME . NAME or not NAME . NAME . NAME : NAME . NAME ( LIT ) return None return NAME . NAME . NAME . NAME ( )"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._setup_progress_tracking",
      "lineno": 906,
      "end_lineno": 922,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "e2508a048585afa19f90d929ba4b2c7e5e216a48",
      "simhash64": 7451729014636844587,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : None , # Start with unknown total LIT : LIT , LIT : LIT , LIT : True , LIT : True , LIT : LIT , LIT : NAME . NAME , } NAME . NAME ( f\" Processing inbox items (limit: { NAME . NAME if NAME . NAME > LIT else LIT } )... \" ) return NAME"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor.search_inbox",
      "lineno": 924,
      "end_lineno": 940,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "8f7eaf4de01128ce6b3b3968b6826abb47c9860d",
      "simhash64": 7488252045353714723,
      "normalized": "def NAME ( NAME ) -> NAME : LIT # Initialize statistics and state NAME . NAME ( ) # Counters and state for this run # Validate session manager state NAME = NAME . NAME ( ) if not NAME : return False return None"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._get_database_session_and_comparator",
      "lineno": 942,
      "end_lineno": 957,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "7c3d87b367e895caf1842dae3e36cb17080439ec",
      "simhash64": 7488109654302962707,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME [ NAME ] , NAME [ NAME ] , NAME [ NAME ] ] : LIT NAME = NAME . NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) return None , None , None # Get the comparator (latest message in DB) NAME = NAME . NAME ( NAME ) NAME : NAME [ NAME ] = None NAME : NAME [ NAME ] = None # Comparator timestamp (aware) if NAME : NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) return NAME , NAME , NAME"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._run_inbox_processing_loop",
      "lineno": 959,
      "end_lineno": 1093,
      "is_method": true,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 12,
      "loc": 135,
      "tags": [
        "pure-ish",
        "time",
        "size:large"
      ],
      "signature": "(self, session, comp_conv_id, comp_ts, my_pid_lower)",
      "fingerprint": "58094f57e154c6cc198d452f3fcda27142bcab07",
      "simhash64": 7452080857216889875,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME ] , NAME : NAME ) -> NAME [ NAME [ NAME ] , NAME , NAME , NAME , NAME ] : LIT NAME = NAME . NAME ( ) # PHASE 1 OPTIMIZATION: Enhanced progress tracking for inbox processing NAME = NAME . NAME if NAME . NAME > LIT else LIT with NAME ( NAME = LIT , NAME = NAME if NAME > LIT else None , NAME = LIT , NAME = True , NAME = True , NAME = False , NAME = False , ) as NAME : with NAME ( ) , NAME ( ** NAME ) as NAME : # Link enhanced progress to tqdm for updates (avoid pylance attr warnings) from NAME import NAME with NAME ( NAME ) : NAME . NAME = NAME NAME = NAME . NAME ( NAME , NAME , NAME , NAME , NAME ) # Ensure a newline after the progress bar completes to avoid inline log overlap try : NAME . NAME ( ) finally : NAME . NAME . NAME ( LIT ) NAME . NAME . NAME ( ) # Update the progress bar to show completion - only set total if needed if NAME . NAME is None : NAME . NAME = NAME ( NAME [ LIT ] , LIT ) # items_processed_before_stop NAME . NAME ( ) # Don't manually set progress_bar.n here since it's already updated in the loop NAME . NAME ( LIT ) NAME . NAME ( ) return NAME # Continue with the main search_inbox method # --- Step 2: Get DB Session and Comparator --- NAME : NAME [ NAME ] = None try : NAME , NAME , NAME = NAME . NAME ( ) if not NAME : return False # --- Step 3: Setup and Run Main Loop --- ( NAME , NAME , NAME , NAME , NAME , ) = NAME . NAME ( NAME , NAME , NAME , NAME ) # Check if loop stopped due to an error state NAME = True if NAME and LIT in NAME . NAME ( ) : NAME = False # --- Step 4: Handle Outer Exceptions (Action 6/8 Pattern) --- except NAME as NAME : NAME . NAME [ LIT ] += LIT NAME . NAME [ LIT ] = NAME . NAME ( NAME . NAME ) NAME . NAME ( f\" Halting Action 7 due to excessive critical API failures: { NAME } \" , NAME = False , ) NAME = False except NAME as NAME : NAME . NAME [ LIT ] += LIT NAME . NAME [ LIT ] = NAME . NAME ( NAME . NAME ) NAME . NAME ( f\" Browser session error in Action 7: { NAME } \" , NAME = True , ) NAME = False except NAME as NAME : NAME . NAME [ LIT ] += LIT NAME . NAME [ LIT ] = NAME . NAME ( NAME . NAME ) NAME . NAME ( f\" API rate limit exceeded in Action 7: { NAME } \" , NAME = False , ) NAME = False except NAME as NAME : NAME . NAME [ LIT ] += LIT NAME . NAME [ LIT ] = NAME . NAME ( NAME . NAME ) NAME . NAME ( f\" Authentication expired during Action 7: { NAME } \" , NAME = False , ) NAME = False except NAME as NAME : NAME . NAME [ LIT ] += LIT NAME . NAME [ LIT ] = NAME . NAME ( NAME . NAME ) NAME . NAME ( f\" CRITICAL error during search_inbox execution: { NAME } \" , NAME = True , ) NAME = False # --- Step 5: Final Logging and Cleanup --- finally : # Log summary of the run NAME = NAME or ( LIT if NAME else LIT ) # Use updated status_updated_count which now correctly tracks Person updates NAME . NAME ( NAME = NAME , NAME = NAME , NAME = LIT , # Can no longer accurately track upserts easily, set to 0 NAME = NAME , NAME = NAME , # This count is correct NAME = NAME , NAME = NAME . NAME , ) # Release the database session if NAME : NAME . NAME . NAME ( NAME ) # Step 6: Return overall success status return NAME"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor.get_statistics",
      "lineno": 1096,
      "end_lineno": 1103,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5b1200acd5c965e2aeee23e69a9cf1f9051dec9b",
      "simhash64": 5146308216814482435,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME . NAME ( ) if NAME [ LIT ] and NAME [ LIT ] : NAME [ LIT ] = ( NAME [ LIT ] - NAME [ LIT ] ) . NAME ( ) return NAME"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._initialize_loop_state",
      "lineno": 1105,
      "end_lineno": 1123,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 19,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "e88bc00f14ec82c9961ce79de0d600d73fd7bbf9",
      "simhash64": 5727968560667858479,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : None , LIT : None , LIT : LIT , LIT : [ ] , LIT : { } , LIT : False , LIT : NAME . NAME . NAME ( NAME = NAME . NAME ) , LIT : LIT , }"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._check_browser_health",
      "lineno": 1125,
      "end_lineno": 1133,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:tiny"
      ],
      "signature": "(self, current_batch_num)",
      "fingerprint": "9f2adb151174af72e9f4583fab0c69fb23c76a9b",
      "simhash64": 7434136827451577347,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT if NAME % LIT == LIT : # Check every 5 batches if not NAME . NAME . NAME ( ) : NAME . NAME ( f\" \ud83d\udea8 Browser health check failed at batch { NAME } \" ) if not NAME . NAME . NAME ( LIT ) : NAME . NAME ( f\" \u274c Browser recovery failed at batch { NAME } - halting inbox processing \" ) return LIT return None"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._validate_session",
      "lineno": 1135,
      "end_lineno": 1139,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "b5ae153b057cf56dddb4bcd4a22b7785fa396cb2",
      "simhash64": 8640573767441355819,
      "normalized": "def NAME ( NAME ) -> None : LIT if not NAME . NAME . NAME ( ) : NAME . NAME ( LIT ) raise NAME ( LIT )"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._calculate_api_limit",
      "lineno": 1141,
      "end_lineno": 1149,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, items_processed_before_stop)",
      "fingerprint": "6e62406ebea68b3ec1f976e3fccda7e10e38ee82",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME [ NAME ] ] : LIT NAME = NAME . NAME if NAME . NAME > LIT : NAME = NAME . NAME - NAME if NAME <= LIT : return LIT , f\" Inbox Limit ( { NAME . NAME } ) \" NAME = NAME ( NAME . NAME , NAME ) return NAME , None"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._process_inbox_loop",
      "lineno": 1151,
      "end_lineno": 1911,
      "is_method": true,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 8,
      "yield_count": 0,
      "complexity": 111,
      "loc": 761,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "regex",
        "size:large"
      ],
      "signature": "(self, session, comp_conv_id, comp_ts, my_pid_lower, progress_bar)",
      "fingerprint": "b236d2908c6b0c06b52b0e2f7379253c38617b5d",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME ] , # Aware datetime NAME : NAME , NAME : NAME [ NAME ] , # Accept progress bar instance ) -> NAME [ NAME [ NAME ] , NAME , NAME , NAME , NAME ] : LIT # Initialize loop state NAME = NAME . NAME ( ) # Extract variables from state for easier access NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME [ LIT ] # Step 2: Main loop - continues until stop condition met while not NAME : try : # Inner try for handling exceptions within a single batch iteration # Step 2a: Browser Health Monitoring (Action 6/8 Pattern) if NAME % LIT == LIT : # Check every 5 batches if not NAME . NAME . NAME ( ) : NAME . NAME ( f\" \ud83d\udea8 Browser health check failed at batch { NAME } \" ) if not NAME . NAME . NAME ( LIT ) : NAME . NAME ( f\" \u274c Browser recovery failed at batch { NAME } - halting inbox processing \" ) NAME = LIT NAME = True break # Step 2b: Check session validity before each API call if not NAME . NAME . NAME ( ) : NAME . NAME ( LIT ) raise NAME ( LIT ) # Step 2c: Calculate API Limit for this batch, considering overall limit NAME = NAME . NAME if NAME . NAME > LIT : NAME = ( NAME . NAME - NAME ) if NAME <= LIT : # Stop *before* fetching if limit already reached NAME = f\" Inbox Limit ( { NAME . NAME } ) \" NAME = True break NAME = NAME ( NAME . NAME , NAME ) # Step 2d: Fetch a batch of conversations from API NAME , NAME = ( NAME . NAME ( NAME . NAME , NAME = NAME , NAME = NAME ) ) # Step 2e: Handle API failure if NAME is None : NAME . NAME ( LIT ) NAME = LIT NAME = True break # Step 2f: Process fetched batch NAME = NAME ( NAME ) NAME += NAME NAME += LIT # Processing batch (removed verbose debug) # Log progress every 5 batches or when significant progress is made if NAME % LIT == LIT or NAME >= LIT : NAME . NAME ( f\" Action 7 Progress: Batch { NAME } \" f\" (Processed= { NAME } , AI= { NAME } , \" f\" StatusUpdates= { NAME } , Errors= { NAME } ) \" ) # Handle empty batch result if NAME == LIT : if ( not NAME ) : # No items AND no next cursor = end of inbox NAME = LIT NAME = True break # Empty batch BUT cursor exists (API might sometimes do this) NAME . NAME ( LIT ) NAME = NAME continue # Fetch next batch # Update progress bar total if this is the first batch or if we're not limited if NAME is not None and NAME . NAME is None : if NAME . NAME > LIT : # Use the configured limit as the total NAME . NAME = NAME . NAME else : # For unlimited processing, estimate based on first batch NAME . NAME = NAME * LIT # Rough estimate NAME . NAME ( ) # Step 2f: Pre-fetch existing Person and ConversationLog data for the batch NAME = [ NAME [ LIT ] for NAME in NAME if NAME . NAME ( LIT ) ] NAME = { NAME . NAME ( LIT , LIT ) . NAME ( ) for NAME in NAME if NAME . NAME ( LIT ) and NAME . NAME ( LIT ) != LIT } NAME : NAME [ NAME , NAME ] = { } NAME : NAME [ NAME [ NAME , NAME ] , NAME ] = ( { } ) # Key: (conv_id, direction_enum.name) try : if NAME : # Normalize both sides to uppercase for robust matching NAME = ( NAME . NAME ( NAME ) . NAME ( NAME . NAME ( NAME . NAME ) . NAME ( [ NAME . NAME ( ) for NAME in NAME ] ) , NAME . NAME . NAME ( None ) , ) . NAME ( ) ) NAME = { NAME ( NAME , LIT ) . NAME ( ) : NAME for NAME in NAME if NAME ( NAME , LIT ) } if NAME : NAME = ( NAME . NAME ( NAME ) . NAME ( NAME . NAME . NAME ( NAME ) ) . NAME ( ) ) # Ensure timestamps are aware before putting in map for NAME in NAME : NAME = NAME ( NAME , LIT , None ) if NAME and NAME . NAME is None : NAME . NAME = NAME . NAME ( NAME = NAME . NAME ) NAME = { ( NAME ( NAME ( NAME , LIT ) ) , ( NAME ( NAME ( NAME , LIT ) . NAME ) if NAME ( NAME , LIT ) else LIT ) , ) : NAME for NAME in NAME if NAME ( NAME , LIT ) } except NAME as NAME : NAME . NAME ( f\" DB prefetch failed for Batch { NAME } : { NAME } \" ) # Decide whether to skip batch or abort run - Abort for now NAME = LIT NAME = True break # Step 2g: Process each conversation in the batch for NAME in NAME : # --- Check Max Inbox Limit --- if ( NAME . NAME > LIT and NAME >= NAME . NAME ) : if not NAME : NAME = f\" Inbox Limit ( { NAME . NAME } ) \" NAME = True break # Break inner conversation loop NAME += LIT # Extract key info NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) # Already aware from _extract if not NAME or NAME == LIT : NAME . NAME ( f\" Skipping item { NAME } : Invalid ConvID/ProfileID. \" ) # Update progress bar even for skipped items if NAME is not None : NAME . NAME ( LIT ) NAME . NAME ( LIT ) # PHASE 1 OPTIMIZATION: Enhanced progress tracking NAME = NAME ( NAME , LIT , None ) if NAME is not None : NAME . NAME ( NAME = LIT , NAME = LIT , # Invalid items are warnings NAME = LIT ) continue # --- Comparator Logic & Fetch Decision --- # For live test, always fetch all conversations NAME = True # Check if this is a live test (command line argument 'live') if NAME ( NAME . NAME ) > LIT and NAME . NAME [ LIT ] . NAME ( ) == LIT : # Skip the comparator logic for live test pass else : # Normal operation - use comparator logic NAME = False # Check 1: Is this the comparator conversation? if NAME and NAME == NAME : NAME = ( True # Found comparator, plan to stop after this item ) # Fetch only if API timestamp is newer than comparator timestamp if ( NAME and NAME and NAME > NAME ) : NAME = True else : # Comparator found, timestamp not newer or invalid -> stop and don't fetch if not NAME : NAME = LIT break # Stop processing immediately after comparator check passes # Check 2: Not comparator, compare API timestamp with DB timestamps else : NAME = NAME . NAME ( ( NAME , NAME . NAME . NAME ) ) NAME = NAME . NAME ( ( NAME , NAME . NAME . NAME ) ) # Get latest *overall* timestamp from DB for this conversation (ensure aware) NAME = ( NAME ( NAME , LIT ) if NAME and NAME ( NAME , LIT ) else NAME ) NAME = ( NAME ( NAME , LIT ) if NAME and NAME ( NAME , LIT ) else NAME ) NAME = NAME ( NAME , NAME ) # Fetch if API timestamp is newer OR if no DB logs exist at all if ( NAME and NAME > NAME ) : NAME = True elif ( not NAME and not NAME ) : # No record in DB yet NAME = True # --- End Comparator Logic --- # Skip if no fetch needed if not NAME : # logger.debug(f\"Skipping ConvID {api_conv_id}: No fetch needed (up-to-date).\") NAME += LIT # Update progress bar for skipped items if NAME is not None : NAME . NAME ( LIT ) NAME . NAME ( LIT ) # PHASE 1 OPTIMIZATION: Enhanced progress tracking NAME = NAME ( NAME , LIT , None ) if NAME is not None : NAME . NAME ( NAME = LIT , NAME = LIT , # Up-to-date items are cache hits NAME = LIT ) if NAME : break # Break inner loop if comparator was hit continue # Move to next conversation # --- Fetch Context & Process Message --- if ( not NAME . NAME . NAME ( ) ) : # Check session before fetch raise NAME ( f\" Session invalid before fetching context for ConvID { NAME } \" ) # Update progress bar before processing this case NAME += LIT if NAME is not None : NAME . NAME ( LIT ) NAME . NAME ( f\" Processing conversation { NAME } \" ) # PHASE 1 OPTIMIZATION: Enhanced progress tracking NAME = NAME ( NAME , LIT , None ) if NAME is not None : NAME . NAME ( NAME = LIT , NAME = LIT , # Conversation fetch + AI classification NAME = f\" Processing { NAME [ : LIT ] } \" ) NAME = NAME . NAME ( NAME ) if NAME is None : NAME += LIT NAME . NAME ( f\" Failed to fetch context for ConvID { NAME } . Skipping item. \" ) continue # Skip this conversation if context fetch fails # --- Lookup/Create Person --- NAME , NAME = NAME . NAME ( NAME , NAME , NAME . NAME ( LIT , LIT ) , NAME , NAME = NAME . NAME ( NAME ) , # Pass prefetched if available ) if not NAME or not NAME ( NAME , LIT ) : NAME += LIT NAME . NAME ( f\" Failed person lookup/create for ConvID { NAME } . Skipping item. \" ) continue # Cannot proceed without person record NAME = NAME ( NAME , LIT ) # --- Debug-only: log quality summary of any extracted genealogical data on the person --- try : if NAME ( NAME , LIT ) : NAME ( NAME , LIT , { } ) or { } # Quality summary (removed verbose debug) except NAME : # Skipped quality summary logging (removed verbose debug) pass # --- Process Fetched Context Messages --- NAME : NAME [ NAME ] = None NAME : NAME [ NAME ] = None # Find the latest IN and OUT message from the fetched context for NAME in NAME ( NAME ) : # Iterate newest first NAME = NAME . NAME ( LIT , LIT ) if NAME != NAME and NAME is None : NAME = NAME elif NAME == NAME and NAME is None : NAME = NAME if NAME and NAME : break # Stop when both found NAME : NAME [ NAME ] = None # --- Process IN Row --- if NAME : NAME = NAME . NAME ( LIT ) # Already aware # Compare context timestamp with DB timestamp *for IN direction* NAME = NAME . NAME ( ( NAME , NAME . NAME . NAME ) , None ) NAME = ( NAME ( NAME , LIT ) if NAME else NAME ) # Process only if context message is newer than DB record for IN if ( NAME and NAME > NAME ) : # Prepare context for AI NAME = NAME . NAME ( NAME , NAME ) # Call AI for classification if ( not NAME . NAME . NAME ( ) ) : # Check session before AI call raise NAME ( f\" Session invalid before AI classification call for ConvID { NAME } \" ) # PHASE 1 OPTIMIZATION: Enhanced error recovery for AI calls @ NAME ( NAME = LIT , NAME = LIT ) def NAME ( ) -> NAME [ NAME ] : return NAME ( NAME , NAME . NAME ) # Guardrail: if model returns PRODUCTIVE but last USER msg lacks actionable cues, downgrade def NAME ( NAME : NAME [ NAME ] ) -> NAME [ NAME ] : try : if ( not NAME ) or NAME != LIT : return NAME # Identify last USER message text from context_messages NAME = None for NAME in NAME ( NAME ) : if NAME . NAME ( LIT , LIT ) . NAME ( ) != NAME : NAME = NAME ( NAME . NAME ( LIT , LIT ) ) break if not NAME : return NAME NAME = NAME . NAME ( ) NAME = ( LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ) if not NAME ( NAME in NAME for NAME in NAME ) : return LIT if NAME ( NAME in NAME for NAME in ( LIT , LIT , LIT , LIT ) ) else LIT return NAME except NAME : return NAME NAME = NAME ( ) # Handle AI result - it should return just a string, not a tuple if NAME ( NAME , NAME ) : NAME = ( NAME [ LIT ] if NAME else None ) else : NAME = NAME # Apply guardrail downgrade if necessary NAME = NAME ( NAME ) if NAME : NAME += ( LIT # Count successful classifications ) else : NAME . NAME ( f\" AI classification failed for ConvID { NAME } . \" ) # Prepare data DICTIONARY for ConversationLog upsert (IN row) # Ensure required keys for commit_bulk_data are present NAME = { LIT : NAME , LIT : NAME . NAME , # Pass Enum here, commit func can handle LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) [ : NAME ( NAME , LIT , LIT ) ] , LIT : NAME , # Already aware UTC LIT : NAME , # Store AI result LIT : None , LIT : None , } # Add dict to list for batch commit NAME . NAME ( NAME ) # <-- Store dict # Stage Person status update based on AI classification if NAME == LIT : # AI classified as UNINTERESTED - staging status update (removed verbose debug) # Directly assign the Enum value to the person ID key NAME [ NAME ] = NAME . NAME elif NAME == LIT : # AI classified as PRODUCTIVE - keeping status ACTIVE (removed verbose debug) # Keep person as ACTIVE so Action 9 can process them # No status change needed pass # --- Process OUT Row --- if NAME : NAME = NAME . NAME ( LIT ) # Already aware # Compare context timestamp with DB timestamp *for OUT direction* NAME = NAME . NAME ( ( NAME , NAME . NAME . NAME ) , None ) NAME = ( NAME ( NAME , LIT ) if NAME else NAME ) # Process only if context message is newer than DB record for OUT if ( NAME and NAME > NAME ) : # Prepare data DICTIONARY for ConversationLog upsert (OUT row) NAME = { LIT : NAME , LIT : NAME . NAME , # Pass Enum LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) [ : NAME ( NAME , LIT , LIT ) ] , LIT : NAME , # Already aware UTC LIT : None , LIT : None , # Should be updated by Action 8 if script sent last LIT : None , # Should be updated by Action 8 } # Add dict to list for batch commit NAME . NAME ( NAME ) # <-- Store dict # --- End Context Processing --- # Update progress bar description with stats if NAME is not None : NAME . NAME ( f\" Processing: AI= { NAME } Updates= { NAME } Skip= { NAME } Err= { NAME } \" ) # Check stop flag again after processing item (if comparator was hit) if NAME : break # Break inner conversation loop # --- End Inner Loop (Processing conversations in batch) --- # --- Commit Batch Data --- if NAME or NAME : # Attempting batch commit (removed verbose debug) # --- CALL NEW FUNCTION --- NAME , NAME = NAME ( NAME = NAME , NAME = NAME , # Pass list of dicts NAME = NAME , NAME = f\" Action 7 Batch { NAME } \" , ) # --- Update counters --- NAME += ( NAME # Track person updates ) NAME += ( NAME # Track logs processed ) # --- Clear lists --- NAME . NAME ( ) NAME . NAME ( ) # Batch commit finished (removed verbose debug) # Step 2h: Check stop flag *after* potential commit if NAME : if not NAME : NAME = ( LIT # Set reason if not already set ) break # Break outer while loop # Step 2i: Prepare for next batch iteration NAME = NAME if not NAME : # End of inbox reached NAME = LIT NAME = True NAME . NAME ( LIT ) # Update progress bar total to current processed count for 100% completion if NAME is not None : NAME . NAME = NAME NAME . NAME ( ) break # Break outer while loop # Cooperative cancellation: if a timeout wrapper requested cancel, stop gracefully try : from NAME . NAME import NAME if NAME ( ) : NAME = NAME or LIT NAME = True NAME . NAME ( LIT ) break except NAME : pass # --- Step 3: Handle Exceptions During Batch Processing --- except NAME as NAME : NAME += LIT NAME . NAME ( f\" WebDriverException occurred during inbox loop (Batch { NAME } ): { NAME } \" ) NAME = LIT NAME = True # Stop processing # Attempt final save before exiting loop NAME . NAME ( LIT ) try : # --- CALL NEW FUNCTION --- NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , ) except NAME as NAME : # Check for session death cascade if LIT in NAME ( NAME ) : NAME . NAME ( f\" \ud83d\udea8 SESSION DEATH CASCADE in Action 7 WebDriverException save: { NAME } \" ) raise NAME ( LIT ) from None NAME . NAME ( f\" ConnectionError during Action 7 WebDriverException save: { NAME } \" ) NAME , NAME = LIT , LIT NAME += NAME NAME += NAME # Break loop after final save attempt break except NAME : NAME . NAME ( LIT ) NAME = LIT NAME = True # Stop processing # Attempt final save NAME . NAME ( LIT ) try : # --- CALL NEW FUNCTION --- NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , ) except NAME as NAME : # Check for session death cascade if LIT in NAME ( NAME ) : NAME . NAME ( f\" \ud83d\udea8 SESSION DEATH CASCADE in Action 7 KeyboardInterrupt save: { NAME } \" ) raise NAME ( LIT ) from None NAME . NAME ( f\" ConnectionError during Action 7 KeyboardInterrupt save: { NAME } \" ) NAME , NAME = LIT , LIT NAME += NAME NAME += NAME # Break loop after final save attempt break except NAME as NAME : NAME += LIT NAME . NAME ( f\" Critical error in inbox processing loop (Batch { NAME } ): { NAME } \" , NAME = True , ) NAME = f\" Critical Error ( { NAME ( NAME ) . NAME } ) \" NAME = True # Stop processing # Attempt final save NAME . NAME ( LIT ) try : # --- CALL NEW FUNCTION --- NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , ) except NAME as NAME : # Check for session death cascade if LIT in NAME ( NAME ) : NAME . NAME ( f\" \ud83d\udea8 SESSION DEATH CASCADE in Action 7 Critical Error save: { NAME } \" ) raise NAME ( LIT ) NAME . NAME ( f\" ConnectionError during Action 7 Critical Error save: { NAME } \" ) NAME , NAME = LIT , LIT NAME += NAME NAME += NAME # Return from helper to signal failure to outer function return ( NAME , NAME , NAME , NAME , NAME , ) # --- End Main Loop (while not stop_processing) --- # Update state dictionary with final values NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , } ) # Step 4: Perform final commit if loop finished normally or stopped early if ( not NAME or NAME in ( # Only commit if loop ended somewhat gracefully LIT , LIT , f\" Inbox Limit ( { NAME . NAME } ) \" , LIT , LIT , ) ) : if NAME or NAME : NAME . NAME ( LIT ) # --- CALL NEW FUNCTION --- NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , ) NAME += NAME NAME += NAME # Step 5: Return results from the loop execution (modified tuple) return ( NAME , NAME , NAME , NAME , NAME , )"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._classify_with_recovery",
      "lineno": 1566,
      "end_lineno": 1569,
      "is_method": true,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "4fc8dc55126aa8939c2518324c2bf45ab71f6c2d",
      "simhash64": 7488180022980027459,
      "normalized": "def NAME ( ) -> NAME [ NAME ] : return NAME ( NAME , NAME . NAME )"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._downgrade_if_non_actionable",
      "lineno": 1572,
      "end_lineno": 1594,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 10,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(label)",
      "fingerprint": "4d2efcd5efaffaeb3b9338b2a629d8ea036cef1c",
      "simhash64": 5181914802375005227,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME [ NAME ] : try : if ( not NAME ) or NAME != LIT : return NAME # Identify last USER message text from context_messages NAME = None for NAME in NAME ( NAME ) : if NAME . NAME ( LIT , LIT ) . NAME ( ) != NAME : NAME = NAME ( NAME . NAME ( LIT , LIT ) ) break if not NAME : return NAME NAME = NAME . NAME ( ) NAME = ( LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ) if not NAME ( NAME in NAME for NAME in NAME ) : return LIT if NAME ( NAME in NAME for NAME in ( LIT , LIT , LIT , LIT ) ) else LIT return NAME except NAME : return NAME"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor._log_unified_summary",
      "lineno": 1915,
      "end_lineno": 1962,
      "is_method": true,
      "is_async": false,
      "args_count": 8,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 48,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(self, total_api_items, items_processed, new_logs, ai_classified, status_updates, stop_reason, max_inbox_limit)",
      "fingerprint": "f1dc201589d93084c61a6ec53a725ac9340bdf66",
      "simhash64": 7452151225962107963,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , ) : LIT # Step 1: Print header (green summary block) NAME ( LIT ) NAME = LIT NAME = LIT def NAME ( NAME : NAME ) -> NAME : return f\" { NAME } { NAME } { NAME } \" NAME . NAME ( NAME ( LIT ) ) # Mark unused parameters to satisfy linter without changing signature NAME = NAME # Step 2: Log key metrics NAME . NAME ( NAME ( f\" API Conversations Fetched: { NAME } \" ) ) NAME . NAME ( NAME ( f\" Conversations Processed: { NAME } \" ) ) # logger.info(f\"  New/Updated Log Entries:    {new_logs}\") # Removed as upsert logic complicates exact counts NAME . NAME ( NAME ( f\" AI Classifications Attempted: { NAME } \" ) ) NAME . NAME ( NAME ( f\" Person Status Updates Made: { NAME } \" ) ) # Step 3: Log stopping reason NAME = NAME if not NAME : # Infer reason if not explicitly set if NAME == LIT or NAME < NAME : NAME = LIT else : NAME = f\" Inbox Limit ( { NAME } ) Reached \" NAME . NAME ( NAME ( f\" Processing Stopped Due To: { NAME } \" ) ) # Step 4: Print footer NAME . NAME ( NAME ( LIT ) ) # Update statistics NAME . NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME . NAME ( NAME . NAME ) , } )"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "InboxProcessor.g",
      "lineno": 1930,
      "end_lineno": 1931,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(msg)",
      "fingerprint": "20068d16362cc9790de4b480be9b420a00991e4f",
      "simhash64": 7452256780152116827,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : return f\" { NAME } { NAME } { NAME } \""
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "action7_inbox_module_tests",
      "lineno": 1969,
      "end_lineno": 2072,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 7,
      "loc": 104,
      "tags": [
        "pure-ish",
        "logging",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "cf2909e69d7f7d8b0739879532b1aeaf93874e79",
      "simhash64": 5146448955309462571,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME . NAME import NAME from NAME . NAME import NAME from NAME import NAME , NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) def NAME ( ) -> None : LIT # InboxProcessor exists assert LIT in NAME ( ) , LIT assert NAME ( NAME ) , LIT # search_inbox method exists and is callable on an instance NAME = NAME ( ) NAME = NAME ( NAME ) assert NAME ( NAME , LIT ) and NAME ( NAME . NAME ) # internal helpers exist assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT return True def NAME ( ) -> None : LIT try : NAME = NAME ( NAME , LIT , None ) if not NAME : return False NAME = NAME . NAME ( NAME ) return LIT in NAME . NAME except NAME : return False def NAME ( ) -> None : LIT with NAME ( NAME = LIT , NAME = LIT , NAME = LIT , NAME = False , NAME = False , NAME = False , ) as NAME : NAME = NAME . NAME assert NAME is not None , LIT NAME . NAME ( LIT ) return True def NAME ( ) -> None : LIT NAME = NAME ( ) NAME = NAME ( NAME ) with NAME ( NAME ( ) ) as NAME : NAME . NAME ( NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME = LIT . NAME ( NAME . NAME ) assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME return True with NAME ( ) : NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "test_class_and_methods_available",
      "lineno": 1979,
      "end_lineno": 1991,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2c92df5b7ba571802c04e1add96febbfe2f8c038",
      "simhash64": 7487757777228960803,
      "normalized": "def NAME ( ) -> None : LIT # InboxProcessor exists assert LIT in NAME ( ) , LIT assert NAME ( NAME ) , LIT # search_inbox method exists and is callable on an instance NAME = NAME ( ) NAME = NAME ( NAME ) assert NAME ( NAME , LIT ) and NAME ( NAME . NAME ) # internal helpers exist assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT return True"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "test_circuit_breaker_config",
      "lineno": 1993,
      "end_lineno": 2002,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 10,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "987cd0a5bc166b4ffa1d47b59b385acc255c0ad8",
      "simhash64": 7488320760535487499,
      "normalized": "def NAME ( ) -> None : LIT try : NAME = NAME ( NAME , LIT , None ) if not NAME : return False NAME = NAME . NAME ( NAME ) return LIT in NAME . NAME except NAME : return False"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "test_progress_indicator_smoke",
      "lineno": 2004,
      "end_lineno": 2017,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "082bd83863317f05bd35d76e63c6e3faf8b56966",
      "simhash64": 5146448955309462539,
      "normalized": "def NAME ( ) -> None : LIT with NAME ( NAME = LIT , NAME = LIT , NAME = LIT , NAME = False , NAME = False , NAME = False , ) as NAME : NAME = NAME . NAME assert NAME is not None , LIT NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "test_summary_logging_structure",
      "lineno": 2019,
      "end_lineno": 2040,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d436561890a830dc88d04b0447d5abc20adc2468",
      "simhash64": 7488320761542121019,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) NAME = NAME ( NAME ) with NAME ( NAME ( ) ) as NAME : NAME . NAME ( NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME = LIT . NAME ( NAME . NAME ) assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME return True"
    },
    {
      "module_path": "action7_inbox.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 2075,
      "end_lineno": 2077,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_handle_status_enum_conversion",
      "lineno": 64,
      "end_lineno": 81,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(value, default)",
      "fingerprint": "3cbe7687a0510d3e5da824bd2836dc41025cfa16",
      "simhash64": 7488215207353685043,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT # If it's already an enum instance, return it if NAME ( NAME , NAME ) : return NAME # If it's a string, try to convert to enum if NAME ( NAME , NAME ) : try : return NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid status string ' { NAME } ', cannot convert to enum \" ) return NAME # If it's something else, log and return default else : NAME . NAME ( f\" Unexpected status type: { NAME ( NAME ) } \" ) return NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_convert_value_to_primitive",
      "lineno": 84,
      "end_lineno": 94,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 8,
      "loc": 11,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(value)",
      "fingerprint": "a9dccb013e2c4381af6bc9f71fc960b586ca3f96",
      "simhash64": 7487652257398690859,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if NAME ( NAME , NAME ) or NAME is True or NAME is False : return NAME ( NAME ) if NAME ( NAME , NAME ) or NAME ( NAME ) . NAME ( ) : return NAME ( NAME ) if NAME ( NAME , NAME ) or NAME ( NAME ) . NAME ( LIT , LIT , LIT ) . NAME ( ) : return NAME ( NAME ) if NAME ( NAME , LIT ) : # datetime-like return NAME return NAME ( NAME )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "safe_column_value",
      "lineno": 97,
      "end_lineno": 126,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(obj, attr_name, default)",
      "fingerprint": "a4226a8cac46bf1d46b129f6da24c82282ad7872",
      "simhash64": 7488320726110213139,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME = None ) -> NAME : LIT if not NAME ( NAME , NAME ) : return NAME NAME = NAME ( NAME , NAME ) if NAME is None : return NAME # Try to convert to Python primitive try : # Special handling for status enum if NAME == LIT : return NAME ( NAME , NAME ) # For different types of attributes return NAME ( NAME ) except ( NAME , NAME , NAME ) : return NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "load_message_templates",
      "lineno": 215,
      "end_lineno": 269,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 9,
      "loc": 55,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "88c10762b563dedbde8f82d4fda743f8d7bcdb87",
      "simhash64": 7452080857216889875,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT try : from NAME . NAME import NAME NAME = NAME ( ) with NAME . NAME ( ) as NAME : if not NAME : NAME . NAME ( LIT ) return { } # Fetch all templates from database NAME = NAME . NAME ( NAME ) . NAME ( ) # Build dictionary with full message content (subject + body) NAME = { } for NAME in NAME : # Reconstruct full message content with subject line if NAME . NAME and NAME . NAME : NAME = f\" Subject: { NAME . NAME } \\n\\n { NAME . NAME } \" elif NAME . NAME : NAME = NAME . NAME else : NAME . NAME ( f\" Template { NAME . NAME } has no content \" ) continue NAME [ NAME . NAME ] = NAME # Validate that all required keys for Action 8 exist NAME = { LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT } NAME = NAME - NAME ( NAME . NAME ( ) ) if NAME : NAME . NAME ( f\" CRITICAL: Database is missing required template keys: { LIT . NAME ( NAME ) } \" ) return { } NAME . NAME ( f\" Loaded { NAME ( NAME ) } message templates from database \" ) return NAME except NAME as NAME : NAME . NAME ( f\" CRITICAL: Error loading templates from database: { NAME } \" , NAME = True ) return { }"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_audit_template_placeholders",
      "lineno": 297,
      "end_lineno": 353,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 9,
      "loc": 57,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(templates)",
      "fingerprint": "ea091612b5cbf7cf0c9ac20b991173e5872dd6c6",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> None : LIT try : NAME = NAME ( ) NAME = { LIT , LIT , LIT , LIT , LIT , } NAME = { # Keys created by MessagePersonalizer._create_enhanced_format_data LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , } NAME = NAME | NAME for NAME , NAME in NAME . NAME ( ) : # Only audit Enhanced_* aggressively; others will mostly use base_keys NAME = { NAME for ( NAME , NAME , NAME , NAME ) in NAME . NAME ( NAME ) if NAME } if NAME . NAME ( LIT ) : NAME = NAME ( NAME for NAME in NAME if NAME not in NAME ) if NAME : NAME . NAME ( f\" Template audit: Template ' { NAME } ' has unknown placeholders: { NAME } \" ) else : # For standard templates, just note uncommon placeholders NAME = NAME ( NAME for NAME in NAME if NAME not in NAME ) if NAME : NAME . NAME ( f\" Template audit: Template ' { NAME } ' uses non-base placeholders: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Template audit skipped due to error: { NAME } \" )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_log_personalization_sanity_for_template",
      "lineno": 378,
      "end_lineno": 454,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 13,
      "loc": 77,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(template_key, template_str, extracted_data, log_prefix)",
      "fingerprint": "7dd019373b0964c7c495d17d7d55f86da59fb974",
      "simhash64": 7487757777228960811,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME , ) -> None : LIT try : # Collect placeholders used by this template NAME = NAME ( ) NAME = { NAME for ( NAME , NAME , NAME , NAME ) in NAME . NAME ( NAME ) if NAME } # Map of placeholder -> function that checks if data likely exists def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME : NAME = NAME . NAME ( NAME ) return NAME ( NAME , NAME ) and NAME ( NAME ) > LIT def NAME ( NAME : NAME [ NAME ] ) -> NAME : return NAME ( NAME , NAME ) and NAME ( NAME . NAME ( ) ) NAME = { # Genealogical context fields LIT : lambda NAME : NAME ( NAME , LIT ) , LIT : lambda NAME : NAME ( NAME , LIT ) , LIT : lambda NAME : NAME ( NAME , LIT ) or NAME ( NAME , LIT ) , LIT : lambda NAME : NAME ( NAME , LIT ) , LIT : lambda NAME : NAME ( NAME , LIT ) or NAME ( NAME , LIT ) , LIT : lambda NAME : NAME ( NAME , LIT ) , LIT : lambda NAME : NAME ( NAME , LIT ) , LIT : lambda NAME : NAME ( NAME , LIT ) or NAME ( NAME , LIT ) , LIT : lambda NAME : NAME ( NAME , LIT ) , LIT : lambda NAME : NAME ( NAME , LIT ) , LIT : lambda NAME : NAME ( NAME , LIT ) or NAME ( NAME , LIT ) , # DNA-related LIT : lambda NAME : NAME ( NAME , LIT ) , LIT : lambda NAME : NAME ( NAME , LIT ) , # Often defaulted; considered neutral LIT : lambda NAME : True , LIT : lambda NAME : True , LIT : lambda NAME : True , LIT : lambda NAME : True , LIT : lambda NAME : NAME ( NAME , LIT ) or NAME ( NAME , LIT ) , LIT : lambda NAME : NAME ( NAME , LIT ) , LIT : lambda NAME : NAME ( NAME , LIT ) , LIT : lambda NAME : True , LIT : lambda NAME : True , # Standard/base placeholders are handled elsewhere; ignore here LIT : lambda NAME : True , LIT : lambda NAME : True , LIT : lambda NAME : True , LIT : lambda NAME : True , LIT : lambda NAME : True , } NAME = [ NAME for NAME in NAME if NAME in NAME ] if not NAME : NAME . NAME ( f\" Personalization sanity for { NAME } : Template ' { NAME } ' has no scorable fields. \" ) return NAME = NAME ( LIT for NAME in NAME if NAME [ NAME ] ( NAME ) ) NAME = NAME ( NAME ) NAME = ( NAME / NAME ) * LIT if NAME else LIT NAME . NAME ( f\" Personalization sanity for { NAME } : Template ' { NAME } ' \u2014 coverage { NAME } / { NAME } ( { NAME : .0f } %). Fields: { NAME ( NAME ) } \" ) except NAME as NAME : NAME . NAME ( f\" Skipped personalization sanity check for { NAME } (template ' { NAME } '): { NAME } \" )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "has_list",
      "lineno": 397,
      "end_lineno": 399,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(d, key)",
      "fingerprint": "6d23c88ad03e95f4998d0c4b8d4c5b12f973dbac",
      "simhash64": 7488109654235849731,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME : NAME = NAME . NAME ( NAME ) return NAME ( NAME , NAME ) and NAME ( NAME ) > LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "nonempty_str",
      "lineno": 401,
      "end_lineno": 402,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(s)",
      "fingerprint": "15a032517f9a2c78de45d9c4ff4c4e51df27d174",
      "simhash64": 7488180022980027427,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME : return NAME ( NAME , NAME ) and NAME ( NAME . NAME ( ) )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "determine_next_message_type",
      "lineno": 511,
      "end_lineno": 585,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 75,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(last_message_details, is_in_family_tree)",
      "fingerprint": "458be768123392d48ec2b515c20a26d782681af3",
      "simhash64": 7452256779145483291,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME , NAME ] ] , # (type_name, sent_at_utc, status) NAME : NAME , ) -> NAME [ NAME ] : LIT # Step 1: Determine next message type (removed verbose debug logging) # Step 2: Extract the last message type (or None if no previous message) NAME = None if NAME : NAME , NAME , NAME = NAME # Last message details (removed verbose debug logging) # Step 3: Look up the next message type in the transition table NAME = ( NAME , NAME ) NAME = None NAME = LIT if NAME in NAME : # Standard transition found in table NAME = NAME [ NAME ] if NAME : NAME = f\" Standard transition from ' { NAME or LIT } ' with in_tree= { NAME } \" else : NAME = f\" End of sequence for ' { NAME } ' with in_tree= { NAME } \" # Handle unexpected previous message type elif NAME : NAME = LIT if NAME else LIT NAME = f\" Unexpected previous { NAME } type: ' { NAME } ' \" NAME . NAME ( f\" Decision: Skip ( { NAME } ) \" ) # CRITICAL FIX: Instead of skipping, treat unknown types as if no previous message # This allows the system to recover from corrupted/unknown message types NAME . NAME ( f\" Recovery: Treating unknown type ' { NAME } ' as initial message \" ) NAME = ( LIT if NAME else LIT ) NAME = f\" Recovery from unknown type ' { NAME } ' - treating as initial \" else : # Fallback for initial message if somehow not in transition table NAME = ( LIT if NAME else LIT ) NAME = LIT # Step 4: Convert next_type string to actual message type from MESSAGE_TYPES_ACTION8 if NAME : NAME = NAME . NAME ( NAME , NAME ) # Decision: Send message (removed verbose debug logging) else : # Decision: Skip message (removed verbose debug logging) pass return NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "get_safe_relationship_text",
      "lineno": 594,
      "end_lineno": 613,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 20,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(family_tree, predicted_rel)",
      "fingerprint": "0f208600a891ec4ff560694cd63f6014e39e8311",
      "simhash64": 7487617074100343843,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT if NAME : NAME = NAME ( NAME , LIT , None ) if NAME and NAME != LIT and NAME . NAME ( ) : return f\" my { NAME } \" if NAME and NAME != LIT and NAME . NAME ( ) : return f\" possibly my { NAME } \" return LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "get_safe_relationship_path",
      "lineno": 616,
      "end_lineno": 643,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 8,
      "loc": 28,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(family_tree)",
      "fingerprint": "d76d76f461ec2bf78d560f118e3786d540504f89",
      "simhash64": 7487792995961836587,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if NAME : NAME = NAME ( NAME , LIT , None ) if NAME and NAME != LIT and NAME . NAME ( ) : # Fix broken \"Enhanced API:\" paths if NAME . NAME ( LIT ) : # Extract the relationship type and format it properly NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) NAME = NAME ( NAME , LIT , None ) NAME = NAME ( NAME , LIT , None ) if NAME and NAME : return f\" Wayne Gault -> { NAME } ( { NAME } ) \" if NAME : return f\" Wayne Gault -> { NAME } ( { NAME } ) \" return f\" Wayne Gault -> [Person] ( { NAME } ) \" return NAME return LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_is_distant_relationship",
      "lineno": 646,
      "end_lineno": 649,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(actual_rel)",
      "fingerprint": "36f2dda154f626e2aca1e7804a520c5b43d92b3b",
      "simhash64": 7487757811588699179,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT NAME = [ LIT , LIT , LIT , LIT , LIT ] return NAME ( NAME in NAME . NAME ( ) for NAME in NAME )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_calculate_family_tree_confidence",
      "lineno": 652,
      "end_lineno": 665,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(family_tree, is_distant_relationship)",
      "fingerprint": "1b9e6807b08b2d16cc1ddc6a73d918b2f7c5d72b",
      "simhash64": 7488180024053761059,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT NAME = LIT if NAME : NAME = NAME ( NAME , LIT , None ) if NAME and NAME != LIT and NAME . NAME ( ) and not NAME : NAME += LIT NAME = NAME ( NAME , LIT , None ) if NAME and NAME != LIT and NAME . NAME ( ) and not NAME : NAME += LIT return NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_calculate_dna_match_confidence",
      "lineno": 668,
      "end_lineno": 674,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(dna_match, is_distant_relationship)",
      "fingerprint": "1b5fa2a4e71385b4e1445b9061669a863b4e2e1a",
      "simhash64": 7487757811588699171,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT if NAME and not NAME : NAME = NAME ( NAME , LIT , None ) if NAME and NAME != LIT and NAME . NAME ( ) : return LIT return LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_get_template_for_distant_relationship",
      "lineno": 677,
      "end_lineno": 688,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(base_template_key)",
      "fingerprint": "802ce2868e135f9cc96b50fe186b49057290eedf",
      "simhash64": 7488109652088362579,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT NAME = f\" { NAME } _Exploratory \" if NAME in NAME : return NAME # Fallback to short variant for distant relationships NAME = f\" { NAME } _Short \" if NAME in NAME : return NAME return NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_get_template_by_confidence_score",
      "lineno": 691,
      "end_lineno": 710,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 20,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(base_template_key, confidence_score)",
      "fingerprint": "ee92601cb59a0a4a2b2b435eba9145f96f6630e3",
      "simhash64": 7488285576096289907,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT if NAME >= LIT : # High confidence - use confident variant if available NAME = f\" { NAME } _Confident \" if NAME in NAME : return NAME elif NAME <= LIT : # Low confidence - use exploratory variant if available NAME = f\" { NAME } _Exploratory \" if NAME in NAME : return NAME # Check for short variant (A/B testing) NAME = f\" { NAME } _Short \" if NAME in NAME : return NAME # Fallback to standard template return NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "select_template_by_confidence",
      "lineno": 713,
      "end_lineno": 737,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 25,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(base_template_key, family_tree, dna_match)",
      "fingerprint": "2beec71988353fb731a5b7799f3fd142ecbdf92c",
      "simhash64": 7488180022981067827,
      "normalized": "def NAME ( NAME : NAME , NAME , NAME ) -> NAME : LIT # Check for distant relationships first NAME = False if NAME : NAME = NAME ( NAME , LIT , None ) if NAME and NAME != LIT and NAME . NAME ( ) : NAME = NAME ( NAME ) if NAME : NAME . NAME ( f\" Detected distant relationship: { NAME } - forcing exploratory template \" ) # CRITICAL FIX: Force distant relationships to use exploratory templates if NAME : return NAME ( NAME ) # Calculate confidence score NAME = NAME ( NAME , NAME ) NAME += NAME ( NAME , NAME ) # Select template based on confidence return NAME ( NAME , NAME )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "select_template_variant_ab_testing",
      "lineno": 740,
      "end_lineno": 761,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(person_id, base_template_key)",
      "fingerprint": "6b46f3548e4266e63fe0f0ea07692b7d12431347",
      "simhash64": 7452291963441026675,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT # Use person ID for consistent assignment (50/50 split) NAME = NAME % LIT == LIT if NAME : NAME = f\" { NAME } _Short \" if NAME in NAME : # A/B Testing: Selected short variant (removed verbose debug) return NAME # Use confidence-based selection as fallback return NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "track_template_selection",
      "lineno": 764,
      "end_lineno": 777,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "(template_key, person_id, selection_reason)",
      "fingerprint": "878cd7e9f9eb77d332f3dc9a2775977e8e85f8dd",
      "simhash64": 7488285577171080767,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) : LIT # CONSOLIDATED APPROACH: Only log for debugging, no separate database entries NAME . NAME ( f\" Template selected for person { NAME } : { NAME } ( { NAME } ) \" )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_get_session_manager",
      "lineno": 787,
      "end_lineno": 792,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(session_manager)",
      "fingerprint": "8e7e6b8f4e45180b2a8297558f9cfc31375e7c08",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME : from NAME . NAME import NAME NAME = NAME ( ) return NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_get_template_selections",
      "lineno": 795,
      "end_lineno": 800,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(session, cutoff_date)",
      "fingerprint": "75239d6113390a0a02e50f9aff93161528c300a1",
      "simhash64": 7487617077321573379,
      "normalized": "def NAME ( NAME , NAME ) -> NAME : LIT return NAME . NAME ( NAME ) . NAME ( NAME . NAME . NAME ( LIT ) , NAME . NAME >= NAME ) . NAME ( )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_extract_template_name",
      "lineno": 803,
      "end_lineno": 808,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(script_message_status)",
      "fingerprint": "7faa990ae9cb983a91f26d41204a1b3a5fe338a8",
      "simhash64": 5182337013833438243,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT NAME = NAME . NAME ( LIT ) if NAME ( NAME ) >= LIT : return NAME [ LIT ] . NAME ( ) . NAME ( LIT ) [ LIT ] return None"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_initialize_template_stats",
      "lineno": 811,
      "end_lineno": 818,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "1ee3664e6e64fd074a14d00ee62e00de77685dff",
      "simhash64": 5726842660759967275,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT }"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_find_response_for_template",
      "lineno": 821,
      "end_lineno": 828,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(session, person_id, sent_time)",
      "fingerprint": "9883a3149cb794dce3ca8522c684c58d7b5d6942",
      "simhash64": 7487617073026606099,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) : LIT return NAME . NAME ( NAME ) . NAME ( NAME . NAME == NAME , NAME . NAME == NAME . NAME , NAME . NAME > NAME , NAME . NAME <= NAME + NAME ( NAME = LIT ) # Response window ) . NAME ( )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_update_response_time_average",
      "lineno": 831,
      "end_lineno": 836,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(template_stats, template_name, response_hours)",
      "fingerprint": "f84bfa61594bd51672265c18805b919fe5b973e0",
      "simhash64": 7452151226028176403,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME : NAME ) -> None : LIT NAME = NAME [ NAME ] [ LIT ] NAME = NAME [ NAME ] [ LIT ] NAME = ( ( NAME * ( NAME - LIT ) ) + NAME ) / NAME NAME [ NAME ] [ LIT ] = NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_calculate_response_rates",
      "lineno": 839,
      "end_lineno": 843,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(template_stats)",
      "fingerprint": "2a9059e02d8f2cdb17c70b48015e19fc8777f94c",
      "simhash64": 5146308216814482467,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME [ NAME , NAME ] ] ) -> None : LIT for NAME , NAME in NAME . NAME ( ) : if NAME [ LIT ] > LIT : NAME [ LIT ] = ( NAME [ LIT ] / NAME [ LIT ] ) * LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_process_template_selections",
      "lineno": 846,
      "end_lineno": 868,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 23,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(session, template_selections, template_stats)",
      "fingerprint": "fe53286717364357d9067bdab0ce9afe97f739c6",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME , NAME , NAME : NAME [ NAME , NAME [ NAME , NAME ] ] ) -> None : LIT for NAME in NAME : NAME = NAME ( NAME . NAME ) if not NAME : continue if NAME not in NAME : NAME [ NAME ] = NAME ( ) NAME [ NAME ] [ LIT ] += LIT # Check for responses from this person after this template NAME = NAME . NAME NAME = NAME . NAME NAME = NAME ( NAME , NAME , NAME ) if NAME : NAME [ NAME ] [ LIT ] += LIT # Calculate response time NAME = NAME . NAME - NAME NAME = NAME . NAME ( ) / LIT NAME ( NAME , NAME , NAME )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "analyze_template_effectiveness",
      "lineno": 871,
      "end_lineno": 908,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 38,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(session_manager, days_back)",
      "fingerprint": "c6ed46a19a8eb825cc135e02d3899ea8d7003f29",
      "simhash64": 7488109655309587483,
      "normalized": "def NAME ( NAME = None , NAME : NAME = LIT ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( NAME ) try : with NAME . NAME ( ) as NAME : if not NAME : return { LIT : LIT } # Get cutoff date NAME = NAME . NAME ( NAME . NAME ) - NAME ( NAME = NAME ) # Query for template selections and responses NAME = { } NAME = NAME ( NAME , NAME ) NAME ( NAME , NAME , NAME ) NAME ( NAME ) return { LIT : NAME , LIT : NAME ( NAME ) , LIT : NAME , LIT : NAME . NAME ( NAME . NAME ) . NAME ( ) } except NAME as NAME : NAME . NAME ( f\" Error analyzing template effectiveness: { NAME } \" , NAME = True ) return { LIT : NAME ( NAME ) }"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "print_template_effectiveness_report",
      "lineno": 911,
      "end_lineno": 967,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 57,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(days_back)",
      "fingerprint": "c171b060b8f7c8baccd2a59a06655554696b7919",
      "simhash64": 7452151225961059387,
      "normalized": "def NAME ( NAME : NAME = LIT ) : LIT NAME . NAME ( LIT * LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT * LIT ) NAME = NAME ( NAME = NAME ) if LIT in NAME : NAME . NAME ( f\" Analysis failed: { NAME [ LIT ] } \" ) return NAME = NAME . NAME ( LIT , { } ) if not NAME : NAME . NAME ( LIT ) return NAME . NAME ( f\" Analysis Period: Last { NAME } days \" ) NAME . NAME ( f\" Templates Analyzed: { NAME ( NAME ) } \" ) NAME . NAME ( LIT ) # Sort templates by response rate NAME = NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ LIT ] [ LIT ] , NAME = True ) NAME . NAME ( LIT ) NAME . NAME ( LIT * LIT ) NAME . NAME ( f\" { LIT : <25 } { LIT : <6 } { LIT : <6 } { LIT : <8 } { LIT : <10 } \" ) NAME . NAME ( LIT * LIT ) for NAME , NAME in NAME : NAME . NAME ( f\" { NAME : <25 } { NAME [ LIT ] : <6 } { NAME [ LIT ] : <6 } \" f\" { NAME [ LIT ] : <7.1f } % { NAME [ LIT ] : <9.1f } \" ) NAME . NAME ( LIT * LIT ) # Summary statistics NAME = NAME ( NAME [ LIT ] for NAME in NAME . NAME ( ) ) NAME = NAME ( NAME [ LIT ] for NAME in NAME . NAME ( ) ) NAME = ( NAME / NAME * LIT ) if NAME > LIT else LIT NAME . NAME ( LIT ) NAME . NAME ( f\" Total Messages Sent: { NAME } \" ) NAME . NAME ( f\" Total Responses: { NAME } \" ) NAME . NAME ( f\" Overall Response Rate: { NAME : .1f } % \" ) NAME . NAME ( LIT * LIT )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_update_messaging_performance",
      "lineno": 974,
      "end_lineno": 1011,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 38,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(session_manager, duration)",
      "fingerprint": "2e3db8a3d0cc6f5e2ad9aa78a83eff4c9fb943df",
      "simhash64": 7488180023047140355,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT try : # Initialize performance tracking attributes if they don't exist if not NAME ( NAME , LIT ) : NAME . NAME = [ ] if not NAME ( NAME , LIT ) : NAME . NAME = LIT if not NAME ( NAME , LIT ) : NAME . NAME = LIT # Track response time (keep last 50 measurements) NAME . NAME . NAME ( NAME ) if NAME ( NAME . NAME ) > LIT : NAME . NAME . NAME ( LIT ) # Update average response time NAME . NAME = NAME ( NAME . NAME ) / NAME ( NAME . NAME ) # Track consecutive slow calls - OPTIMIZATION: Adjusted threshold like Action 6 if NAME > LIT : # OPTIMIZATION: Increased from 5.0s to 15.0s - align with Action 6 thresholds NAME . NAME += LIT else : NAME . NAME = NAME ( LIT , NAME . NAME - LIT ) # Cap slow call counter to prevent endless accumulation NAME . NAME = NAME ( NAME . NAME , LIT ) except NAME as NAME : NAME . NAME ( f\" Failed to update messaging performance tracking: { NAME } \" ) pass"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_commit_messaging_batch",
      "lineno": 1019,
      "end_lineno": 1270,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 38,
      "loc": 252,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "(session, logs_to_add, person_updates, batch_num)",
      "fingerprint": "2edd3b06af918a80704b84f7e67e6883bda2d7ac",
      "simhash64": 7488180022981080083,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] , # List of ConversationLog OBJECTS NAME : NAME [ NAME , NAME ] , # Dict of {person_id: new_status_enum} NAME : NAME , ) -> NAME : LIT # Step 1: Check if there's anything to commit if not NAME and not NAME : NAME . NAME ( f\" Batch Commit (Msg Batch { NAME } ): No data to commit. \" ) return True # Attempting batch commit (removed verbose debug logging) # Step 2: Perform DB operations within a transaction context try : with NAME ( NAME ) as NAME : # Use the provided session in the transaction NAME = [ ] NAME = ( [ ] ) # List to hold tuples: (existing_log_obj, new_log_obj) # --- Step 2a: Prepare ConversationLog data: Separate Inserts and Updates --- if NAME : # Preparing ConversationLog entries for upsert (removed verbose debug) # Extract unique keys from the input OBJECTS NAME = NAME ( ) NAME = [ ] # Store objects that have valid keys for NAME in NAME : # Use our safe helper to get values NAME = NAME ( NAME , LIT , None ) NAME = NAME ( NAME , LIT , None ) if NAME and NAME : NAME . NAME ( ( NAME , NAME ) ) NAME . NAME ( NAME ) else : NAME . NAME ( f\" Invalid log object data (Msg Batch { NAME } ): Missing key info. Skipping log object. \" ) # Query for existing logs matching the keys in this batch NAME : NAME [ NAME [ NAME , NAME ] , NAME ] = { } if NAME : NAME = ( NAME . NAME ( NAME ) . NAME ( NAME ( NAME . NAME , NAME . NAME , ) . NAME ( [ ( NAME , NAME ) for NAME , NAME in NAME ] ) ) . NAME ( ) ) NAME = { } for NAME in NAME : # Use our safe helper to get values NAME = NAME ( NAME , LIT , None ) NAME = NAME ( NAME , LIT , None ) if NAME and NAME : NAME [ ( NAME , NAME ) ] = NAME # Prefetched existing ConversationLog entries (removed verbose debug) # Process each valid log object for NAME in NAME : NAME = ( NAME . NAME , NAME . NAME ) NAME = NAME . NAME ( NAME ) if NAME : # Prepare for individual update by pairing existing and new objects NAME . NAME ( ( NAME , NAME ) ) else : # Prepare for bulk insert by converting object to dict try : NAME = { NAME . NAME : NAME ( NAME , NAME . NAME ) for NAME in NAME ( NAME ) . NAME . NAME # Include None values as they might be valid states (e.g., ai_sentiment for OUT) } # Ensure Enums are handled if needed (SQLAlchemy mapping usually handles this) if NAME ( NAME . NAME ( LIT ) , NAME ) : NAME [ LIT ] = NAME [ LIT ] . NAME # Ensure timestamp is added if missing (should be set by caller) if ( LIT not in NAME or NAME [ LIT ] is None ) : NAME . NAME ( f\" Timestamp missing for new log ConvID { NAME . NAME } . Setting to now. \" ) NAME [ LIT ] = NAME . NAME ( NAME . NAME ) elif NAME ( NAME [ LIT ] , NAME ) : # Ensure TZ aware UTC NAME = NAME [ LIT ] NAME [ LIT ] = ( NAME . NAME ( NAME . NAME ) if NAME . NAME else NAME . NAME ( NAME = NAME . NAME ) ) NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error preparing new log object for bulk insert (Msg Batch { NAME } , ConvID: { NAME . NAME } ): { NAME } \" , NAME = True , ) # --- Execute Bulk Insert --- if NAME : NAME . NAME ( f\" Attempting bulk insert for { NAME ( NAME ) } ConversationLog entries... \" ) try : NAME . NAME ( NAME , NAME ) # type: ignore NAME . NAME ( f\" Bulk insert mappings called for { NAME ( NAME ) } logs. \" ) except NAME as NAME : NAME . NAME ( f\" IntegrityError during bulk insert (likely duplicate ConvID/Direction): { NAME } . Some logs might not have been inserted. \" ) # Need robust handling if this occurs - maybe skip or attempt update? except NAME as NAME : NAME . NAME ( f\" Error during ConversationLog bulk insert (Msg Batch { NAME } ): { NAME } \" , NAME = True , ) raise # Rollback transaction # --- Perform Individual Updates --- NAME = LIT if NAME : NAME . NAME ( f\" Processing { NAME ( NAME ) } individual ConversationLog updates... \" ) for NAME , NAME in NAME : try : NAME = False # Compare relevant fields from the new object against the existing one NAME = [ LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : NAME = NAME ( NAME , NAME , None ) NAME = NAME ( NAME , NAME , None ) # Handle timestamp comparison carefully (aware) if NAME == LIT : NAME = ( NAME . NAME ( NAME . NAME ) if NAME ( NAME , NAME ) and NAME . NAME else ( NAME . NAME ( NAME = NAME . NAME ) if NAME ( NAME , NAME ) else None ) ) NAME = ( NAME . NAME ( NAME . NAME ) if NAME ( NAME , NAME ) and NAME . NAME else ( NAME . NAME ( NAME = NAME . NAME ) if NAME ( NAME , NAME ) else None ) ) if NAME != NAME : NAME ( NAME , NAME , NAME ) NAME = True elif NAME != NAME : NAME ( NAME , NAME , NAME ) NAME = True # Update timestamp if any changes occurred if NAME : NAME . NAME = NAME . NAME ( NAME . NAME ) NAME += LIT except NAME as NAME : NAME . NAME ( f\" Error updating individual log ConvID { NAME . NAME } / { NAME . NAME } : { NAME } \" , NAME = True , ) NAME . NAME ( f\" Finished { NAME } individual log updates. \" ) # --- Step 2b: Person Status Updates (Bulk Update - remains the same) --- if NAME : NAME = [ ] NAME . NAME ( f\" Preparing { NAME ( NAME ) } Person status updates... \" ) for NAME , NAME in NAME . NAME ( ) : if not NAME ( NAME , NAME ) : NAME . NAME ( f\" Invalid status type ' { NAME ( NAME ) } ' for Person ID { NAME } . Skipping update. \" ) continue NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME . NAME ( NAME . NAME ) , } ) if NAME : NAME . NAME ( f\" Updating { NAME ( NAME ) } Person statuses via bulk... \" ) NAME . NAME ( NAME , NAME ) # type: ignore NAME . NAME ( f\" Exiting transaction block (Msg Batch { NAME } , commit follows). \" ) # --- Transaction automatically commits here if no exceptions --- NAME . NAME ( f\" Batch commit successful (Msg Batch { NAME } ). \" ) return True # Step 3/4: Handle exceptions during commit except NAME as NAME : NAME . NAME ( f\" DB UNIQUE constraint error during messaging batch commit (Batch { NAME } ): { NAME } \" , NAME = False , ) return False except NAME as NAME : NAME . NAME ( f\" Error committing messaging batch (Batch { NAME } ): { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_get_simple_messaging_data",
      "lineno": 1276,
      "end_lineno": 1353,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 10,
      "loc": 78,
      "tags": [
        "pure-ish",
        "regex",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(db_session, session_manager)",
      "fingerprint": "1ff8c09b77cb89446e63e78858674f7aceef247f",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME [ NAME [ NAME , NAME ] ] , NAME [ NAME [ NAME ] ] ] : LIT try : # Check for halt signal before starting if NAME and NAME . NAME ( ) : NAME . NAME ( LIT ) raise NAME ( LIT ) # Step 1: Fetch MessageTemplate map NAME . NAME ( LIT ) # Check if we're running in a test/mock environment NAME = LIT in NAME . NAME or LIT in NAME . NAME if NAME : # Create mock data for testing NAME . NAME ( LIT ) NAME = { NAME : NAME for NAME , NAME in NAME ( NAME . NAME ( ) , NAME = LIT ) } NAME [ LIT ] = NAME ( NAME ) + LIT else : # Fetch MessageTemplate key-to-ID mapping NAME = NAME . NAME ( NAME . NAME , NAME . NAME ) . NAME ( ) NAME = { NAME : NAME for NAME , NAME in NAME } # Basic validation if not NAME : NAME . NAME ( LIT ) return None , None # Step 2: Fetch Candidate Persons NAME . NAME ( LIT ) if NAME : NAME = [ ] else : NAME = ( NAME . NAME ( NAME ) . NAME ( NAME ( NAME . NAME ) , NAME ( NAME . NAME ) , ) . NAME ( NAME . NAME . NAME ( None ) , NAME . NAME != LIT , NAME . NAME , NAME . NAME . NAME ( [ NAME . NAME , NAME . NAME ] ) , NAME . NAME . NAME ( None ) , ) . NAME ( NAME . NAME ) . NAME ( ) ) NAME . NAME ( f\" Found { NAME ( NAME ) } potential candidates. \" ) return NAME , NAME except NAME as NAME : NAME . NAME ( f\" Error fetching messaging data: { NAME } \" , NAME = True ) return None , None"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_get_person_message_history",
      "lineno": 1356,
      "end_lineno": 1404,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 49,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(db_session, person_id)",
      "fingerprint": "34f652acad1607f294857b5af5678c866fbab0ba",
      "simhash64": 7487617077321577475,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME ] , NAME [ NAME ] , NAME [ NAME ] ] : LIT try : # Get latest IN message NAME = ( NAME . NAME ( NAME ) . NAME ( NAME . NAME == NAME , NAME . NAME == NAME . NAME , ~ NAME . NAME . NAME ( LIT ) , ~ NAME . NAME . NAME ( LIT ) ) . NAME ( NAME . NAME . NAME ( ) ) . NAME ( ) ) # Get latest OUT message with template key NAME = ( NAME . NAME ( NAME , NAME . NAME ) . NAME ( NAME , NAME . NAME == NAME . NAME ) . NAME ( NAME . NAME == NAME , NAME . NAME == NAME . NAME , ~ NAME . NAME . NAME ( LIT ) , ~ NAME . NAME . NAME ( LIT ) ) . NAME ( NAME . NAME . NAME ( ) ) . NAME ( ) ) if NAME : NAME , NAME = NAME else : NAME , NAME = None , None return NAME , NAME , NAME except NAME as NAME : NAME . NAME ( f\" Error getting message history for person { NAME } : { NAME } \" ) return None , None , None"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_validate_system_health",
      "lineno": 1407,
      "end_lineno": 1443,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 37,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(session_manager)",
      "fingerprint": "fd153504d7ee8d970c27e3b1ac250b173247fc83",
      "simhash64": 7488215207419229203,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT try : # Use consolidated session health validation if not NAME . NAME ( LIT ) : return False # Action 8-specific check: Essential message templates availability NAME = NAME ( NAME . NAME ( ) ) NAME = [ ] for NAME in NAME : if NAME not in NAME : NAME . NAME ( NAME ) if NAME : NAME . NAME ( f\" \ud83d\udea8 Action 8: Essential message templates missing: { NAME } . \" f\" Cannot proceed with messaging operations. \" ) return False NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" \ud83d\udea8 Action 8: System health check failed: { NAME } \" ) return False"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_safe_commit_with_rollback",
      "lineno": 1450,
      "end_lineno": 1504,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 55,
      "tags": [
        "pure-ish",
        "logging",
        "size:medium"
      ],
      "signature": "(session, log_upserts, person_updates, context, session_manager)",
      "fingerprint": "6bcc9f2cbca70e2f98a467a7403d50fc345fdaf5",
      "simhash64": 7487617073026610203,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME : NAME ) -> NAME [ NAME , NAME , NAME ] : LIT # Check for cascade before attempting commit NAME . NAME ( LIT , f\" safe commit { NAME } \" ) # Create backup of data for potential rollback NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) try : # Use isolation level to prevent concurrent access issues with NAME . NAME ( ) : # Explicit transaction with automatic rollback on exception NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) # Verify commit was successful if NAME == LIT and NAME == LIT and ( NAME or NAME ) : NAME . NAME ( f\" Commit returned zero counts but data was provided for { NAME } \" ) return False , LIT , LIT NAME . NAME ( f\" Safe commit successful for { NAME } : { NAME } logs, { NAME } persons \" ) return True , NAME , NAME except NAME as NAME : NAME . NAME ( f\" Safe commit failed for { NAME } : { NAME } \" , NAME = True ) # Attempt to restore data for retry (if needed) NAME . NAME ( ) NAME . NAME ( NAME ) NAME . NAME ( ) NAME . NAME ( NAME ) return False , LIT , LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ErrorCategorizer.__init__",
      "lineno": 1512,
      "end_lineno": 1523,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "18d12342ec7c31309ea9e9d05b4f4e2bf40a709d",
      "simhash64": 5727968560666809899,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } NAME . NAME = [ ]"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ErrorCategorizer.categorize_status",
      "lineno": 1525,
      "end_lineno": 1593,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 13,
      "yield_count": 0,
      "complexity": 19,
      "loc": 69,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, status)",
      "fingerprint": "fd8d98e786ad5afaf3b9bf50e6c893b37c0d302e",
      "simhash64": 5145887103852647467,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT if not NAME : return LIT , LIT NAME = NAME . NAME ( ) # Successful outcomes if NAME in [ LIT , LIT ] : return LIT , LIT if NAME in [ LIT , LIT ] : return LIT , LIT # Business logic skips (not errors) NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ] if NAME . NAME ( LIT ) : for NAME in NAME : if NAME in NAME : NAME . NAME [ LIT ] += LIT return LIT , f' business_logic_ { NAME } ' # Generic skip NAME . NAME [ LIT ] += LIT return LIT , LIT # Technical errors if NAME . NAME ( LIT ) : # Extract error type from parentheses if LIT in NAME and LIT in NAME : NAME = NAME [ NAME . NAME ( LIT ) + LIT : NAME . NAME ( LIT ) ] . NAME ( ) if LIT in NAME or LIT in NAME : NAME . NAME [ LIT ] += LIT return LIT , LIT if LIT in NAME or LIT in NAME : NAME . NAME [ LIT ] += LIT return LIT , LIT if LIT in NAME : NAME . NAME [ LIT ] += LIT return LIT , LIT if LIT in NAME : NAME . NAME [ LIT ] += LIT return LIT , LIT if LIT in NAME or LIT in NAME : NAME . NAME [ LIT ] += LIT return LIT , LIT if LIT in NAME : NAME . NAME [ LIT ] += LIT return LIT , LIT # Generic technical error NAME . NAME [ LIT ] += LIT return LIT , LIT # Default to error for unknown status NAME . NAME [ LIT ] += LIT return LIT , LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ErrorCategorizer.add_monitoring_hook",
      "lineno": 1595,
      "end_lineno": 1597,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, hook_function)",
      "fingerprint": "c2664991185302329ef95477bb2bd28562c3caf0",
      "simhash64": 7488180024053769219,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ErrorCategorizer.trigger_monitoring_alert",
      "lineno": 1599,
      "end_lineno": 1613,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 15,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, alert_type, message, severity)",
      "fingerprint": "874493694bb49d9d67690516a86f45655200119c",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME = LIT ) -> None : LIT NAME = { LIT : NAME . NAME ( NAME . NAME ) . NAME ( ) , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME . NAME . NAME ( ) } for NAME in NAME . NAME : try : NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Monitoring hook failed: { NAME } \" )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ErrorCategorizer.get_error_summary",
      "lineno": 1615,
      "end_lineno": 1626,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "4cdc38f2e2c42b70b28f3b27d390fa50152fa999",
      "simhash64": 7487617073093710851,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( NAME for NAME , NAME in NAME . NAME . NAME ( ) if LIT in NAME ) NAME = NAME . NAME [ LIT ] return { LIT : NAME , LIT : NAME , LIT : NAME . NAME . NAME ( ) , LIT : NAME / NAME ( LIT , NAME + NAME ) , LIT : NAME ( NAME . NAME . NAME ( ) , NAME = lambda NAME : NAME [ LIT ] ) [ LIT ] if NAME > LIT else None }"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ResourceManager.__init__",
      "lineno": 1634,
      "end_lineno": 1638,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "26914f4fe0a68e8beb9bef5ec5a4852700e035ef",
      "simhash64": 7452081407039812689,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME = [ ] NAME . NAME = LIT # Trigger cleanup at 100MB NAME . NAME = LIT # Trigger GC every 50 operations NAME . NAME = LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ResourceManager.track_resource",
      "lineno": 1640,
      "end_lineno": 1642,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, resource_name, resource_obj)",
      "fingerprint": "1d5968bb6c12e68b1a96bde57ce931757d83390d",
      "simhash64": 7487617039740601379,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> None : LIT NAME . NAME . NAME ( ( NAME , NAME ) )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ResourceManager.check_memory_usage",
      "lineno": 1644,
      "end_lineno": 1667,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 24,
      "tags": [
        "impure",
        "filesystem",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "4ad09d9003d50656c4a4e986fd8be27d6484ac3c",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT import NAME import NAME try : NAME = NAME . NAME ( NAME . NAME ( ) ) NAME = NAME . NAME ( ) . NAME / ( LIT * LIT ) NAME = NAME > NAME . NAME if NAME : NAME . NAME ( f\" \ud83e\udde0 Memory usage high: { NAME : .1f } MB (threshold: { NAME . NAME } MB) \" ) return NAME , NAME except NAME as NAME : NAME . NAME ( f\" Could not check memory usage: { NAME } \" ) return LIT , False"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ResourceManager.trigger_garbage_collection",
      "lineno": 1669,
      "end_lineno": 1683,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "14a1b15d9285989c681f9009fb553d3781164e59",
      "simhash64": 7488144839681680403,
      "normalized": "def NAME ( NAME ) -> NAME : LIT import NAME NAME = NAME ( NAME . NAME ( ) ) NAME = NAME . NAME ( ) NAME = NAME ( NAME . NAME ( ) ) NAME . NAME ( f\" \ud83d\uddd1\ufe0f Garbage collection: { NAME } cycles, { NAME - NAME } objects freed \" ) return NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ResourceManager.cleanup_resources",
      "lineno": 1685,
      "end_lineno": 1705,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "49166bfebff7212ae00906c12d98de6627762195",
      "simhash64": 8641101527586870283,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME = LIT for NAME , NAME in NAME . NAME : try : if NAME ( NAME , LIT ) : NAME . NAME ( ) elif NAME ( NAME , LIT ) : NAME . NAME ( ) elif NAME ( NAME , LIT ) : NAME . NAME ( ) NAME += LIT NAME . NAME ( f\" \ud83e\uddf9 Cleaned up resource: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Failed to cleanup resource { NAME } : { NAME } \" ) NAME . NAME . NAME ( ) NAME . NAME ( f\" \ud83e\uddf9 Resource cleanup completed: { NAME } resources cleaned \" )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ResourceManager.periodic_maintenance",
      "lineno": 1707,
      "end_lineno": 1720,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "f1cf2204bf38866e1f3c4fe97879c3ee7ffca974",
      "simhash64": 8641136711958963203,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME += LIT # Check memory and cleanup if needed NAME , NAME = NAME . NAME ( ) if NAME : NAME . NAME ( ) NAME . NAME ( ) # Periodic garbage collection elif NAME . NAME % NAME . NAME == LIT : NAME . NAME ( )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ProactiveApiManager.__init__",
      "lineno": 1728,
      "end_lineno": 1735,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, session_manager)",
      "fingerprint": "a234ed425f98854fecee8f97c071d5bf45a37966",
      "simhash64": 7452080857283998739,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME NAME . NAME = LIT NAME . NAME = LIT NAME . NAME = LIT # Check auth every 5 minutes NAME . NAME = LIT NAME . NAME = LIT NAME . NAME = LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ProactiveApiManager.check_authentication",
      "lineno": 1737,
      "end_lineno": 1767,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 31,
      "tags": [
        "pure-ish",
        "time",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "b06e2f9b74d1121be191f2e08a940899f5bc2d61",
      "simhash64": 7488215207419229187,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) # Only check if enough time has passed if NAME - NAME . NAME < NAME . NAME : return True NAME . NAME = NAME try : if not NAME . NAME . NAME ( ) : NAME . NAME ( LIT ) return False # Additional check for profile ID if not NAME . NAME . NAME : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" \ud83d\udd10 Authentication check error: { NAME } \" ) return False"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ProactiveApiManager.attempt_reauthentication",
      "lineno": 1769,
      "end_lineno": 1792,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 24,
      "tags": [
        "pure-ish",
        "regex",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "d04a5ecf6e4682686b1a51bdfc8c43fcc44f7474",
      "simhash64": 7487652257465807875,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME . NAME ( LIT ) try : # Use session manager's recovery mechanism if NAME ( NAME . NAME , LIT ) : NAME = NAME . NAME . NAME ( LIT ) if NAME : NAME . NAME ( LIT ) NAME . NAME = LIT return True NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" \u274c Re-authentication error: { NAME } \" ) return False"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ProactiveApiManager.calculate_delay",
      "lineno": 1794,
      "end_lineno": 1808,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "randomness",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "c0e05e4e9770f37ba66be26c4ca7be8c809bdf9c",
      "simhash64": 7488180022980027427,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if NAME . NAME == LIT : return LIT # Exponential backoff with jitter import NAME NAME = NAME ( NAME . NAME * ( LIT ** NAME . NAME ) , NAME . NAME ) NAME = NAME . NAME ( LIT , LIT ) # \u00b120% jitter return NAME * NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ProactiveApiManager.validate_api_response",
      "lineno": 1810,
      "end_lineno": 1842,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 11,
      "loc": 33,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, response_data, operation)",
      "fingerprint": "ab3a4539c324dc93a1b86534d2559793350b004f",
      "simhash64": 7488180022981072427,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT if NAME is None : NAME . NAME ( f\" API validation failed for { NAME } : Response is None \" ) return False # For message sending, check for specific success indicators if NAME . NAME ( LIT ) and NAME ( NAME , NAME ) and NAME ( NAME ) >= LIT : NAME = NAME [ LIT ] if NAME and LIT in NAME : NAME . NAME ( f\" \u2705 API validation passed for { NAME } : { NAME } \" ) return True if NAME and LIT in NAME . NAME ( ) : NAME . NAME ( f\" \u274c API validation failed for { NAME } : { NAME } \" ) return False # Generic validation for other responses if NAME ( NAME , NAME ) and ( LIT in NAME or LIT in NAME ) : # Check for common error indicators NAME . NAME ( f\" \u274c API validation failed for { NAME } : Response contains errors \" ) return False NAME . NAME ( f\" \u2705 API validation passed for { NAME } \" ) return True"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "ProactiveApiManager.record_api_result",
      "lineno": 1844,
      "end_lineno": 1861,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, success, operation)",
      "fingerprint": "3defe24c89a3f6d6fdddbc191b177aacecab2df5",
      "simhash64": 7452151225961067539,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> None : LIT if NAME : NAME . NAME = LIT NAME . NAME ( f\" \ud83d\udcca API success recorded for { NAME } \" ) else : NAME . NAME += LIT NAME . NAME ( f\" \ud83d\udcca API failure recorded for { NAME } (consecutive: { NAME . NAME } ) \" ) # If too many failures, suggest longer delays if NAME . NAME >= NAME . NAME : NAME . NAME ( f\" \ud83d\udea8 Too many consecutive API failures ( { NAME . NAME } ). Consider halting operations. \" )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_with_operation_timeout",
      "lineno": 1864,
      "end_lineno": 1902,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 39,
      "tags": [
        "pure-ish",
        "logging",
        "size:medium"
      ],
      "signature": "(operation_func, timeout_seconds, operation_name)",
      "fingerprint": "b973900f4085fb30641060dfdb4ed0342f3eb912",
      "simhash64": 7452151226028176403,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) : LIT import NAME NAME = [ None ] NAME = [ None ] NAME = [ False ] def NAME ( ) -> None : try : NAME [ LIT ] = NAME ( ) NAME [ LIT ] = True except NAME as NAME : NAME [ LIT ] = NAME NAME [ LIT ] = True NAME = NAME . NAME ( NAME = NAME , NAME = True ) NAME . NAME ( ) NAME . NAME ( NAME = NAME ) if not NAME [ LIT ] : # Operation timed out NAME . NAME ( f\" \u23f1\ufe0f Operation ' { NAME } ' timed out after { NAME } s (thread abandoned) \" ) raise NAME ( f\" Operation ' { NAME } ' timed out after { NAME } seconds \" ) if NAME [ LIT ] : raise NAME [ LIT ] return NAME [ LIT ]"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "target",
      "lineno": 1882,
      "end_lineno": 1888,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "37da8f9bf0d240116440c29e35d905b64e79e461",
      "simhash64": 5146308174938551319,
      "normalized": "def NAME ( ) -> None : try : NAME [ LIT ] = NAME ( ) NAME [ LIT ] = True except NAME as NAME : NAME [ LIT ] = NAME NAME [ LIT ] = True"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_safe_api_call_with_validation",
      "lineno": 1905,
      "end_lineno": 1963,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 59,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(session_manager, api_function, operation_name, *args, **kwargs)",
      "fingerprint": "d38cd69f53c570b58f62ca1d1f6db6c4a47f21d0",
      "simhash64": 7488180022981071899,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , * NAME , ** NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( NAME ) # Step 1: Check authentication proactively if not NAME . NAME ( ) and not NAME . NAME ( ) : NAME . NAME ( f\" \ud83d\udd10 Cannot proceed with { NAME } - authentication failed \" ) return False , None # Step 2: Check for cascade before API call NAME . NAME ( LIT , f\" API call { NAME } \" ) # Step 3: Apply proactive delay if needed NAME = NAME . NAME ( ) if NAME > LIT : import NAME NAME . NAME ( f\" \u23f1\ufe0f Proactive delay for { NAME } : { NAME : .1f } s \" ) NAME . NAME ( NAME ) # Step 4: Make the API call with timeout protection try : def NAME ( ) -> NAME : return NAME ( * NAME , ** NAME ) # Use operation-level timeout (60 seconds for API calls) NAME = NAME ( NAME , LIT , f\" API_ { NAME } \" ) # Step 5: Validate the response NAME = NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME , NAME ) return NAME , NAME except NAME as NAME : NAME . NAME ( f\" \u23f1\ufe0f API call timeout for { NAME } : { NAME } \" ) NAME . NAME ( False , NAME ) return False , None except NAME as NAME : NAME . NAME ( f\" \u274c API call failed for { NAME } : { NAME } \" ) NAME . NAME ( False , NAME ) return False , None"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "api_call",
      "lineno": 1944,
      "end_lineno": 1945,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "77ff67f57ed1b060f8544099c4e9bd9560222393",
      "simhash64": 7488215212722390115,
      "normalized": "def NAME ( ) -> NAME : return NAME ( * NAME , ** NAME )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_process_single_person",
      "lineno": 1966,
      "end_lineno": 2583,
      "is_method": false,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 84,
      "loc": 618,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "regex",
        "size:large"
      ],
      "signature": "(db_session, session_manager, person, latest_in_log, latest_out_log, latest_out_template_key, message_type_map)",
      "fingerprint": "28b8dc3fb287515b4773e8c6b76a127843f90b3c",
      "simhash64": 7452080857217930259,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME ] , NAME : NAME [ NAME ] , # Template key from latest OUT message NAME : NAME [ NAME , NAME ] , ) -> NAME [ NAME [ NAME ] , NAME [ NAME [ NAME , NAME ] ] , NAME ] : LIT # --- Step 0: Session Validation and Initialization (Action 6 Pattern) --- # CRITICAL FIX: Check for halt signal before processing person if NAME . NAME ( ) : NAME = NAME . NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" \ud83d\udea8 HALT SIGNAL: Skipping person processing due to session death cascade (# { NAME } ) \" ) raise NAME ( f\" Session death cascade detected (# { NAME } ) - halting person processing \" ) # --- Step 1: Initialization and Logging --- # Convert SQLAlchemy Column objects to Python primitives using our safe helper NAME = NAME ( NAME , LIT , LIT ) NAME = NAME ( NAME , LIT , LIT ) # For nested attributes like person.status.name, we need to be more careful NAME = NAME ( NAME , LIT , None ) NAME = NAME ( NAME , LIT , LIT ) if NAME is not None else LIT NAME = f\" { NAME } # { NAME } (Status: { NAME } ) \" NAME : NAME [ NAME ] = None # Key from MESSAGE_TEMPLATES NAME = LIT # Reason for sending/skipping NAME = LIT # CONSOLIDATED: Track template selection reason NAME : NAME [ LIT , LIT , LIT , LIT ] = ( LIT # Default outcome ) # Initialize variables early to prevent UnboundLocalError in exception handlers NAME = None NAME = None NAME : NAME [ NAME ] = None # Prepared log object NAME : NAME [ NAME [ NAME , NAME ] ] = None # Staged status update NAME = NAME . NAME ( NAME . NAME ) # Consistent timestamp for checks NAME = NAME . NAME . NAME ( NAME = NAME . NAME ) # For comparisons # Processing person (removed verbose debug logging) # Debug-only: log a quality summary of any extracted genealogical data attached to the person try : # Import locally to avoid module-level dependency if file moves if NAME ( NAME , LIT ) : NAME = NAME ( NAME , LIT , { } ) or { } # Quality summary (removed verbose debug logging) pass except NAME as NAME : # Best-effort logging only; never fail processing due to QA summary issues # Skipped quality summary logging (removed verbose debug) pass # Optional: Log latest log details for debugging # if latest_in_log: logger.debug(f\"  Latest IN: {latest_in_log.latest_timestamp} ({latest_in_log.ai_sentiment})\") else: logger.debug(\"  Latest IN: None\") # if latest_out_log: logger.debug(f\"  Latest OUT: {latest_out_log.latest_timestamp} ({getattr(latest_out_log.message_type, 'type_name', 'N/A')}, {latest_out_log.script_message_status})\") else: logger.debug(\"  Latest OUT: None\") try : # Main processing block for this person # --- Step 1: Check Person Status for Eligibility --- if NAME . NAME in ( NAME . NAME , NAME . NAME , NAME . NAME , ) : NAME . NAME ( f\" Skipping { NAME } : Status is ' { NAME . NAME . NAME } '. \" ) raise NAME ( LIT ) # Use StopIteration to exit cleanly # --- Step 2: Determine Action based on Status (DESIST vs ACTIVE) --- # Get the status as a Python enum using our safe helper NAME = NAME ( NAME , LIT , None ) # Handle DESIST status if NAME == NAME . NAME : # When status is DESIST, we only send an acknowledgment if needed NAME . NAME ( f\" { NAME } : Status is DESIST. Checking if Desist ACK needed. \" ) # Get the message type ID for the Desist acknowledgment NAME = NAME . NAME ( LIT ) if not NAME : # Should have been checked during prefetch NAME . NAME ( LIT ) raise NAME ( LIT ) # Check if the latest OUT message was already the Desist ACK NAME = NAME ( NAME and NAME . NAME == NAME ) if NAME : NAME . NAME ( f\" Skipping { NAME } : Desist ACK already sent (Last OUT Template ID: { NAME . NAME if NAME else LIT } ). \" ) # If ACK sent but status still DESIST, could change to ARCHIVE here or Action 9 raise NAME ( LIT ) # ACK needs to be sent NAME = LIT NAME = LIT NAME . NAME ( f\" Action needed for { NAME } : Send Desist ACK. \" ) elif NAME == NAME . NAME : # Handle ACTIVE status: Check rules for sending standard messages NAME . NAME ( f\" { NAME } : Status is ACTIVE. Checking messaging rules... \" ) # Rule 1: Check if reply received since last script message # Use our safe helper to get timestamps NAME = NAME if NAME : NAME = NAME ( NAME , LIT , NAME ) # Ensure timezone-aware if NAME and NAME . NAME is None : NAME = NAME . NAME ( NAME = NAME . NAME ) NAME = NAME if NAME : NAME = NAME ( NAME , LIT , NAME ) # Ensure timezone-aware if NAME and NAME . NAME is None : NAME = NAME . NAME ( NAME = NAME . NAME ) if NAME > NAME : NAME . NAME ( f\" Skipping { NAME } : Reply received ( { NAME } ) after last script msg ( { NAME } ). \" ) raise NAME ( LIT ) # Rule 1b: Check if custom reply has already been sent for the latest incoming message if ( NAME and NAME ( NAME , LIT ) and NAME . NAME is not None ) : NAME . NAME ( f\" Skipping { NAME } : Custom reply already sent at { NAME . NAME } . \" ) raise NAME ( LIT ) # Rule 2: Check time interval since last script message if NAME : # Use our safe helper to get the timestamp NAME = NAME ( NAME , LIT , None ) if NAME : # CRITICAL FIX: Handle timezone mismatch between now_utc and out_timestamp try : # Ensure out_timestamp is timezone-aware if NAME . NAME is None : NAME = NAME . NAME ( NAME = NAME . NAME ) elif NAME . NAME != NAME . NAME : # Convert to UTC if it's in a different timezone NAME = NAME . NAME ( NAME . NAME ) # Ensure now_utc is timezone-aware (should already be, but double-check) if NAME . NAME is None : NAME = NAME . NAME ( NAME = NAME . NAME ) NAME = NAME - NAME if NAME < NAME : NAME . NAME ( f\" Skipping { NAME } : Interval not met ( { NAME } < { NAME } ). \" ) raise NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Datetime comparison error for { NAME } : { NAME } . \" f\" now_utc= { NAME } (tzinfo= { NAME . NAME } ), \" f\" out_timestamp= { NAME } (tzinfo= { NAME ( NAME , LIT , LIT ) } ) \" ) # Skip this person due to datetime error raise NAME ( LIT ) from None # else: logger.debug(f\"Interval met for {log_prefix}.\") # else: logger.debug(f\"No previous OUT message for {log_prefix}, interval check skipped.\") # Rule 3: Determine next message type in sequence NAME : NAME [ NAME [ NAME , NAME , NAME ] ] = None if NAME : # Use our safe helper to get the timestamp NAME = NAME ( NAME , LIT , None ) if NAME : # Ensure timestamp is timezone-aware before using it try : if NAME . NAME is None : NAME = NAME . NAME ( NAME = NAME . NAME ) elif NAME . NAME != NAME . NAME : NAME = NAME . NAME ( NAME . NAME ) except NAME as NAME : NAME . NAME ( f\" Timezone conversion error for { NAME } : { NAME } \" ) # Use current time as fallback NAME = NAME # Use the template key from the latest OUT message NAME = NAME # If we still don't have a valid type name, use None for proper fallback handling if not NAME or NAME == LIT : NAME = None NAME . NAME ( f\" Could not determine message type for { NAME } , using None for fallback \" ) # Get status using safe helper NAME = NAME ( NAME , LIT , LIT ) # Create the tuple with Python primitives NAME = ( NAME , NAME , NAME , ) NAME = NAME ( NAME , NAME ( NAME . NAME ) ) if not NAME : # No appropriate next message in the standard sequence NAME . NAME ( f\" Skipping { NAME } : No appropriate next standard message found. \" ) raise NAME ( LIT ) # Apply improved template selection logic NAME = NAME ( NAME , LIT , LIT ) # Prepare data for template selection (needed early for confidence-based selection) NAME = NAME . NAME # Eager loaded NAME = NAME . NAME # Eager loaded # First try A/B testing for initial messages if NAME in [ LIT , LIT ] : NAME = NAME ( NAME , NAME ) NAME = LIT # If A/B testing didn't select a variant, try confidence-based selection if NAME == NAME : NAME = NAME ( NAME , NAME , NAME ) NAME = LIT else : # For follow-up messages, use standard template NAME = NAME NAME = LIT # CONSOLIDATED LOGGING: Track template selection (debug only) NAME ( NAME , NAME , NAME ) NAME = LIT NAME . NAME ( f\" Action needed for { NAME } : Send ' { NAME } ' (selected via { NAME } ). \" ) else : # Should not happen if prefetch filters correctly NAME . NAME ( f\" Unexpected status ' { NAME ( NAME . NAME , LIT , LIT ) } ' encountered for { NAME } . Skipping. \" ) raise NAME ( LIT ) # --- Step 3: Format the Selected Message --- if not NAME or NAME not in NAME : NAME . NAME ( f\" Logic Error: Invalid/missing message key ' { NAME } ' for { NAME } . \" ) raise NAME ( LIT ) NAME = NAME [ NAME ] # Note: dna_match and family_tree already loaded above for template selection # Determine best name to use (Tree Name > First Name > Username) # Use our safe helper to get values NAME = None if NAME : NAME = NAME ( NAME , LIT , None ) NAME = NAME ( NAME , LIT , None ) NAME = NAME ( NAME , LIT , None ) # Choose the best name with fallbacks if NAME : NAME = NAME elif NAME : NAME = NAME elif NAME and NAME not in [ LIT , LIT ] : NAME = NAME else : NAME = LIT # Format the name NAME = NAME ( NAME ) # Get total rows count (optional, consider caching if slow) NAME = LIT try : NAME = ( NAME . NAME ( NAME . NAME ( NAME . NAME ) ) . NAME ( ) or LIT ) except NAME as NAME : NAME . NAME ( f\" Could not get FamilyTree count for formatting: { NAME } \" ) # Helper function to format predicted relationship with correct percentage def NAME ( NAME : NAME ) -> NAME : if not NAME or NAME == LIT : return LIT # Check if the string contains a percentage in brackets import NAME NAME = NAME . NAME ( LIT , NAME ) if NAME : try : # Extract the percentage value NAME = NAME ( NAME . NAME ( LIT ) ) # Fix percentage formatting based on the value range if NAME > LIT : # Values like 9900.0% should be 99.0% NAME = NAME / LIT return NAME . NAME ( LIT , f\" [ { NAME : .1f } %] \" , NAME ) if NAME < LIT : # Values like 0.99% should be 99.0% NAME = NAME * LIT return NAME . NAME ( LIT , f\" [ { NAME : .1f } %] \" , NAME ) # If percentage is between 1-100, it's already correct except ( NAME , NAME ) : pass # Return the original string if no percentage found or couldn't be processed return NAME # Get the predicted relationship and format it correctly NAME = LIT if NAME : NAME = NAME ( NAME , LIT , LIT ) NAME = NAME ( NAME ) # Use improved variable handling for natural text NAME = NAME ( NAME , NAME ) NAME = NAME ( NAME ) NAME = { LIT : NAME , LIT : NAME if NAME != LIT else LIT , LIT : NAME , LIT : NAME , LIT : NAME , } # Try enhanced personalized message formatting first NAME = None if NAME and NAME ( NAME , LIT ) : try : # Check if we have an enhanced template available NAME = f\" Enhanced_ { NAME } \" if NAME in NAME : NAME . NAME ( f\" Using enhanced template ' { NAME } ' for { NAME } \" ) # Get extracted data from person object (if available) NAME = NAME ( NAME , LIT , { } ) NAME = { LIT : NAME ( NAME , LIT , LIT ) } # Log-only: estimate personalization coverage with NAME . NAME ( NAME ) : NAME ( NAME , NAME [ NAME ] , NAME or { } , NAME , ) NAME , NAME = NAME . NAME ( NAME , NAME , NAME , NAME ) NAME . NAME ( f\" Successfully created personalized message for { NAME } \" ) else : NAME . NAME ( f\" Enhanced template ' { NAME } ' not available, using standard template \" ) except NAME as NAME : NAME . NAME ( f\" Enhanced message formatting failed for { NAME } : { NAME } , falling back to standard \" ) NAME = None # Fallback to standard template formatting if not NAME : try : NAME = NAME . NAME ( ** NAME ) except NAME as NAME : NAME . NAME ( f\" Template formatting error (Missing key { NAME } ) for ' { NAME } ' { NAME } \" ) raise NAME ( LIT ) from None except NAME as NAME : NAME . NAME ( f\" Unexpected template formatting error for { NAME } : { NAME } \" , NAME = True , ) raise NAME ( LIT ) from None # --- Step 4: Apply Mode/Recipient Filtering --- NAME = NAME ( NAME , LIT , LIT ) NAME = NAME . NAME # Use profile_id for filtering (should exist for contactable ACTIVE/DESIST persons) NAME = NAME ( NAME , LIT , LIT ) NAME = True # Default to sending NAME = LIT # Testing mode checks if NAME == LIT : # Check if testing profile ID is configured if not NAME : NAME . NAME ( f\" Testing mode active, but TESTING_PROFILE_ID not configured. Skipping { NAME } . \" ) NAME = False NAME = LIT # Check if current profile matches testing profile elif NAME != NAME : NAME = False NAME = ( f\" skipped (testing_mode_filter: not { NAME } ) \" ) NAME . NAME ( f\" Testing Mode: Skipping send to { NAME } ( { NAME } ). \" ) # Production mode checks elif NAME == LIT and ( NAME and NAME == NAME ) : NAME = False NAME = ( f\" skipped (production_mode_filter: is { NAME } ) \" ) NAME . NAME ( f\" Production Mode: Skipping send to test profile { NAME } ( { NAME } ). \" ) # `dry_run` mode is handled internally by _send_message_via_api # --- Step 5: Send/Simulate Message --- if NAME : NAME . NAME ( f\" Processing { NAME } : Sending/Simulating ' { NAME } ' ( { NAME } )... \" ) # Determine existing conversation ID (prefer OUT log, fallback IN log) NAME = None if NAME : NAME = NAME ( NAME , LIT , None ) if NAME is None and NAME : NAME = NAME ( NAME , LIT , None ) # Use safe API call with proactive validation NAME = f\" Action8: { NAME . NAME } # { NAME . NAME } \" NAME , NAME = NAME ( NAME , NAME , f\" send_message_ { NAME . NAME } \" , NAME , NAME , NAME , NAME , NAME , ) if NAME and NAME : NAME , NAME = NAME else : # API call failed or validation failed NAME = LIT NAME = None NAME . NAME ( f\" API call failed for { NAME . NAME } : validation or execution error \" ) else : # If filtered out, use the skip reason as the status for logging NAME = NAME # Try to get a conv ID for logging consistency, or generate placeholder NAME = None if NAME : NAME = NAME ( NAME , LIT , None ) if NAME is None and NAME : NAME = NAME ( NAME , LIT , None ) if NAME is None : NAME = f\" skipped_ { NAME . NAME ( ) } \" # --- Step 6: Prepare Database Updates based on outcome --- if NAME in ( LIT , LIT , ) or NAME . NAME ( LIT ) : # Prepare new OUT log entry if message sent, simulated, or intentionally skipped by filter NAME = NAME . NAME ( NAME ) if ( not NAME ) : # Should not happen if templates loaded correctly NAME . NAME ( f\" CRITICAL: MessageTemplate ID missing for key ' { NAME } ' for { NAME } . \" ) raise NAME ( LIT ) if ( not NAME ) : # Should be set by _send_message_via_api or placeholder NAME . NAME ( f\" CRITICAL: effective_conv_id missing after successful send/simulation/skip for { NAME } . \" ) raise NAME ( LIT ) # Log content: Prepend skip reason if skipped, otherwise use message text NAME = ( f\" [ { NAME . NAME ( ) } ] { NAME } \" if not NAME else NAME ) [ : NAME . NAME ] # Truncate NAME = NAME . NAME ( NAME . NAME ) NAME . NAME ( f\" Preparing new OUT log entry for ConvID { NAME } , PersonID { NAME . NAME } \" ) # CONSOLIDATED LOGGING: Create enhanced script_message_status with template details NAME = f\" { NAME } | Template: { NAME } ( { NAME } ) \" # Create the ConversationLog OBJECT directly NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME . NAME , NAME = NAME , NAME = NAME , NAME = None , # Not applicable for OUT messages NAME = NAME , NAME = NAME , # CONSOLIDATED: Include template selection details # updated_at handled by default/onupdate in model ) # Determine overall status and potential person status update if NAME == LIT : # If Desist ACK sent/simulated, stage person update to ARCHIVE NAME . NAME ( f\" Staging Person status update to ARCHIVE for { NAME } (ACK sent/simulated). \" ) NAME = ( NAME , NAME . NAME ) NAME = LIT # Specific status for ACK elif NAME : # Standard message sent/simulated successfully NAME = LIT else : # Standard message skipped by filter NAME = LIT # Use 'skipped' status string else : # Handle actual send failure reported by _send_message_via_api NAME . NAME ( f\" Message send failed for { NAME } with status ' { NAME } '. No DB changes staged. \" ) NAME = LIT # Indicate send error # Step 7: Return prepared updates and status return NAME , NAME , NAME # --- Step 8: Handle clean exits via StopIteration --- except NAME as NAME : NAME = ( NAME ( NAME . NAME ) if NAME . NAME else LIT ) # Get status string from exception value # logger.debug(f\"{log_prefix}: Processing stopped cleanly with status '{status_val}'.\") return None , None , NAME # Return None for updates, status string # --- Step 9: Handle unexpected errors --- except NAME as NAME : NAME . NAME ( f\" Unexpected critical error processing { NAME } : { NAME } \" , NAME = True ) return None , None , LIT # Return None, None, 'error'"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "format_predicted_relationship",
      "lineno": 2301,
      "end_lineno": 2332,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 7,
      "loc": 32,
      "tags": [
        "pure-ish",
        "regex",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "(rel_str)",
      "fingerprint": "fa6eeb91befc9c5fef43359c7ea0605c2596e5f7",
      "simhash64": 7452291963450463787,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : if not NAME or NAME == LIT : return LIT # Check if the string contains a percentage in brackets import NAME NAME = NAME . NAME ( LIT , NAME ) if NAME : try : # Extract the percentage value NAME = NAME ( NAME . NAME ( LIT ) ) # Fix percentage formatting based on the value range if NAME > LIT : # Values like 9900.0% should be 99.0% NAME = NAME / LIT return NAME . NAME ( LIT , f\" [ { NAME : .1f } %] \" , NAME ) if NAME < LIT : # Values like 0.99% should be 99.0% NAME = NAME * LIT return NAME . NAME ( LIT , f\" [ { NAME : .1f } %] \" , NAME ) # If percentage is between 1-100, it's already correct except ( NAME , NAME ) : pass # Return the original string if no percentage found or couldn't be processed return NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "send_messages_to_matches",
      "lineno": 2599,
      "end_lineno": 3166,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 75,
      "loc": 568,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "(session_manager)",
      "fingerprint": "06a76a91965cabf01aae458130f5338e6491c33a",
      "simhash64": 7452151225961059355,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT # --- Step 1: Initialization and System Health Check --- NAME . NAME ( LIT ) # Start performance monitoring NAME ( ) # Visibility of mode and interval from NAME import NAME with NAME ( NAME ) : NAME . NAME ( f\" Action 8: APP_MODE= { NAME ( NAME , LIT , LIT ) } , MIN_MESSAGE_INTERVAL= { NAME } \" ) # CRITICAL FIX: Comprehensive system health validation before proceeding if not NAME ( NAME ) : NAME . NAME ( LIT ) return False # Validate prerequisites if not NAME : NAME . NAME ( LIT ) return False # Use safe_column_value to get profile_id NAME = None if NAME ( NAME , LIT ) : NAME = NAME ( NAME , LIT , None ) if not NAME : # TEMPORARY: Use a test profile ID for debugging message progression NAME = LIT NAME . NAME ( LIT ) if not NAME : NAME . NAME ( LIT ) return False # TEMPORARY: Skip login check for debugging message progression # if ( #     login_status(session_manager, disable_ui_fallback=True) is not True # ):  # API check only for speed #     logger.error(\"Action 8: Not logged in.\") #     return False NAME . NAME ( LIT ) # Counters for summary NAME , NAME , NAME , NAME = LIT , LIT , LIT , LIT NAME = LIT # Lists for batch DB operations NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] # Store prepared Log DICTIONARIES NAME : NAME [ NAME , NAME ] = ( { } ) # Store {person_id: new_status_enum} # Configuration NAME = LIT NAME = False # Track if a commit fails critically NAME = LIT NAME = NAME ( LIT , NAME . NAME ) # Ensure positive batch size # Limit number of messages *successfully sent* (sent + acked) in one run (0 = unlimited) NAME = NAME . NAME # Reuse MAX_INBOX setting NAME = True # Track overall process success # MEMORY MANAGEMENT: Set maximum memory limits for batch processing NAME = LIT # Maximum 50MB per batch NAME = NAME ( NAME , LIT ) # Cap at 100 items per batch NAME = LIT # RESOURCE MANAGEMENT: Initialize resource manager NAME = NAME ( ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) # ERROR CATEGORIZATION: Initialize error categorizer NAME = NAME ( ) # Add monitoring hook for critical errors def NAME ( NAME : NAME [ NAME , NAME ] ) -> None : if NAME [ LIT ] == LIT : NAME . NAME ( f\" \ud83d\udea8 CRITICAL ALERT: { NAME [ LIT ] } - { NAME [ LIT ] } \" ) NAME . NAME ( NAME ) # --- Step 2: Get DB Session and Pre-fetch Data --- NAME : NAME [ NAME ] = None # Use Session type hint try : NAME = NAME . NAME ( ) if not NAME : # Log critical error if session cannot be obtained NAME . NAME ( LIT ) # Ensure cleanup if needed, though SessionManager handles pool return False # Abort if DB session fails # Get simplified messaging data (templates and candidates) try : NAME , NAME = NAME ( NAME , NAME ) except NAME as NAME : NAME . NAME ( f\" \ud83d\udea8 CRITICAL: Session death cascade detected during prefetch: { NAME } \" ) # Ensure session is returned on cascade failure if NAME : NAME . NAME ( NAME ) return False # Hard fail on cascade detection # Validate simplified data if NAME is None or NAME is None : NAME . NAME ( LIT ) if NAME : NAME . NAME ( NAME ) return False NAME = NAME ( NAME ) if NAME == LIT : NAME . NAME ( LIT ) # No candidates is considered a successful run else : NAME . NAME ( f\" Action 8: Found { NAME } candidates to process. \" ) # Log limit if applicable if NAME > LIT : NAME . NAME ( f\" Action 8: Will send/ack a maximum of { NAME } messages this run.\\n \" ) # --- Step 3: Main Processing Loop --- if NAME > LIT : # Setup progress bar import NAME # Local import to avoid scope issues NAME = { LIT : NAME , LIT : LIT , # Add a description LIT : LIT , LIT : True , LIT : True , LIT : LIT , LIT : NAME . NAME , } NAME . NAME ( LIT ) with NAME ( ) , NAME ( ** NAME ) as NAME : for NAME in NAME : NAME += LIT if NAME : # Update bar for remaining skipped items due to critical error NAME = NAME - NAME + LIT NAME += NAME if NAME : NAME . NAME ( f\" ERROR: DB commit failed - Sent= { NAME } ACK= { NAME } Skip= { NAME } Err= { NAME } \" ) NAME . NAME ( NAME ) break # Stop if previous batch commit failed # --- BROWSER HEALTH MONITORING (Action 6 Pattern) --- # Check browser health periodically during message processing if NAME % LIT == LIT and not NAME . NAME ( ) : # Check every 5 messages (improved from 10) NAME . NAME ( f\" \ud83d\udea8 BROWSER DEATH DETECTED during message processing at person { NAME } \" ) # Attempt browser recovery if NAME . NAME ( ) : NAME . NAME ( f\" \u2705 Browser recovery successful at person { NAME } - continuing \" ) else : NAME . NAME ( f\" \u274c Browser recovery failed at person { NAME } - halting messaging \" ) NAME = True NAME = False NAME = NAME - NAME + LIT NAME += NAME if NAME : NAME . NAME ( f\" ERROR: Browser failed - Sent= { NAME } ACK= { NAME } Skip= { NAME } Err= { NAME } \" ) NAME . NAME ( NAME ) break # Exit processing loop # --- RESOURCE MANAGEMENT --- # Perform periodic maintenance every 10 messages if NAME % LIT == LIT : NAME . NAME ( ) # --- Check Max Send Limit --- NAME = NAME + NAME if ( NAME > LIT and NAME >= NAME ) : # Only log the limit message once if not NAME ( NAME , LIT ) : NAME . NAME ( f\" Message sending limit ( { NAME } ) reached. Skipping remaining. \" ) NAME . NAME = True # Mark as logged # Increment skipped count for this specific skipped item NAME += LIT # Update description and bar, then continue to next person if NAME : NAME . NAME ( f\" Limit reached: Sent= { NAME } ACK= { NAME } Skip= { NAME } Err= { NAME } \" ) NAME . NAME ( LIT ) continue # Skip processing this person # --- Process Single Person --- # CRITICAL FIX: Check for halt signal before processing each person (Action 6 pattern) if NAME . NAME ( ) : NAME = NAME . NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" \ud83d\udea8 HALT SIGNAL DETECTED: Stopping person processing at { NAME } / { NAME } . \" f\" Cascade count: { NAME } . Emergency termination triggered. \" ) break # Exit processing loop immediately # Log progress every 5% or every 100 people if NAME > LIT and ( NAME % NAME ( LIT , NAME // LIT ) == LIT ) : NAME . NAME ( f\" Action 8 Progress: { NAME } / { NAME } processed \" f\" (Sent= { NAME } ACK= { NAME } Skip= { NAME } Err= { NAME } ) \" ) # _process_single_person still returns a ConversationLog object or None # Convert person.id to Python int for dictionary lookup using our safe helper NAME = NAME ( NAME , LIT , LIT ) # CRITICAL FIX: Ensure person_id is always a Python int (same as prefetch mapping) NAME = NAME ( NAME ) # Get message history for this person NAME , NAME , NAME = NAME ( NAME , NAME ) # --- PERFORMANCE TRACKING (Action 6 Pattern) --- import NAME NAME = NAME . NAME ( ) try : NAME , NAME , NAME = ( NAME ( NAME , NAME , NAME , NAME , NAME , NAME , NAME , ) ) except NAME as NAME : NAME = NAME ( NAME , LIT , LIT ) NAME . NAME ( f\" \ud83d\udea8 SESSION DEATH CASCADE in person processing for { NAME } : { NAME } . \" f\" Halting remaining processing to prevent infinite cascade. \" ) break # Exit processing loop immediately # Log the message creation for debugging if NAME and NAME ( NAME , LIT ) and NAME . NAME == NAME . NAME : # Get template info for logging NAME = LIT if NAME . NAME : NAME = NAME . NAME ( NAME ) . NAME ( NAME . NAME == NAME . NAME ) . NAME ( ) if NAME : NAME = NAME . NAME NAME . NAME ( f\" Created new OUT message for Person { NAME } : { NAME } \" ) # Update performance tracking NAME = NAME . NAME ( ) - NAME NAME ( NAME , NAME ) # --- Tally Results & Collect DB Updates --- NAME : NAME [ NAME [ NAME , NAME ] ] = None if NAME : try : # Convert the SQLAlchemy object attributes to a dictionary NAME = { NAME . NAME : NAME ( NAME , NAME . NAME ) for NAME in NAME ( NAME ) . NAME . NAME if NAME ( NAME , NAME . NAME ) # Ensure attr exists } # Ensure required keys for commit_bulk_data are present and correct type if not NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , ] ) : raise NAME ( LIT ) if not NAME ( NAME [ LIT ] , NAME ) : raise NAME ( LIT ) # Pass Enum directly for direction, commit func handles it NAME [ LIT ] = NAME . NAME # Normalize timestamp just in case NAME = NAME [ LIT ] NAME [ LIT ] = ( NAME . NAME ( NAME . NAME ) if NAME . NAME else NAME . NAME ( NAME = NAME . NAME ) ) except NAME as NAME : NAME . NAME ( f\" Failed to convert ConversationLog object to dict for { NAME . NAME } : { NAME } \" , NAME = True , ) NAME = None # Prevent adding malformed data NAME = LIT # Treat as error if conversion fails # Update counters and collect data based on status if NAME == LIT : NAME += LIT if NAME : NAME . NAME ( NAME ) elif NAME == LIT : NAME += LIT if NAME : NAME . NAME ( NAME ) if NAME : NAME [ NAME [ LIT ] ] = ( NAME [ LIT ] ) else : # Use proper error categorization NAME , NAME = NAME . NAME ( NAME ) if NAME == LIT : NAME += LIT # If skipped due to filter/rules, still add the log entry if one was prepared if NAME : NAME . NAME ( NAME ) elif NAME == LIT : NAME += LIT NAME = False # Trigger monitoring alert for technical errors if NAME != LIT : NAME = LIT if LIT in NAME or LIT in NAME else LIT NAME . NAME ( NAME = NAME , NAME = f\" Technical error processing { NAME . NAME } : { NAME } \" , NAME = NAME ) else : # Unknown category - treat as error NAME += LIT NAME = False NAME . NAME ( f\" Unknown status category for { NAME . NAME } : { NAME } \" ) # Update progress bar description and advance bar if NAME : NAME . NAME ( f\" Processing: Sent= { NAME } ACK= { NAME } Skip= { NAME } Err= { NAME } \" ) NAME . NAME ( LIT ) # --- MEMORY TRACKING AND BATCH COMMIT LOGIC --- # Calculate current memory usage (rough estimate) import NAME NAME = NAME ( NAME ) + NAME ( NAME ) NAME = NAME . NAME ( NAME ) + NAME . NAME ( NAME ) NAME = NAME / ( LIT * LIT ) # Commit if we hit size, memory, or item limits NAME = ( NAME >= NAME or NAME >= NAME or NAME >= NAME ) if NAME : NAME += LIT NAME . NAME ( f\" Committing batch { NAME } : { NAME } items, { NAME : .1f } MB \" ) # Use safe commit with rollback protection NAME , NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = f\" Action 8 Batch { NAME } \" , NAME = NAME ) if NAME : # Commit successful - clear data and reset memory tracking NAME . NAME ( ) NAME . NAME ( ) NAME = LIT NAME . NAME ( f\" Batch { NAME } committed successfully: { NAME } logs, { NAME } persons \" ) else : # Commit failed - set critical error flag NAME . NAME ( f\" Batch { NAME } commit failed - halting processing \" ) NAME = True NAME = False break # Stop processing loop # --- End Main Person Loop --- # --- End Conditional Processing Block (if total_candidates > 0) --- # --- Step 4: Final Commit --- if not NAME and ( NAME or NAME ) : NAME += LIT NAME . NAME ( f\" Performing final commit for remaining items (Batch { NAME } )... \" ) # Use safe commit for final batch NAME , NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , NAME = NAME ) if NAME : # Final commit successful NAME . NAME ( ) NAME . NAME ( ) NAME . NAME ( f\" Action 8 Final commit executed (Logs Processed: { NAME } , Persons Updated: { NAME } ). \" ) else : NAME . NAME ( LIT ) NAME = False # --- Step 5: Handle Outer Exceptions (Action 6 Pattern) --- except NAME as NAME : NAME . NAME ( f\" Halting Action 8 due to excessive critical API failures: { NAME } \" , NAME = False , ) NAME = False except NAME as NAME : NAME . NAME ( f\" Browser session error in Action 8: { NAME } \" , NAME = True , ) NAME = False except NAME as NAME : NAME . NAME ( f\" API rate limit exceeded in Action 8: { NAME } \" , NAME = False , ) NAME = False except NAME as NAME : NAME . NAME ( f\" Authentication expired during Action 8: { NAME } \" , NAME = False , ) NAME = False except NAME as NAME : # Check for session death cascade one more time at top level if LIT in NAME ( NAME ) : NAME . NAME ( f\" \ud83d\udea8 SESSION DEATH CASCADE at Action 8 top level: { NAME } \" , NAME = False , ) else : NAME . NAME ( f\" Connection error during Action 8: { NAME } \" , NAME = True , ) NAME = False except NAME : NAME . NAME ( LIT ) NAME = False except NAME as NAME : NAME . NAME ( f\" CRITICAL: Unhandled error during Action 8 execution: { NAME } \" , NAME = True , ) NAME = False # Emergency resource cleanup on critical failure try : NAME . NAME ( ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Emergency resource cleanup failed: { NAME } \" ) # --- Step 6: Final Cleanup and Summary --- finally : if NAME : NAME . NAME ( NAME ) # Ensure session is returned # Log Summary # Adjust final skipped count if loop was stopped early by critical error if NAME and NAME > NAME : NAME = NAME - NAME NAME . NAME ( f\" Adding { NAME } unprocessed candidates to skipped count due to DB commit failure. \" ) NAME += NAME NAME ( LIT ) # Spacer NAME . NAME ( LIT ) NAME . NAME ( f\" Candidates Considered: { NAME } \" ) NAME . NAME ( f\" Candidates Processed in Loop: { NAME } \" ) NAME . NAME ( f\" Template Messages Sent/Simulated: { NAME } \" ) NAME . NAME ( f\" Desist ACKs Sent/Simulated: { NAME } \" ) NAME . NAME ( f\" Skipped (Rules/Filter/Limit/Error): { NAME } \" ) NAME . NAME ( f\" Errors during processing/sending: { NAME } \" ) NAME . NAME ( f\" Overall Action Success: { NAME } \" ) # Enhanced error reporting NAME = NAME . NAME ( ) if NAME [ LIT ] > LIT or NAME [ LIT ] > LIT : NAME . NAME ( LIT ) NAME . NAME ( f\" Technical Errors: { NAME [ LIT ] } \" ) NAME . NAME ( f\" Business Logic Skips: { NAME [ LIT ] } \" ) NAME . NAME ( f\" Error Rate: { NAME [ LIT ] : .1% } \" ) if NAME [ LIT ] : NAME . NAME ( f\" Most Common Issue: { NAME [ LIT ] } \" ) # Detailed breakdown NAME . NAME ( LIT ) for NAME , NAME in NAME [ LIT ] . NAME ( ) : if NAME > LIT : NAME . NAME ( f\" { NAME . NAME ( LIT , LIT ) . NAME ( ) } : { NAME } \" ) NAME . NAME ( LIT ) # Step 7: Final resource cleanup try : NAME . NAME ( ) NAME . NAME ( ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Final resource cleanup failed: { NAME } \" ) # Step 8: Stop performance monitoring and log summary try : NAME = NAME ( ) NAME . NAME ( LIT ) NAME . NAME ( f\" Runtime: { NAME . NAME ( LIT , LIT ) } \" ) NAME . NAME ( f\" Memory Peak: { NAME . NAME ( LIT , LIT ) : .1f } MB \" ) NAME . NAME ( f\" Operations Completed: { NAME . NAME ( LIT , LIT ) } \" ) NAME . NAME ( f\" API Calls: { NAME . NAME ( LIT , LIT ) } \" ) NAME . NAME ( f\" Errors: { NAME . NAME ( LIT , LIT ) } \" ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Performance monitoring summary failed: { NAME } \" ) # Step 9: Return overall success status return NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "critical_error_hook",
      "lineno": 2690,
      "end_lineno": 2692,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(alert_data)",
      "fingerprint": "3cc04809b2de111ae3758866e5aa1530dcce539b",
      "simhash64": 7452151226029225015,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> None : if NAME [ LIT ] == LIT : NAME . NAME ( f\" \ud83d\udea8 CRITICAL ALERT: { NAME [ LIT ] } - { NAME [ LIT ] } \" )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "action8_messaging_tests",
      "lineno": 3175,
      "end_lineno": 3712,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 34,
      "loc": 538,
      "tags": [
        "impure",
        "logging",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "eb9862424f62e29fd26c58389324608a4d51b539",
      "simhash64": 7488180024053765147,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( LIT , LIT ) def NAME ( ) -> None : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT ] from NAME import NAME return NAME ( NAME , NAME ( ) , LIT ) def NAME ( ) -> None : LIT NAME = [ ( None , LIT , LIT , LIT ) , ( NAME ( LIT , ( ) , { LIT : LIT } ) ( ) , LIT , LIT , LIT , ) , ( NAME ( LIT , ( ) , { } ) ( ) , LIT , LIT , LIT , ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME , NAME , NAME in NAME : try : NAME = NAME ( NAME , NAME , NAME ) NAME = NAME is not None or NAME == NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" Input: obj= { NAME ( NAME ) . NAME } , attr=' { NAME } ', default=' { NAME } ' \u2192 Result: { NAME ! NAME } \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u274c { NAME } \" ) NAME ( f\" Error: { NAME } \" ) NAME . NAME ( False ) raise NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } safe column value tests passed \" ) def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : NAME = NAME ( ) NAME = NAME ( NAME , NAME ) NAME = LIT if NAME else LIT NAME ( f\" { NAME } Message template loading \" ) NAME ( f\" Type: { NAME ( NAME ) . NAME } , Count: { NAME ( NAME ) if NAME else LIT } \" ) NAME . NAME ( NAME ) assert NAME , LIT except NAME as NAME : NAME ( LIT ) NAME ( f\" Error: { NAME } \" ) NAME . NAME ( False ) # Don't raise as templates file might not exist in test environment NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } message template loading tests passed \" ) def NAME ( ) -> None : LIT import NAME NAME ( LIT ) NAME = [ ] # Get the decorators applied to send_messages_to_matches NAME = NAME # Check if function has the expected attributes from decorators NAME = [ ( LIT , NAME ( NAME ) ) , ( LIT , NAME ( NAME , LIT ) or NAME ( NAME , LIT ) ) , ( LIT , NAME . NAME == LIT ) , ] for NAME , NAME in NAME : NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME . NAME ( NAME ) # Test that the function can be imported and called (basic validation) try : # Verify the function signature is intact NAME = NAME . NAME ( NAME ) NAME = LIT in NAME . NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } Function signature intact (has session_manager parameter) \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u274c Function signature validation failed: { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } circuit breaker configuration tests passed \" ) NAME ( LIT ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : # Test that MaxApiFailuresExceededError is available NAME = NAME is not None NAME = LIT if NAME else LIT NAME ( f\" { NAME } MaxApiFailuresExceededError class available \" ) NAME . NAME ( NAME ) # Test cascade detection string matching NAME = NAME ( LIT ) NAME = LIT in NAME ( NAME ) NAME = LIT if NAME else LIT NAME ( f\" { NAME } Cascade detection string matching \" ) NAME . NAME ( NAME ) # Test error inheritance NAME = NAME ( LIT , NAME = { LIT : LIT } ) NAME = NAME ( NAME , NAME ) NAME = LIT if NAME else LIT NAME ( f\" { NAME } MaxApiFailuresExceededError inherits from Exception \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u274c Session death cascade detection test failed: { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } cascade detection tests passed \" ) assert NAME ( NAME ) , LIT def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : # Test performance tracking function exists NAME = NAME ( NAME ) NAME = LIT if NAME else LIT NAME ( f\" { NAME } _update_messaging_performance function available \" ) NAME . NAME ( NAME ) # Test with mock session manager class NAME : pass NAME = NAME ( ) # Test performance tracking doesn't crash try : NAME ( NAME , LIT ) NAME = True except NAME : NAME = False NAME = LIT if NAME else LIT NAME ( f\" { NAME } Performance tracking executes without errors \" ) NAME . NAME ( NAME ) # Test attributes are created NAME = NAME ( NAME , LIT ) NAME = NAME ( NAME , LIT ) NAME = NAME ( NAME , LIT ) NAME = NAME and NAME and NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } Performance tracking attributes created \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u274c Performance tracking test failed: { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } performance tracking tests passed \" ) assert NAME ( NAME ) , LIT def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : # Test error classes are available NAME = [ NAME , NAME , NAME , NAME ] for NAME in NAME : try : # Handle different error class signatures if NAME == NAME : NAME = NAME ( LIT , NAME = { LIT : LIT } ) else : NAME = NAME ( LIT ) NAME = NAME ( NAME , NAME ) NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME . NAME } class works correctly \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u274c { NAME . NAME } class failed: { NAME } \" ) NAME . NAME ( False ) # Test enhanced recovery import NAME = NAME is not None NAME = LIT if NAME else LIT NAME ( f\" { NAME } Enhanced recovery decorator available \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u274c Enhanced error handling test failed: { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } enhanced error handling tests passed \" ) assert NAME ( NAME ) , LIT with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : # Test universal session monitor integration (now in SessionManager) try : from NAME . NAME import NAME NAME = NAME ( NAME , LIT ) except NAME : NAME = False NAME = LIT if NAME else LIT NAME ( f\" { NAME } Universal session health validation available \" ) NAME . NAME ( NAME ) # Test API call framework integration (now in core/api_manager.py) try : from NAME . NAME import NAME NAME = NAME is not None except NAME : NAME = False NAME = LIT if NAME else LIT NAME ( f\" { NAME } Universal API call framework available \" ) NAME . NAME ( NAME ) # Test error recovery patterns integration (now in core/enhanced_error_recovery.py) try : from NAME . NAME import NAME NAME = NAME is not None except NAME : NAME = False NAME = LIT if NAME else LIT NAME ( f\" { NAME } Universal error recovery patterns available \" ) NAME . NAME ( NAME ) # Test database session manager integration (now in core/database_manager.py) try : from NAME . NAME import NAME NAME = NAME is not None except NAME : NAME = False NAME = LIT if NAME else LIT NAME ( f\" { NAME } Universal database session manager available \" ) NAME . NAME ( NAME ) # Test performance monitoring integration from NAME import NAME NAME = NAME is not None NAME = LIT if NAME else LIT NAME ( f\" { NAME } Performance monitoring available \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u2717 Integration test failed: { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } integration tests passed \" ) assert NAME ( NAME ) , LIT NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) # Additional hardening tests integrated from test_action8_hardening.py def NAME ( ) -> None : from NAME . NAME import NAME # None session manager assert NAME ( None ) is False # type: ignore[arg-type] # Healthy mock NAME = NAME ( ) NAME . NAME . NAME = False NAME . NAME . NAME = True NAME . NAME = { LIT : LIT } for NAME in NAME ( NAME . NAME ( ) ) : NAME . NAME ( NAME , LIT ) assert NAME ( NAME ) is True # Death cascade NAME . NAME . NAME = True NAME . NAME . NAME = False NAME . NAME = { LIT : LIT } assert NAME ( NAME ) is False def NAME ( ) -> None : from NAME . NAME import NAME NAME = NAME ( ) NAME . NAME = LIT NAME . NAME = LIT NAME = NAME ( ) NAME . NAME = LIT NAME = NAME ( LIT , NAME , NAME ) assert NAME ( NAME , NAME ) and NAME . NAME ( LIT ) def NAME ( ) -> None : from NAME . NAME import NAME NAME = NAME ( ) NAME . NAME . NAME = True NAME . NAME = { LIT : LIT } NAME . NAME . NAME = False assert NAME ( NAME ) is False def NAME ( ) -> None : class NAME : def NAME ( NAME ) -> None : NAME . NAME = { LIT : LIT } NAME . NAME = lambda : False NAME . NAME = LIT def NAME ( NAME ) -> NAME : return True @ NAME def NAME ( NAME ) -> NAME : return NAME . NAME NAME = NAME ( NAME ( ) ) NAME = NAME . NAME ( ) assert NAME ( NAME , ( NAME , NAME ) ) and NAME >= LIT assert NAME . NAME ( ( LIT , LIT ) , LIT ) is True def NAME ( ) -> None : NAME = NAME ( ) NAME , NAME = NAME . NAME ( LIT ) assert NAME == LIT and LIT in NAME NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) def NAME ( ) -> None : import NAME as NAME class NAME ( NAME . NAME ) : def NAME ( NAME ) -> None : NAME ( ) . NAME ( ) NAME . NAME = [ ] def NAME ( NAME , NAME : NAME . NAME ) -> None : NAME . NAME . NAME ( NAME ) NAME = NAME ( ) NAME . NAME ( NAME . NAME ) NAME = NAME . NAME try : NAME . NAME ( NAME ) NAME . NAME ( NAME . NAME ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) finally : NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME = [ NAME . NAME for NAME in NAME . NAME ] # Under suppress_logging(), INFO may be muted; the invariant we require is no DEBUG at INFO level assert not NAME ( NAME == NAME . NAME for NAME in NAME ) def NAME ( ) -> None : import NAME as NAME class NAME ( NAME . NAME ) : def NAME ( NAME ) -> None : NAME ( ) . NAME ( ) NAME . NAME = [ ] def NAME ( NAME , NAME : NAME . NAME ) -> None : NAME . NAME . NAME ( ( NAME . NAME , NAME . NAME ( ) ) ) NAME = NAME ( ) NAME . NAME ( NAME . NAME ) NAME = NAME . NAME try : NAME . NAME ( NAME ) NAME . NAME ( NAME . NAME ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) finally : NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME = [ NAME for ( NAME , NAME ) in NAME . NAME ] NAME = [ NAME for ( NAME , NAME ) in NAME . NAME if NAME == NAME . NAME ] assert NAME . NAME not in NAME or NAME ( NAME ) == LIT NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_function_availability",
      "lineno": 3180,
      "end_lineno": 3189,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c920889f09a568367683cc570378d8be7bf8a4b1",
      "simhash64": 5145885975288648747,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT ] from NAME import NAME return NAME ( NAME , NAME ( ) , LIT )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_safe_column_value",
      "lineno": 3191,
      "end_lineno": 3233,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 43,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "494cbc32dfc024dd2ddc21faaa96e9d494e41ef3",
      "simhash64": 7469743413080265771,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ ( None , LIT , LIT , LIT ) , ( NAME ( LIT , ( ) , { LIT : LIT } ) ( ) , LIT , LIT , LIT , ) , ( NAME ( LIT , ( ) , { } ) ( ) , LIT , LIT , LIT , ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME , NAME , NAME in NAME : try : NAME = NAME ( NAME , NAME , NAME ) NAME = NAME is not None or NAME == NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" Input: obj= { NAME ( NAME ) . NAME } , attr=' { NAME } ', default=' { NAME } ' \u2192 Result: { NAME ! NAME } \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u274c { NAME } \" ) NAME ( f\" Error: { NAME } \" ) NAME . NAME ( False ) raise NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } safe column value tests passed \" )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_message_template_loading",
      "lineno": 3235,
      "end_lineno": 3261,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 27,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "8b0b0bfec41c6f72bae1bffeb8e9aa53ad1e2430",
      "simhash64": 8641101528660612155,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : NAME = NAME ( ) NAME = NAME ( NAME , NAME ) NAME = LIT if NAME else LIT NAME ( f\" { NAME } Message template loading \" ) NAME ( f\" Type: { NAME ( NAME ) . NAME } , Count: { NAME ( NAME ) if NAME else LIT } \" ) NAME . NAME ( NAME ) assert NAME , LIT except NAME as NAME : NAME ( LIT ) NAME ( f\" Error: { NAME } \" ) NAME . NAME ( False ) # Don't raise as templates file might not exist in test environment NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } message template loading tests passed \" )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_circuit_breaker_config",
      "lineno": 3263,
      "end_lineno": 3299,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 37,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "8210751b2d52d6abcbfa7ab3290ee009b3af9a25",
      "simhash64": 7488180022980023355,
      "normalized": "def NAME ( ) -> None : LIT import NAME NAME ( LIT ) NAME = [ ] # Get the decorators applied to send_messages_to_matches NAME = NAME # Check if function has the expected attributes from decorators NAME = [ ( LIT , NAME ( NAME ) ) , ( LIT , NAME ( NAME , LIT ) or NAME ( NAME , LIT ) ) , ( LIT , NAME . NAME == LIT ) , ] for NAME , NAME in NAME : NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME . NAME ( NAME ) # Test that the function can be imported and called (basic validation) try : # Verify the function signature is intact NAME = NAME . NAME ( NAME ) NAME = LIT in NAME . NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } Function signature intact (has session_manager parameter) \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u274c Function signature validation failed: { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } circuit breaker configuration tests passed \" )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_session_death_cascade_detection",
      "lineno": 3338,
      "end_lineno": 3369,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 32,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "9c28e29a4ed508457b4b76aefd5502a1b88e7702",
      "simhash64": 8641101528661660699,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : # Test that MaxApiFailuresExceededError is available NAME = NAME is not None NAME = LIT if NAME else LIT NAME ( f\" { NAME } MaxApiFailuresExceededError class available \" ) NAME . NAME ( NAME ) # Test cascade detection string matching NAME = NAME ( LIT ) NAME = LIT in NAME ( NAME ) NAME = LIT if NAME else LIT NAME ( f\" { NAME } Cascade detection string matching \" ) NAME . NAME ( NAME ) # Test error inheritance NAME = NAME ( LIT , NAME = { LIT : LIT } ) NAME = NAME ( NAME , NAME ) NAME = LIT if NAME else LIT NAME ( f\" { NAME } MaxApiFailuresExceededError inherits from Exception \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u274c Session death cascade detection test failed: { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } cascade detection tests passed \" ) assert NAME ( NAME ) , LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_performance_tracking",
      "lineno": 3371,
      "end_lineno": 3415,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 45,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "812b9f8058c5e447f8c2c883cea995bb881c1baa",
      "simhash64": 7488215207352112155,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : # Test performance tracking function exists NAME = NAME ( NAME ) NAME = LIT if NAME else LIT NAME ( f\" { NAME } _update_messaging_performance function available \" ) NAME . NAME ( NAME ) # Test with mock session manager class NAME : pass NAME = NAME ( ) # Test performance tracking doesn't crash try : NAME ( NAME , LIT ) NAME = True except NAME : NAME = False NAME = LIT if NAME else LIT NAME ( f\" { NAME } Performance tracking executes without errors \" ) NAME . NAME ( NAME ) # Test attributes are created NAME = NAME ( NAME , LIT ) NAME = NAME ( NAME , LIT ) NAME = NAME ( NAME , LIT ) NAME = NAME and NAME and NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } Performance tracking attributes created \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u274c Performance tracking test failed: { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } performance tracking tests passed \" ) assert NAME ( NAME ) , LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_enhanced_error_handling",
      "lineno": 3417,
      "end_lineno": 3457,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 41,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "8208a6efb7a98471314d3302c4448e58c81c1a0a",
      "simhash64": 7488215208425853979,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : # Test error classes are available NAME = [ NAME , NAME , NAME , NAME ] for NAME in NAME : try : # Handle different error class signatures if NAME == NAME : NAME = NAME ( LIT , NAME = { LIT : LIT } ) else : NAME = NAME ( LIT ) NAME = NAME ( NAME , NAME ) NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME . NAME } class works correctly \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u274c { NAME . NAME } class failed: { NAME } \" ) NAME . NAME ( False ) # Test enhanced recovery import NAME = NAME is not None NAME = LIT if NAME else LIT NAME ( f\" { NAME } Enhanced recovery decorator available \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u274c Enhanced error handling test failed: { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } enhanced error handling tests passed \" ) assert NAME ( NAME ) , LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_integration_with_shared_modules",
      "lineno": 3484,
      "end_lineno": 3544,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 61,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "8186f8bb2d278571146f309e224f0077b246daa7",
      "simhash64": 7488109654235845723,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) NAME = [ ] try : # Test universal session monitor integration (now in SessionManager) try : from NAME . NAME import NAME NAME = NAME ( NAME , LIT ) except NAME : NAME = False NAME = LIT if NAME else LIT NAME ( f\" { NAME } Universal session health validation available \" ) NAME . NAME ( NAME ) # Test API call framework integration (now in core/api_manager.py) try : from NAME . NAME import NAME NAME = NAME is not None except NAME : NAME = False NAME = LIT if NAME else LIT NAME ( f\" { NAME } Universal API call framework available \" ) NAME . NAME ( NAME ) # Test error recovery patterns integration (now in core/enhanced_error_recovery.py) try : from NAME . NAME import NAME NAME = NAME is not None except NAME : NAME = False NAME = LIT if NAME else LIT NAME ( f\" { NAME } Universal error recovery patterns available \" ) NAME . NAME ( NAME ) # Test database session manager integration (now in core/database_manager.py) try : from NAME . NAME import NAME NAME = NAME is not None except NAME : NAME = False NAME = LIT if NAME else LIT NAME ( f\" { NAME } Universal database session manager available \" ) NAME . NAME ( NAME ) # Test performance monitoring integration from NAME import NAME NAME = NAME is not None NAME = LIT if NAME else LIT NAME ( f\" { NAME } Performance monitoring available \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u2717 Integration test failed: { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } integration tests passed \" ) assert NAME ( NAME ) , LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_system_health_validation_hardening",
      "lineno": 3556,
      "end_lineno": 3572,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "801db8b7a1b5fd7fafbf3dbc6dda4ae242c02856",
      "simhash64": 7488144838607942675,
      "normalized": "def NAME ( ) -> None : from NAME . NAME import NAME # None session manager assert NAME ( None ) is False # type: ignore[arg-type] # Healthy mock NAME = NAME ( ) NAME . NAME . NAME = False NAME . NAME . NAME = True NAME . NAME = { LIT : LIT } for NAME in NAME ( NAME . NAME ( ) ) : NAME . NAME ( NAME , LIT ) assert NAME ( NAME ) is True # Death cascade NAME . NAME . NAME = True NAME . NAME . NAME = False NAME . NAME = { LIT : LIT } assert NAME ( NAME ) is False"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_confidence_scoring_hardening",
      "lineno": 3574,
      "end_lineno": 3582,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "9749193fe33c620cc651019398417ad4840cfafc",
      "simhash64": 7488109655309591571,
      "normalized": "def NAME ( ) -> None : from NAME . NAME import NAME NAME = NAME ( ) NAME . NAME = LIT NAME . NAME = LIT NAME = NAME ( ) NAME . NAME = LIT NAME = NAME ( LIT , NAME , NAME ) assert NAME ( NAME , NAME ) and NAME . NAME ( LIT )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_halt_signal_integration",
      "lineno": 3584,
      "end_lineno": 3590,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "f3910e81e2ae8a2568884a3f6821b9622d9dbcfd",
      "simhash64": 8641066343214789715,
      "normalized": "def NAME ( ) -> None : from NAME . NAME import NAME NAME = NAME ( ) NAME . NAME . NAME = True NAME . NAME = { LIT : LIT } NAME . NAME . NAME = False assert NAME ( NAME ) is False"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_real_api_manager_integration_minimal",
      "lineno": 3592,
      "end_lineno": 3606,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c8af18fcf9991b7d2b4bd0374ab97af6a522a39f",
      "simhash64": 7488215208425853987,
      "normalized": "def NAME ( ) -> None : class NAME : def NAME ( NAME ) -> None : NAME . NAME = { LIT : LIT } NAME . NAME = lambda : False NAME . NAME = LIT def NAME ( NAME ) -> NAME : return True @ NAME def NAME ( NAME ) -> NAME : return NAME . NAME NAME = NAME ( NAME ( ) ) NAME = NAME . NAME ( ) assert NAME ( NAME , ( NAME , NAME ) ) and NAME >= LIT assert NAME . NAME ( ( LIT , LIT ) , LIT ) is True"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "MockSessionManager.__init__",
      "lineno": 3594,
      "end_lineno": 3597,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "34bfd35a258d75966c51b0d09e0fbe4c281c4e5e",
      "simhash64": 7452257879729804819,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME = { LIT : LIT } NAME . NAME = lambda : False NAME . NAME = LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "MockSessionManager.is_sess_valid",
      "lineno": 3598,
      "end_lineno": 3599,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "60b972358941ddacc1e1e761e3b26511e23c05ba",
      "simhash64": 7488277301305443427,
      "normalized": "def NAME ( NAME ) -> NAME : return True"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "MockSessionManager.my_profile_id",
      "lineno": 3601,
      "end_lineno": 3602,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "c535505b83302f749df69716dfd6a90687463628",
      "simhash64": 7488145388363752531,
      "normalized": "def NAME ( NAME ) -> NAME : return NAME . NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_error_categorization_integration_minimal",
      "lineno": 3608,
      "end_lineno": 3611,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "20589254f69673bfa5839087bc6f3d38e7de6afe",
      "simhash64": 7488180024053765171,
      "normalized": "def NAME ( ) -> None : NAME = NAME ( ) NAME , NAME = NAME . NAME ( LIT ) assert NAME == LIT and LIT in NAME"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_logger_respects_info_level",
      "lineno": 3628,
      "end_lineno": 3649,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 22,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "0de241705970fa0e0999ae182a69c1650ebc00aa",
      "simhash64": 8641101527586874387,
      "normalized": "def NAME ( ) -> None : import NAME as NAME class NAME ( NAME . NAME ) : def NAME ( NAME ) -> None : NAME ( ) . NAME ( ) NAME . NAME = [ ] def NAME ( NAME , NAME : NAME . NAME ) -> None : NAME . NAME . NAME ( NAME ) NAME = NAME ( ) NAME . NAME ( NAME . NAME ) NAME = NAME . NAME try : NAME . NAME ( NAME ) NAME . NAME ( NAME . NAME ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) finally : NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME = [ NAME . NAME for NAME in NAME . NAME ] # Under suppress_logging(), INFO may be muted; the invariant we require is no DEBUG at INFO level assert not NAME ( NAME == NAME . NAME for NAME in NAME )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_ListHandler.__init__",
      "lineno": 3631,
      "end_lineno": 3633,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "e56812a2046d3b5237c40f0a078086690211bb89",
      "simhash64": 8623122834819822593,
      "normalized": "def NAME ( NAME ) -> None : NAME ( ) . NAME ( ) NAME . NAME = [ ]"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_ListHandler.emit",
      "lineno": 3634,
      "end_lineno": 3635,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "(self, record)",
      "fingerprint": "7ae82a83ea8493eedcd454aa58a4ee5898c4a01d",
      "simhash64": 8641136711958963267,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME ) -> None : NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "test_no_debug_when_info",
      "lineno": 3651,
      "end_lineno": 3673,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 23,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "0ee0b1d20753e809cd869b84f6d78a0fdd9169bb",
      "simhash64": 8641101527586874387,
      "normalized": "def NAME ( ) -> None : import NAME as NAME class NAME ( NAME . NAME ) : def NAME ( NAME ) -> None : NAME ( ) . NAME ( ) NAME . NAME = [ ] def NAME ( NAME , NAME : NAME . NAME ) -> None : NAME . NAME . NAME ( ( NAME . NAME , NAME . NAME ( ) ) ) NAME = NAME ( ) NAME . NAME ( NAME . NAME ) NAME = NAME . NAME try : NAME . NAME ( NAME ) NAME . NAME ( NAME . NAME ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) finally : NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME = [ NAME for ( NAME , NAME ) in NAME . NAME ] NAME = [ NAME for ( NAME , NAME ) in NAME . NAME if NAME == NAME . NAME ] assert NAME . NAME not in NAME or NAME ( NAME ) == LIT"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_ListHandler.__init__",
      "lineno": 3654,
      "end_lineno": 3656,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "e56812a2046d3b5237c40f0a078086690211bb89",
      "simhash64": 8623122834819822593,
      "normalized": "def NAME ( NAME ) -> None : NAME ( ) . NAME ( ) NAME . NAME = [ ]"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "_ListHandler.emit",
      "lineno": 3657,
      "end_lineno": 3658,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "(self, record)",
      "fingerprint": "d60c2de672c9e87b2c468f010e812f329f341358",
      "simhash64": 8640573766300509187,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME ) -> None : NAME . NAME . NAME ( ( NAME . NAME , NAME . NAME ( ) ) )"
    },
    {
      "module_path": "action8_messaging.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 3715,
      "end_lineno": 3717,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "cached_database_query",
      "lineno": 104,
      "end_lineno": 108,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(ttl)",
      "fingerprint": "8b14e3f124319c55c8a0191feb9823a7d669eea7",
      "simhash64": 7487687408476914731,
      "normalized": "def NAME ( NAME : NAME = LIT ) : LIT def NAME ( NAME ) : return NAME ( LIT , NAME = NAME ) ( NAME ) return NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "decorator",
      "lineno": 106,
      "end_lineno": 107,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(func)",
      "fingerprint": "7299a1680361842703f93ca0b0db1c1e37d563bc",
      "simhash64": 7487792965897585707,
      "normalized": "def NAME ( NAME ) : return NAME ( LIT , NAME = NAME ) ( NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "safe_column_value",
      "lineno": 146,
      "end_lineno": 167,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(obj, attr_name, default)",
      "fingerprint": "83ce45d7575359750b4c8dc0a7eb66b2ae2187d8",
      "simhash64": 7488250391724725251,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME = None ) -> NAME : LIT try : if NAME ( NAME , NAME ) : NAME = NAME ( NAME , NAME ) if NAME is None : return NAME return NAME return NAME except NAME : return NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "should_exclude_message",
      "lineno": 170,
      "end_lineno": 186,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(message_content)",
      "fingerprint": "3ccb24a4074943d3ee7131265d70b1695126f498",
      "simhash64": 8641102077342680115,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if not NAME : return False NAME = NAME . NAME ( ) # Check for exclusion keywords return NAME ( NAME . NAME ( ) in NAME for NAME in NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "ExtractedData.ensure_list_of_strings",
      "lineno": 285,
      "end_lineno": 291,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(cls, v)",
      "fingerprint": "715fe87da886a006e2f806ea668c2a51508a40ab",
      "simhash64": 7488180022980555795,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT if NAME is None : return [ ] if not NAME ( NAME , NAME ) : return [ ] return [ NAME ( NAME ) for NAME in NAME if NAME is not None ]"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "ExtractedData.get_all_names",
      "lineno": 293,
      "end_lineno": 299,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "bdcfe67285619d1f955880bc4864b1f667f47b99",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME = [ ] for NAME in NAME . NAME : NAME . NAME ( NAME . NAME ) NAME . NAME ( NAME . NAME ) return NAME ( NAME ( NAME ) )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "ExtractedData.get_all_locations",
      "lineno": 301,
      "end_lineno": 307,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "ba51cfb3761aa6d6f5abaa0317197f4f1cf300a1",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME = [ ] for NAME in NAME . NAME : if NAME . NAME : NAME . NAME ( NAME . NAME ) return NAME ( NAME ( NAME ) )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "AIResponse.ensure_tasks_list",
      "lineno": 318,
      "end_lineno": 324,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(cls, v)",
      "fingerprint": "715fe87da886a006e2f806ea668c2a51508a40ab",
      "simhash64": 7488180022980555795,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT if NAME is None : return [ ] if not NAME ( NAME , NAME ) : return [ ] return [ NAME ( NAME ) for NAME in NAME if NAME is not None ]"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "get_gedcom_data",
      "lineno": 331,
      "end_lineno": 378,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 6,
      "loc": 48,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "d59d478897b5d16fc294db26e240b32990a48497",
      "simhash64": 7488215207352120339,
      "normalized": "def NAME ( ) -> NAME [ NAME ] : LIT global NAME # Return cached data if already loaded if NAME is not None : return NAME # Check if GEDCOM path is configured NAME = NAME . NAME . NAME if not NAME : NAME . NAME ( LIT ) return None # Check if GEDCOM file exists if not NAME . NAME ( ) : NAME . NAME ( f\" GEDCOM file not found at { NAME } . Cannot load GEDCOM file. \" ) return None # Load GEDCOM data try : NAME . NAME ( f\" Loading GEDCOM file { NAME . NAME } (first time)... \" ) from NAME import NAME as NAME NAME = NAME ( NAME ( NAME ) ) if NAME : NAME . NAME ( LIT ) # Log some stats about the loaded data NAME . NAME ( f\" Index size: { NAME ( NAME ( NAME , LIT , { } ) ) } \" ) NAME . NAME ( f\" Pre-processed cache size: { NAME ( NAME ( NAME , LIT , { } ) ) } \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Error loading GEDCOM file: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_get_gedcom_data_for_search",
      "lineno": 390,
      "end_lineno": 398,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(gedcom_data)",
      "fingerprint": "c0421f780a17383fd23b16f2f065cf838f02aaf7",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME : LIT if NAME is None : NAME = NAME ( ) if not NAME : NAME = LIT NAME . NAME ( NAME ) raise NAME ( NAME ) return NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_parse_name_parts",
      "lineno": 401,
      "end_lineno": 406,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(name)",
      "fingerprint": "d5aafb6ca9deec6909a871943dc4b799eec4f939",
      "simhash64": 5182337013833446403,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME ( ) . NAME ( ) NAME = NAME [ LIT ] if NAME else LIT NAME = NAME [ - LIT ] if NAME ( NAME ) > LIT else LIT return NAME , NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_create_search_criteria",
      "lineno": 409,
      "end_lineno": 416,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(first_name, surname)",
      "fingerprint": "61e8a6d650053203326f2f8abd2a8f24816d3b9d",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] , NAME [ NAME , NAME ] ] : LIT NAME = { LIT : NAME . NAME ( ) if NAME else None , LIT : NAME . NAME ( ) if NAME else None , } NAME = NAME . NAME ( ) return NAME , NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_get_scoring_config",
      "lineno": 419,
      "end_lineno": 426,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "31878274af8b60c1d5202b770c460c0bf149d74c",
      "simhash64": 5146448955309462571,
      "normalized": "def NAME ( ) -> NAME [ NAME [ NAME , NAME ] , NAME [ NAME , NAME ] ] : LIT NAME = NAME . NAME NAME = { LIT : NAME ( NAME , LIT , LIT ) , LIT : NAME ( NAME , LIT , LIT ) , } return NAME , NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_prepare_indi_index",
      "lineno": 429,
      "end_lineno": 444,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(gedcom_data)",
      "fingerprint": "d410cff76ee54fe74b6ce0cc401d74a9deaabaca",
      "simhash64": 7487617073026606115,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not ( NAME and NAME ( NAME , LIT ) and NAME . NAME and NAME ( NAME . NAME , LIT ) ) : return None # Convert to dict if it's not already to ensure it's iterable return ( NAME ( NAME . NAME ) if not NAME ( NAME . NAME , NAME ) else NAME . NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_matches_filter_criteria",
      "lineno": 447,
      "end_lineno": 461,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(indi_data, filter_criteria)",
      "fingerprint": "8209c16a17fdd8234b32614e780d88b2ad5062ff",
      "simhash64": 7488180023047140387,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT # Skip individuals with no name if not NAME . NAME ( LIT ) and not NAME . NAME ( LIT ) : return False # Simple OR filter: match on first name OR surname NAME = NAME [ LIT ] and NAME . NAME ( LIT , LIT ) . NAME ( ) . NAME ( NAME [ LIT ] ) NAME = NAME [ LIT ] and NAME . NAME ( LIT , LIT ) . NAME ( ) . NAME ( NAME [ LIT ] ) return NAME or NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_create_match_record",
      "lineno": 464,
      "end_lineno": 486,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 23,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(indi_id, indi_data, total_score, field_scores, reasons)",
      "fingerprint": "cae4f024aa7639b31f2339999d5879239bdd7222",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME , LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME , LIT : NAME , LIT : NAME , LIT : LIT , }"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_process_individuals_for_name",
      "lineno": 489,
      "end_lineno": 530,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 8,
      "loc": 42,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(name, gedcom_data)",
      "fingerprint": "8beaea90e7802cfcb45880639642ecd7577ce709",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME or NAME ( NAME . NAME ( ) ) < LIT : return [ ] NAME , NAME = NAME ( NAME ) NAME , NAME = NAME ( NAME , NAME ) NAME , NAME = NAME ( ) NAME = NAME ( NAME ) if not NAME : return [ ] NAME = [ ] for NAME , NAME in NAME . NAME ( ) : try : if NAME ( NAME , NAME ) : # Calculate match score NAME , NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) # Only include if score is above threshold if NAME > LIT : NAME = NAME ( NAME , NAME , NAME , NAME , NAME ) NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error processing individual { NAME } : { NAME } \" ) continue # Sort matches by score (highest first) and take top 3 NAME . NAME ( NAME = lambda NAME : NAME [ LIT ] , NAME = True ) return NAME [ : LIT ]"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_search_gedcom_for_names",
      "lineno": 533,
      "end_lineno": 556,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(names, gedcom_data)",
      "fingerprint": "099148b0ee891a4633d0369642d0184a849e4872",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME [ NAME ] = None ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = NAME ( NAME ) NAME . NAME ( f\" Searching GEDCOM data for: { NAME } \" ) try : NAME = [ ] # For each name, create a simple search criteria and filter individuals for NAME in NAME : NAME = NAME ( NAME , NAME ) NAME . NAME ( NAME ) return NAME except NAME as NAME : NAME = f\" Error searching GEDCOM file: { NAME } \" NAME . NAME ( NAME , NAME = True ) raise NAME ( NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_validate_api_search_parameters",
      "lineno": 559,
      "end_lineno": 572,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 14,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(session_manager, names)",
      "fingerprint": "2960af69fea8473903ca376128c820007b0b73e1",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME [ NAME [ NAME ] ] ) -> NAME [ NAME ] : LIT if not NAME : NAME = LIT NAME . NAME ( NAME ) raise NAME ( NAME ) NAME = NAME or [ ] if not NAME : NAME = LIT NAME . NAME ( NAME ) raise NAME ( NAME ) return NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_validate_api_configuration",
      "lineno": 575,
      "end_lineno": 591,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "cc40dfa7d581f259c00bbb18c7c65bc16be64520",
      "simhash64": 7488109654235845659,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME , NAME ] : LIT # Get owner tree ID from session manager NAME = NAME ( NAME , LIT , None ) if not NAME : NAME = LIT NAME . NAME ( NAME ) raise NAME ( NAME ) # Get base URL from config NAME = NAME ( NAME . NAME , LIT , LIT ) . NAME ( LIT ) if not NAME : NAME = LIT NAME . NAME ( NAME ) raise NAME ( NAME ) return NAME , NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_create_api_search_criteria",
      "lineno": 594,
      "end_lineno": 611,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 18,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(name)",
      "fingerprint": "8e8a18bd1336d2ed9416a2431c05da5d9a070be8",
      "simhash64": 7488180023047132195,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME or NAME ( NAME . NAME ( ) ) < LIT : return None # Split name into first name and surname if possible NAME = NAME . NAME ( ) . NAME ( ) NAME = NAME [ LIT ] if NAME else LIT NAME = NAME [ - LIT ] if NAME ( NAME ) > LIT else LIT # Skip if both first name and surname are empty if not NAME and not NAME : return None return { LIT : NAME , LIT : NAME , }"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_process_api_search_results",
      "lineno": 614,
      "end_lineno": 629,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(api_results, search_criteria)",
      "fingerprint": "236ff3434b44b4424b6b8fd0f273fa7efcde2306",
      "simhash64": 5146308217082917975,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME : return [ ] # Process and score the API results if they exist NAME = NAME ( NAME , NAME ) # Take top 3 results NAME = NAME [ : LIT ] if NAME else [ ] # Add source information for NAME in NAME : NAME [ LIT ] = LIT return NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_search_single_name_via_api",
      "lineno": 632,
      "end_lineno": 653,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(name)",
      "fingerprint": "c3e98693ad1ec8769efb304b5de2a8978a1a7f8f",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = NAME ( NAME ) if not NAME : return [ ] # Call the API search function from action11 # NOTE: _search_ancestry_api function does not exist, so return empty results NAME = [ ] NAME . NAME ( f\" API search functionality not available for: { NAME } \" ) if NAME is None : NAME = f\" API search failed for name: { NAME } \" NAME . NAME ( NAME ) raise NAME ( NAME ) # Empty results are OK - just log and continue if not NAME : NAME . NAME ( f\" API search returned no results for name: { NAME } \" ) return [ ] return NAME ( NAME , NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_search_api_for_names",
      "lineno": 656,
      "end_lineno": 691,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 36,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(session_manager, names)",
      "fingerprint": "11acdc5ba3ec488db341cb6aa03b74a59c295b38",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME [ NAME ] = None , NAME : NAME [ NAME [ NAME ] ] = None , ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = NAME ( NAME , NAME ) NAME ( NAME ) NAME . NAME ( f\" Searching Ancestry API for: { NAME } \" ) try : NAME = [ ] # For each name, create a search criteria and search the API for NAME in NAME : NAME = NAME ( NAME ) NAME . NAME ( NAME ) return NAME except NAME as NAME : NAME = f\" Error searching Ancestry API: { NAME } \" NAME . NAME ( NAME , NAME = True ) raise NAME ( NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "DatabaseState.__post_init__",
      "lineno": 735,
      "end_lineno": 739,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "0d2fbbc7dcbd878b113456f2293a6a807ec95e69",
      "simhash64": 8606199180298728465,
      "normalized": "def NAME ( NAME ) -> None : if NAME . NAME is None : NAME . NAME = [ ] if NAME . NAME is None : NAME . NAME = { }"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "MessageConfig.__post_init__",
      "lineno": 750,
      "end_lineno": 752,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "9615b2d2207dc461dc0c3b60b469c9681d370f55",
      "simhash64": 8606375103165797395,
      "normalized": "def NAME ( NAME ) -> None : if NAME . NAME is None : NAME . NAME = { }"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor.__init__",
      "lineno": 763,
      "end_lineno": 778,
      "is_method": true,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 16,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self, session_manager, db_state, msg_config, ms_state)",
      "fingerprint": "b48779bc5c983d3fc56acdf21d7ed19b97d06a25",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , ) -> None : NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = ( NAME . NAME . NAME ( ) if NAME . NAME else LIT )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor.process_person",
      "lineno": 780,
      "end_lineno": 835,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 9,
      "loc": 56,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, person, progress_bar)",
      "fingerprint": "124677f267f6e021d74c4aad854c350fb6572196",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME = None ) -> NAME [ NAME , NAME ] : LIT NAME = f\" Productive: { NAME . NAME } # { NAME . NAME } \" try : # Apply rate limiting (defensive: dynamic_rate_limiter may be None in some contexts) try : NAME = NAME ( NAME . NAME , LIT , None ) if NAME is not None : NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" { NAME } : Rate limiter unavailable or failed: { NAME } \" ) # Get message context NAME = NAME . NAME ( NAME , NAME ) if not NAME : return False , LIT # Check exclusions and status if NAME . NAME ( NAME , NAME , NAME ) : return False , LIT # Process with AI NAME = NAME . NAME ( NAME , NAME , NAME ) if not NAME : return False , LIT NAME , NAME = NAME # Log-only: assess suggested_tasks quality before any task creation (no behavior change) try : NAME ( NAME , NAME , NAME ) NAME ( NAME , NAME ) except NAME as NAME : NAME . NAME ( f\" { NAME } : Task quality audit unavailable: { NAME } \" ) # Create MS Graph tasks NAME . NAME ( NAME , NAME , NAME , NAME ) # Generate and send response NAME = NAME . NAME ( NAME , NAME , NAME , NAME , NAME ) if not NAME : return False , LIT return True , LIT except NAME as NAME : NAME . NAME ( f\" Error processing { NAME } : { NAME } \" , NAME = True ) return False , f\" error: { NAME ! NAME } \""
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._get_context_logs",
      "lineno": 837,
      "end_lineno": 849,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, person, log_prefix)",
      "fingerprint": "7a56194d8e15b0e8f783243f974c42f2aac4de17",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME ] ] : LIT if NAME . NAME . NAME is None : NAME . NAME ( f\" Database session is None for { NAME } \" ) return None NAME = NAME ( NAME . NAME . NAME , NAME . NAME ) if not NAME : NAME . NAME ( f\" Skipping { NAME } : Failed to retrieve message context. \" ) return NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._should_skip_person",
      "lineno": 851,
      "end_lineno": 894,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 6,
      "loc": 44,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, person, context_logs, log_prefix)",
      "fingerprint": "9433f0bbc260cfa4093e833b91dfdca0b5698f25",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME ) -> NAME : LIT # Check person status NAME = [ NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , ] if NAME . NAME in NAME : NAME . NAME ( f\" { NAME } : Person has status { NAME . NAME } . Skipping. \" ) return True # Get latest message NAME = NAME . NAME ( NAME ) if not NAME : return True # Check if custom reply already sent NAME = NAME ( NAME , LIT , None ) if NAME is not None : NAME . NAME ( f\" { NAME } : Custom reply already sent. Skipping. \" ) return True # Check for exclusion keywords NAME = NAME ( NAME , LIT , LIT ) if NAME ( NAME ) : NAME . NAME ( f\" { NAME } : Message contains exclusion keyword. Skipping. \" ) return True # Check if OTHER message with no mentioned names NAME = NAME ( NAME , LIT , None ) if NAME == NAME : # We'll handle this in the AI processing step pass return False"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._get_latest_incoming_message",
      "lineno": 896,
      "end_lineno": 904,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self, context_logs)",
      "fingerprint": "8ca8c8fcc1e801ac109c26d94bb0daaabbb0adcf",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] ) -> NAME [ NAME ] : LIT for NAME in NAME ( NAME ) : NAME = NAME ( NAME , LIT , None ) if NAME == NAME . NAME : return NAME return None"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._process_with_ai",
      "lineno": 906,
      "end_lineno": 964,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 7,
      "loc": 59,
      "tags": [
        "pure-ish",
        "json",
        "size:medium"
      ],
      "signature": "(self, person, context_logs, progress_bar)",
      "fingerprint": "9606894d5b6f1b37db75286af35f7f9227b4cabd",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME = None ) -> NAME [ NAME [ NAME [ NAME , NAME ] , NAME [ NAME ] ] ] : LIT if NAME : NAME . NAME ( f\" Processing { NAME . NAME } : Analyzing content \" ) # Check session validity if not NAME . NAME . NAME ( ) : NAME . NAME ( f\" Session invalid for { NAME . NAME } . Skipping. \" ) return None # Format context for AI NAME = NAME ( NAME , NAME . NAME ) # Call AI NAME . NAME ( f\" Calling AI for { NAME . NAME } ... \" ) NAME = NAME ( NAME , NAME . NAME ) # Process AI response NAME = NAME ( NAME , f\" { NAME . NAME } \" ) NAME = NAME [ LIT ] NAME = NAME [ LIT ] # Log results if NAME : NAME . NAME ( f\" Processed { NAME ( NAME ) } tasks for { NAME . NAME } \" ) NAME = { NAME : NAME ( NAME ) for NAME , NAME in NAME . NAME ( ) } NAME . NAME ( f\" Extracted entities for { NAME . NAME } : { NAME . NAME ( NAME ) } \" ) # Debug-only quality summary for interrogation try : from NAME import NAME NAME = NAME ( NAME ) NAME . NAME ( f\" Quality summary for { NAME . NAME } : \" f\" counts= { NAME . NAME ( LIT ) } , flags= { NAME . NAME ( LIT ) } \" ) except NAME as NAME : NAME . NAME ( f\" Quality summary unavailable: { NAME } \" ) # Store extracted data on person object for message personalization try : NAME . NAME = NAME NAME . NAME ( f\" Stored extracted genealogical data on person object for { NAME . NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Failed to store extracted data on person object: { NAME } \" ) return NAME , NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._create_ms_tasks",
      "lineno": 966,
      "end_lineno": 1145,
      "is_method": true,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 34,
      "loc": 180,
      "tags": [
        "pure-ish",
        "regex",
        "json",
        "purpose:factory",
        "size:large"
      ],
      "signature": "(self, person, suggested_tasks, log_prefix, progress_bar)",
      "fingerprint": "610ca70ddd43bf4d167352be8bb94d6f5f3e8c99",
      "simhash64": 7452151225962107931,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME = None , ) : LIT if not NAME : return if NAME : NAME . NAME ( f\" Processing { NAME . NAME } : Creating { NAME ( NAME ) } tasks \" ) # Initialize MS Graph if needed NAME . NAME ( ) if not NAME . NAME . NAME or not NAME . NAME . NAME : NAME . NAME ( f\" { NAME } : Skipping MS task creation - MS Auth/List ID unavailable. \" ) return # Optional guarded de-duplication (Phase 4.3) \u2014 only in testing mode and when flag enabled if ( NAME . NAME == LIT and NAME ( NAME , LIT , False ) and NAME ( NAME ) > LIT ) : try : NAME = NAME ( NAME ) NAME = { } for NAME in NAME : NAME = NAME ( NAME ) # Reuse same core transform as preview (lightweight subset) NAME = NAME . NAME ( LIT , LIT , NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) if NAME : NAME . NAME ( NAME , [ ] ) . NAME ( NAME ) # Keep first occurrence per core group NAME = [ NAME [ LIT ] for NAME in NAME . NAME ( ) ] if NAME ( NAME ) < NAME : NAME . NAME ( f\" { NAME } : Guarded de-dup (testing) reduced tasks { NAME } \u2192 { NAME ( NAME ) } \" ) NAME = NAME else : NAME . NAME ( f\" { NAME } : Guarded de-dup found no reductions \" ) except NAME as NAME : NAME . NAME ( f\" { NAME } : Guarded de-dup failed: { NAME } \" ) # Create tasks NAME = NAME . NAME if NAME == LIT : NAME . NAME ( f\" { NAME } : DRY RUN - Skipping MS To-Do task creation for { NAME ( NAME ) } tasks. \" ) return # Generate enhanced tasks if genealogical task generation is available NAME = [ ] if ( NAME and NAME ( NAME , LIT , False ) and NAME ( NAME , LIT ) and NAME ( NAME ) ) : try : NAME = NAME ( ) # type: ignore[call-arg] NAME = { LIT : NAME ( NAME , LIT , LIT ) } NAME = NAME ( NAME , LIT , { } ) # === PHASE 12: GEDCOM DATA INTEGRATION === NAME = None try : # Try to load GEDCOM data for enhanced task generation from NAME import NAME NAME = NAME ( ) if NAME : NAME . NAME ( f\" { NAME } : Using GEDCOM data for enhanced task generation \" ) except NAME as NAME : NAME . NAME ( f\" { NAME } : GEDCOM data not available for task generation: { NAME } \" ) # === PHASE 12.3: ENHANCED DATA INTEGRATION === NAME = NAME . NAME ( NAME , NAME , NAME , NAME ) # Apply intelligent task selection and validation NAME = NAME ( NAME , NAME , NAME , NAME ) # Validate and score task quality NAME = NAME ( NAME , NAME , NAME ) if NAME : NAME . NAME ( f\" { NAME } : Generated { NAME ( NAME ) } enhanced genealogical tasks \" ) # Log a small debug sample mapping original suggested tasks to enhanced outputs (Phase 4.4 completion instrumentation) try : NAME = NAME ( LIT , NAME ( NAME ) ) NAME = NAME [ : NAME ] NAME = [ ] for NAME in NAME ( NAME ) : NAME = NAME [ NAME ] NAME . NAME ( { LIT : NAME [ NAME ] if NAME < NAME ( NAME ) else None , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , } ) # Use json dumps to keep single-line structured debug output try : import NAME as NAME NAME . NAME ( f\" { NAME } : Task enrichment sample: { NAME . NAME ( NAME , NAME = False ) } \" ) except NAME : NAME . NAME ( f\" { NAME } : Task enrichment sample (fallback repr): { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" { NAME } : Failed to log enrichment sample: { NAME } \" ) else : NAME . NAME ( f\" { NAME } : No enhanced tasks generated, using standard tasks \" ) except NAME as NAME : NAME . NAME ( f\" { NAME } : Enhanced task generation failed: { NAME } , using standard tasks \" ) NAME = [ ] # Use enhanced tasks if available and enrichment flag enabled, otherwise fall back to standard tasks if NAME and NAME ( NAME , LIT , False ) : NAME . NAME ( f\" { NAME } : Creating { NAME ( NAME ) } enhanced MS To-Do tasks... \" ) for NAME , NAME in NAME ( NAME ) : NAME = NAME . NAME ( LIT , f\" Ancestry Research: { NAME . NAME or LIT } \" ) NAME = f\" { NAME . NAME ( LIT , LIT ) } \\n\\n--- Task Details ---\\nCategory: { NAME . NAME ( LIT , LIT ) } \\nPriority: { NAME . NAME ( LIT , LIT ) } \\nTemplate: { NAME . NAME ( LIT , LIT ) } \\n\\n--- Match Information ---\\nMatch: { NAME . NAME or LIT } (# { NAME . NAME } )\\nProfile: { NAME . NAME or LIT } \" NAME = NAME . NAME ( NAME . NAME . NAME , NAME . NAME . NAME , NAME , NAME , ) if NAME : NAME . NAME ( f\" { NAME } : Created enhanced task: { NAME [ : LIT ] } ... \" ) else : NAME . NAME ( f\" { NAME } : Failed to create enhanced MS task: ' { NAME [ : LIT ] } ...' \" ) else : # Fallback to standard task creation NAME . NAME ( f\" { NAME } : Creating { NAME ( NAME ) } standard MS To-Do tasks... \" ) for NAME , NAME in NAME ( NAME ) : NAME = ( f\" Ancestry Follow-up: { NAME . NAME or LIT } (# { NAME . NAME } ) \" ) NAME = f\" AI Suggested Task ( { NAME + LIT } / { NAME ( NAME ) } ): { NAME } \\n\\nMatch: { NAME . NAME or LIT } (# { NAME . NAME } )\\nProfile: { NAME . NAME or LIT } \" NAME = NAME . NAME ( NAME . NAME . NAME , NAME . NAME . NAME , NAME , NAME , ) if NAME : NAME . NAME ( f\" { NAME } : Created standard task: { NAME [ : LIT ] } ... \" ) else : NAME . NAME ( f\" { NAME } : Failed to create standard MS task: ' { NAME [ : LIT ] } ...' \" )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._initialize_ms_graph",
      "lineno": 1147,
      "end_lineno": 1166,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "f4d95767c0bc03aaff7d40303b1fddfdde106217",
      "simhash64": 8641101527586874387,
      "normalized": "def NAME ( NAME ) -> None : LIT if not NAME . NAME . NAME and not NAME . NAME . NAME : NAME . NAME ( LIT ) NAME . NAME . NAME = NAME . NAME ( ) NAME . NAME . NAME = True if not NAME . NAME . NAME : NAME . NAME ( LIT ) if NAME . NAME . NAME and not NAME . NAME . NAME : NAME . NAME ( f\" Looking up MS To-Do List ID for ' { NAME . NAME . NAME } '... \" ) NAME . NAME . NAME = NAME . NAME ( NAME . NAME . NAME , NAME . NAME . NAME ) if not NAME . NAME . NAME : NAME . NAME ( f\" Failed find/get MS List ID for ' { NAME . NAME . NAME } '. \" )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._handle_message_response",
      "lineno": 1168,
      "end_lineno": 1217,
      "is_method": true,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 50,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, person, context_logs, extracted_data, log_prefix, progress_bar)",
      "fingerprint": "50356f308f10de12eb0d2589ce87187c298cb8d6",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME = None , ) -> NAME : LIT # Get latest message NAME = NAME . NAME ( NAME ) if not NAME : return False # Check if this is an OTHER message with no mentioned names NAME = NAME ( NAME , LIT , None ) if NAME == NAME : NAME = NAME . NAME ( LIT , [ ] ) if not NAME : NAME . NAME ( f\" { NAME } : Message is 'OTHER' with no names. Marking as processed. \" ) NAME . NAME ( NAME ) return True # Successfully handled (by skipping) # Generate custom reply if person identified NAME = NAME . NAME ( NAME , NAME , NAME , NAME , NAME , NAME , ) # Format message (custom or standard acknowledgment) NAME , NAME = NAME . NAME ( NAME , NAME , NAME , NAME ) # Apply filtering and send message return NAME . NAME ( NAME , NAME , NAME , NAME , NAME , NAME , NAME , NAME , )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._mark_message_processed",
      "lineno": 1219,
      "end_lineno": 1227,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "time",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self, message)",
      "fingerprint": "e623051f177f47977681f7c0a27031f218de5b8f",
      "simhash64": 8641101527586874387,
      "normalized": "def NAME ( NAME , NAME : NAME ) : LIT try : if NAME . NAME . NAME : NAME . NAME = NAME . NAME ( NAME . NAME ) NAME . NAME . NAME . NAME ( NAME ) NAME . NAME . NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" Failed to mark message as processed: { NAME } \" )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._generate_custom_reply",
      "lineno": 1229,
      "end_lineno": 1297,
      "is_method": true,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 69,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, person, context_logs, extracted_data, latest_message, log_prefix, progress_bar)",
      "fingerprint": "609514837e1dc4ccc470ada413c181df8de1d22d",
      "simhash64": 7452080857216889875,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME : NAME , NAME = None , ) -> NAME [ NAME ] : LIT if NAME : NAME . NAME ( f\" Processing { NAME . NAME } : Identifying person \" ) # Try to identify a person mentioned in the message NAME = NAME ( NAME . NAME , NAME , NAME ) if not NAME : NAME . NAME ( f\" { NAME } : No person identified. Will use standard acknowledgement. \" ) return None # Check if custom responses are enabled if not NAME . NAME : NAME . NAME ( f\" { NAME } : Custom replies disabled via config. Using standard. \" ) return None if NAME : NAME . NAME ( f\" Processing { NAME . NAME } : Generating custom reply \" ) # Format genealogical data NAME = NAME ( NAME [ LIT ] , NAME [ LIT ] , ) # Get user's last message NAME = NAME ( NAME , LIT , LIT ) # Format context NAME = NAME ( NAME , NAME . NAME ) # Generate custom reply NAME = NAME ( NAME = NAME . NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) if NAME : NAME . NAME ( f\" { NAME } : Generated custom genealogical reply. \" ) else : NAME . NAME ( f\" { NAME } : Failed to generate custom reply. Will fall back. \" ) return NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._format_message",
      "lineno": 1299,
      "end_lineno": 1384,
      "is_method": true,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 13,
      "loc": 86,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "(self, person, extracted_data, custom_reply, log_prefix)",
      "fingerprint": "162dcf3e53848f1f2ab1b4285d5c49d8acedb48e",
      "simhash64": 7488109654235845659,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] , NAME : NAME , ) -> NAME [ NAME , NAME ] : LIT try : if NAME : # Add signature to custom reply NAME = NAME ( NAME , LIT , LIT ) NAME = NAME ( NAME , LIT , LIT ) NAME = f\" \\n { NAME } \" if NAME else LIT NAME = f\" \\n\\nBest regards,\\n { NAME } { NAME } \" NAME = NAME + NAME NAME = NAME . NAME . NAME NAME . NAME ( f\" { NAME } : Using custom genealogical reply with signature. \" ) else : # Use standard acknowledgement template # Get person name NAME = NAME ( NAME , LIT , LIT ) NAME = NAME ( NAME , LIT , LIT ) NAME = NAME ( NAME or NAME ) # Generate summary NAME = NAME ( NAME ) # Try enhanced personalized message formatting first NAME = None if NAME and NAME ( NAME , LIT ) : try : from NAME import NAME NAME = NAME ( ) # Check if we have an enhanced productive reply template NAME = LIT if NAME in NAME . NAME : NAME . NAME ( f\" Using enhanced productive reply template for { NAME } \" ) NAME = NAME ( NAME , LIT , { } ) NAME = { LIT : NAME ( NAME , LIT , LIT ) } NAME = { LIT : NAME , LIT : NAME } NAME = NAME . NAME ( NAME , NAME , NAME , NAME ) NAME . NAME ( f\" Successfully created personalized productive reply for { NAME } \" ) else : NAME . NAME ( f\" Enhanced template ' { NAME } ' not available \" ) except NAME as NAME : NAME . NAME ( f\" Enhanced productive reply formatting failed for { NAME } : { NAME } , falling back to standard \" ) NAME = None # Fallback to standard template formatting if not NAME : if ( NAME . NAME . NAME and NAME in NAME . NAME . NAME ) : NAME = NAME . NAME . NAME [ NAME ] . NAME ( NAME = NAME , NAME = NAME ) else : NAME = NAME ( NAME , LIT , LIT ) NAME = f\" Dear { NAME } ,\\n\\nThank you for your message!\\n\\n { NAME } \" NAME . NAME ( f\" { NAME } : Using standard acknowledgement template. \" ) NAME = NAME . NAME . NAME return NAME , NAME or LIT # Provide default except NAME as NAME : NAME . NAME ( f\" { NAME } : Message formatting error: { NAME } . Using fallback. \" ) # Simple fallback NAME = NAME ( NAME , LIT , LIT ) NAME = NAME ( NAME , LIT , LIT ) NAME = f\" Dear { NAME ( NAME ) } ,\\n\\nThank you for your message!\\n\\n { NAME } \" NAME = NAME . NAME . NAME or LIT # Provide default return NAME , NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._send_message",
      "lineno": 1386,
      "end_lineno": 1442,
      "is_method": true,
      "is_async": false,
      "args_count": 9,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 57,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, person, context_logs, message_text, message_template_id, custom_reply, latest_message, log_prefix, progress_bar)",
      "fingerprint": "36d51c2ef99504ecc196d2c3ca6a6f874294ef9c",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME , NAME = None , ) -> NAME : LIT # Apply mode/recipient filtering NAME , NAME = NAME . NAME ( NAME , NAME ) if NAME : if NAME : NAME . NAME ( f\" Processing { NAME . NAME } : Sending custom reply \" ) else : NAME . NAME ( f\" Processing { NAME . NAME } : Sending acknowledgement \" ) # Get conversation ID NAME = NAME . NAME ( NAME , NAME ) if not NAME : return False # Send or skip message if NAME : from NAME import NAME NAME , NAME = NAME ( NAME . NAME , NAME , NAME , NAME , f\" Action9: { NAME . NAME } # { NAME . NAME } \" , ) else : NAME = NAME NAME = NAME NAME . NAME ( f\" Skipping message to { NAME . NAME } : { NAME } \" ) # Handle database updates return NAME . NAME ( NAME , NAME , NAME , NAME , NAME or LIT , NAME , NAME , NAME , )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._should_send_message",
      "lineno": 1444,
      "end_lineno": 1464,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, person, log_prefix)",
      "fingerprint": "e31b7a0388ae1114ec533f3133e7877a49bea6d4",
      "simhash64": 7487617073026602035,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME NAME = NAME . NAME # Get current profile ID safely NAME = NAME ( NAME , LIT , LIT ) if NAME == LIT : if not NAME : return False , LIT if NAME != NAME ( NAME ) : return False , f\" skipped (testing_mode_filter: not { NAME } ) \" elif ( NAME == LIT and NAME and NAME == NAME ( NAME ) ) : return False , f\" skipped (production_mode_filter: is { NAME } ) \" return True , LIT"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._get_conversation_id",
      "lineno": 1466,
      "end_lineno": 1487,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 22,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, context_logs, log_prefix)",
      "fingerprint": "1846e37f3774bfa6201c44acf3985505ee56a790",
      "simhash64": 7452151225962107923,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME ) -> NAME [ NAME ] : LIT if not NAME : NAME . NAME ( f\" { NAME } : No context logs available for conversation ID. \" ) return None NAME = NAME [ - LIT ] . NAME if NAME is None : NAME . NAME ( f\" { NAME } : Conversation ID is None. \" ) return None try : return NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" { NAME } : Failed to convert conversation ID to string: { NAME } \" ) return None"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "PersonProcessor._stage_database_updates",
      "lineno": 1489,
      "end_lineno": 1566,
      "is_method": true,
      "is_async": false,
      "args_count": 9,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 11,
      "loc": 78,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, person, message_text, message_template_id, send_status, effective_conv_id, custom_reply, latest_message, log_prefix)",
      "fingerprint": "a53c3b91faccfb78e1dae7421ca4041afdfbca94",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME , ) -> NAME : LIT if not NAME : NAME . NAME ( f\" { NAME } : effective_conv_id is None. Cannot stage log entry. \" ) return False # Handle successful sends if NAME in ( LIT , LIT ) or NAME . NAME ( LIT ) : try : # Get person ID as int NAME = NAME ( NAME ( NAME . NAME ) ) # Prepare log data NAME = { LIT : NAME ( NAME ) , LIT : NAME . NAME , LIT : NAME , LIT : NAME [ : NAME . NAME ] , LIT : NAME . NAME ( NAME . NAME ) , LIT : NAME , LIT : NAME , LIT : None , } if NAME . NAME . NAME is not None : NAME . NAME . NAME . NAME ( NAME ) # Update custom_reply_sent_at if this was a custom reply if ( NAME and NAME and NAME == NAME . NAME . NAME ) : try : if NAME . NAME . NAME : NAME . NAME = NAME . NAME ( NAME . NAME ) NAME . NAME . NAME . NAME ( NAME ) NAME . NAME . NAME . NAME ( ) NAME . NAME ( f\" { NAME } : Updated custom_reply_sent_at. \" ) except NAME as NAME : NAME . NAME ( f\" { NAME } : Failed to update custom_reply_sent_at: { NAME } \" ) # Stage person for archiving if NAME . NAME . NAME is not None : NAME . NAME . NAME [ NAME ] = ( NAME . NAME ) NAME . NAME ( f\" { NAME } : Person status staged for ARCHIVE. \" ) return True except NAME as NAME : NAME . NAME ( f\" { NAME } : Failed to stage database updates: { NAME } \" ) return False else : NAME . NAME ( f\" { NAME } : Failed to send message (Status: { NAME } ). \" ) return False"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "BatchCommitManager.__init__",
      "lineno": 1572,
      "end_lineno": 1573,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, db_state)",
      "fingerprint": "0f70e91530b827d64534e5f608ec2fe7441857ef",
      "simhash64": 7488109620949853267,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "BatchCommitManager.should_commit",
      "lineno": 1575,
      "end_lineno": 1582,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "deae64a00084fcce04f0913faaecef9b49bd4ac6",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME ( NAME . NAME . NAME ) if NAME . NAME . NAME else LIT NAME = ( NAME ( NAME . NAME . NAME ) if NAME . NAME . NAME else LIT ) NAME = NAME + NAME return NAME >= NAME . NAME . NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "BatchCommitManager.commit_batch",
      "lineno": 1584,
      "end_lineno": 1631,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 9,
      "loc": 48,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, batch_num)",
      "fingerprint": "1622b2b05f33d2aba9ea9f78255634c43dedf4c9",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME , NAME ] : LIT if not NAME . NAME . NAME and not NAME . NAME . NAME : return True , LIT , LIT try : NAME = ( NAME ( NAME . NAME . NAME ) if NAME . NAME . NAME else LIT ) NAME = ( NAME ( NAME . NAME . NAME ) if NAME . NAME . NAME else LIT ) NAME . NAME ( f\" Committing batch { NAME } ( { NAME } logs, { NAME } person updates) \" ) if not NAME . NAME . NAME : NAME . NAME ( f\" Database session is None for batch { NAME } \" ) return False , LIT , LIT NAME , NAME = NAME ( NAME = NAME . NAME . NAME , NAME = NAME . NAME . NAME or [ ] , NAME = NAME . NAME . NAME or { } , NAME = f\" Action 9 Batch { NAME } \" , ) # Clear the staged data if NAME . NAME . NAME is not None : NAME . NAME . NAME . NAME ( ) if NAME . NAME . NAME is not None : NAME . NAME . NAME . NAME ( ) NAME . NAME ( f\" Batch { NAME } committed successfully ( { NAME } logs, { NAME } person updates) \" ) return True , NAME , NAME except NAME as NAME : NAME . NAME ( f\" Database commit failed for batch { NAME } : { NAME } \" , NAME = True ) return False , LIT , LIT"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_initialize_state_objects",
      "lineno": 1644,
      "end_lineno": 1648,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "404203362122eb227f15bc8b679e3af91dbd35fb",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( ) NAME = NAME ( NAME = NAME . NAME ) return NAME , NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_initialize_adaptive_systems",
      "lineno": 1651,
      "end_lineno": 1682,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 32,
      "tags": [
        "pure-ish",
        "json",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "ea387a68d0f4cbb20fbad64434339c239b663b1f",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( ) -> NAME [ NAME [ NAME ] , NAME [ NAME ] , NAME ] : LIT NAME = NAME . NAME NAME = None NAME = None if NAME : try : # Initialize adaptive systems only if classes loaded if NAME ( NAME ) : NAME = NAME ( NAME = NAME . NAME , NAME = LIT , NAME = NAME ( LIT , NAME . NAME or LIT ) ) NAME = NAME . NAME ( ) NAME . NAME ( f\" Adaptive batch processing enabled: initial size { NAME } \" ) if NAME ( NAME ) : NAME = NAME ( LIT ) NAME . NAME ( { LIT : LIT , LIT : NAME . NAME , LIT : NAME . NAME } ) except NAME as NAME : NAME . NAME ( f\" Failed to initialize adaptive systems: { NAME } , using standard batch processing \" ) NAME = None NAME = None return NAME , NAME , NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_initialize_database_and_message_config",
      "lineno": 1685,
      "end_lineno": 1692,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(adaptive_batch_size)",
      "fingerprint": "0e414d725f16a1c09d329812423378ba47a65f8e",
      "simhash64": 7488179989695599675,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( NAME = NAME ( LIT , NAME ) , NAME = NAME ( LIT , NAME ) , ) NAME = NAME ( ) return NAME , NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_validate_session_manager",
      "lineno": 1695,
      "end_lineno": 1700,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:tiny"
      ],
      "signature": "(session_manager)",
      "fingerprint": "00847c0377217b1dbf498aa1f1827efbe2f3863e",
      "simhash64": 7492076692188861443,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if not NAME or not NAME . NAME : NAME . NAME ( LIT ) return False return True"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_finalize_performance_monitoring",
      "lineno": 1703,
      "end_lineno": 1710,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(performance_dashboard)",
      "fingerprint": "6a7842888246a034c4d21b0507cd8aaa146d539c",
      "simhash64": 8641136712026076211,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> None : LIT if NAME : try : NAME . NAME ( ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Failed to finalize performance monitoring: { NAME } \" )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_cleanup_resources",
      "lineno": 1713,
      "end_lineno": 1716,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(session_manager, db_state)",
      "fingerprint": "3569845225b0d566bd7a7f68a273edfa068c47ea",
      "simhash64": 8641136711958967299,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT if NAME . NAME : NAME . NAME ( NAME . NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "process_productive_messages",
      "lineno": 1719,
      "end_lineno": 1778,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 60,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(session_manager)",
      "fingerprint": "9d47d9d89418684d6a38f0e5ca998350f10cff5e",
      "simhash64": 7488109654236378131,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT NAME . NAME ( LIT ) # Initialize state objects NAME , NAME = NAME ( ) # Initialize adaptive systems NAME , NAME , NAME = NAME ( ) # Initialize database and message configuration NAME , NAME = NAME ( NAME ) # Validate session manager if not NAME ( NAME ) : return False try : # Step 1: Setup - Load templates and get database session if not NAME ( NAME , NAME , NAME ) : return False # Step 2: Query candidates NAME = NAME ( NAME , NAME , NAME . NAME ) if not NAME : NAME . NAME ( LIT ) return True NAME . NAME = NAME ( NAME ) NAME . NAME ( f\" Action 9: Found { NAME . NAME } candidates to process. \" ) # Step 3: Process candidates NAME = NAME ( NAME , NAME , NAME , NAME , NAME , NAME ) # Step 4: Final commit NAME ( NAME , NAME ) # Step 5: Log summary NAME ( NAME ) return NAME except NAME as NAME : NAME . NAME ( f\" Critical error in process_productive_messages: { NAME } \" , NAME = True ) return False finally : NAME ( NAME ) NAME ( NAME , NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_setup_configuration",
      "lineno": 1781,
      "end_lineno": 1829,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 6,
      "loc": 49,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(session_manager, db_state, msg_config)",
      "fingerprint": "8c70f1c0288ae9b56510aeb3b72fc1be45bbaa0b",
      "simhash64": 8641136712026076179,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT # Load templates NAME . NAME = NAME ( ) if not NAME . NAME : NAME . NAME ( LIT ) return False # Get database session NAME . NAME = NAME . NAME ( ) if not NAME . NAME : NAME . NAME ( LIT ) return False # Get message type IDs if not NAME . NAME : NAME . NAME ( LIT ) return False NAME = ( NAME . NAME . NAME ( NAME . NAME ) . NAME ( NAME . NAME == NAME ) . NAME ( ) ) if not NAME : NAME . NAME ( f\" Action 9: MessageTemplate ' { NAME } ' not found in DB. \" ) return False NAME . NAME = NAME # Get custom reply message template ID (optional) NAME = ( NAME . NAME . NAME ( NAME . NAME ) . NAME ( NAME . NAME == NAME ) . NAME ( ) ) if NAME : NAME . NAME = NAME else : NAME . NAME ( f\" Action 9: MessageTemplate ' { NAME } ' not found in DB. \" ) return True"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_query_candidates",
      "lineno": 1833,
      "end_lineno": 1907,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 75,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(db_state, msg_config, limit)",
      "fingerprint": "9ba54fab996ab5d0c9b36ee221ddba53e8a5092b",
      "simhash64": 7487617077321573379,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME ] : LIT if not NAME . NAME : NAME . NAME ( LIT ) return [ ] NAME . NAME ( LIT ) # Subquery for latest IN messages NAME = ( NAME . NAME . NAME ( NAME . NAME , NAME . NAME ( NAME . NAME ) . NAME ( LIT ) , ) . NAME ( NAME . NAME == NAME . NAME ) . NAME ( NAME . NAME ) . NAME ( LIT ) ) # Subquery for latest OUT acknowledgement messages NAME = ( NAME . NAME . NAME ( NAME . NAME , NAME . NAME ( NAME . NAME ) . NAME ( LIT ) , ) . NAME ( NAME . NAME == NAME . NAME , NAME . NAME == NAME . NAME , ) . NAME ( NAME . NAME ) . NAME ( LIT ) ) # Main query NAME = ( NAME . NAME . NAME ( NAME ) . NAME ( NAME ( NAME . NAME ) ) . NAME ( NAME , NAME . NAME == NAME . NAME . NAME ) . NAME ( NAME , NAME ( NAME . NAME == NAME . NAME , NAME . NAME == NAME . NAME , NAME . NAME == NAME . NAME . NAME , NAME ( NAME . NAME == NAME , NAME . NAME == NAME , ) , NAME . NAME is None , ) , ) . NAME ( NAME , NAME . NAME == NAME . NAME . NAME , ) . NAME ( NAME . NAME == NAME . NAME , ( NAME . NAME . NAME is None ) | ( NAME . NAME . NAME < NAME . NAME . NAME ) , ) . NAME ( NAME . NAME ) ) # Apply limit if configured if NAME > LIT : NAME = NAME . NAME ( NAME ) NAME . NAME ( f\" Processing limited to { NAME } candidates \" ) return NAME . NAME ( )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_process_candidates",
      "lineno": 1910,
      "end_lineno": 2025,
      "is_method": false,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 15,
      "loc": 116,
      "tags": [
        "pure-ish",
        "time",
        "size:large"
      ],
      "signature": "(session_manager, candidates, state, ms_state, db_state, msg_config)",
      "fingerprint": "a087c81bc1f1c1a56aef8e5fa2a9868f15b675a7",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , ) -> NAME : LIT # Initialize processors NAME = NAME ( NAME , NAME , NAME , NAME ) NAME = NAME ( NAME ) # Setup progress tracking NAME = { LIT : NAME . NAME , LIT : LIT , LIT : LIT , LIT : True , LIT : True , LIT : LIT , LIT : NAME . NAME , } NAME . NAME ( f\" Processing { NAME . NAME } candidates... \" ) with NAME ( ) , NAME ( ** NAME ) as NAME : for NAME in NAME : if NAME . NAME : # Skip remaining candidates if critical DB error occurred NAME = NAME . NAME - NAME . NAME NAME . NAME += NAME NAME . NAME ( f\" Skipping remaining { NAME } candidates due to DB error. \" ) break NAME . NAME += LIT # Process individual person NAME , NAME = NAME . NAME ( NAME , NAME ) # Update counters based on result if NAME : if NAME == LIT : NAME . NAME += LIT NAME . NAME += LIT # Note: tasks_created_count is updated in the person processor else : NAME . NAME += LIT elif NAME . NAME ( LIT ) : NAME . NAME += LIT NAME . NAME = False else : NAME . NAME += LIT # Check for batch commit if NAME . NAME ( ) : NAME . NAME += LIT # === PHASE 11.1: BATCH PERFORMANCE MONITORING === NAME = NAME . NAME ( ) NAME = NAME ( NAME . NAME or [ ] ) + NAME ( NAME . NAME or [ ] ) NAME , NAME , NAME = ( NAME . NAME ( NAME . NAME ) ) # Record batch performance for adaptive processing NAME = NAME ( ) . NAME ( LIT ) NAME = NAME ( ) . NAME ( LIT ) if NAME and NAME is not None and NAME is not None : try : NAME = NAME . NAME ( ) - NAME NAME = LIT if NAME else LIT NAME . NAME ( NAME = NAME , NAME = NAME , NAME = NAME ) NAME . NAME ( { LIT : NAME . NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME } ) # Get updated batch size recommendation NAME = NAME . NAME ( ) if NAME != NAME . NAME : NAME . NAME ( f\" Adaptive batch size adjustment: { NAME . NAME } \u2192 { NAME } \" ) NAME . NAME = NAME NAME . NAME = NAME except NAME as NAME : NAME . NAME ( f\" Batch performance monitoring failed: { NAME } \" ) if not NAME : NAME . NAME ( f\" Critical: Batch { NAME . NAME } commit failed! \" ) NAME . NAME = True NAME . NAME = False break # Update progress bar NAME . NAME ( f\" Processing: Tasks= { NAME . NAME } Acks= { NAME . NAME } \" f\" Skip= { NAME . NAME } Err= { NAME . NAME } \" ) NAME . NAME ( LIT ) return NAME . NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_final_commit",
      "lineno": 2028,
      "end_lineno": 2053,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(db_state, state)",
      "fingerprint": "aa87be2fcf5f2057d2d528276ad484c8271982f0",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) : LIT if not NAME . NAME and ( NAME . NAME or NAME . NAME ) : NAME . NAME += LIT NAME = NAME ( NAME ) NAME = NAME ( NAME . NAME ) if NAME . NAME else LIT NAME = NAME ( NAME . NAME ) if NAME . NAME else LIT NAME . NAME ( f\" Committing final batch ( { NAME } logs, { NAME } person updates) \" ) NAME , NAME , NAME = NAME . NAME ( NAME . NAME ) if not NAME : NAME . NAME ( LIT ) NAME . NAME = False else : NAME . NAME ( f\" Final batch committed successfully ( { NAME } logs, { NAME } person updates) \" )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_log_summary",
      "lineno": 2056,
      "end_lineno": 2068,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(state)",
      "fingerprint": "54a3aeb79ac2eff8da80b14ba652b1c1be3b67b5",
      "simhash64": 7470200808842638355,
      "normalized": "def NAME ( NAME : NAME ) : LIT NAME . NAME ( LIT ) NAME . NAME ( f\" Candidates Queried: { NAME . NAME } \" ) NAME . NAME ( f\" Candidates Processed: { NAME . NAME } \" ) NAME . NAME ( f\" Skipped (Various Reasons): { NAME . NAME } \" ) NAME . NAME ( f\" MS To-Do Tasks Created: { NAME . NAME } \" ) NAME . NAME ( f\" Acks Sent/Simulated: { NAME . NAME } \" ) NAME . NAME ( f\" Persons Archived (Staged): { NAME . NAME } \" ) NAME . NAME ( f\" Errors during processing: { NAME . NAME } \" ) NAME . NAME ( f\" Overall Success: { NAME . NAME } \" ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_normalize_task_text",
      "lineno": 2076,
      "end_lineno": 2090,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "regex",
        "size:small"
      ],
      "signature": "(task)",
      "fingerprint": "81bacba1691884f2f091d85319198c29c062daa1",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if not NAME ( NAME , NAME ) : return LIT NAME = NAME . NAME ( ) NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) NAME = NAME . NAME ( LIT , LIT , NAME ) # strip trailing punctuation clusters NAME = NAME . NAME ( LIT , LIT , NAME ) # strip leading punctuation clusters return NAME . NAME ( LIT , LIT , NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_log_suggested_tasks_quality",
      "lineno": 2093,
      "end_lineno": 2160,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 26,
      "loc": 68,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(suggested_tasks, extracted_data, log_prefix)",
      "fingerprint": "dbdb14c38a098171a6cc21e2fb355a10683d5a38",
      "simhash64": 7488180022980023355,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> None : LIT try : NAME = NAME or [ ] if not NAME : NAME . NAME ( f\" { NAME } : No suggested_tasks to audit. \" ) return # Normalize and hash NAME = [ NAME ( NAME ) for NAME in NAME if NAME ( NAME , NAME ) and NAME . NAME ( ) ] NAME = NAME ( { NAME for NAME in NAME if NAME } ) NAME = NAME ( LIT , NAME ( NAME ) - NAME ( NAME ) ) NAME = [ NAME . NAME ( NAME . NAME ( LIT ) ) . NAME ( ) [ : LIT ] for NAME in NAME ] # Length stats NAME = [ NAME ( NAME ) for NAME in NAME if NAME ( NAME , NAME ) ] NAME = NAME ( NAME ) / NAME ( NAME ) if NAME else LIT NAME = NAME ( LIT for NAME in NAME if NAME < LIT ) NAME = NAME ( LIT for NAME in NAME if NAME > LIT ) # Action verbs heuristic NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] NAME = NAME ( LIT for NAME in NAME for NAME in NAME if f\" { NAME } \" in f\" { NAME } \" ) # Names/locations coverage (best-effort; extracted_data structure may vary) NAME = NAME ( ) try : for NAME in ( NAME . NAME ( LIT ) or [ ] ) : NAME = NAME . NAME ( LIT ) if NAME ( NAME , NAME ) else None if NAME : NAME . NAME ( NAME . NAME ( ) ) except NAME : pass NAME = NAME ( ) try : for NAME in ( NAME . NAME ( LIT ) or [ ] ) : NAME = NAME . NAME ( LIT ) if NAME ( NAME , NAME ) else None if NAME : NAME . NAME ( NAME . NAME ( ) ) except NAME : pass NAME = NAME ( LIT for NAME in NAME if NAME ( NAME in NAME for NAME in NAME ) ) if NAME else LIT NAME = NAME ( LIT for NAME in NAME if NAME ( NAME in NAME for NAME in NAME ) ) if NAME else LIT NAME . NAME ( f\" { NAME } : Task audit \u2014 total= { NAME ( NAME ) } , unique_norm= { NAME ( NAME ) } , dupes= { NAME } , \" f\" avg_len= { NAME : .1f } , short(<25)= { NAME } , long(>220)= { NAME } , verbs= { NAME } , \" f\" name_refs= { NAME } , location_refs= { NAME } \" ) # Log a compact preview of normalized tasks and their hashes NAME = [ f\" { NAME + LIT } : { NAME [ NAME ] [ : LIT ] } # { NAME [ NAME ] } \" for NAME in NAME ( NAME ( LIT , NAME ( NAME ) ) ) ] if NAME : NAME . NAME ( f\" { NAME } : Task audit sample: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" { NAME } : Task audit failed: { NAME } \" )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_log_task_dedup_preview",
      "lineno": 2163,
      "end_lineno": 2205,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 13,
      "loc": 43,
      "tags": [
        "pure-ish",
        "regex",
        "size:medium"
      ],
      "signature": "(suggested_tasks, log_prefix)",
      "fingerprint": "2443560eb8c1b5eadb280f192f597fcba4b183f4",
      "simhash64": 7488180022980023323,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME ) -> None : LIT try : NAME = NAME or [ ] if NAME ( NAME ) < LIT : return # Lightweight normalization reuse NAME : NAME [ NAME , NAME [ NAME ] ] = { } for NAME , NAME in NAME ( NAME ) : if not NAME ( NAME , NAME ) or not NAME . NAME ( ) : continue NAME = NAME ( NAME ) # Remove parenthetical clarifiers & counts for grouping NAME = NAME . NAME ( LIT , LIT , NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) # Generalize years NAME = NAME . NAME ( LIT , LIT , NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) if not NAME : continue NAME . NAME ( NAME , [ ] ) . NAME ( NAME ) NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME ( NAME ) > LIT } if not NAME : NAME . NAME ( f\" { NAME } : De-dup preview: no duplicate clusters detected \" ) return NAME = NAME ( NAME ( NAME ) - LIT for NAME in NAME . NAME ( ) ) NAME . NAME ( f\" { NAME } : De-dup preview \u2014 clusters= { NAME ( NAME ) } , \" f\" potential_savings= { NAME } (would reduce { NAME ( NAME ) } \u2192 { NAME ( NAME ) - NAME } ) \" ) NAME = [ ] for NAME , NAME in NAME ( NAME . NAME ( ) ) [ : LIT ] : NAME = NAME . NAME ( NAME . NAME ( LIT ) ) . NAME ( ) [ : LIT ] NAME . NAME ( f\" { NAME } : { NAME ( NAME ) } :' { NAME [ : LIT ] } ' \" ) if NAME : NAME . NAME ( f\" { NAME } : De-dup cluster samples: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" { NAME } : De-dup preview failed: { NAME } \" )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_process_ai_response",
      "lineno": 2208,
      "end_lineno": 2263,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 9,
      "loc": 56,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(ai_response, log_prefix)",
      "fingerprint": "ef05168334957c99cbe32c97d5ed3696231c3c23",
      "simhash64": 7452151225962107963,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT # Lazy import to avoid circulars at module import time try : from NAME import NAME except NAME : NAME = None # type: ignore # Default minimal fallback NAME : NAME [ NAME , NAME ] = { LIT : { } , LIT : [ ] , } if not NAME ( NAME , NAME ) : NAME . NAME ( f\" { NAME } : AI response is not a dict; applying defaults. \" ) return ( NAME ( { } ) if NAME ( NAME ) else NAME ) NAME . NAME ( f\" { NAME } : Processing AI response... \" ) try : # First attempt: Try direct validation with Pydantic NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( ) NAME . NAME ( f\" { NAME } : AI response validated with Pydantic schema. \" ) except NAME as NAME : NAME . NAME ( f\" { NAME } : AI response validation failed: { NAME } \" ) # Salvage minimal content before normalization NAME = { LIT : { } , LIT : [ ] } try : if NAME ( NAME . NAME ( LIT ) , NAME ) : NAME [ LIT ] = NAME ( NAME [ LIT ] ) # shallow copy if NAME ( NAME . NAME ( LIT ) , NAME ) : NAME [ LIT ] = NAME ( NAME [ LIT ] ) # shallow copy except NAME as NAME : NAME . NAME ( f\" { NAME } : Defensive salvage failed: { NAME } \" ) NAME = NAME except NAME as NAME : NAME . NAME ( f\" { NAME } : Unexpected error processing AI response: { NAME } \" , NAME = True ) NAME = { LIT : { } , LIT : [ ] } # Normalize to ensure structured keys exist and legacy fields are promoted if NAME ( NAME ) : try : NAME = NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" { NAME } : Normalization failed, using unnormalized result: { NAME } \" ) return NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_format_context_for_ai_extraction",
      "lineno": 2266,
      "end_lineno": 2334,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 69,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "(context_logs, _)",
      "fingerprint": "cf3810c44e9e17705e18a441c182de4e840d5c39",
      "simhash64": 5182301829461357587,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , # my_pid_lower parameter is kept for compatibility but not used # pylint: disable=unused-argument NAME : NAME = LIT , # Renamed to underscore to indicate unused parameter ) -> NAME : LIT # Step 1: Initialize list for formatted lines NAME = [ ] # Step 2: Get truncation limit from config NAME = NAME . NAME # Step 3: Iterate through sorted logs (oldest first) for NAME in NAME : # Step 3a: Determine label based on direction # Note: Assumes IN logs have author != my_pid_lower, OUT logs have author == my_pid_lower # This might need adjustment if author field isn't reliably populated or needed. # Using direction is simpler and more reliable here. # Handle SQLAlchemy Column type safely NAME = False try : # Try to get the direction value if NAME ( NAME , LIT ) : NAME = NAME . NAME # Check if it's a MessageDirectionEnum or can be compared to one if NAME ( NAME , LIT ) : # It's an enum object NAME = NAME == NAME . NAME elif NAME ( NAME , NAME ) : # It's a string NAME = NAME == NAME . NAME . NAME elif NAME ( NAME ) == NAME ( NAME . NAME ) : # Try string comparison as last resort NAME = True except NAME : # Default to OUT if any error occurs NAME = False # Use a simple boolean value to avoid SQLAlchemy type issues NAME = LIT if NAME ( NAME ) else LIT # Step 3b: Get message content and handle potential None NAME = NAME . NAME or LIT # Ensure content is a string if not NAME ( NAME , NAME ) : NAME = NAME ( NAME ) # Step 3c: Truncate content by word count if necessary NAME = NAME . NAME ( ) NAME = LIT . NAME ( NAME [ : NAME ] ) + LIT if NAME ( NAME ) > NAME else NAME # Step 3d: Append formatted line to the list NAME . NAME ( f\" { NAME } { NAME } \" ) # Step 4: Join lines into a single string separated by newlines return LIT . NAME ( NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_get_message_context",
      "lineno": 2337,
      "end_lineno": 2389,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 4,
      "loc": 53,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(db_session, person_id, limit)",
      "fingerprint": "8297c2091837dfacbf655ac57e3b725eead112ae",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , # Accept SQLAlchemy Column type or int NAME : NAME = NAME . NAME , ) -> NAME [ NAME ] : LIT # Step 1: Query database for recent logs try : NAME = ( NAME . NAME ( NAME ) . NAME ( NAME . NAME == NAME ) . NAME ( NAME . NAME . NAME ( ) ) # Fetch newest first . NAME ( NAME ) # Limit the number fetched . NAME ( ) ) # Step 2: Sort the fetched logs by timestamp ascending (oldest first) for AI context # Convert SQLAlchemy Column objects to Python datetime objects for sorting def NAME ( NAME : NAME ) -> NAME : # Extract timestamp value from SQLAlchemy Column if needed NAME = NAME . NAME # If it's already a datetime or can be used as one, use it if NAME ( NAME , LIT ) and NAME ( NAME , LIT ) : return NAME if NAME . NAME else NAME . NAME ( NAME = NAME . NAME ) # Otherwise use minimum date return NAME . NAME . NAME ( NAME = NAME . NAME ) return NAME ( NAME , NAME = NAME ) except NAME as NAME : # Step 3: Log database errors NAME . NAME ( f\" DB error fetching message context for Person ID { NAME } : { NAME } \" , NAME = True , ) return [ ] except NAME as NAME : # Step 4: Log unexpected errors NAME . NAME ( f\" Unexpected error fetching message context for Person ID { NAME } : { NAME } \" , NAME = True , ) return [ ]"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "get_sort_key",
      "lineno": 2366,
      "end_lineno": 2373,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(log)",
      "fingerprint": "71643d2d1c7e831aef8829aba891bfa4705c11d9",
      "simhash64": 7488144838607942659,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : # Extract timestamp value from SQLAlchemy Column if needed NAME = NAME . NAME # If it's already a datetime or can be used as one, use it if NAME ( NAME , LIT ) and NAME ( NAME , LIT ) : return NAME if NAME . NAME else NAME . NAME ( NAME = NAME . NAME ) # Otherwise use minimum date return NAME . NAME . NAME ( NAME = NAME . NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_load_templates_for_action9",
      "lineno": 2392,
      "end_lineno": 2416,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 25,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b9ef1eb0b2bb5dc0528acb3ff136c519d8fea98c",
      "simhash64": 8641066343214789683,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT try : # Import the template loading function from action8_messaging from NAME import NAME # Load all templates NAME = NAME ( ) # Check if the required template exists if not NAME or NAME not in NAME : NAME . NAME ( f\" Required template ' { NAME } ' not found in templates. \" ) return { } return NAME except NAME as NAME : NAME . NAME ( f\" Error loading templates for Action 9: { NAME } \" , NAME = True ) return { }"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_search_ancestry_tree",
      "lineno": 2419,
      "end_lineno": 2466,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 48,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(_session_manager, extracted_data)",
      "fingerprint": "b82563d3919602eeaf1846fbc891d624963e63b2",
      "simhash64": 7452291963450463259,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] ) -> NAME [ NAME , NAME ] : LIT # Step 1: Get all names from the extracted data if NAME ( NAME , NAME ) : NAME = NAME . NAME ( ) elif NAME ( NAME , NAME ) : # Legacy support for list of names NAME = NAME else : NAME . NAME ( LIT ) return { LIT : [ ] , LIT : { } } if not NAME : NAME . NAME ( LIT ) return { LIT : [ ] , LIT : { } } # Step 2: Get search method from config NAME = NAME . NAME NAME . NAME ( f\" Action 9 Tree Search: Method configured as ' { NAME } '. Found { NAME ( NAME ) } names to search. \" ) # Step 3: Return empty results for any search method # This is a simplified version that doesn't depend on complex GEDCOM/API functionality NAME = [ ] NAME . NAME ( f\" Action 9 Tree Search: Found { NAME ( NAME ) } potential matches. \" ) # Step 4: Return empty relationship paths NAME = { } return { LIT : NAME , LIT : NAME }"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_identify_and_get_person_details",
      "lineno": 2469,
      "end_lineno": 2477,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(_session_manager, extracted_data, log_prefix)",
      "fingerprint": "633b4cb298b8a87562495db4b2f90b5631b6e430",
      "simhash64": 7452151225961067603,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME . NAME ( f\" { NAME } : _identify_and_get_person_details - returning None (simplified version) \" )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_format_genealogical_data_for_ai",
      "lineno": 2480,
      "end_lineno": 2496,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 17,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(genealogical_data, log_prefix)",
      "fingerprint": "f644bcf74d6e0e8447c9616c838d6619b474bf98",
      "simhash64": 7451588276074746915,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME : LIT if not NAME or not NAME . NAME ( LIT ) : return LIT # Simple formatting of search results NAME = [ LIT ] for NAME in NAME . NAME ( LIT , [ ] ) [ : LIT ] : # Limit to top 3 if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" - { NAME } \" ) return LIT . NAME ( NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "generate_genealogical_reply",
      "lineno": 2499,
      "end_lineno": 2523,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 25,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(session_manager, conversation_context, user_message, genealogical_data, log_prefix)",
      "fingerprint": "2089027c1175683118ba75594ef01b05979f165f",
      "simhash64": 7452080857216885843,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , ) -> NAME [ NAME ] : LIT try : # Import the AI interface function from NAME import NAME as NAME # Use the AI interface to generate a reply return NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) except NAME as NAME : NAME . NAME ( f\" { NAME } : Error generating genealogical reply: { NAME ! NAME } \" ) return None"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_generate_ack_summary",
      "lineno": 2526,
      "end_lineno": 2552,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 27,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(extracted_data)",
      "fingerprint": "d691736421b228c98b6d3fd06b62824fb7bd320b",
      "simhash64": 7434136827518686251,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : LIT try : # Get mentioned names NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , [ ] ) NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , [ ] ) NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , [ ] ) NAME = [ ] if NAME : NAME . NAME ( f\" information about { LIT . NAME ( NAME [ : LIT ] ) } \" ) if NAME : NAME . NAME ( f\" details from { LIT . NAME ( NAME [ : LIT ] ) } \" ) if NAME : NAME . NAME ( f\" records from { LIT . NAME ( NAME [ : LIT ] ) } \" ) if NAME : return LIT . NAME ( NAME ) return LIT except NAME as NAME : NAME . NAME ( f\" Error generating acknowledgment summary: { NAME } \" ) return LIT"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "action9_process_productive_module_tests",
      "lineno": 2563,
      "end_lineno": 2820,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 258,
      "tags": [
        "impure",
        "time",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "e1ede8e6fc3497f2d7f9372d79e43b59740657e8",
      "simhash64": 5146448920951297067,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( LIT , LIT , ) NAME . NAME ( ) # INITIALIZATION TESTS def NAME ( ) -> None : LIT # Test constants assert ( NAME == LIT ) , LIT assert NAME == LIT , LIT assert ( NAME == LIT ) , LIT assert ( NAME == LIT ) , LIT # Test class availability assert LIT in NAME ( ) , LIT assert LIT in NAME ( ) , LIT # Test function availability assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT # CORE FUNCTIONALITY TESTS def NAME ( ) -> None : LIT # Test safe_column_value function with a simple object class NAME : def NAME ( NAME ) -> None : NAME . NAME = LIT NAME = NAME ( ) NAME = NAME ( NAME , LIT , LIT ) assert NAME == LIT , LIT NAME = NAME ( NAME , LIT , LIT ) assert NAME == LIT , LIT # Test should_exclude_message function NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) , LIT NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) , LIT def NAME ( ) -> None : LIT # Test _process_ai_response function NAME = { LIT : LIT , LIT : { LIT : LIT } } NAME = NAME ( NAME , LIT ) assert NAME ( NAME , NAME ) , LIT # Test _generate_ack_summary function NAME = { LIT : [ LIT ] , LIT : [ LIT ] } NAME = NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert ( LIT in NAME or NAME ( NAME ) > LIT ) , LIT # EDGE CASE TESTS def NAME ( ) -> None : LIT # Test safe_column_value with None object NAME = NAME ( None , LIT , LIT ) assert NAME == LIT , LIT # Test should_exclude_message with empty string NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) , LIT # Test with empty string instead of None for type safety NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) , LIT # Test _process_ai_response with invalid data NAME = NAME ( None , LIT ) assert NAME ( NAME , NAME ) , LIT NAME = NAME ( { } , LIT ) assert NAME ( NAME , NAME ) , LIT # INTEGRATION TESTS def NAME ( ) -> None : LIT # Test get_gedcom_data integration - patch the import with NAME ( LIT ) as NAME : NAME . NAME = { LIT : LIT } # Set global to None to force reload global NAME NAME = NAME NAME = None try : NAME = NAME ( ) assert NAME is not None , LIT finally : NAME = NAME # Test template loading integration NAME = NAME ( ) assert NAME ( NAME , NAME ) , LIT # PERFORMANCE TESTS def NAME ( ) -> None : LIT import NAME # Test safe_column_value performance NAME = NAME ( ) NAME . NAME = LIT NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( NAME , LIT , f\" default_ { NAME } _12345 \" ) NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 1000 safe_column_value calls should be fast, took { NAME : .3f } s \" # Test should_exclude_message performance NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( f\" test message { NAME } 12345 \" ) NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 500 exclusion checks should be fast, took { NAME : .3f } s \" # ERROR HANDLING TESTS def NAME ( ) -> None : LIT # Test safe_column_value with attribute access exception class NAME : @ NAME def NAME ( NAME ) -> None : raise NAME ( LIT ) NAME = NAME ( ) NAME = NAME ( NAME , LIT , LIT ) assert NAME == LIT , LIT def NAME ( ) -> None : LIT import NAME # Test process_productive_messages function has proper decorators NAME = NAME # Check function attributes assert NAME ( NAME ) , LIT assert NAME . NAME == LIT , LIT # Check function signature NAME = NAME . NAME ( NAME ) assert LIT in NAME . NAME , LIT # Verify function can be inspected (indicates decorators are properly applied) assert NAME ( NAME , LIT ) or NAME ( NAME , LIT ) , LIT # Test _process_ai_response with malformed data NAME = { LIT : LIT } NAME = NAME ( NAME , LIT ) assert NAME ( NAME , NAME ) , LIT # Test _generate_ack_summary with empty data NAME = NAME ( { } ) assert NAME ( NAME , NAME ) , LIT # Run all tests with suppress_logging with NAME ( ) : # INITIALIZATION TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # CORE FUNCTIONALITY TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # EDGE CASE TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # INTEGRATION TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # PERFORMANCE TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # CIRCUIT BREAKER TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # ERROR HANDLING TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "test_module_initialization",
      "lineno": 2572,
      "end_lineno": 2594,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "277724448872058d41046a44fbb65fad827a031b",
      "simhash64": 5145886091252766251,
      "normalized": "def NAME ( ) -> None : LIT # Test constants assert ( NAME == LIT ) , LIT assert NAME == LIT , LIT assert ( NAME == LIT ) , LIT assert ( NAME == LIT ) , LIT # Test class availability assert LIT in NAME ( ) , LIT assert LIT in NAME ( ) , LIT # Test function availability assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT # CORE FUNCTIONALITY TESTS"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "test_core_functionality",
      "lineno": 2596,
      "end_lineno": 2616,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2f176d5d9d19c9c2c0c0330f0422c3d8a2caac8e",
      "simhash64": 5145885970996302891,
      "normalized": "def NAME ( ) -> None : LIT # Test safe_column_value function with a simple object class NAME : def NAME ( NAME ) -> None : NAME . NAME = LIT NAME = NAME ( ) NAME = NAME ( NAME , LIT , LIT ) assert NAME == LIT , LIT NAME = NAME ( NAME , LIT , LIT ) assert NAME == LIT , LIT # Test should_exclude_message function NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) , LIT NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "TestObj.__init__",
      "lineno": 2601,
      "end_lineno": 2602,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "751789f28928c095ea105f32dd8834d2bad13544",
      "simhash64": 8605249168965276675,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME = LIT"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "test_ai_processing_functions",
      "lineno": 2618,
      "end_lineno": 2632,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3fabb7ea137731b26ed622f65f47f56750df63f4",
      "simhash64": 5145885970988963371,
      "normalized": "def NAME ( ) -> None : LIT # Test _process_ai_response function NAME = { LIT : LIT , LIT : { LIT : LIT } } NAME = NAME ( NAME , LIT ) assert NAME ( NAME , NAME ) , LIT # Test _generate_ack_summary function NAME = { LIT : [ LIT ] , LIT : [ LIT ] } NAME = NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert ( LIT in NAME or NAME ( NAME ) > LIT ) , LIT"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "test_edge_cases",
      "lineno": 2635,
      "end_lineno": 2656,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 22,
      "tags": [
        "impure",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "a6c0a77daf7099885545324204a4ec2f91105dab",
      "simhash64": 5146448925246264363,
      "normalized": "def NAME ( ) -> None : LIT # Test safe_column_value with None object NAME = NAME ( None , LIT , LIT ) assert NAME == LIT , LIT # Test should_exclude_message with empty string NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) , LIT # Test with empty string instead of None for type safety NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) , LIT # Test _process_ai_response with invalid data NAME = NAME ( None , LIT ) assert NAME ( NAME , NAME ) , LIT NAME = NAME ( { } , LIT ) assert NAME ( NAME , NAME ) , LIT # INTEGRATION TESTS"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "test_integration",
      "lineno": 2658,
      "end_lineno": 2678,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "751ca9a1bfd0eedf89c7f684fe72ff3801fe9986",
      "simhash64": 8605213434771838011,
      "normalized": "def NAME ( ) -> None : LIT # Test get_gedcom_data integration - patch the import with NAME ( LIT ) as NAME : NAME . NAME = { LIT : LIT } # Set global to None to force reload global NAME NAME = NAME NAME = None try : NAME = NAME ( ) assert NAME is not None , LIT finally : NAME = NAME # Test template loading integration NAME = NAME ( ) assert NAME ( NAME , NAME ) , LIT # PERFORMANCE TESTS"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "test_performance",
      "lineno": 2680,
      "end_lineno": 2705,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 26,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b695662aa0c00bb66d1add4ee2eceb865568d054",
      "simhash64": 8641136678674011195,
      "normalized": "def NAME ( ) -> None : LIT import NAME # Test safe_column_value performance NAME = NAME ( ) NAME . NAME = LIT NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( NAME , LIT , f\" default_ { NAME } _12345 \" ) NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 1000 safe_column_value calls should be fast, took { NAME : .3f } s \" # Test should_exclude_message performance NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( f\" test message { NAME } 12345 \" ) NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 500 exclusion checks should be fast, took { NAME : .3f } s \" # ERROR HANDLING TESTS"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "test_error_handling",
      "lineno": 2707,
      "end_lineno": 2718,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "0db0fb9c8e0bb3db9711bb786ba004febacb2165",
      "simhash64": 5182477717969212459,
      "normalized": "def NAME ( ) -> None : LIT # Test safe_column_value with attribute access exception class NAME : @ NAME def NAME ( NAME ) -> None : raise NAME ( LIT ) NAME = NAME ( ) NAME = NAME ( NAME , LIT , LIT ) assert NAME == LIT , LIT"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "ErrorObj.test_attr",
      "lineno": 2713,
      "end_lineno": 2714,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "9575d0781d2f0bd10aaf8521cbfb4c4ed0983463",
      "simhash64": 6334863215456850987,
      "normalized": "def NAME ( NAME ) -> None : raise NAME ( LIT )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "test_circuit_breaker_config",
      "lineno": 2720,
      "end_lineno": 2745,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "61cea34e3b93863ccecbb710ea4fe4da21e2c15c",
      "simhash64": 7452291930163942955,
      "normalized": "def NAME ( ) -> None : LIT import NAME # Test process_productive_messages function has proper decorators NAME = NAME # Check function attributes assert NAME ( NAME ) , LIT assert NAME . NAME == LIT , LIT # Check function signature NAME = NAME . NAME ( NAME ) assert LIT in NAME . NAME , LIT # Verify function can be inspected (indicates decorators are properly applied) assert NAME ( NAME , LIT ) or NAME ( NAME , LIT ) , LIT # Test _process_ai_response with malformed data NAME = { LIT : LIT } NAME = NAME ( NAME , LIT ) assert NAME ( NAME , NAME ) , LIT # Test _generate_ack_summary with empty data NAME = NAME ( { } ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_apply_intelligent_task_selection",
      "lineno": 2825,
      "end_lineno": 2864,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 8,
      "loc": 40,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(tasks, extracted_data, person_data, log_prefix)",
      "fingerprint": "33f21edc0a3357be204edc9e2fd7cd689344ac8e",
      "simhash64": 7488180022980031539,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : if not NAME : return NAME NAME . NAME ( f\" { NAME } : Applying intelligent task selection to { NAME ( NAME ) } tasks \" ) # Score tasks based on data integration potential NAME = [ ] for NAME in NAME : NAME = NAME ( NAME , NAME ) NAME [ LIT ] = NAME NAME . NAME ( NAME ) # Sort by integration score (highest first) and select top tasks NAME . NAME ( NAME = lambda NAME : NAME . NAME ( LIT , LIT ) , NAME = True ) # Select tasks with good data integration (score > 0.6) or top 5 tasks NAME = [ ] for NAME in NAME : if NAME . NAME ( LIT , LIT ) > LIT or NAME ( NAME ) < LIT : NAME . NAME ( NAME ) if NAME ( NAME ) >= LIT : # Maximum 8 tasks break NAME . NAME ( f\" { NAME } : Selected { NAME ( NAME ) } tasks with good data integration \" ) return NAME except NAME as NAME : NAME . NAME ( f\" { NAME } : Error in intelligent task selection: { NAME } \" ) return NAME [ : LIT ] # Fallback to first 5 tasks"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_calculate_task_data_integration_score",
      "lineno": 2866,
      "end_lineno": 2912,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 24,
      "loc": 47,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(task, extracted_data)",
      "fingerprint": "292a48375bbedfbd71cc139bb592cd32cb8cf3ae",
      "simhash64": 7487617074167452715,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = LIT # Check if task uses specific extracted data NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) NAME . NAME ( LIT , LIT ) . NAME ( ) # Score based on data type utilization if NAME . NAME ( LIT ) : if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT ] ) : NAME += LIT if NAME . NAME ( LIT ) : if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT ] ) : NAME += LIT if NAME . NAME ( LIT ) : if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT ] ) : NAME += LIT if NAME . NAME ( LIT ) and NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT ] ) : NAME += LIT if NAME . NAME ( LIT ) : if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT ] ) : NAME += LIT # Bonus for specific names mentioned NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if NAME and NAME . NAME ( ) in NAME : NAME += LIT break # Bonus for research questions alignment NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( ) . NAME ( ) if NAME ( NAME in NAME for NAME in NAME if NAME ( NAME ) > LIT ) : NAME += LIT break return NAME ( LIT , NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_validate_and_score_tasks",
      "lineno": 2914,
      "end_lineno": 2945,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 32,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(tasks, extracted_data, log_prefix)",
      "fingerprint": "9f1fa9a73d3d9e4422912245997d741b209e989e",
      "simhash64": 7452151225961067547,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : if not NAME : return NAME NAME . NAME ( f\" { NAME } : Validating and scoring { NAME ( NAME ) } tasks \" ) NAME = [ ] for NAME in NAME : # Calculate task quality score NAME = NAME ( NAME , NAME ) NAME [ LIT ] = NAME # Only include tasks with minimum quality threshold if NAME >= LIT : # Minimum 40% quality score NAME . NAME ( NAME ) else : NAME . NAME ( f\" { NAME } : Filtered out low-quality task: { NAME . NAME ( LIT , LIT ) [ : LIT ] } \" ) NAME . NAME ( f\" { NAME } : Validated { NAME ( NAME ) } tasks meeting quality threshold \" ) return NAME except NAME as NAME : NAME . NAME ( f\" { NAME } : Error in task validation: { NAME } \" ) return NAME"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "_calculate_task_quality_score",
      "lineno": 2947,
      "end_lineno": 2999,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 20,
      "loc": 53,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(task, extracted_data)",
      "fingerprint": "755c24af39bfcb4ff0a7df77e99afa165f205d2a",
      "simhash64": 7488180024053765163,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = LIT # Check task completeness NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) if NAME and NAME ( NAME ) > LIT : NAME += LIT if NAME and NAME ( NAME ) > LIT : NAME += LIT if NAME : NAME += LIT # Check specificity (specific names, dates, places) NAME = LIT # Look for specific names NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if NAME and NAME in NAME : NAME += LIT break # Look for specific dates NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if NAME and NAME in NAME : NAME += LIT break # Look for specific places NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if NAME and NAME in NAME : NAME += LIT break NAME += NAME ( LIT , NAME ) # Check actionability (presence of research steps or methodology) if NAME ( NAME in NAME . NAME ( ) for NAME in [ LIT , LIT , LIT , LIT , LIT ] ) : NAME += LIT return NAME ( LIT , NAME )"
    },
    {
      "module_path": "action9_process_productive.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 3002,
      "end_lineno": 3004,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter.__init__",
      "lineno": 57,
      "end_lineno": 115,
      "is_method": true,
      "is_async": false,
      "args_count": 10,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 59,
      "tags": [
        "impure",
        "network",
        "time",
        "purpose:initialization",
        "size:medium"
      ],
      "signature": "(self, initial_rps, min_rps, max_rps, initial_delay, min_delay, max_delay, adaptation_window, success_threshold, rate_limit_threshold)",
      "fingerprint": "1749341ed9960ed00e2a40ae4dbe806e5d0203ef",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , # Increased from 0.5 - start more aggressively NAME : NAME = LIT , # Increased from 0.1 NAME : NAME = LIT , # Increased from 2.0 - log shows 3.0 worked flawlessly NAME : NAME = LIT , # Reduced from 2.0 - faster startup NAME : NAME = LIT , # Reduced from 0.5 - allow higher speeds NAME : NAME = LIT , NAME : NAME = LIT , # Reduced from 50 - adapt faster NAME : NAME = LIT , NAME : NAME = LIT ) : LIT NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME # Metrics tracking NAME . NAME : NAME = NAME ( NAME = NAME ) NAME . NAME : NAME [ NAME ] = None NAME . NAME = NAME ( ) # Adaptive behavior settings NAME . NAME = True NAME . NAME = NAME . NAME ( ) NAME . NAME = LIT # Seconds between adaptations # \u26a1 OPTIMIZATION 2: Load cached optimal settings from previous sessions NAME . NAME ( ) # === PHASE 12.4.2: ENHANCED ADAPTIVE PROCESSING & INTELLIGENCE === NAME . NAME = NAME ( ) NAME . NAME = NAME ( ) NAME . NAME = NAME ( ) NAME . NAME ( f\" Initialized adaptive rate limiter: { NAME . NAME } RPS, { NAME . NAME } s delay \" )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter.wait",
      "lineno": 117,
      "end_lineno": 135,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 19,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "b579c3c4d3994a313e3f00569d84096a39707df2",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) if NAME . NAME is not None : NAME = NAME - NAME . NAME NAME = LIT / NAME . NAME if NAME < NAME : NAME = NAME - NAME NAME . NAME ( NAME ) NAME . NAME = NAME . NAME ( ) return NAME NAME . NAME = NAME return LIT"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter.record_response",
      "lineno": 137,
      "end_lineno": 181,
      "is_method": true,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 8,
      "loc": 45,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, success, response_time, status_code, error_type)",
      "fingerprint": "ca857b905e2e225ab98fe575dc9c1cf51bb1c8ee",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None ) : LIT # Record metrics NAME = NAME ( NAME = NAME . NAME ( ) , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) NAME . NAME . NAME ( NAME ) # Update statistics NAME . NAME . NAME += LIT if NAME : NAME . NAME . NAME += LIT else : NAME . NAME . NAME += LIT if NAME == LIT or LIT in NAME ( NAME ) . NAME ( ) : NAME . NAME . NAME += LIT # Calculate current stats if NAME . NAME : NAME = [ NAME . NAME for NAME in NAME . NAME ] NAME . NAME . NAME = NAME . NAME ( NAME ) NAME . NAME . NAME = NAME . NAME # Trigger adaptation if enabled and enough data if NAME . NAME and NAME ( NAME . NAME ) >= LIT : NAME . NAME ( )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter._adapt_rate_limiting",
      "lineno": 183,
      "end_lineno": 256,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 21,
      "loc": 74,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "c917a6193123dbae5a41a63a60a1872deff1085a",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME = NAME . NAME ( ) # Check adaptation cooldown if NAME - NAME . NAME < NAME . NAME : return # Calculate recent metrics NAME = NAME ( NAME . NAME ) [ - LIT : ] # Last 20 responses if NAME ( NAME ) < LIT : return NAME = NAME ( LIT for NAME in NAME if NAME . NAME ) / NAME ( NAME ) NAME = NAME ( LIT for NAME in NAME if NAME . NAME == LIT or LIT in NAME ( NAME . NAME ) . NAME ( ) ) / NAME ( NAME ) NAME = NAME . NAME ( [ NAME . NAME for NAME in NAME ] ) # Determine adaptation strategy NAME = False # Simple rate limiting response if NAME > LIT : # More than 2% rate limiting NAME = NAME ( NAME . NAME , NAME . NAME * LIT ) if NAME != NAME . NAME : NAME . NAME ( f\" Decreasing RPS due to rate limiting: { NAME . NAME : .2f } \u2192 { NAME : .2f } \" ) NAME . NAME = NAME NAME . NAME = NAME ( NAME . NAME , NAME . NAME * LIT ) NAME = True # Increase RPS more aggressively if performance is excellent elif NAME > LIT and NAME < LIT and NAME == LIT : # Aggressive increase for excellent performance NAME = NAME ( NAME . NAME , NAME . NAME * LIT ) if NAME != NAME . NAME : NAME . NAME ( f\" Aggressively increasing RPS due to excellent performance: { NAME . NAME : .2f } \u2192 { NAME : .2f } \" ) NAME . NAME = NAME NAME . NAME = NAME ( NAME . NAME , NAME . NAME * LIT ) NAME = True # Moderate increase for good performance elif NAME > NAME . NAME and NAME < LIT : NAME = NAME ( NAME . NAME , NAME . NAME * LIT ) # Increased from 1.1 to 1.2 if NAME != NAME . NAME : NAME . NAME ( f\" Increasing RPS due to good performance: { NAME . NAME : .2f } \u2192 { NAME : .2f } \" ) NAME . NAME = NAME NAME . NAME = NAME ( NAME . NAME , NAME . NAME * LIT ) # More aggressive decrease NAME = True # Decrease RPS if success rate is low (more conservative threshold) elif NAME < LIT : # Increased threshold from 0.8 to 0.9 for earlier intervention NAME = NAME ( NAME . NAME , NAME . NAME * LIT ) # More aggressive reduction from 0.8 to 0.7 if NAME != NAME . NAME : NAME . NAME ( f\" Decreasing RPS due to low success rate: { NAME . NAME : .2f } \u2192 { NAME : .2f } \" ) NAME . NAME = NAME NAME . NAME = NAME ( NAME . NAME , NAME . NAME * LIT ) # Increased from 1.2 to 1.5 NAME = True if NAME : NAME . NAME . NAME += LIT NAME . NAME = NAME # \u26a1 OPTIMIZATION 2: Save optimal settings when performance is good if NAME >= LIT : # Save settings when we have good performance NAME . NAME ( ) # Simple cooldown adjustment if NAME > LIT : NAME . NAME = NAME ( LIT , NAME . NAME * LIT ) elif NAME > LIT : NAME . NAME = NAME ( LIT , NAME . NAME * LIT ) NAME . NAME ( f\" \u26a1 Adaptive rate limiting: RPS= { NAME . NAME : .2f } , Delay= { NAME . NAME : .2f } s, \" f\" Success= { NAME : .2% } , RateLimit= { NAME : .2% } \" )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter.get_current_settings",
      "lineno": 258,
      "end_lineno": 265,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "6c1bfa70701fa396ff54756b321ca820a2dba6b4",
      "simhash64": 7451729014569735203,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : LIT / NAME . NAME }"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter.get_statistics",
      "lineno": 267,
      "end_lineno": 269,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "7cf791c4ea854fe6df646a3cb215382778b2a514",
      "simhash64": 7488109654235849795,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter.reset_to_defaults",
      "lineno": 271,
      "end_lineno": 277,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "3c66aab7a93a3d0e81fab39ed572e5c71664857a",
      "simhash64": 8641031158842696787,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = NAME . NAME NAME . NAME = NAME . NAME NAME . NAME . NAME ( ) NAME . NAME = NAME ( ) NAME . NAME ( f\" Reset adaptive rate limiter to defaults: { NAME . NAME } RPS, { NAME . NAME } s delay \" )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter.enable_adaptation",
      "lineno": 279,
      "end_lineno": 282,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "fd54a05c2908c3c4856c8592073c3fc5e539e54c",
      "simhash64": 8641136717394777091,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = True NAME . NAME ( LIT )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter.disable_adaptation",
      "lineno": 284,
      "end_lineno": 287,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "f47c256aca402678d1693f095396818b255f76cb",
      "simhash64": 8641137262855623715,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = False NAME . NAME ( LIT )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter.record_rate_limit",
      "lineno": 289,
      "end_lineno": 292,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "b0b2c2ea6d5544ee9efadc73c5dac66590f02c2c",
      "simhash64": 7488215207352116307,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = NAME ( NAME . NAME , NAME . NAME * LIT ) NAME . NAME ( f\" Rate limit detected, increasing delay to { NAME . NAME : .1f } s \" )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter.is_throttled",
      "lineno": 294,
      "end_lineno": 296,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "30579116643adb0337fe74ffe02f223c0f31ad5d",
      "simhash64": 7488180022980027459,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME < NAME . NAME * LIT"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter.get_performance_report",
      "lineno": 298,
      "end_lineno": 329,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 32,
      "tags": [
        "impure",
        "network",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "7ab0a3deb196cad17dbe7fba72b87bd35e2dc5b4",
      "simhash64": 7451517907263467539,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME . NAME : return LIT NAME = NAME ( NAME . NAME ) [ - LIT : ] NAME = NAME ( LIT for NAME in NAME if NAME . NAME ) / NAME ( NAME ) NAME = NAME . NAME ( [ NAME . NAME for NAME in NAME ] ) NAME = NAME ( LIT for NAME in NAME if NAME . NAME == LIT or LIT in NAME ( NAME . NAME ) . NAME ( ) ) NAME = f\"\"\" Adaptive Rate Limiter Performance Report:\n==========================================\nCurrent Settings:\n  - RPS: { NAME . NAME : .2f } (Range: { NAME . NAME : .2f } - { NAME . NAME : .2f } )\n  - Delay: { NAME . NAME : .2f } s (Range: { NAME . NAME : .2f } - { NAME . NAME : .2f } )\n  - Adaptation: { LIT if NAME . NAME else LIT } Recent Performance (Last { NAME ( NAME ) } requests):\n  - Success Rate: { NAME : .2% } - Average Response Time: { NAME : .2f } s\n  - Rate Limit Errors: { NAME } - Adaptive Adjustments: { NAME . NAME . NAME } Overall Statistics:\n  - Total Requests: { NAME . NAME . NAME } - Successful: { NAME . NAME . NAME } - Failed: { NAME . NAME . NAME } - Rate Limit Errors: { NAME . NAME . NAME } \"\"\" return NAME . NAME ( )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter._load_cached_optimal_settings",
      "lineno": 331,
      "end_lineno": 357,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 27,
      "tags": [
        "impure",
        "filesystem",
        "regex",
        "json",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "7c5234da7fb8b953b178f114c33b5ed8e6935d0b",
      "simhash64": 8641101527586874387,
      "normalized": "def NAME ( NAME ) -> None : LIT try : import NAME from NAME import NAME NAME = NAME ( LIT ) if NAME . NAME ( ) : with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( NAME ) # Use cached optimal settings if they're reasonable NAME = NAME . NAME ( LIT , NAME . NAME ) if NAME . NAME <= NAME <= NAME . NAME : NAME . NAME = NAME NAME . NAME = LIT / NAME if NAME > LIT else NAME . NAME NAME . NAME ( f\" \u26a1 Loaded optimal RPS from cache: { NAME : .2f } \" ) else : NAME . NAME ( f\" \u26a1 Cached RPS { NAME : .2f } out of range, using defaults \" ) else : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" \u26a1 Error loading rate limit cache: { NAME } \" )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "AdaptiveRateLimiter._save_optimal_settings",
      "lineno": 359,
      "end_lineno": 386,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 28,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "ad59a36c7a7a45d8c89470f3dae3277ac1b26e1f",
      "simhash64": 7488180022980031547,
      "normalized": "def NAME ( NAME ) -> None : LIT try : import NAME from NAME import NAME # Only save if we have good performance metrics if NAME ( NAME . NAME ) >= LIT : NAME = NAME ( LIT for NAME in NAME . NAME if NAME . NAME ) / NAME ( NAME . NAME ) if NAME >= LIT : # Only cache if 90%+ success rate NAME = NAME ( LIT ) NAME . NAME ( NAME = True , NAME = True ) NAME = { LIT : NAME . NAME , LIT : NAME , LIT : NAME . NAME ( ) } with ( NAME / LIT ) . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME ) NAME . NAME ( f\" \u26a1 Saved optimal RPS to cache: { NAME . NAME : .2f } (success: { NAME : .2% } ) \" ) except NAME as NAME : NAME . NAME ( f\" \u26a1 Error saving rate limit cache: { NAME } \" )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "SmartBatchProcessor.__init__",
      "lineno": 394,
      "end_lineno": 420,
      "is_method": true,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 27,
      "tags": [
        "pure-ish",
        "time",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self, initial_batch_size, min_batch_size, max_batch_size, target_processing_time)",
      "fingerprint": "8dd7e7bd12af6302620033efb0b7086fdbf58728",
      "simhash64": 7452080857216889875,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT ) : LIT NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME : NAME = NAME ( NAME = LIT ) NAME . NAME = NAME . NAME ( ) NAME . NAME = LIT # Seconds between batch size adaptations NAME . NAME ( f\" Initialized smart batch processor: { NAME } batch size \" )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "SmartBatchProcessor.get_next_batch_size",
      "lineno": 422,
      "end_lineno": 424,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "7cf791c4ea854fe6df646a3cb215382778b2a514",
      "simhash64": 7488109654235849795,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "SmartBatchProcessor.record_batch_performance",
      "lineno": 426,
      "end_lineno": 446,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 21,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, batch_size, processing_time, success_rate)",
      "fingerprint": "86d386aafae6a148f76063463c88ad60e6823673",
      "simhash64": 7487617074100343843,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME ) : LIT NAME . NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME . NAME ( ) } ) # Adapt batch size if enough data and cooldown passed NAME = NAME . NAME ( ) if ( NAME ( NAME . NAME ) >= LIT and NAME - NAME . NAME > NAME . NAME ) : NAME . NAME ( )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "SmartBatchProcessor._adapt_batch_size",
      "lineno": 448,
      "end_lineno": 479,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 10,
      "loc": 32,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "1393e6aa8844fa7895cba5dbc7a01362a241cdeb",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME ) -> None : LIT if NAME ( NAME . NAME ) < LIT : return NAME = NAME ( NAME . NAME ) [ - LIT : ] NAME = NAME . NAME ( [ NAME [ LIT ] for NAME in NAME ] ) NAME = NAME . NAME ( [ NAME [ LIT ] for NAME in NAME ] ) NAME = False # Increase batch size if processing is fast and successful if ( NAME < NAME . NAME * LIT and NAME > LIT and NAME . NAME < NAME . NAME ) : NAME = NAME ( NAME . NAME , NAME . NAME + LIT ) NAME . NAME ( f\" Increasing batch size: { NAME . NAME } \u2192 { NAME } \" ) NAME . NAME = NAME NAME = True # Decrease batch size if processing is slow or unsuccessful elif ( NAME > NAME . NAME * LIT or NAME < LIT ) and NAME . NAME > NAME . NAME : NAME = NAME ( NAME . NAME , NAME . NAME - LIT ) NAME . NAME ( f\" Decreasing batch size: { NAME . NAME } \u2192 { NAME } \" ) NAME . NAME = NAME NAME = True if NAME : NAME . NAME = NAME . NAME ( )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "SmartBatchProcessor.get_performance_summary",
      "lineno": 481,
      "end_lineno": 493,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 13,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "7d0c7ce18b969cfba4813d667927b81bfad8e7d9",
      "simhash64": 7451588276074746915,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT if not NAME . NAME : return { LIT : LIT } NAME = NAME ( NAME . NAME ) return { LIT : NAME . NAME , LIT : NAME ( NAME ) , LIT : NAME . NAME ( [ NAME [ LIT ] for NAME in NAME ] ) , LIT : NAME . NAME ( [ NAME [ LIT ] for NAME in NAME ] ) , LIT : NAME . NAME }"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "MLBasedOptimizer.__init__",
      "lineno": 504,
      "end_lineno": 514,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "d7e87b850e230dc7bd72f0a1ae249283d976fa19",
      "simhash64": 7452293064101893159,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] NAME . NAME : NAME [ NAME , NAME ] = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } NAME . NAME : NAME = LIT NAME . NAME : NAME = LIT NAME . NAME : NAME = LIT # Retrain every hour"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "MLBasedOptimizer.add_training_sample",
      "lineno": 516,
      "end_lineno": 538,
      "is_method": true,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 23,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, current_rps, success_rate, avg_response_time, rate_limit_rate, throughput, outcome_score)",
      "fingerprint": "049f058ff586b6d629c3d69ec74ec0056d8b0d53",
      "simhash64": 7451729014569743403,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) : LIT NAME = { LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME } NAME . NAME . NAME ( NAME ) # Keep only recent data (last 1000 samples) if NAME ( NAME . NAME ) > LIT : NAME . NAME = NAME . NAME [ - LIT : ]"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "MLBasedOptimizer.predict_optimal_rps",
      "lineno": 540,
      "end_lineno": 566,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 27,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, current_success_rate, current_response_time, current_rate_limit_rate)",
      "fingerprint": "bf3466bbf886893e34197dda1825f02a0158b4f6",
      "simhash64": 7452151226028176499,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT if NAME ( NAME . NAME ) < LIT : return LIT # Default if insufficient data # Simple weighted scoring based on historical patterns NAME = - LIT NAME = LIT for NAME in NAME . NAME [ - LIT : ] : # Use recent samples # Calculate similarity to current conditions NAME = NAME . NAME ( NAME , NAME , NAME , NAME [ LIT ] , NAME [ LIT ] , NAME [ LIT ] ) # Weight by similarity and outcome score NAME = NAME * NAME [ LIT ] if NAME > NAME : NAME = NAME NAME = NAME [ LIT ] return NAME"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "MLBasedOptimizer._calculate_similarity",
      "lineno": 568,
      "end_lineno": 583,
      "is_method": true,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, sr1, rt1, rl1, sr2, rt2, rl2)",
      "fingerprint": "13fa798d8daf679eb4c2d574001839dfbc4b0531",
      "simhash64": 7488180022980019219,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT # Normalize differences NAME = NAME ( NAME - NAME ) NAME = NAME ( NAME - NAME ) / NAME ( NAME , NAME , LIT ) NAME = NAME ( NAME - NAME ) # Calculate weighted similarity (higher = more similar) NAME = ( ( LIT - NAME ) * NAME . NAME [ LIT ] + ( LIT - NAME ) * NAME . NAME [ LIT ] + ( LIT - NAME ) * NAME . NAME [ LIT ] ) return NAME ( LIT , NAME )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "PredictiveProcessor.__init__",
      "lineno": 591,
      "end_lineno": 594,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "82ca1163a0c221ff6a5698a16550c80f8730a4a2",
      "simhash64": 7452080857216889943,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME : NAME [ NAME , NAME [ NAME [ NAME , NAME ] ] ] = { } NAME . NAME : NAME [ NAME , NAME [ NAME , NAME ] ] = { } # hour -> predictions NAME . NAME : NAME [ NAME , NAME ] = { } # load_level -> optimal_rps"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "PredictiveProcessor.record_processing_pattern",
      "lineno": 596,
      "end_lineno": 621,
      "is_method": true,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 26,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, pattern_type, load_level, optimal_rps, success_rate, response_time)",
      "fingerprint": "7f368e989bbbe73bec75a86e177328b92782fd4e",
      "simhash64": 7452151226028176407,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) : LIT NAME = NAME . NAME ( ) . NAME if NAME not in NAME . NAME : NAME . NAME [ NAME ] = [ ] NAME = { LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME } NAME . NAME [ NAME ] . NAME ( NAME ) # Keep only recent patterns (last 500 per type) if NAME ( NAME . NAME [ NAME ] ) > LIT : NAME . NAME [ NAME ] = NAME . NAME [ NAME ] [ - LIT : ]"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "SystemHealthMonitor.__init__",
      "lineno": 629,
      "end_lineno": 638,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "18b801d2311c79f63795a5dfc75ca823227d0e3a",
      "simhash64": 7452856014046926383,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] NAME . NAME : NAME [ NAME , NAME [ NAME , NAME ] ] = { LIT : { LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT } } NAME . NAME : NAME = True"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "SystemHealthMonitor.update_health_metrics",
      "lineno": 640,
      "end_lineno": 661,
      "is_method": true,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 22,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, cpu_usage, memory_usage, error_rate, avg_response_time, throughput)",
      "fingerprint": "dcb65675b99353f09c0f561f07155880c62a159f",
      "simhash64": 7451588277081388043,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) : LIT NAME . NAME = { LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME . NAME ( NAME , NAME , NAME , NAME ) } NAME . NAME . NAME ( NAME . NAME . NAME ( ) ) # Keep only recent history (last 100 samples) if NAME ( NAME . NAME ) > LIT : NAME . NAME = NAME . NAME [ - LIT : ]"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "SystemHealthMonitor._calculate_health_score",
      "lineno": 663,
      "end_lineno": 691,
      "is_method": true,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 29,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, cpu, memory, error_rate, response_time)",
      "fingerprint": "43f93d8341903e761e216b0979d9cf1f3048a5b8",
      "simhash64": 7451729014569735203,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT NAME = LIT # CPU penalty if NAME > LIT : NAME -= LIT elif NAME > LIT : NAME -= LIT # Memory penalty if NAME > LIT : NAME -= LIT elif NAME > LIT : NAME -= LIT # Error rate penalty if NAME > LIT : NAME -= LIT elif NAME > LIT : NAME -= LIT # Response time penalty if NAME > LIT : NAME -= LIT elif NAME > LIT : NAME -= LIT return NAME ( LIT , NAME )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "test_adaptive_rate_limiter",
      "lineno": 695,
      "end_lineno": 719,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 25,
      "tags": [
        "impure",
        "network",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3330dde2a36375a2d21d0470ad6048b735e8ac47",
      "simhash64": 7452291964523156507,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) NAME = NAME ( NAME = LIT , NAME = LIT , NAME = LIT ) # Test basic functionality NAME = NAME . NAME ( ) assert NAME >= LIT , LIT # Test response recording NAME . NAME ( NAME = True , NAME = LIT , NAME = LIT ) NAME . NAME ( NAME = False , NAME = LIT , NAME = LIT , NAME = LIT ) NAME = NAME . NAME ( ) assert NAME . NAME == LIT , LIT assert NAME . NAME == LIT , LIT # Test settings retrieval NAME = NAME . NAME ( ) assert LIT in NAME , LIT assert LIT in NAME , LIT NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "test_smart_batch_processor",
      "lineno": 722,
      "end_lineno": 740,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5f643a5e61a105d0172538d9c49f783790dfd1d0",
      "simhash64": 5146448955309462571,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) NAME = NAME ( NAME = LIT , NAME = LIT , NAME = LIT ) # Test basic functionality NAME = NAME . NAME ( ) assert NAME == LIT , LIT # Test performance recording NAME . NAME ( NAME = LIT , NAME = LIT , NAME = LIT ) NAME = NAME . NAME ( ) assert LIT in NAME , LIT assert NAME [ LIT ] == LIT , LIT NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "ConfigurationOptimizer.__init__",
      "lineno": 748,
      "end_lineno": 751,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "aa0d7bf0ba1c92a8453b4b51917ad2a860b76f2b",
      "simhash64": 7452151226028176403,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME : NAME = NAME ( NAME = LIT ) NAME . NAME : NAME [ NAME [ NAME , NAME ] ] = [ ]"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "ConfigurationOptimizer.analyze_performance",
      "lineno": 753,
      "end_lineno": 818,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 66,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, rate_limiter_stats, batch_processor_summary, system_metrics)",
      "fingerprint": "cb79feae4b5de1078029f377ceb49a7cd571e673",
      "simhash64": 7451729014636844075,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME [ NAME , NAME ] ] = None ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME ( NAME ) , LIT : [ ] } # Generate recommendations based on analysis NAME = [ ] # Rate limiting recommendations if NAME . NAME > NAME . NAME * LIT : NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : NAME . NAME , LIT : NAME . NAME * LIT } ) # Batch processing recommendations if NAME . NAME ( LIT , LIT ) > LIT : NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME ( LIT , NAME . NAME ( LIT , LIT ) - LIT ) } ) # Performance recommendations NAME = ( NAME . NAME / NAME ( LIT , NAME . NAME ) ) if NAME > LIT and NAME . NAME < LIT : NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : NAME . NAME , LIT : NAME ( LIT , NAME . NAME * LIT ) } ) NAME [ LIT ] = NAME NAME . NAME . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "ConfigurationOptimizer._analyze_rate_limiting",
      "lineno": 820,
      "end_lineno": 835,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, stats)",
      "fingerprint": "d6fbb80f7647d1f0a9440ae7081f252564b4388a",
      "simhash64": 7451729013495993347,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT if NAME . NAME == LIT : return { LIT : LIT } NAME = NAME . NAME / NAME . NAME NAME = NAME . NAME / NAME . NAME return { LIT : NAME , LIT : NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : LIT if NAME > LIT and NAME < LIT else LIT }"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "ConfigurationOptimizer._analyze_batch_processing",
      "lineno": 837,
      "end_lineno": 852,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, summary)",
      "fingerprint": "50884eea04626fbdad019b7a188aab6805f8755e",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT if not NAME or NAME . NAME ( LIT , LIT ) == LIT : return { LIT : LIT } NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) return { LIT : NAME , LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME / NAME ( LIT , NAME ) , LIT : LIT if NAME < NAME and NAME > LIT else LIT }"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "ConfigurationOptimizer.get_optimization_report",
      "lineno": 854,
      "end_lineno": 884,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 11,
      "loc": 31,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "051335fe50d2dfeef147943fdd6c154e7e7716c1",
      "simhash64": 7452151226028176467,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME . NAME : return LIT NAME = [ NAME for NAME in NAME . NAME if NAME . NAME ( LIT ) == LIT ] NAME = [ NAME for NAME in NAME . NAME if NAME . NAME ( LIT ) == LIT ] NAME = [ NAME for NAME in NAME . NAME if NAME . NAME ( LIT ) == LIT ] NAME = LIT NAME += LIT * LIT + LIT if NAME : NAME += LIT for NAME in NAME [ - LIT : ] : # Last 3 high priority NAME += f\" \u2022 { NAME [ LIT ] } \\n \" NAME += f\" { NAME [ LIT ] } \\n\\n \" if NAME : NAME += LIT for NAME in NAME [ - LIT : ] : # Last 3 medium priority NAME += f\" \u2022 { NAME [ LIT ] } \\n \" NAME += f\" { NAME [ LIT ] } \\n\\n \" if NAME : NAME += LIT for NAME in NAME [ - LIT : ] : # Last 2 low priority NAME += f\" \u2022 { NAME [ LIT ] } \\n \" NAME += f\" { NAME [ LIT ] } \\n\\n \" return NAME . NAME ( )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "test_configuration_optimizer",
      "lineno": 887,
      "end_lineno": 919,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 33,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "6e36215b6aff5bd8d4347034072cfa0d0fc23798",
      "simhash64": 5145887104934778411,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) NAME = NAME ( ) # Test data NAME = NAME ( NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT ) NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } # Test analysis NAME = NAME . NAME ( NAME , NAME ) assert LIT in NAME , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "test_regression_prevention_rate_limiter_caching",
      "lineno": 922,
      "end_lineno": 1014,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 11,
      "loc": 93,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "json",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "63c07f295c0fc0caa91b9f9ca61b4c1a46e9f43d",
      "simhash64": 8641136712026068011,
      "normalized": "def NAME ( ) -> NAME : LIT NAME ( LIT ) NAME = [ ] try : # Test 1: Verify caching methods exist NAME = NAME ( ) if NAME ( NAME , LIT ) : NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) if NAME ( NAME , LIT ) : NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) # Test 2: Verify initial RPS is reasonable (should be from cache or default) NAME = NAME . NAME if LIT <= NAME <= LIT : # Reasonable bounds NAME ( f\" \u2705 Initial RPS reasonable: { NAME } \" ) NAME . NAME ( True ) else : NAME ( f\" \u274c Initial RPS suspicious: { NAME } \" ) NAME . NAME ( False ) # Test 3: Test save/load cycle try : # Adjust RPS and save NAME = LIT NAME . NAME = NAME NAME . NAME ( ) # Create new limiter (should load saved settings) NAME = NAME ( ) NAME ( f\" \u2705 Save/load cycle test completed (RPS: { NAME . NAME } -> { NAME . NAME } ) \" ) NAME . NAME ( True ) except NAME as NAME : NAME ( f\" \u26a0\ufe0f  Save/load cycle test failed: { NAME } \" ) NAME . NAME ( False ) # Test 4: Verify cache file functionality (actual implementation check) try : # Check that the cache file path is accessible in the actual implementation import NAME NAME = NAME . NAME ( NAME . NAME ) # Look for the cache file path in the actual code NAME = LIT in NAME if NAME : NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) # Test that Cache directory exists or can be created from NAME import NAME NAME = NAME ( LIT ) if NAME . NAME ( ) or True : # Directory can be created if needed NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) except NAME as NAME : NAME ( f\" \u26a0\ufe0f  Cache file path test failed: { NAME } \" ) NAME . NAME ( False ) except NAME as NAME : NAME ( f\" \u274c Rate limiter caching test failed: { NAME } \" ) NAME . NAME ( False ) NAME = NAME ( NAME ) if NAME : NAME ( LIT ) return NAME"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "adaptive_rate_limiter_module_tests",
      "lineno": 1017,
      "end_lineno": 1061,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 45,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "3d5b1f0b5799e9e1196e0f533921d0bbe5a34b29",
      "simhash64": 5145885975287075883,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # \ud83d\udee1\ufe0f REGRESSION PREVENTION TESTS NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "adaptive_rate_limiter.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 1064,
      "end_lineno": 1066,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "get_prompt",
      "lineno": 95,
      "end_lineno": 96,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(_prompt_key)",
      "fingerprint": "9fca1938a567da32f08bfb7ec6523aa41e886341",
      "simhash64": 5182302343248393335,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : # type: ignore return None"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "load_prompts",
      "lineno": 97,
      "end_lineno": 98,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d14d7b06cdd81fa49feea84b653d27ebbf887962",
      "simhash64": 7453382643551735871,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : # type: ignore return { LIT : { } }"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "get_fallback_extraction_prompt",
      "lineno": 131,
      "end_lineno": 157,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 27,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7b15ce4efa3521dc6d245388aa4886dc1ded178d",
      "simhash64": 8645656048501697195,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME . NAME return f\"\"\" You are an AI assistant analyzing conversation histories from a genealogy website messaging system. The history alternates between 'SCRIPT' (automated messages from me) and 'USER' (replies from the DNA match).\n\nAnalyze the entire provided conversation history, focusing on information shared by the USER.\n\nYour goal is twofold:\n1.  **Extract Key Genealogical Information:** Identify and extract specific entities mentioned by the USER. Structure this as an object under an \"extracted_data\" key. This object should contain lists of strings for entities like: \"mentioned_names\" (full names preferred), \"mentioned_locations\" (towns, counties, countries), \"mentioned_dates\" (e.g., \"abt 1880\", \"1912-1915\"), \"potential_relationships\" (e.g., \"my grandfather\", \"her sister\"), and \"key_facts\" (e.g., \"immigrated via Liverpool\", \"worked in coal mines\"). Only include entities explicitly mentioned by the USER. Do not infer or add information not present. If no entities of a certain type are found, provide an empty list [].\n2.  **Suggest Actionable Follow-up Tasks:** Based ONLY on the information provided in the conversation history, suggest 2-4 concrete, actionable research tasks for 'Me'/' { NAME } '. Tasks MUST be directly based on information, questions, or ambiguities present *only* in the provided conversation history. Tasks should be specific. Examples: \"Check [Year] census for [Name] in [Location]\", \"Search ship manifests for [Name] arriving [Port] around [Date]\", \"Compare shared matches with [Match Name]\", \"Look for [Event record] for [Name] in [Place]\". Provide this as a list of strings under a \"suggested_tasks\" key. Provide an empty list [] if no specific tasks can be suggested.\n\nFormat your response STRICTLY as a JSON object, starting with `{ ` and ending with `} `, with no introductory text or markdown. Example:\n{ \"extracted_data\": { \"mentioned_names\": [\"John Smith\", \"Mary Anne Jones\"],\n    \"mentioned_locations\": [\"Glasgow\", \"County Cork\", \"Liverpool\"],\n    \"mentioned_dates\": [\"abt 1880\", \"1912\"],\n    \"potential_relationships\": [\"Grandfather of current user\"],\n    \"key_facts\": [\"Immigrated via Liverpool\", \"Worked in coal mines\"]\n  } ,\n  \"suggested_tasks\": [\n    \"Check 1881 Scotland Census for John Smith in Glasgow.\",\n    \"Search immigration records for Mary Anne Jones arriving Liverpool around 1910-1915.\"\n  ]\n} \"\"\""
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "get_fallback_reply_prompt",
      "lineno": 161,
      "end_lineno": 195,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 35,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "870c1be0ade7a2e616a02a03ee9888191ec7efeb",
      "simhash64": 9221974689108623918,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME . NAME NAME = NAME . NAME NAME = f\" from { NAME } \" if NAME else LIT return f\"\"\" You are a helpful genealogical assistant named { NAME } responding to messages on behalf of a family history researcher { NAME } .\n\nYou will receive:\n1. A conversation history between the researcher (SCRIPT) and a user (USER).\n2. The user's last message.\n3. Genealogical data about a person mentioned in the user's message, including: Name, birth/death information, family relationships, relationship to the tree owner (the researcher).\n\nYour task is to generate a natural, polite, and informative reply that:\n- Directly addresses the user's query or comment.\n- Incorporates the provided genealogical data in a helpful way.\n- Acknowledges the user's point and integrates the found information smoothly.\n- May suggest connections or ask a clarifying follow-up question if appropriate.\n- Maintains a warm, helpful, conversational tone.\n- Refers to yourself as \"I\" and the tree as \"my family tree\" or \"my records\".\n- Shows genuine interest in the user's research and family connections.\n\nIMPORTANT: When replying about people found in your tree, you MUST include:\n1. COMPLETE birth details (full date and place if available).\n2. COMPLETE death details (full date and place if available).\n3. DETAILED family information (parents, spouse, children).\n4. SPECIFIC relationship to you (the tree owner).\n5. Any other significant details like occupation, immigration, etc.\n\nIf multiple people are mentioned in the genealogical data, focus on the one with the highest match score or most complete information.\nIf the genealogical data indicates \"No person found\" or is empty, acknowledge this and ask for more details that might help identify the person in your records.\nFor people not in your tree, acknowledge this and ask for more details that might help identify connections.\n\nYour response should be ONLY the message text, with no additional formatting, explanation, or signature (the system will add a signature automatically). \"\"\""
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "_call_ai_model",
      "lineno": 202,
      "end_lineno": 394,
      "is_method": false,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 8,
      "yield_count": 0,
      "complexity": 47,
      "loc": 193,
      "tags": [
        "impure",
        "network",
        "size:large"
      ],
      "signature": "(provider, system_prompt, user_content, session_manager, max_tokens, temperature, response_format_type)",
      "fingerprint": "21a976dd10660f0fad08f96341135c16ab2d6433",
      "simhash64": 7488180022981071891,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None , # e.g., \"json_object\" for DeepSeek ) -> NAME [ NAME ] : LIT NAME . NAME ( f\" Calling AI model. Provider: { NAME } , Max Tokens: { NAME } , Temp: { NAME } \" ) # Apply rate limiting (guarded) NAME = None try : if NAME and NAME ( NAME , LIT ) : NAME = NAME ( NAME , LIT , None ) if NAME is not None and NAME ( NAME , LIT ) : NAME = NAME . NAME ( ) if NAME ( NAME , ( NAME , NAME ) ) and NAME > LIT : NAME . NAME ( f\" AI API rate limit wait: { NAME ( NAME ) : .2f } s for { NAME } \" ) else : NAME . NAME ( LIT ) except NAME : NAME . NAME ( LIT ) NAME : NAME [ NAME ] = None try : if NAME == LIT : if not NAME or NAME is None : NAME . NAME ( LIT ) return None NAME = NAME . NAME . NAME NAME = NAME . NAME . NAME NAME = NAME . NAME . NAME if not NAME ( [ NAME , NAME , NAME ] ) : NAME . NAME ( LIT ) return None NAME = NAME ( NAME = NAME , NAME = NAME ) NAME = [ { LIT : LIT , LIT : NAME } , { LIT : LIT , LIT : NAME } , ] NAME : NAME [ NAME , NAME ] = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : False , } if NAME == LIT : NAME [ LIT ] = { LIT : LIT } NAME = NAME . NAME . NAME . NAME ( ** NAME ) if ( NAME . NAME and NAME . NAME [ LIT ] . NAME and NAME . NAME [ LIT ] . NAME . NAME ) : NAME = NAME . NAME [ LIT ] . NAME . NAME . NAME ( ) else : NAME . NAME ( LIT ) elif NAME == LIT : if not NAME or NAME is None or NAME is None : NAME . NAME ( LIT ) return None NAME = NAME ( NAME . NAME , LIT , None ) NAME = NAME ( NAME . NAME , LIT , None ) if not NAME or not NAME : NAME . NAME ( LIT ) return None if not NAME ( NAME , LIT ) or not NAME ( NAME , LIT ) : NAME . NAME ( LIT ) return None try : NAME . NAME ( NAME = NAME ) # type: ignore[attr-defined] NAME = NAME . NAME ( NAME ) # type: ignore[attr-defined] except NAME as NAME : NAME . NAME ( f\" _call_ai_model: Failed initializing Gemini model: { NAME } \" ) return None # Gemini prefers the system prompt to be part of the main prompt content # or handled through specific parts if using more complex multi-turn chat. # For simplicity here, we'll prepend system prompt to user content. NAME = ( f\" { NAME } \\n\\n---\\n\\nUser Query/Content:\\n { NAME } \" ) # Create a proper GenerationConfig object instead of a dictionary NAME = None if NAME ( NAME , LIT ) : try : NAME = NAME . NAME ( # type: ignore[attr-defined] NAME = LIT , NAME = NAME , NAME = NAME , ) except NAME : NAME = None # Gemini's way of requesting JSON is less direct, often relies on prompt engineering. # If `response_format_type` is 'json_object', ensure the prompt strongly requests JSON. NAME = None if NAME ( NAME , LIT ) : try : NAME = NAME . NAME ( NAME , NAME = NAME ) # type: ignore[call-arg] except NAME as NAME : NAME . NAME ( f\" Gemini generation failed: { NAME } \" ) NAME = None if NAME is not None and NAME ( NAME , LIT , None ) : NAME = NAME ( NAME , LIT , LIT ) . NAME ( ) else : NAME = LIT try : if NAME is not None and NAME ( NAME , LIT ) : NAME = NAME ( NAME , LIT , None ) if NAME and NAME ( NAME , LIT ) : NAME = NAME ( NAME , LIT , None ) if NAME ( NAME , LIT ) : NAME = NAME ( NAME , LIT , LIT ) elif NAME is not None : NAME = NAME ( NAME ) except NAME : pass NAME . NAME ( f\" Gemini returned an empty or blocked response. Reason: { NAME } \" ) else : NAME . NAME ( f\" _call_ai_model: Unsupported AI provider ' { NAME } '. \" ) return None except NAME as NAME : # type: ignore NAME . NAME ( f\" AI Authentication Error ( { NAME } ): { NAME } \" ) except NAME as NAME : # type: ignore NAME . NAME ( f\" AI Rate Limit Error ( { NAME } ): { NAME } \" ) if NAME and NAME ( NAME , LIT ) : try : NAME = NAME ( NAME , LIT , None ) if NAME is not None and NAME ( NAME , LIT ) : NAME . NAME ( ) except NAME : pass except NAME as NAME : # type: ignore NAME . NAME ( f\" AI Connection Error ( { NAME } ): { NAME } \" ) except NAME as NAME : # type: ignore NAME . NAME ( f\" AI API Error ( { NAME } ): Status= { NAME ( NAME , LIT , LIT ) } , Message= { NAME ( NAME , LIT , NAME ( NAME ) ) } \" ) except NAME . NAME as NAME : # type: ignore NAME . NAME ( f\" Gemini Permission Denied: { NAME } \" ) except NAME . NAME as NAME : # type: ignore NAME . NAME ( f\" Gemini Resource Exhausted (Rate Limit): { NAME } \" ) if NAME and NAME ( NAME , LIT ) : try : NAME = NAME ( NAME , LIT , None ) if NAME is not None and NAME ( NAME , LIT ) : NAME . NAME ( ) except NAME : pass except NAME . NAME as NAME : # type: ignore NAME . NAME ( f\" Google API Error (Gemini): { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" AttributeError during AI call ( { NAME } ): { NAME } . Lib loaded: OpenAI= { NAME } , Gemini= { NAME } \" , NAME = True , ) except NAME as NAME : NAME . NAME ( f\" NameError during AI call ( { NAME } ): { NAME } . Lib loaded: OpenAI= { NAME } , Gemini= { NAME } \" , NAME = True , ) except NAME as NAME : NAME . NAME ( f\" Unexpected error in _call_ai_model ( { NAME } ): { NAME ( NAME ) . NAME } - { NAME } \" , NAME = True , ) return NAME"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "classify_message_intent",
      "lineno": 403,
      "end_lineno": 457,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 8,
      "loc": 55,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(context_history, session_manager)",
      "fingerprint": "2b1bae05f73cec6b722cd18cbe4a956b7aae05ba",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME ] : LIT NAME = NAME . NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) return None if not NAME : NAME . NAME ( LIT ) return LIT NAME = NAME if NAME : try : NAME = NAME ( LIT ) if NAME : NAME = NAME else : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error loading 'intent_classification' prompt: { NAME } , using fallback. \" ) NAME = NAME . NAME ( ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , # Expecting a single word NAME = LIT , ) NAME = NAME . NAME ( ) - NAME if NAME : NAME = NAME . NAME ( ) . NAME ( ) if NAME in NAME : NAME . NAME ( f\" AI intent classification: ' { NAME } ' (Took { NAME : .2f } s) \" ) return NAME NAME . NAME ( f\" AI returned unexpected classification: ' { NAME } '. Defaulting to OTHER. \" ) return LIT NAME . NAME ( f\" AI intent classification failed. (Took { NAME : .2f } s) \" ) return None"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "extract_genealogical_entities",
      "lineno": 463,
      "end_lineno": 724,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 41,
      "loc": 262,
      "tags": [
        "pure-ish",
        "time",
        "json",
        "size:large"
      ],
      "signature": "(context_history, session_manager)",
      "fingerprint": "b2794a0a10ed575397fa3ac3cde18b0d2dcb9d59",
      "simhash64": 5146308216747365435,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = NAME . NAME . NAME ( ) NAME = { LIT : { } , LIT : [ ] } if not NAME : NAME . NAME ( LIT ) return NAME if not NAME : NAME . NAME ( LIT ) return NAME NAME = ( NAME ( ) ) # Dynamic default if NAME : try : # If experimentation utilities available, attempt variant selection try : from NAME import ( NAME , # local import to avoid circular at module import ) # Variants mapping (control vs alt). Additional variants can be added safely. NAME = { LIT : LIT , LIT : LIT } NAME = NAME ( LIT , NAME = NAME , NAME = NAME ( NAME , LIT , None ) ) except NAME : NAME = NAME ( LIT ) if NAME : NAME = NAME else : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error loading 'extraction_task' prompt (experiments path): { NAME } , using fallback. \" ) NAME = NAME . NAME ( ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , # Increased for potentially larger JSON NAME = LIT , NAME = LIT , # For DeepSeek ) NAME = NAME . NAME ( ) - NAME if NAME : try : # Clean the response string (remove potential markdown code blocks) NAME = NAME . NAME ( ) if NAME . NAME ( LIT ) : NAME = NAME [ NAME ( LIT ) : ] . NAME ( ) elif NAME . NAME ( LIT ) : NAME = NAME [ NAME ( LIT ) : ] . NAME ( ) if NAME . NAME ( LIT ) : NAME = NAME [ : - NAME ( LIT ) ] . NAME ( ) NAME = NAME . NAME ( NAME ) if ( NAME ( NAME , NAME ) and LIT in NAME and NAME ( NAME [ LIT ] , NAME ) and LIT in NAME and NAME ( NAME [ LIT ] , NAME ) ) : NAME . NAME ( f\" AI extraction successful. (Took { NAME : .2f } s) \" ) # Telemetry try : # pragma: no cover - instrumentation from NAME import NAME from NAME import NAME , NAME from NAME import NAME # Determine variant label heuristically (control vs alt) NAME = LIT if LIT in NAME [ : LIT ] else LIT NAME = NAME ( NAME ) # Component coverage: fraction of structured keys that are non-empty try : NAME = NAME . NAME ( LIT , { } ) if NAME ( NAME , NAME ) else { } NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ] NAME = LIT NAME = NAME ( NAME ) for NAME in NAME : NAME = NAME . NAME ( NAME ) if NAME ( NAME , NAME ) and NAME ( NAME ) > LIT : NAME += LIT NAME = ( NAME / NAME ) if NAME else LIT except NAME : NAME = None with NAME . NAME ( NAME ) : NAME [ LIT ] = NAME NAME = None try : NAME = NAME ( NAME ) except NAME : NAME = None NAME ( NAME = NAME , NAME = LIT if NAME == LIT else LIT , NAME = NAME ( LIT if NAME == LIT else LIT ) , NAME = True , NAME = NAME . NAME ( LIT ) , NAME = NAME . NAME ( LIT ) , NAME = NAME , NAME = NAME ( NAME , LIT , None ) , NAME = NAME , NAME = NAME , NAME = NAME , ) except NAME : pass return NAME NAME . NAME ( f\" AI extraction response is valid JSON but uses flat structure instead of nested. Attempting to transform. Response: { NAME [ : LIT ] } \" ) # Attempt to salvage by transforming flat structure to expected nested structure NAME = NAME . NAME ( ) if NAME ( NAME , NAME ) : # Handle expected nested structure if LIT in NAME and NAME ( NAME [ LIT ] , NAME ) : NAME [ LIT ] = NAME [ LIT ] if LIT in NAME and NAME ( NAME [ LIT ] , NAME ) : NAME [ LIT ] = NAME [ LIT ] # Handle flat structure and transform to nested else : NAME = { } # Map flat structure keys to expected nested structure NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } for NAME , NAME in NAME . NAME ( ) : if NAME in NAME and NAME ( NAME [ NAME ] , NAME ) : if NAME not in NAME : NAME [ NAME ] = [ ] NAME [ NAME ] . NAME ( NAME [ NAME ] ) # Ensure all expected keys exist for NAME in [ LIT , LIT , LIT , LIT , LIT , ] : if NAME not in NAME : NAME [ NAME ] = [ ] NAME [ LIT ] = NAME # Note: flat structure doesn't include suggested_tasks, so it remains empty NAME . NAME ( f\" Successfully transformed flat structure to nested. Extracted { NAME ( NAME . NAME ( LIT , [ ] ) ) } names, { NAME ( NAME . NAME ( LIT , [ ] ) ) } locations, { NAME ( NAME . NAME ( LIT , [ ] ) ) } dates \" ) try : # Telemetry salvage event from NAME import NAME from NAME import NAME , NAME from NAME import NAME NAME = LIT if LIT in NAME [ : LIT ] else LIT NAME = NAME ( NAME ) try : NAME = NAME . NAME ( LIT , { } ) if NAME ( NAME , NAME ) else { } NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ] NAME = LIT NAME = NAME ( NAME ) for NAME in NAME : NAME = NAME . NAME ( NAME ) if NAME ( NAME , NAME ) and NAME ( NAME ) > LIT : NAME += LIT NAME = ( NAME / NAME ) if NAME else LIT except NAME : NAME = None with NAME . NAME ( NAME ) : NAME [ LIT ] = NAME NAME = None try : NAME = NAME ( NAME ) except NAME : NAME = None NAME ( NAME = NAME , NAME = LIT if NAME == LIT else LIT , NAME = NAME ( LIT if NAME == LIT else LIT ) , NAME = False , NAME = NAME . NAME ( LIT ) , NAME = NAME . NAME ( LIT ) , NAME = NAME , NAME = NAME ( NAME , LIT , None ) , NAME = LIT , NAME = NAME , NAME = NAME , NAME = NAME , ) except NAME : pass return NAME except NAME . NAME as NAME : NAME . NAME ( f\" AI extraction response was not valid JSON: { NAME } . Response: { NAME [ : LIT ] } \" ) try : # Telemetry parse failure from NAME import NAME from NAME import NAME NAME = LIT if LIT in NAME [ : LIT ] else LIT NAME ( NAME = NAME , NAME = LIT if NAME == LIT else LIT , NAME = NAME ( LIT if NAME == LIT else LIT ) , NAME = False , NAME = None , NAME = None , NAME = NAME , NAME = NAME ( NAME , LIT , None ) , NAME = NAME ( NAME ) [ : LIT ] , ) except NAME : pass return NAME else : NAME . NAME ( f\" AI extraction failed or returned empty. (Took { NAME : .2f } s) \" ) try : # Telemetry empty failure from NAME import NAME from NAME import NAME NAME = LIT if LIT in NAME [ : LIT ] else LIT NAME ( NAME = NAME , NAME = LIT if NAME == LIT else LIT , NAME = NAME ( LIT if NAME == LIT else LIT ) , NAME = False , NAME = None , NAME = None , NAME = None , NAME = NAME ( NAME , LIT , None ) , NAME = LIT , NAME = None , ) except NAME : pass return NAME"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "generate_genealogical_reply",
      "lineno": 730,
      "end_lineno": 800,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 8,
      "loc": 71,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(conversation_context, user_last_message, genealogical_data_str, session_manager)",
      "fingerprint": "e2224a5615b48efcc035b6aeb13f3ff374de9aad",
      "simhash64": 7488180022980031515,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , ) -> NAME [ NAME ] : LIT NAME = NAME . NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) return None if not NAME ( [ NAME , NAME , NAME ] ) : NAME . NAME ( LIT ) return None NAME = NAME ( ) if NAME : try : NAME = NAME ( LIT ) if NAME : NAME = NAME else : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error loading 'genealogical_reply' prompt: { NAME } , using fallback. \" ) # The prompt itself is the system message; user_content can be minimal. # The template includes placeholders for {conversation_context}, {user_message}, {genealogical_data} try : NAME = NAME . NAME ( NAME = NAME , NAME = NAME , NAME = NAME , ) except NAME as NAME : NAME . NAME ( f\" Prompt formatting error for genealogical_reply. Missing key: { NAME } . Using unformatted prompt. \" ) NAME = ( NAME # Fallback to unformatted if keys missing ) except NAME as NAME : NAME . NAME ( f\" Unexpected error formatting genealogical_reply prompt: { NAME } . Using unformatted prompt. \" ) NAME = NAME NAME = NAME . NAME ( ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = LIT , # Or \"\" NAME = NAME , NAME = LIT , # For a detailed reply NAME = LIT , ) NAME = NAME . NAME ( ) - NAME if NAME : NAME . NAME ( f\" AI reply generation successful. (Took { NAME : .2f } s) \" ) else : NAME . NAME ( f\" AI reply generation failed. (Took { NAME : .2f } s) \" ) return NAME"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "extract_with_custom_prompt",
      "lineno": 806,
      "end_lineno": 857,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 8,
      "loc": 52,
      "tags": [
        "pure-ish",
        "time",
        "json",
        "size:medium"
      ],
      "signature": "(context_history, custom_prompt, session_manager)",
      "fingerprint": "eedc473586fc4ca2738e9c73db5dca81b95e7eb8",
      "simhash64": 7488180022980023299,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = NAME . NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) return None if not NAME : NAME . NAME ( LIT ) return None NAME = NAME . NAME ( ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , # Assume JSON is often desired ) NAME = NAME . NAME ( ) - NAME if NAME : NAME . NAME ( f\" AI custom extraction successful. (Took { NAME : .2f } s) \" ) try : # Clean the response string NAME = NAME . NAME ( ) if NAME . NAME ( LIT ) : NAME = NAME [ NAME ( LIT ) : ] . NAME ( ) elif NAME . NAME ( LIT ) : NAME = NAME [ NAME ( LIT ) : ] . NAME ( ) if NAME . NAME ( LIT ) : NAME = NAME [ : - NAME ( LIT ) ] . NAME ( ) NAME = NAME . NAME ( NAME ) return { LIT : NAME } except NAME . NAME : NAME . NAME ( LIT ) return { LIT : NAME } # Return raw string under 'extracted_data' else : NAME . NAME ( f\" AI custom extraction failed or returned empty. (Took { NAME : .2f } s) \" ) return None"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "generate_with_custom_prompt",
      "lineno": 863,
      "end_lineno": 916,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 54,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(conversation_context, user_last_message, genealogical_data_str, custom_prompt, session_manager)",
      "fingerprint": "1d33fd0aae591be6f96e35afb3675268493af80d",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , ) -> NAME [ NAME ] : LIT NAME = NAME . NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) return None if not NAME : NAME . NAME ( LIT ) return None try : # Format the custom_prompt with the context, user message, and genealogical data NAME = NAME . NAME ( NAME = NAME , NAME = NAME , NAME = NAME , ) except NAME as NAME : NAME . NAME ( f\" Custom prompt formatting error. Missing key: { NAME } . Using unformatted custom prompt. \" ) NAME = NAME # Fallback to unformatted if keys missing except NAME as NAME : NAME . NAME ( f\" Unexpected error formatting custom prompt: { NAME } . Using unformatted custom prompt. \" ) NAME = NAME NAME = NAME . NAME ( ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , ) NAME = NAME . NAME ( ) - NAME if NAME : NAME . NAME ( f\" AI custom generation successful. (Took { NAME : .2f } s) \" ) else : NAME . NAME ( f\" AI custom generation failed or returned empty. (Took { NAME : .2f } s) \" ) return NAME"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "analyze_dna_match_conversation",
      "lineno": 924,
      "end_lineno": 982,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 8,
      "loc": 59,
      "tags": [
        "pure-ish",
        "time",
        "json",
        "size:medium"
      ],
      "signature": "(context_history, session_manager)",
      "fingerprint": "047548168cb729bedf67f04e333cd3889157be12",
      "simhash64": 7488109654235853851,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = NAME . NAME . NAME ( ) NAME = { LIT : { } , LIT : [ ] } if not NAME : NAME . NAME ( LIT ) return NAME if not NAME : NAME . NAME ( LIT ) return NAME # Get DNA match analysis prompt NAME = LIT if NAME : try : NAME = NAME ( LIT ) if NAME : NAME = NAME else : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error loading 'dna_match_analysis' prompt: { NAME } , using fallback. \" ) NAME = NAME . NAME ( ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME = NAME . NAME ( ) - NAME if NAME : try : NAME = NAME . NAME ( NAME ) NAME . NAME ( f\" DNA match analysis successful. (Took { NAME : .2f } s) \" ) return NAME except NAME . NAME as NAME : NAME . NAME ( f\" DNA match analysis JSON parsing failed: { NAME } \" ) return NAME else : NAME . NAME ( f\" DNA match analysis failed. (Took { NAME : .2f } s) \" ) return NAME"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "verify_family_tree_connections",
      "lineno": 985,
      "end_lineno": 1043,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 8,
      "loc": 59,
      "tags": [
        "pure-ish",
        "time",
        "json",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(context_history, session_manager)",
      "fingerprint": "19efed3311d9753ad2b7436468b4649359f98842",
      "simhash64": 7488109654235853851,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = NAME . NAME . NAME ( ) NAME = { LIT : { } , LIT : [ ] } if not NAME : NAME . NAME ( LIT ) return NAME if not NAME : NAME . NAME ( LIT ) return NAME # Get family tree verification prompt NAME = LIT if NAME : try : NAME = NAME ( LIT ) if NAME : NAME = NAME else : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error loading 'family_tree_verification' prompt: { NAME } , using fallback. \" ) NAME = NAME . NAME ( ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME = NAME . NAME ( ) - NAME if NAME : try : NAME = NAME . NAME ( NAME ) NAME . NAME ( f\" Family tree verification analysis successful. (Took { NAME : .2f } s) \" ) return NAME except NAME . NAME as NAME : NAME . NAME ( f\" Family tree verification JSON parsing failed: { NAME } \" ) return NAME else : NAME . NAME ( f\" Family tree verification analysis failed. (Took { NAME : .2f } s) \" ) return NAME"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "generate_record_research_strategy",
      "lineno": 1046,
      "end_lineno": 1104,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 8,
      "loc": 59,
      "tags": [
        "pure-ish",
        "time",
        "json",
        "size:medium"
      ],
      "signature": "(context_history, session_manager)",
      "fingerprint": "62ba4bc8e51ab23b20d66dfa0c6361969c00ecce",
      "simhash64": 7488109654235853851,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = NAME . NAME . NAME ( ) NAME = { LIT : { } , LIT : [ ] } if not NAME : NAME . NAME ( LIT ) return NAME if not NAME : NAME . NAME ( LIT ) return NAME # Get record research guidance prompt NAME = LIT if NAME : try : NAME = NAME ( LIT ) if NAME : NAME = NAME else : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error loading 'record_research_guidance' prompt: { NAME } , using fallback. \" ) NAME = NAME . NAME ( ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME = NAME . NAME ( ) - NAME if NAME : try : NAME = NAME . NAME ( NAME ) NAME . NAME ( f\" Record research strategy generation successful. (Took { NAME : .2f } s) \" ) return NAME except NAME . NAME as NAME : NAME . NAME ( f\" Record research strategy JSON parsing failed: { NAME } \" ) return NAME else : NAME . NAME ( f\" Record research strategy generation failed. (Took { NAME : .2f } s) \" ) return NAME"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "test_configuration",
      "lineno": 1110,
      "end_lineno": 1183,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 12,
      "loc": 74,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "9c8cd7a37fa2ff4fb7ae86cd856f289194289a82",
      "simhash64": 8641136711958959107,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) NAME = True # Test AI provider setting NAME = NAME . NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) NAME = False elif NAME not in [ LIT , LIT ] : NAME . NAME ( f\" \u274c Invalid AI_PROVIDER: { NAME } . Must be 'deepseek' or 'gemini' \" ) NAME = False else : NAME . NAME ( f\" \u2705 AI_PROVIDER: { NAME } \" ) # Test provider-specific configuration if NAME == LIT : if not NAME : NAME . NAME ( LIT ) NAME = False else : NAME . NAME ( LIT ) NAME = NAME . NAME . NAME NAME = NAME . NAME . NAME NAME = NAME . NAME . NAME if not NAME : NAME . NAME ( LIT ) NAME = False else : NAME . NAME ( f\" \u2705 DEEPSEEK_API_KEY configured (length: { NAME ( NAME ) } ) \" ) if not NAME : NAME . NAME ( LIT ) NAME = False else : NAME . NAME ( f\" \u2705 DEEPSEEK_AI_MODEL: { NAME } \" ) if not NAME : NAME . NAME ( LIT ) NAME = False else : NAME . NAME ( f\" \u2705 DEEPSEEK_AI_BASE_URL: { NAME } \" ) elif NAME == LIT : if not NAME : NAME . NAME ( LIT ) NAME = False else : NAME . NAME ( LIT ) NAME = NAME . NAME . NAME NAME = NAME . NAME . NAME if not NAME : NAME . NAME ( LIT ) NAME = False else : NAME . NAME ( f\" \u2705 GOOGLE_API_KEY configured (length: { NAME ( NAME ) } ) \" ) if not NAME : NAME . NAME ( LIT ) NAME = False else : NAME . NAME ( f\" \u2705 GOOGLE_AI_MODEL: { NAME } \" ) return NAME"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "test_prompt_loading",
      "lineno": 1186,
      "end_lineno": 1254,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 11,
      "loc": 69,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "d19bced0c4ff6036b428d170961833c93a2b7603",
      "simhash64": 7488215207352112699,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) NAME = True NAME = [ LIT , LIT , LIT , ] try : # Test loading all prompts NAME = NAME ( ) if not NAME : NAME . NAME ( LIT ) return False NAME . NAME ( f\" \u2705 Loaded { NAME ( NAME ) } prompts from JSON file \" ) # Test each required prompt for NAME in NAME : try : NAME = NAME ( NAME ) if NAME : NAME . NAME ( f\" \u2705 { NAME } : loaded ( { NAME ( NAME ) } characters) \" ) # Test for key indicators in specific prompts if NAME == LIT : # Check for either the nested structure keywords OR the flat structure keywords NAME = ( LIT in NAME and LIT in NAME ) NAME = ( LIT in NAME and LIT in NAME and LIT in NAME ) if NAME or NAME : NAME = ( LIT if NAME else LIT ) NAME . NAME ( f\" \u2705 { NAME } : contains valid { NAME } structure keywords \" ) else : NAME . NAME ( f\" \u26a0\ufe0f { NAME } : missing required structure keywords for either nested or flat format \" ) NAME = False else : NAME . NAME ( f\" \u274c { NAME } : failed to load \" ) NAME = False except NAME as NAME : NAME . NAME ( f\" \u274c { NAME } : error loading - { NAME } \" ) NAME = False except NAME as NAME : NAME . NAME ( f\" \u274c Prompt loading system error: { NAME } \" ) NAME = False return NAME"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "test_pydantic_compatibility",
      "lineno": 1257,
      "end_lineno": 1306,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 50,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "e125451babdef5cb53047ebd4d4626832c724da6",
      "simhash64": 7452151225962107947,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) # Test data structure that should be compatible with action9_process_productive.py models NAME = { LIT : { LIT : [ LIT , LIT ] , LIT : [ LIT , LIT ] , LIT : [ LIT , LIT ] , LIT : [ LIT , LIT ] , LIT : [ LIT , LIT ] , } , LIT : [ LIT , LIT , LIT , ] , } try : # Try to import and test the AIResponse model from NAME import NAME # Test creating the model NAME = NAME ( ** NAME ) NAME . NAME ( LIT ) NAME . NAME ( f\" \u2705 extracted_data type: { NAME ( NAME . NAME ) } \" ) NAME . NAME ( f\" \u2705 suggested_tasks type: { NAME ( NAME . NAME ) } \" ) NAME . NAME ( f\" \u2705 suggested_tasks count: { NAME ( NAME . NAME ) } \" ) # Test accessing nested fields NAME = NAME . NAME NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) NAME . NAME ( f\" \u2705 Nested fields accessible: names= { NAME ( NAME ) } , locations= { NAME ( NAME ) } \" ) return True except NAME as NAME : NAME . NAME ( f\" \u274c Failed to import AIResponse model: { NAME } \" ) return False except NAME as NAME : NAME . NAME ( f\" \u274c Pydantic model test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "test_ai_functionality",
      "lineno": 1309,
      "end_lineno": 1440,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 19,
      "loc": 132,
      "tags": [
        "pure-ish",
        "regex",
        "size:large"
      ],
      "signature": "(session_manager)",
      "fingerprint": "a5fe4de8ba9cbcfacf87f49f42a03e899b01aece",
      "simhash64": 7488180022980023307,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT NAME . NAME ( LIT ) NAME = NAME . NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) NAME = NAME ( LIT , NAME ) if NAME is None : NAME . NAME ( LIT ) return True NAME . NAME ( f\" \u274c Expected None for disabled AI, got: { NAME } \" ) return False # Test with simple inputs if AI is configured NAME . NAME ( f\" Testing with AI provider: { NAME } \" ) try : # Test intent classification NAME = ( LIT ) NAME . NAME ( LIT ) NAME = NAME ( NAME , NAME ) if NAME and NAME in NAME : NAME . NAME ( f\" \u2705 Intent classification successful: { NAME } \" ) elif NAME is None : NAME . NAME ( LIT ) return False else : NAME . NAME ( f\" \u26a0\ufe0f Intent classification returned unexpected result: { NAME } \" ) return False # Test extraction with genealogical content NAME = LIT NAME . NAME ( LIT ) NAME = NAME ( NAME , NAME ) if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , [ ] ) # Count extracted items NAME = NAME ( NAME . NAME ( LIT , [ ] ) ) NAME = NAME ( NAME . NAME ( LIT , [ ] ) ) NAME = NAME ( NAME . NAME ( LIT , [ ] ) ) NAME = NAME ( NAME . NAME ( LIT , [ ] ) ) NAME = NAME ( NAME . NAME ( LIT , [ ] ) ) NAME = NAME ( NAME ) NAME . NAME ( f\" \u2705 Extraction successful: extracted { NAME } names, { NAME } locations, { NAME } dates, { NAME } relationships, { NAME } key facts, { NAME } suggested tasks \" ) # Basic validation that some data was extracted if NAME > LIT or NAME > LIT or NAME > LIT : NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) else : NAME . NAME ( f\" \u274c Extraction failed or returned invalid structure: { NAME } \" ) return False # Test reply generation NAME = LIT NAME . NAME ( LIT ) NAME = NAME ( LIT , LIT , NAME , NAME , ) if NAME and NAME ( NAME , NAME ) and NAME ( NAME ) > LIT : NAME . NAME ( f\" \u2705 Reply generation successful (length: { NAME ( NAME ) } characters) \" ) else : NAME . NAME ( f\" \u26a0\ufe0f Reply generation returned unexpected result: { NAME } \" ) # Test specialized genealogical analysis functions NAME . NAME ( LIT ) # Test DNA match analysis NAME = LIT NAME = NAME ( NAME , NAME ) if NAME and NAME ( NAME , NAME ) : NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) # Test family tree verification NAME = LIT NAME = NAME ( NAME , NAME ) if NAME and NAME ( NAME , NAME ) : NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) # Test record research strategy NAME = LIT NAME = NAME ( NAME , NAME ) if NAME and NAME ( NAME , NAME ) : NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" \u274c AI functionality test failed with exception: { NAME } \" ) return False"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "ai_interface_tests",
      "lineno": 1443,
      "end_lineno": 1468,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 26,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2563f1bfdba4d02a828f867b6f5514441ea96cde",
      "simhash64": 7487757777297118763,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT # Test implementation moved to unified test framework # Simulate comprehensive test suite for reporting NAME = { LIT : True , LIT : True , LIT : True , LIT : True , LIT : True , LIT : True , LIT : True , LIT : True , LIT : True , LIT : True , } NAME = NAME ( LIT for NAME in NAME . NAME ( ) if NAME ) NAME = NAME ( NAME ) - NAME # Report test counts in detectable format NAME ( f\" \u2705 Passed: { NAME } \" ) NAME ( f\" \u274c Failed: { NAME } \" ) return NAME ( NAME . NAME ( ) )"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 1471,
      "end_lineno": 1473,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "quick_health_check",
      "lineno": 1476,
      "end_lineno": 1540,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 12,
      "loc": 65,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(session_manager)",
      "fingerprint": "ab1bb7cc5f59d9ccd456c21089d033d9cd0706e4",
      "simhash64": 5146308216814482467,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : LIT , LIT : NAME . NAME , LIT : False , LIT : False , LIT : False , LIT : False , LIT : [ ] , } try : # Check API key NAME = NAME . NAME . NAME ( ) if NAME == LIT : NAME [ LIT ] = NAME ( NAME . NAME . NAME ) NAME [ LIT ] = NAME elif NAME == LIT : NAME [ LIT ] = NAME ( NAME . NAME . NAME ) NAME [ LIT ] = NAME # Check prompts try : NAME = NAME ( ) NAME [ LIT ] = NAME ( NAME and LIT in NAME ) except NAME as NAME : NAME [ LIT ] . NAME ( f\" Prompt loading error: { NAME } \" ) # Quick test call (only if configuration looks good) if ( NAME [ LIT ] and NAME [ LIT ] ) : try : NAME = NAME ( LIT , NAME ) NAME [ LIT ] = NAME is not None except NAME as NAME : NAME [ LIT ] . NAME ( f\" Test call error: { NAME } \" ) # Determine overall health if ( NAME [ LIT ] and NAME [ LIT ] and NAME [ LIT ] ) : if NAME [ LIT ] : NAME [ LIT ] = LIT else : NAME [ LIT ] = LIT else : NAME [ LIT ] = LIT except NAME as NAME : NAME [ LIT ] . NAME ( f\" Health check error: { NAME } \" ) NAME [ LIT ] = LIT return NAME"
    },
    {
      "module_path": "ai_interface.py",
      "qualname": "self_check_ai_interface",
      "lineno": 1543,
      "end_lineno": 1616,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 74,
      "tags": [
        "pure-ish",
        "json",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(session_manager)",
      "fingerprint": "fc31cc0a45576ef3352af19d04d2db5ed8cf0cc3",
      "simhash64": 7488180022980031515,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT NAME . NAME ( LIT ) NAME = True # Test data (from original file) NAME = LIT # Expected: UNINTERESTED NAME = LIT # Expected: UNINTERESTED NAME = LIT NAME . NAME ( LIT ) NAME = NAME ( NAME , NAME ) if NAME and NAME in NAME : NAME . NAME ( f\" Intent classification test 1 PASSED. Result: { NAME } \" ) else : NAME . NAME ( f\" Intent classification test 1 FAILED. Expected valid category, got: { NAME } \" ) NAME = False NAME = NAME ( NAME , NAME ) if NAME and NAME in NAME : NAME . NAME ( f\" Intent classification test 2 PASSED. Result: { NAME } \" ) else : NAME . NAME ( f\" Intent classification test 2 FAILED. Expected valid category, got: { NAME } \" ) NAME = False NAME . NAME ( LIT ) NAME = NAME ( NAME , NAME ) if ( NAME and NAME ( NAME . NAME ( LIT ) , NAME ) and NAME ( NAME . NAME ( LIT ) , NAME ) ) : NAME . NAME ( LIT ) NAME . NAME ( f\" Extracted data: { NAME . NAME ( NAME [ LIT ] , NAME = LIT ) } \" ) NAME . NAME ( f\" Suggested tasks: { NAME [ LIT ] } \" ) if not NAME [ LIT ] : NAME . NAME ( LIT ) # This is not a failure of the function itself, but a note on prompt effectiveness. else : NAME . NAME ( f\" Data extraction test FAILED. Invalid structure or None result. Got: { NAME } \" ) NAME = False if NAME : NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "load_prompts",
      "lineno": 55,
      "end_lineno": 101,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 5,
      "loc": 47,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "ab3436d7bf7d663c3ebf454028b61f0266faac90",
      "simhash64": 7488215207352120339,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : LIT , LIT : NAME . NAME ( ) . NAME ( LIT ) , LIT : { } , } try : if not NAME . NAME ( ) : NAME . NAME ( f\" AI prompts file not found at { NAME } \" ) return NAME with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( NAME ) # Validate loaded data structure NAME , NAME = NAME ( NAME ) if not NAME : NAME . NAME ( f\" Invalid prompts structure detected: { NAME } \" ) # Try to create backup before returning default NAME ( ) return NAME NAME . NAME ( f\" Loaded AI prompts from { NAME } \" ) return NAME except NAME . NAME as NAME : NAME . NAME ( f\" Invalid JSON format in prompts file: { NAME } \" , NAME = True ) NAME ( ) # Backup corrupted file return NAME except NAME as NAME : NAME . NAME ( f\" Permission denied accessing prompts file: { NAME } \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Prompts file not found: { NAME } \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Unexpected error loading AI prompts: { NAME } \" , NAME = True ) return NAME"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "save_prompts",
      "lineno": 104,
      "end_lineno": 141,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 4,
      "loc": 38,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "size:medium"
      ],
      "signature": "(prompts_data)",
      "fingerprint": "21a1d7aaa3b6a6951b9488e4319ddbde4d30ed25",
      "simhash64": 7488215207352120339,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : LIT try : # Validate data structure before saving NAME , NAME = NAME ( NAME ) if not NAME : NAME . NAME ( f\" Cannot save invalid prompts data: { NAME } \" ) return False # Create backup before saving NAME ( ) # Update the last_updated field NAME [ LIT ] = NAME . NAME ( ) . NAME ( LIT ) # Save the prompts to the JSON file with NAME . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME = LIT , NAME = False , NAME = NAME ) NAME . NAME ( f\" Saved AI prompts to { NAME } \" ) return True except NAME as NAME : NAME . NAME ( f\" Permission denied saving prompts file: { NAME } \" ) return False except NAME as NAME : NAME . NAME ( f\" OS error saving prompts file: { NAME } \" ) return False except NAME as NAME : NAME . NAME ( f\" Unexpected error saving AI prompts: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "get_prompt",
      "lineno": 144,
      "end_lineno": 157,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(prompt_key)",
      "fingerprint": "25b37e0540ec34e889a0e5ae54528ae4e5904146",
      "simhash64": 5146308216814482467,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT NAME = NAME ( ) if LIT in NAME and NAME in NAME [ LIT ] : return NAME [ LIT ] [ NAME ] [ LIT ] return None"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "update_prompt",
      "lineno": 160,
      "end_lineno": 206,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 8,
      "loc": 47,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(prompt_key, new_prompt, name, description)",
      "fingerprint": "f5ab20d5ab7905b16b9259e5d4e45eea21b50371",
      "simhash64": 7452151226028176439,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , ) -> NAME : LIT try : NAME = NAME ( ) # Create the prompt entry if it doesn't exist if LIT not in NAME : NAME [ LIT ] = { } if NAME not in NAME [ LIT ] : NAME [ LIT ] [ NAME ] = { LIT : NAME or NAME . NAME ( LIT , LIT ) . NAME ( ) , LIT : NAME or f\" Prompt for { NAME . NAME ( LIT , LIT ) } \" , LIT : NAME , } else : # Update the existing prompt NAME [ LIT ] [ NAME ] [ LIT ] = NAME # Update name and description if provided if NAME : NAME [ LIT ] [ NAME ] [ LIT ] = NAME if NAME : NAME [ LIT ] [ NAME ] [ LIT ] = NAME # Save the updated prompts return NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error updating prompt { NAME } : { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "get_prompt_version",
      "lineno": 210,
      "end_lineno": 228,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(prompt_key)",
      "fingerprint": "84aaefe0b8233b8f9685be99ffff1edfea988f5b",
      "simhash64": 7488180023047140355,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT try : NAME = NAME ( ) NAME = NAME . NAME ( LIT , { } ) if NAME in NAME : NAME = NAME [ NAME ] if NAME ( NAME , NAME ) : if LIT in NAME and NAME ( NAME [ LIT ] , NAME ) : return NAME [ LIT ] # Fallback to global version NAME = NAME . NAME ( LIT ) return NAME if NAME ( NAME , NAME ) else None except NAME : return None"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "set_prompt_version",
      "lineno": 231,
      "end_lineno": 277,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 11,
      "loc": 47,
      "tags": [
        "pure-ish",
        "regex",
        "size:medium"
      ],
      "signature": "(prompt_key, new_version)",
      "fingerprint": "5d54fc0b121bd5ad47ec23cc522742770ead8ba8",
      "simhash64": 7452151225961059387,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT try : NAME = NAME ( ) if LIT not in NAME : NAME [ LIT ] = { } if NAME not in NAME [ LIT ] : # Minimal scaffold so validation still passes NAME [ LIT ] [ NAME ] = { LIT : NAME . NAME ( LIT , LIT ) . NAME ( ) , LIT : f\" Autocreated entry for { NAME } \" , LIT : LIT , } import NAME # Validate semantic version format if not NAME ( NAME , NAME ) or not NAME . NAME ( NAME , NAME ) : NAME . NAME ( f\" Invalid semantic version ' { NAME } ' for { NAME } (expected MAJOR.MINOR.PATCH) \" ) return False NAME = NAME [ LIT ] [ NAME ] . NAME ( LIT ) # Enforce monotonic non-decreasing version (allow setting if no old version) if NAME and NAME ( NAME , NAME ) < LIT : NAME . NAME ( f\" Refusing to set version ' { NAME } ' lower than existing ' { NAME } ' for { NAME } \" ) return False NAME = NAME [ LIT ] [ NAME ] . NAME ( LIT , LIT ) NAME [ LIT ] [ NAME ] [ LIT ] = NAME ( NAME ) NAME = NAME ( NAME ) if NAME and NAME != NAME ( NAME ) : # Record changelog entry try : NAME ( NAME = NAME , NAME = NAME , NAME = NAME ( NAME ) , NAME = NAME , NAME = NAME [ LIT ] [ NAME ] . NAME ( LIT , LIT ) , ) except NAME as NAME : # pragma: no cover - non critical NAME . NAME ( f\" Failed to append changelog entry: { NAME } \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Failed to set prompt version for { NAME } : { NAME } \" ) return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "_append_changelog_entry",
      "lineno": 280,
      "end_lineno": 343,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 11,
      "loc": 64,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(prompt_key, old_version, new_version, old_content, new_content)",
      "fingerprint": "da656ae21bff2aafa8c61816dfe1e79937dd27fb",
      "simhash64": 7488180022980031515,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME , NAME : NAME , ) -> None : LIT import NAME as NAME from NAME import NAME as NAME NAME = NAME . NAME ( ) . NAME ( LIT ) NAME = NAME . NAME ( NAME . NAME ( LIT , NAME = LIT ) ) . NAME ( ) [ : LIT ] NAME = NAME . NAME ( NAME . NAME ( LIT , NAME = LIT ) ) . NAME ( ) [ : LIT ] NAME = NAME ( NAME ) NAME = NAME ( NAME ) NAME = NAME - NAME NAME = not NAME . NAME ( ) NAME = f\" | { NAME } | { NAME } | { NAME or LIT } | { NAME } | { NAME } | { NAME } | { NAME : + } | { NAME } | { NAME } |\\n \" NAME = LIT try : if NAME ( NAME ) >= NAME : import NAME NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) NAME = NAME ( NAME . NAME ( NAME , NAME , NAME = LIT , NAME = LIT , NAME = LIT ) ) # Truncate very large diffs to first 120 lines if NAME ( NAME ) > LIT : NAME = [ * NAME [ : LIT ] , LIT ] if NAME : NAME = LIT . NAME ( NAME ) NAME = f\" ```diff\\n { NAME } \\n```\\n \" except NAME as NAME : # pragma: no cover NAME = LIT # Fail silent; diff non-critical if NAME : with NAME . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( NAME ) if NAME : NAME . NAME ( NAME ) else : with NAME . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME ) if NAME : NAME . NAME ( NAME )"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "_compare_semver",
      "lineno": 346,
      "end_lineno": 360,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(a, b)",
      "fingerprint": "81b7def6e9858d46044e2ac1f062f93b61749b45",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT try : NAME = [ NAME ( NAME ) for NAME in NAME . NAME ( LIT ) ] NAME = [ NAME ( NAME ) for NAME in NAME . NAME ( LIT ) ] for NAME in NAME ( LIT ) : if NAME [ NAME ] != NAME [ NAME ] : return NAME [ NAME ] - NAME [ NAME ] return LIT except NAME : return LIT"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "import_improved_prompts",
      "lineno": 363,
      "end_lineno": 419,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 9,
      "loc": 57,
      "tags": [
        "impure",
        "filesystem",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "e329030e402c2ff85c6543ca566e4f98af08e31d",
      "simhash64": 7452151225961059355,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME [ NAME ] ] : LIT try : if not NAME . NAME ( ) : NAME . NAME ( f\" Improved prompts directory not found at { NAME } \" ) return LIT , [ ] NAME = LIT NAME = [ ] # Define prompt files to import NAME = [ ( LIT , LIT , LIT , LIT , ) , ( LIT , LIT , LIT , LIT , ) , ] for NAME , NAME , NAME , NAME in NAME : NAME = NAME / NAME if NAME . NAME ( ) : try : with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( ) . NAME ( ) if NAME and NAME ( NAME , NAME , NAME , NAME ) : NAME += LIT NAME . NAME ( NAME ) NAME . NAME ( f\" Imported improved prompt ' { NAME } ' from { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Error reading prompt file { NAME } : { NAME } \" ) return NAME , NAME except NAME as NAME : NAME . NAME ( f\" Error importing improved prompts: { NAME } \" , NAME = True ) return LIT , [ ]"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "validate_prompt_structure",
      "lineno": 422,
      "end_lineno": 457,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 10,
      "loc": 36,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(prompts_data)",
      "fingerprint": "f94a86610733c24933d263327c7ec0717c566929",
      "simhash64": 7488180022981071923,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME [ NAME ] ] : LIT NAME = [ ] # Check required top-level keys NAME = [ LIT , LIT , LIT ] for NAME in NAME : if NAME not in NAME : NAME . NAME ( f\" Missing required key: { NAME } \" ) # Validate prompts structure if LIT in NAME and NAME ( NAME [ LIT ] , NAME ) : for NAME , NAME in NAME [ LIT ] . NAME ( ) : if not NAME ( NAME , NAME ) : NAME . NAME ( f\" Prompt ' { NAME } ' is not a dictionary \" ) continue # Check required prompt fields NAME = [ LIT , LIT , LIT ] for NAME in NAME : if NAME not in NAME : NAME . NAME ( f\" Prompt ' { NAME } ' missing field: { NAME } \" ) elif not NAME ( NAME [ NAME ] , NAME ) : NAME . NAME ( f\" Prompt ' { NAME } ' field ' { NAME } ' is not a string \" ) return NAME ( NAME ) == LIT , NAME"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "backup_prompts_file",
      "lineno": 460,
      "end_lineno": 486,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 27,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "138dd15a97242270ac4de4618bdc7b591815f607",
      "simhash64": 8641136711958959123,
      "normalized": "def NAME ( ) -> NAME : LIT try : if NAME . NAME ( ) : NAME = NAME . NAME / LIT NAME . NAME ( NAME = True ) NAME = ( NAME / f\" ai_prompts.bak. { NAME . NAME ( ) . NAME ( LIT ) } \" ) NAME . NAME ( NAME , NAME ) NAME . NAME ( f\" Created backup: { NAME } \" ) # Clean up old backups NAME = NAME ( NAME = NAME ) if NAME > LIT : NAME . NAME ( f\" Cleaned up { NAME } old backup files \" ) return True return False except NAME as NAME : NAME . NAME ( f\" Error creating backup: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "cleanup_old_backups",
      "lineno": 492,
      "end_lineno": 528,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 37,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(keep_count, logs_dir)",
      "fingerprint": "d9a94388ebf518126e281b021b92174d830cd4fa",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME [ NAME ] = None ) -> NAME : LIT try : if NAME is None : NAME = NAME . NAME / LIT NAME = LIT NAME = NAME ( NAME . NAME ( NAME ) ) if NAME ( NAME ) <= NAME : return LIT # Sort by modification time (newest first) NAME . NAME ( NAME = lambda NAME : NAME . NAME ( ) . NAME , NAME = True ) # Delete old backups NAME = LIT for NAME in NAME [ NAME : ] : try : NAME . NAME ( ) NAME += LIT NAME . NAME ( f\" Deleted old backup: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Could not delete backup { NAME } : { NAME } \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Error cleaning up old backups: { NAME } \" ) return LIT"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "ai_prompt_utils_module_tests",
      "lineno": 531,
      "end_lineno": 1043,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 47,
      "yield_count": 0,
      "complexity": 40,
      "loc": 513,
      "tags": [
        "impure",
        "filesystem",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "352005a832417a03124fc6c12ead990fa41248d6",
      "simhash64": 5145886005423150123,
      "normalized": "def NAME ( ) -> NAME : LIT def NAME ( ) : LIT try : NAME = NAME ( ) assert NAME ( NAME , NAME ) assert LIT in NAME return True except NAME : return False def NAME ( ) : LIT try : NAME = { LIT : LIT , LIT : LIT , LIT : { LIT : { LIT : LIT , LIT : LIT , LIT : LIT , } } , } NAME , NAME = NAME ( NAME ) return NAME and NAME ( NAME ) == LIT except NAME : return False def NAME ( ) : LIT try : # Test that backup functions exist and can be called NAME ( ) NAME ( ) return True except NAME : return False def NAME ( ) : LIT try : # Test that import function works (even if no files exist) NAME , NAME = NAME ( ) assert NAME ( NAME , NAME ) assert NAME ( NAME , NAME ) return True except NAME : return False def NAME ( ) : LIT try : # Test with invalid data NAME = { LIT : LIT } NAME , NAME = NAME ( NAME ) return not NAME and NAME ( NAME ) > LIT except NAME : return False def NAME ( ) : LIT try : # Test getting non-existent prompt NAME = NAME ( LIT ) assert NAME is None return True except NAME : return False def NAME ( ) : LIT try : NAME = LIT # Set version before content exists assert NAME ( NAME , LIT ) NAME = NAME ( NAME ) assert NAME in ( LIT , LIT ) # either specific or fallback # Update with real prompt content + new version assert NAME ( NAME , LIT , NAME = LIT , NAME = LIT ) assert NAME ( NAME , LIT ) NAME = NAME ( NAME ) assert NAME == LIT return True except NAME : return False def NAME ( ) : LIT try : assert NAME ( ) return True except NAME : return False def NAME ( ) : LIT try : for NAME in [ LIT , LIT , LIT , ] : NAME = NAME ( NAME ) assert NAME is not None , f\" Missing version for { NAME } \" return True except NAME : return False def NAME ( ) : LIT try : NAME = LIT NAME ( NAME , LIT , NAME = LIT , NAME = LIT ) NAME ( NAME , LIT ) # first version # Capture file size after first set (may create entry if previously None) NAME = NAME . NAME ( ) . NAME if NAME . NAME ( ) else LIT NAME ( NAME , LIT ) NAME ( NAME , LIT ) # version bump assert NAME . NAME ( ) , LIT NAME = NAME . NAME ( ) . NAME assert NAME > NAME , LIT # Check last line contains new version with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( ) [ - LIT : ] assert NAME ( LIT in NAME and NAME in NAME for NAME in NAME ) , LIT return True except NAME : return False def NAME ( ) : LIT try : NAME ( LIT , LIT , NAME = LIT , NAME = LIT ) NAME ( LIT , LIT ) NAME = NAME ( ) assert LIT not in NAME . NAME ( LIT , [ ] ) , LIT NAME = NAME ( NAME = True ) assert LIT in NAME . NAME ( LIT , [ ] ) , LIT NAME = NAME . NAME ( LIT , { } ) if NAME . NAME ( ) : assert NAME ( NAME . NAME ( LIT ) for NAME in NAME . NAME ( ) ) , LIT return True except NAME : return False def NAME ( ) : LIT try : NAME = LIT NAME ( NAME , LIT , NAME = LIT , NAME = LIT ) NAME = NAME ( ) assert NAME in NAME . NAME ( LIT , [ ] ) , LIT NAME ( NAME , LIT ) NAME = NAME ( ) assert NAME not in NAME . NAME ( LIT , [ ] ) , LIT return True except NAME : return False def NAME ( ) : LIT try : NAME ( LIT , LIT , NAME = LIT , NAME = LIT ) NAME ( LIT , LIT ) NAME = NAME ( ) NAME = { LIT , LIT , LIT , LIT } assert NAME . NAME ( NAME . NAME ( ) ) , LIT assert LIT not in NAME . NAME ( LIT , [ ] ) , LIT # This key lacks _test suffix so should be present actually # Adjust: ensure presence since it doesn't end with _test assert LIT in NAME . NAME ( LIT , [ ] ) , LIT return True except NAME : return False def NAME ( ) : LIT try : NAME = NAME ( ) for NAME in [ LIT , LIT , LIT ] : assert NAME in NAME , f\" Missing report metric: { NAME } \" assert NAME ( NAME . NAME ( LIT ) , NAME ) , LIT return True except NAME : return False def NAME ( ) : LIT try : NAME = LIT NAME ( NAME , LIT , NAME = LIT , NAME = LIT ) assert NAME ( NAME , LIT ) # Invalid pattern assert not NAME ( NAME , LIT ) , LIT # Decreasing version assert not NAME ( NAME , LIT ) , LIT # Increasing assert NAME ( NAME , LIT ) return True except NAME : return False def NAME ( ) : LIT try : NAME = LIT NAME = LIT * LIT NAME ( NAME , NAME , NAME = LIT , NAME = LIT ) assert NAME ( NAME , LIT ) # Make a larger change exceeding threshold NAME = NAME + LIT NAME ( NAME , NAME ) assert NAME ( NAME , LIT ) # Inspect tail of changelog for a diff fence if NAME . NAME ( ) : with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( ) [ - LIT : ] NAME = LIT . NAME ( NAME ) assert LIT in NAME , LIT return True except NAME : return False def NAME ( ) : LIT try : from NAME import NAME , NAME NAME ( NAME = LIT , NAME = LIT , NAME = NAME ( LIT ) , NAME = True , NAME = { LIT : [ { LIT : LIT } ] } , NAME = [ LIT ] , NAME = LIT , NAME = LIT , ) NAME = NAME ( NAME = LIT ) assert NAME . NAME ( LIT , LIT ) > LIT , LIT NAME = NAME . NAME ( LIT , { } ) assert NAME ( NAME for NAME in NAME if NAME in ( LIT , LIT , LIT ) ) , LIT return True except NAME : return False def NAME ( ) : LIT try : from NAME import NAME NAME = NAME ( { } ) NAME = { LIT : { LIT : [ { LIT : LIT } , { LIT : LIT } ] , LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] } , LIT : [ LIT , LIT , LIT ] } NAME = NAME ( NAME ) assert LIT <= NAME <= LIT , f\" Empty score unexpectedly high: { NAME } \" assert NAME > NAME , LIT assert NAME <= LIT , LIT return True except NAME : return False def NAME ( ) : LIT try : from NAME import NAME NAME = { LIT : { LIT : [ { LIT : LIT } ] , LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] , } , LIT : [ LIT , LIT , LIT ] } NAME = NAME ( NAME ) NAME = { LIT : { LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] , } , LIT : [ LIT , LIT , LIT ] } NAME = { LIT : NAME [ LIT ] , LIT : [ ] } NAME = NAME ( NAME ) NAME = NAME ( NAME ) assert NAME < NAME , LIT assert NAME < NAME , LIT return True except NAME : return False def NAME ( ) : LIT try : from NAME import NAME NAME = { LIT : { LIT : [ { LIT : LIT } ] } , LIT : [ LIT , LIT ] } NAME = { LIT : { LIT : [ { LIT : LIT } ] } , LIT : [ LIT , LIT , LIT ] } NAME = NAME ( NAME ) NAME = NAME ( NAME ) assert NAME > NAME , LIT return True except NAME : return False def NAME ( ) : LIT try : from NAME import NAME , NAME NAME ( NAME = LIT , NAME = LIT , NAME = NAME ( LIT ) , NAME = True , NAME = { LIT : [ { LIT : LIT } ] } , NAME = [ LIT , LIT , LIT ] , NAME = LIT , NAME = LIT , ) NAME = NAME ( NAME = LIT ) assert NAME . NAME ( LIT , LIT ) > LIT , LIT NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT ) assert NAME and LIT in NAME , LIT if LIT in NAME : assert NAME [ LIT ] >= NAME [ LIT ] , LIT return True except NAME : return False def NAME ( ) : LIT try : # Ensure variants map has explicit control NAME = { LIT : LIT , LIT : LIT } # We haven't enabled experiments in config so should always return control mapping NAME = NAME ( LIT , NAME , NAME = LIT ) assert NAME == LIT return True except NAME : return False def NAME ( ) : LIT try : # Monkeypatch internal flag function to simulate enabled experiments NAME = NAME ( ) . NAME ( LIT ) NAME ( ) [ LIT ] = lambda : True NAME = { LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME ( LIT , NAME , NAME = LIT ) NAME = NAME ( LIT , NAME , NAME = LIT ) NAME = NAME ( LIT , NAME , NAME = LIT ) assert NAME == NAME , LIT assert NAME in NAME . NAME ( ) and NAME in NAME . NAME ( ) # Restore NAME ( ) [ LIT ] = NAME # type: ignore return True except NAME : return False # Create test suite and run tests with NAME ( ) : NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # Run all tests NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_prompts_loading",
      "lineno": 539,
      "end_lineno": 547,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "3e8f514cfdfdd4489b1750d2335504ff86451fd8",
      "simhash64": 7488355910480729643,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME ( ) assert NAME ( NAME , NAME ) assert LIT in NAME return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_prompt_validation",
      "lineno": 549,
      "end_lineno": 566,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d465eda9a6c40ab9625e4fd65b3f52bba865a605",
      "simhash64": 5726842660765210155,
      "normalized": "def NAME ( ) : LIT try : NAME = { LIT : LIT , LIT : LIT , LIT : { LIT : { LIT : LIT , LIT : LIT , LIT : LIT , } } , } NAME , NAME = NAME ( NAME ) return NAME and NAME ( NAME ) == LIT except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_backup_functionality",
      "lineno": 568,
      "end_lineno": 576,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "a651999740e585126e9f840ebd01725f913d49b2",
      "simhash64": 9221951484163167787,
      "normalized": "def NAME ( ) : LIT try : # Test that backup functions exist and can be called NAME ( ) NAME ( ) return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_import_functionality",
      "lineno": 578,
      "end_lineno": 587,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f38f9684fa37af95d3c31a3e6951b3ad03d6dfdc",
      "simhash64": 7488074419397891111,
      "normalized": "def NAME ( ) : LIT try : # Test that import function works (even if no files exist) NAME , NAME = NAME ( ) assert NAME ( NAME , NAME ) assert NAME ( NAME , NAME ) return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_error_handling",
      "lineno": 589,
      "end_lineno": 597,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "2b8d7ed5179ab9bfbb088d3f5e071fe621f18401",
      "simhash64": 7492261376923440683,
      "normalized": "def NAME ( ) : LIT try : # Test with invalid data NAME = { LIT : LIT } NAME , NAME = NAME ( NAME ) return not NAME and NAME ( NAME ) > LIT except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_prompt_operations",
      "lineno": 599,
      "end_lineno": 607,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "66f3db63bc1272e00ce6e2175ae342456d7b68d0",
      "simhash64": 9217730474090075659,
      "normalized": "def NAME ( ) : LIT try : # Test getting non-existent prompt NAME = NAME ( LIT ) assert NAME is None return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_prompt_versioning",
      "lineno": 609,
      "end_lineno": 624,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "af75b921059d41cd196d7eb45bc8254a61b161af",
      "simhash64": 7487757777228961323,
      "normalized": "def NAME ( ) : LIT try : NAME = LIT # Set version before content exists assert NAME ( NAME , LIT ) NAME = NAME ( NAME ) assert NAME in ( LIT , LIT ) # either specific or fallback # Update with real prompt content + new version assert NAME ( NAME , LIT , NAME = LIT , NAME = LIT ) assert NAME ( NAME , LIT ) NAME = NAME ( NAME ) assert NAME == LIT return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_extraction_schema_regression",
      "lineno": 626,
      "end_lineno": 632,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "0cf2af3c9360ae3101851b9a522a6cdb1dee0e34",
      "simhash64": 9219132334771967531,
      "normalized": "def NAME ( ) : LIT try : assert NAME ( ) return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_specialized_prompt_versions",
      "lineno": 634,
      "end_lineno": 646,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "39ce8b8d2f03c68f5943da8b5a3d30495854cdcb",
      "simhash64": 7451720216396338731,
      "normalized": "def NAME ( ) : LIT try : for NAME in [ LIT , LIT , LIT , ] : NAME = NAME ( NAME ) assert NAME is not None , f\" Missing version for { NAME } \" return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_changelog_version_entry",
      "lineno": 648,
      "end_lineno": 667,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 20,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5f5b72df99a4dbf61183c7da27bb8ebac8bbae1a",
      "simhash64": 7487617073093710891,
      "normalized": "def NAME ( ) : LIT try : NAME = LIT NAME ( NAME , LIT , NAME = LIT , NAME = LIT ) NAME ( NAME , LIT ) # first version # Capture file size after first set (may create entry if previously None) NAME = NAME . NAME ( ) . NAME if NAME . NAME ( ) else LIT NAME ( NAME , LIT ) NAME ( NAME , LIT ) # version bump assert NAME . NAME ( ) , LIT NAME = NAME . NAME ( ) . NAME assert NAME > NAME , LIT # Check last line contains new version with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( ) [ - LIT : ] assert NAME ( LIT in NAME and NAME in NAME for NAME in NAME ) , LIT return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_report_prunes_test_artifacts_and_has_last_change",
      "lineno": 669,
      "end_lineno": 683,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ab0c329d272c78f3712b8382c80c9b3f17e2e583",
      "simhash64": 7487757815950775339,
      "normalized": "def NAME ( ) : LIT try : NAME ( LIT , LIT , NAME = LIT , NAME = LIT ) NAME ( LIT , LIT ) NAME = NAME ( ) assert LIT not in NAME . NAME ( LIT , [ ] ) , LIT NAME = NAME ( NAME = True ) assert LIT in NAME . NAME ( LIT , [ ] ) , LIT NAME = NAME . NAME ( LIT , { } ) if NAME . NAME ( ) : assert NAME ( NAME . NAME ( LIT ) for NAME in NAME . NAME ( ) ) , LIT return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_missing_version_warning_detection",
      "lineno": 685,
      "end_lineno": 697,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "836250c9ba3eb16524256058a7e213d286b20252",
      "simhash64": 5181914802375005227,
      "normalized": "def NAME ( ) : LIT try : NAME = LIT NAME ( NAME , LIT , NAME = LIT , NAME = LIT ) NAME = NAME ( ) assert NAME in NAME . NAME ( LIT , [ ] ) , LIT NAME ( NAME , LIT ) NAME = NAME ( ) assert NAME not in NAME . NAME ( LIT , [ ] ) , LIT return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_summary_generation",
      "lineno": 699,
      "end_lineno": 712,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "85ac8a0629a93733dd06929f93fd74a77d39ed3e",
      "simhash64": 5145885971063411755,
      "normalized": "def NAME ( ) : LIT try : NAME ( LIT , LIT , NAME = LIT , NAME = LIT ) NAME ( LIT , LIT ) NAME = NAME ( ) NAME = { LIT , LIT , LIT , LIT } assert NAME . NAME ( NAME . NAME ( ) ) , LIT assert LIT not in NAME . NAME ( LIT , [ ] ) , LIT # This key lacks _test suffix so should be present actually # Adjust: ensure presence since it doesn't end with _test assert LIT in NAME . NAME ( LIT , [ ] ) , LIT return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_report_metrics_presence",
      "lineno": 714,
      "end_lineno": 723,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 10,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "40789d1de0350e8528286d7cacc3cf79cda485a3",
      "simhash64": 7452291964523157035,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME ( ) for NAME in [ LIT , LIT , LIT ] : assert NAME in NAME , f\" Missing report metric: { NAME } \" assert NAME ( NAME . NAME ( LIT ) , NAME ) , LIT return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_semver_validation_and_monotonicity",
      "lineno": 725,
      "end_lineno": 739,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5a0cbed7aa5fbf3db3fc2e6bc70e8b05dbc9c038",
      "simhash64": 5145885970996302891,
      "normalized": "def NAME ( ) : LIT try : NAME = LIT NAME ( NAME , LIT , NAME = LIT , NAME = LIT ) assert NAME ( NAME , LIT ) # Invalid pattern assert not NAME ( NAME , LIT ) , LIT # Decreasing version assert not NAME ( NAME , LIT ) , LIT # Increasing assert NAME ( NAME , LIT ) return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_changelog_diff_snippet_generation",
      "lineno": 741,
      "end_lineno": 760,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 20,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "e1937dddeaecc0bcb19d8f3f8b9c06f3bbf57bc5",
      "simhash64": 7487757811655808059,
      "normalized": "def NAME ( ) : LIT try : NAME = LIT NAME = LIT * LIT NAME ( NAME , NAME , NAME = LIT , NAME = LIT ) assert NAME ( NAME , LIT ) # Make a larger change exceeding threshold NAME = NAME + LIT NAME ( NAME , NAME ) assert NAME ( NAME , LIT ) # Inspect tail of changelog for a diff fence if NAME . NAME ( ) : with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( ) [ - LIT : ] NAME = LIT . NAME ( NAME ) assert LIT in NAME , LIT return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_telemetry_summary_reporting",
      "lineno": 762,
      "end_lineno": 782,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "8f3ce9fc4bb3d167c5380511bd68d87b9eb8b883",
      "simhash64": 5145886005356041771,
      "normalized": "def NAME ( ) : LIT try : from NAME import NAME , NAME NAME ( NAME = LIT , NAME = LIT , NAME = NAME ( LIT ) , NAME = True , NAME = { LIT : [ { LIT : LIT } ] } , NAME = [ LIT ] , NAME = LIT , NAME = LIT , ) NAME = NAME ( NAME = LIT ) assert NAME . NAME ( LIT , LIT ) > LIT , LIT NAME = NAME . NAME ( LIT , { } ) assert NAME ( NAME for NAME in NAME if NAME in ( LIT , LIT , LIT ) ) , LIT return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_extraction_quality_scoring_basic",
      "lineno": 784,
      "end_lineno": 808,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 25,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "377d9deb97b049527519ae681e02c5a818acc32c",
      "simhash64": 5150381899866609199,
      "normalized": "def NAME ( ) : LIT try : from NAME import NAME NAME = NAME ( { } ) NAME = { LIT : { LIT : [ { LIT : LIT } , { LIT : LIT } ] , LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] } , LIT : [ LIT , LIT , LIT ] } NAME = NAME ( NAME ) assert LIT <= NAME <= LIT , f\" Empty score unexpectedly high: { NAME } \" assert NAME > NAME , LIT assert NAME <= LIT , LIT return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_extraction_quality_penalties",
      "lineno": 810,
      "end_lineno": 842,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 33,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "9bf189875b8321a1f5b263ba8d4c2ec05a45aedc",
      "simhash64": 5145878308834416175,
      "normalized": "def NAME ( ) : LIT try : from NAME import NAME NAME = { LIT : { LIT : [ { LIT : LIT } ] , LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] , } , LIT : [ LIT , LIT , LIT ] } NAME = NAME ( NAME ) NAME = { LIT : { LIT : [ LIT ] , LIT : [ LIT ] , LIT : [ LIT ] , } , LIT : [ LIT , LIT , LIT ] } NAME = { LIT : NAME [ LIT ] , LIT : [ ] } NAME = NAME ( NAME ) NAME = NAME ( NAME ) assert NAME < NAME , LIT assert NAME < NAME , LIT return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_task_quality_specificity",
      "lineno": 844,
      "end_lineno": 865,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "fb00bb61d5427277c702baba1506b7a427ad039a",
      "simhash64": 5150390704553760299,
      "normalized": "def NAME ( ) : LIT try : from NAME import NAME NAME = { LIT : { LIT : [ { LIT : LIT } ] } , LIT : [ LIT , LIT ] } NAME = { LIT : { LIT : [ { LIT : LIT } ] } , LIT : [ LIT , LIT , LIT ] } NAME = NAME ( NAME ) NAME = NAME ( NAME ) assert NAME > NAME , LIT return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_telemetry_quality_aggregation",
      "lineno": 867,
      "end_lineno": 889,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ca30d01d1fb447f2d6504097e55a17c5cc79692e",
      "simhash64": 5145886005423150635,
      "normalized": "def NAME ( ) : LIT try : from NAME import NAME , NAME NAME ( NAME = LIT , NAME = LIT , NAME = NAME ( LIT ) , NAME = True , NAME = { LIT : [ { LIT : LIT } ] } , NAME = [ LIT , LIT , LIT ] , NAME = LIT , NAME = LIT , ) NAME = NAME ( NAME = LIT ) assert NAME . NAME ( LIT , LIT ) > LIT , LIT NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT ) assert NAME and LIT in NAME , LIT if LIT in NAME : assert NAME [ LIT ] >= NAME [ LIT ] , LIT return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_experiment_selection_control_fallback",
      "lineno": 891,
      "end_lineno": 901,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3c16120e5758e32f56fc3b2c4ca199d71eb986d0",
      "simhash64": 7457359613674296875,
      "normalized": "def NAME ( ) : LIT try : # Ensure variants map has explicit control NAME = { LIT : LIT , LIT : LIT } # We haven't enabled experiments in config so should always return control mapping NAME = NAME ( LIT , NAME , NAME = LIT ) assert NAME == LIT return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "test_experiment_selection_sticky_hash",
      "lineno": 903,
      "end_lineno": 919,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7ec4b0a1e7e6768d01f174035b9d0c9bfb65c54c",
      "simhash64": 5145886005423150123,
      "normalized": "def NAME ( ) : LIT try : # Monkeypatch internal flag function to simulate enabled experiments NAME = NAME ( ) . NAME ( LIT ) NAME ( ) [ LIT ] = lambda : True NAME = { LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME ( LIT , NAME , NAME = LIT ) NAME = NAME ( LIT , NAME , NAME = LIT ) NAME = NAME ( LIT , NAME , NAME = LIT ) assert NAME == NAME , LIT assert NAME in NAME . NAME ( ) and NAME in NAME . NAME ( ) # Restore NAME ( ) [ LIT ] = NAME # type: ignore return True except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 1046,
      "end_lineno": 1048,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "_parse_changelog_last_changes",
      "lineno": 1051,
      "end_lineno": 1094,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 12,
      "loc": 44,
      "tags": [
        "impure",
        "filesystem",
        "regex",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "07a3283519199fd94f1dafaca8a7f3f7bb98d63f",
      "simhash64": 7488180023048188979,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT # Simple module-level cache global NAME try : NAME = NAME . NAME ( ) . NAME if NAME . NAME ( ) else None except NAME : NAME = None if not NAME . NAME ( ) : NAME = { LIT : None , LIT : { } } return { } # Initialize cache structure if missing if LIT not in NAME ( ) : # type: ignore NAME = { LIT : None , LIT : { } } # type: ignore NAME = NAME . NAME ( LIT ) if NAME ( NAME , NAME ) else None # type: ignore if NAME == NAME : # Return cached copy (shallow copy to prevent external mutation) return NAME ( NAME . NAME ( LIT , { } ) ) # type: ignore NAME : NAME [ NAME , NAME ] = { } try : with NAME . NAME ( NAME = LIT ) as NAME : for NAME in NAME : if not NAME . NAME ( LIT ) : continue NAME = [ NAME . NAME ( ) for NAME in NAME . NAME ( ) . NAME ( LIT ) if NAME . NAME ( ) ] if NAME ( NAME ) < LIT : continue NAME , NAME = NAME [ LIT ] , NAME [ LIT ] if not NAME . NAME ( LIT ) : continue NAME [ NAME ] = NAME # Update cache NAME [ LIT ] = NAME # type: ignore NAME [ LIT ] = NAME # type: ignore except NAME as NAME : # pragma: no cover NAME . NAME ( f\" Failed to parse changelog: { NAME } \" ) return NAME"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "get_prompts_summary",
      "lineno": 1097,
      "end_lineno": 1148,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 8,
      "loc": 52,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(include_test_artifacts)",
      "fingerprint": "289f57f636f4b647416e4108d5d573331f513ad2",
      "simhash64": 7451588277081379883,
      "normalized": "def NAME ( NAME : NAME = False ) -> NAME [ NAME , NAME ] : LIT try : NAME = NAME ( ) NAME = NAME . NAME ( LIT , { } ) NAME = NAME ( ) NAME : NAME [ NAME , NAME ] = { } NAME : NAME [ NAME ] = [ ] for NAME , NAME in NAME . NAME ( ) : if ( not NAME ) and NAME . NAME ( LIT ) : NAME . NAME ( NAME ) continue NAME [ NAME ] = NAME NAME : NAME [ NAME , NAME [ NAME , NAME ] ] = { } for NAME , NAME in NAME . NAME ( ) : if NAME ( NAME , NAME ) : NAME [ NAME ] = { LIT : NAME . NAME ( LIT ) , LIT : NAME ( NAME . NAME ( LIT , LIT ) ) , LIT : LIT in NAME , LIT : NAME . NAME ( NAME ) , } return { LIT : NAME ( NAME ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME ( NAME . NAME ( ) ) , LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) . NAME if NAME . NAME ( ) else LIT , LIT : NAME ( NAME ( NAME . NAME . NAME ( f\" { NAME . NAME } .bak.* \" ) ) ) , LIT : NAME , LIT : [ NAME for NAME , NAME in NAME . NAME ( ) if not NAME . NAME ( LIT ) ] , LIT : NAME , } except NAME as NAME : NAME . NAME ( f\" Error generating prompts summary: { NAME } \" ) return { LIT : LIT , LIT : LIT , LIT : LIT , LIT : [ ] , LIT : False , LIT : LIT , LIT : LIT , LIT : NAME ( NAME ) , }"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "quick_test",
      "lineno": 1151,
      "end_lineno": 1202,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 52,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "a713432d889c2f5b1be4639be012769361caa360",
      "simhash64": 5146308208224547875,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : LIT , LIT : LIT , LIT : [ ] } try : # Test 1: Load prompts NAME = NAME ( ) if NAME ( NAME , NAME ) and LIT in NAME : NAME [ LIT ] += LIT else : NAME [ LIT ] += LIT NAME [ LIT ] . NAME ( LIT ) # Test 2: Validate structure NAME , NAME = NAME ( NAME ) if NAME : NAME [ LIT ] += LIT else : NAME [ LIT ] += LIT NAME [ LIT ] . NAME ( NAME ) # Test 3: Get summary NAME = NAME ( ) if NAME ( NAME , NAME ) and LIT in NAME : NAME [ LIT ] += LIT else : NAME [ LIT ] += LIT NAME [ LIT ] . NAME ( LIT ) # Test 4: Test import functionality NAME , NAME = NAME ( ) if NAME ( NAME , NAME ) and NAME ( NAME , NAME ) : NAME [ LIT ] += LIT else : NAME [ LIT ] += LIT NAME [ LIT ] . NAME ( LIT ) except NAME as NAME : NAME [ LIT ] += LIT NAME [ LIT ] . NAME ( f\" Unexpected error: { NAME ! NAME } \" ) NAME [ LIT ] = NAME [ LIT ] + NAME [ LIT ] NAME [ LIT ] = ( NAME [ LIT ] / NAME [ LIT ] * LIT if NAME [ LIT ] > LIT else LIT ) return NAME"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "assert_extraction_schema_consistency",
      "lineno": 1206,
      "end_lineno": 1230,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 25,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "94355ce073fbeb8bf11610af79e3a7732bd956b0",
      "simhash64": 5182477752395535915,
      "normalized": "def NAME ( ) -> NAME : LIT try : NAME = NAME ( LIT ) or LIT NAME = [ LIT , LIT ] NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] if NAME ( NAME not in NAME for NAME in NAME ) : return False NAME = [ NAME for NAME in NAME if NAME not in NAME ] return NAME ( NAME ) == LIT except NAME : return False"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "generate_prompts_report",
      "lineno": 1233,
      "end_lineno": 1257,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 25,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(include_test_artifacts)",
      "fingerprint": "78afbf93e5d4e0df947761cb7115b5e60a73495f",
      "simhash64": 7488180024053765179,
      "normalized": "def NAME ( NAME : NAME = False ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( NAME = NAME ) NAME = [ NAME . NAME ( LIT ) for NAME in NAME . NAME ( LIT , { } ) . NAME ( ) if NAME . NAME ( LIT ) ] NAME = [ NAME . NAME ( LIT , LIT ) for NAME in NAME . NAME ( LIT , { } ) . NAME ( ) ] NAME = NAME ( NAME ( NAME ) ) NAME = NAME ( NAME ( NAME ) / NAME ( NAME ) ) if NAME else LIT NAME : NAME [ NAME , NAME ] = { } for NAME in NAME : NAME [ NAME ] = NAME . NAME ( NAME , LIT ) + LIT NAME = [ NAME for NAME , NAME in NAME . NAME ( LIT , { } ) . NAME ( ) if not NAME . NAME ( LIT ) ] if NAME : NAME . NAME ( f\" { NAME ( NAME ) } prompt(s) missing version metadata: { NAME [ : LIT ] } \" ) NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME ( NAME ) , } ) return NAME"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "_get_config_flag",
      "lineno": 1261,
      "end_lineno": 1271,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(flag, default)",
      "fingerprint": "36f645a161844718dee10c9569007e5580d35b08",
      "simhash64": 7488285541737600035,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME = False ) -> NAME : LIT if not NAME : return NAME try : # pragma: no cover - simple getter if NAME is None : # type: ignore return NAME NAME = NAME . NAME ( ) # type: ignore[attr-defined] return NAME ( NAME ( NAME , NAME , NAME ) ) except NAME : return NAME"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "is_prompt_experiments_enabled",
      "lineno": 1274,
      "end_lineno": 1276,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "ac7bc2b960ce59ee0a15b068e440915a9bafda9e",
      "simhash64": 5184192956108543019,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( LIT , False )"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "select_prompt_variant",
      "lineno": 1279,
      "end_lineno": 1309,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 31,
      "tags": [
        "pure-ish",
        "randomness",
        "json",
        "size:medium"
      ],
      "signature": "(base_key, variants, user_id, sticky)",
      "fingerprint": "f7cfe34d3e869e3ff208704a2f43e2ca978e3f83",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] = None , NAME : NAME = True ) -> NAME : LIT if not NAME : raise NAME ( LIT ) if not NAME ( ) : # Return control variant if defined, else first return NAME . NAME ( LIT ) or NAME ( NAME ( NAME . NAME ( ) ) ) if NAME and NAME : import NAME NAME = NAME ( NAME . NAME ( f\" { NAME } : { NAME } \" . NAME ( ) ) . NAME ( ) , LIT ) NAME = NAME ( NAME . NAME ( ) ) NAME = NAME % NAME ( NAME ) NAME = NAME [ NAME ] return NAME [ NAME ] # Random selection (non-sticky) import NAME NAME = NAME . NAME ( NAME ( NAME . NAME ( ) ) ) # pragma: no cover (non-deterministic branch) return NAME [ NAME ]"
    },
    {
      "module_path": "ai_prompt_utils.py",
      "qualname": "get_prompt_with_experiment",
      "lineno": 1312,
      "end_lineno": 1330,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(base_key, variants, user_id)",
      "fingerprint": "7b63d271ea1ff1099dc912e99f15dff44c964d42",
      "simhash64": 7488180022981080147,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME [ NAME ] = None ) -> NAME [ NAME ] : LIT try : if NAME : NAME = NAME ( NAME , NAME , NAME = NAME ) NAME = NAME ( NAME ) if NAME : return NAME # fallback to base return NAME ( NAME ) except NAME as NAME : # pragma: no cover - defensive NAME . NAME ( f\" Experiment prompt retrieval failed for { NAME } : { NAME } \" ) return NAME ( NAME )"
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "_extract_year_from_date",
      "lineno": 49,
      "end_lineno": 62,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 14,
      "tags": [
        "pure-ish",
        "regex",
        "size:small"
      ],
      "signature": "(date_str)",
      "fingerprint": "fb8e358a274c119b5607e73ac7ab7cf01a1f3180",
      "simhash64": 7488180022980023299,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME [ NAME ] : LIT if not NAME or NAME == LIT : return None # Try to extract a 4-digit year NAME = NAME . NAME ( LIT , NAME ) if NAME : try : return NAME ( NAME . NAME ( LIT ) ) except NAME : pass return None"
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "_run_simple_suggestion_scoring",
      "lineno": 65,
      "end_lineno": 100,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 36,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(search_criteria, candidate, weights, date_flex)",
      "fingerprint": "70e6b6e4e194cf0997a24440c9c99a4295da6d14",
      "simhash64": 5146308182387635223,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME [ NAME , NAME [ NAME , NAME ] ] ] = None , NAME : NAME [ NAME [ NAME , NAME ] ] = None , ) -> NAME [ NAME , NAME [ NAME , NAME ] , NAME [ NAME ] ] : LIT # Handle empty inputs - should return zero score if not NAME or not NAME : return ( LIT , { } , [ ] ) # Import the main scoring function from NAME import NAME # Use the unified scoring function NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) # Convert float score to int for API compatibility return ( NAME ( NAME [ LIT ] ) , NAME [ LIT ] , NAME [ LIT ] )"
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "process_and_score_suggestions",
      "lineno": 106,
      "end_lineno": 132,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 27,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(api_results, search_criteria)",
      "fingerprint": "cd4b22a87cb5e8b6783de99c23ed68039518ab10",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] for NAME in NAME : NAME , NAME , NAME = NAME ( NAME , NAME , NAME = None , NAME = None ) NAME = NAME . NAME ( ) NAME [ LIT ] = NAME NAME [ LIT ] = NAME NAME [ LIT ] = NAME NAME . NAME ( NAME ) # Sort by score descending NAME . NAME ( NAME = lambda NAME : NAME . NAME ( LIT , LIT ) , NAME = True ) return NAME"
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "search_api_for_criteria",
      "lineno": 135,
      "end_lineno": 488,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 75,
      "loc": 354,
      "tags": [
        "pure-ish",
        "regex",
        "size:large"
      ],
      "signature": "(session_manager, search_criteria, max_results)",
      "fingerprint": "f2cd7779f5b4367dd1742e45428614e3d830cf4e",
      "simhash64": 7452151226028168235,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME = LIT , ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : # Step 1: Check if session is active if not NAME or not NAME . NAME ( ) : NAME . NAME ( LIT ) return [ ] except NAME as NAME : NAME . NAME ( f\" Error checking session validity: { NAME } \" ) return [ ] # Step 2: Prepare search parameters NAME = LIT if NAME . NAME ( LIT ) : NAME += NAME [ LIT ] + LIT if NAME . NAME ( LIT ) : NAME += NAME [ LIT ] + LIT if NAME . NAME ( LIT ) : NAME += f\" b. { NAME [ LIT ] } \" if NAME . NAME ( LIT ) : NAME += NAME [ LIT ] + LIT if NAME . NAME ( LIT ) : NAME += f\" d. { NAME [ LIT ] } \" if NAME . NAME ( LIT ) : NAME += NAME [ LIT ] + LIT NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) return [ ] # Step 3: Call the suggest API NAME . NAME ( f\" Searching API with query: { NAME } \" ) # Get tree ID from session manager or config NAME = NAME . NAME if not NAME : NAME = NAME ( NAME . NAME , LIT , LIT ) if not NAME : NAME . NAME ( LIT ) return [ ] # Get base URL from config NAME = NAME . NAME . NAME # Get owner profile ID from session manager or config NAME = NAME . NAME if not NAME : NAME = NAME ( NAME . NAME , LIT , LIT ) # Prepare search criteria for API NAME = { LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , } # Call the suggest API NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) if not NAME or not NAME ( NAME , NAME ) : NAME . NAME ( f\" No results from suggest API for query: { NAME } \" ) return [ ] # Step 4: Get configuration values NAME = NAME . NAME NAME = { LIT : NAME . NAME } NAME = NAME . NAME # Step 5: Score and filter results NAME = [ ] # Ensure suggest_results is a list (API returns Optional[List[Dict]]) if not NAME or not NAME ( NAME , NAME ) : NAME = [ ] # Process each suggestion result for NAME in NAME [ : NAME ] : try : # Extract basic information - handle both old and new API formats NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) if not NAME : continue # Extract name components - handle both old and new API formats NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT ) or LIT NAME = NAME . NAME ( LIT ) or LIT # If we don't have separate first/last names, parse from full name if not NAME or not NAME : NAME = NAME . NAME ( ) if not NAME : NAME = NAME [ LIT ] if NAME else LIT if not NAME : NAME = NAME [ - LIT ] if NAME ( NAME ) > LIT else LIT # Extract birth/death years - handle both old and new API formats NAME = None NAME = None # New API format has direct BirthYear/DeathYear fields if NAME . NAME ( LIT ) : with NAME . NAME ( NAME , NAME ) : NAME = NAME ( NAME [ LIT ] ) if NAME . NAME ( LIT ) : with NAME . NAME ( NAME , NAME ) : NAME = NAME ( NAME [ LIT ] ) # Fallback to old lifespan parsing if needed if NAME is None or NAME is None : NAME = NAME . NAME ( LIT , LIT ) if NAME : if LIT in NAME : NAME = NAME . NAME ( LIT ) if NAME ( NAME ) == LIT : try : if NAME is None and NAME [ LIT ] . NAME ( ) : NAME = NAME ( NAME [ LIT ] . NAME ( ) ) if NAME is None and NAME [ LIT ] . NAME ( ) : NAME = NAME ( NAME [ LIT ] . NAME ( ) ) except NAME : pass elif LIT in NAME . NAME ( ) : NAME = NAME . NAME ( LIT , NAME . NAME ( ) ) if NAME and NAME is None : with NAME . NAME ( NAME ) : NAME = NAME ( NAME . NAME ( LIT ) ) elif LIT in NAME . NAME ( ) : NAME = NAME . NAME ( LIT , NAME . NAME ( ) ) if NAME and NAME is None : with NAME . NAME ( NAME ) : NAME = NAME ( NAME . NAME ( LIT ) ) # Extract location information NAME = NAME . NAME ( LIT , LIT ) # Create candidate data for scoring NAME = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , # Assuming location is birth place LIT : None , # Not available in suggestion results LIT : None , # Not available in suggestion results } # Score the candidate using the same function as Action 10 from NAME import NAME NAME , NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) # Only include if score is above threshold if NAME > LIT : # Create a match record NAME = { LIT : NAME , LIT : NAME , # Add person_id field for compatibility LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , # Add full name display field LIT : None , # Not available in suggestion results LIT : NAME , LIT : NAME , # Assuming location is birth place LIT : NAME , LIT : None , # Not available in suggestion results LIT : NAME , LIT : NAME , LIT : NAME , LIT : LIT , } NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error processing suggestion result: { NAME } \" ) continue # Step 6: Try treesui-list API if suggest API didn't return enough results if NAME ( NAME ) < NAME : try : # Prepare search parameters for treesui-list API NAME = { } if NAME . NAME ( LIT ) : NAME [ LIT ] = NAME [ LIT ] if NAME . NAME ( LIT ) : NAME [ LIT ] = NAME [ LIT ] if NAME . NAME ( LIT ) : NAME [ LIT ] = NAME [ LIT ] if NAME . NAME ( LIT ) : NAME [ LIT ] = NAME [ LIT ] if NAME . NAME ( LIT ) : NAME [ LIT ] = NAME [ LIT ] if NAME . NAME ( LIT ) : NAME [ LIT ] = NAME [ LIT ] if NAME . NAME ( LIT ) : NAME [ LIT ] = NAME [ LIT ] # Call treesui-list API if NAME : NAME . NAME ( f\" Calling treesui-list API with params: { NAME } \" ) # Get tree ID from session manager or config (reuse from earlier) NAME = NAME . NAME if not NAME : NAME = NAME ( NAME . NAME , LIT , LIT ) if not NAME : NAME . NAME ( LIT ) return NAME # Get base URL from config (reuse from earlier) NAME = NAME . NAME . NAME # Get owner profile ID from session manager or config (reuse from earlier) NAME = NAME . NAME if not NAME : NAME = NAME ( NAME . NAME , LIT , LIT ) # Call the treesui-list API (pass original search_criteria, not mapped search_params) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) if ( NAME and NAME ( NAME , NAME ) and LIT in NAME ) : NAME = NAME . NAME ( LIT , [ ] ) # Process each person for NAME in NAME : try : NAME = NAME . NAME ( LIT ) if not NAME : continue # Extract name components NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) # Extract birth information NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) NAME = NAME ( NAME ) NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) # Extract death information NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) NAME = NAME ( NAME ) NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) # Extract gender NAME = NAME . NAME ( LIT , LIT ) if NAME == LIT : NAME = LIT elif NAME == LIT : NAME = LIT # Create candidate data for scoring NAME = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , } # Score the candidate NAME , NAME , NAME = ( NAME ( NAME , NAME , NAME , NAME , ) ) # Only include if score is above threshold if NAME > LIT : # Check if this person is already in scored_matches if not NAME ( NAME [ LIT ] == NAME for NAME in NAME ) : # Create a match record NAME = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : LIT , } NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error processing treesui-list result: { NAME } \" ) continue except NAME as NAME : NAME . NAME ( f\" Error calling treesui-list API: { NAME } \" ) # Sort matches by score (highest first) NAME . NAME ( NAME = lambda NAME : NAME . NAME ( LIT , LIT ) , NAME = True ) # Return top matches (limited by max_results) return NAME [ : NAME ] if NAME else [ ]"
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "get_api_family_details",
      "lineno": 491,
      "end_lineno": 770,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 56,
      "loc": 280,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:large"
      ],
      "signature": "(session_manager, person_id, tree_id)",
      "fingerprint": "731a010e7ff33a84bbb12540f2a372b44d8c7594",
      "simhash64": 7452151227101910059,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME , NAME ] : LIT # Step 1: Check if session is active if not NAME or not NAME . NAME ( ) : NAME . NAME ( LIT ) return { } # Step 2: Get tree ID if not provided if not NAME : NAME = NAME . NAME if not NAME : NAME = NAME ( NAME . NAME , LIT , LIT ) if not NAME : NAME . NAME ( LIT ) return { } # Step 3: Get owner profile ID NAME = NAME . NAME if not NAME : NAME = NAME ( NAME . NAME , LIT , LIT ) if not NAME : NAME . NAME ( LIT ) # Step 4: Get base URL NAME = NAME . NAME . NAME # Step 5: Call the facts API to get person details NAME . NAME ( f\" Getting facts for person { NAME } in tree { NAME } \" ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) if not NAME or not NAME ( NAME , NAME ) : NAME . NAME ( f\" No facts data returned for person { NAME } \" ) return { } # Step 6: Extract person details NAME = { LIT : NAME , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : None , LIT : LIT , LIT : LIT , LIT : None , LIT : LIT , LIT : LIT , LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : [ ] , } try : # Extract basic person information NAME = NAME . NAME ( LIT , { } ) NAME [ LIT ] = NAME . NAME ( LIT , LIT ) # Split name into first name and surname NAME = NAME [ LIT ] . NAME ( ) if NAME : NAME [ LIT ] = NAME [ LIT ] if NAME ( NAME ) > LIT : NAME [ LIT ] = NAME [ - LIT ] # Extract gender NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) if NAME == LIT : NAME [ LIT ] = LIT elif NAME == LIT : NAME [ LIT ] = LIT # Extract birth information NAME = [ NAME for NAME in NAME . NAME ( LIT , [ ] ) if NAME . NAME ( LIT ) == LIT ] if NAME : NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) NAME [ LIT ] = NAME NAME [ LIT ] = NAME # Extract birth year if NAME and NAME != LIT : NAME = NAME ( NAME ) if NAME : NAME [ LIT ] = NAME # Extract death information NAME = [ NAME for NAME in NAME . NAME ( LIT , [ ] ) if NAME . NAME ( LIT ) == LIT ] if NAME : NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) NAME [ LIT ] = NAME NAME [ LIT ] = NAME # Extract death year if NAME and NAME != LIT : NAME = NAME ( NAME ) if NAME : NAME [ LIT ] = NAME # Extract family relationships NAME = NAME . NAME ( LIT , [ ] ) # Process parents NAME = [ NAME for NAME in NAME if NAME . NAME ( LIT ) in [ LIT , LIT ] ] for NAME in NAME : NAME = NAME . NAME ( LIT ) if not NAME : continue NAME = NAME . NAME ( LIT , LIT ) NAME = { LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) , LIT : None , LIT : LIT , LIT : None , LIT : LIT , LIT : ( NAME . NAME ( ) if NAME else LIT ) , } # Extract birth/death years if available NAME = NAME . NAME ( LIT ) if NAME : with NAME . NAME ( NAME , NAME ) : NAME [ LIT ] = NAME ( NAME ) NAME = NAME . NAME ( LIT ) if NAME : with NAME . NAME ( NAME , NAME ) : NAME [ LIT ] = NAME ( NAME ) NAME [ LIT ] . NAME ( NAME ) # Process spouses NAME = [ NAME for NAME in NAME if NAME . NAME ( LIT ) in [ LIT ] ] for NAME in NAME : NAME = NAME . NAME ( LIT ) if not NAME : continue NAME = { LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) , LIT : None , LIT : LIT , LIT : None , LIT : LIT , LIT : LIT , LIT : LIT , } # Extract birth/death years if available NAME = NAME . NAME ( LIT ) if NAME : with NAME . NAME ( NAME , NAME ) : NAME [ LIT ] = NAME ( NAME ) NAME = NAME . NAME ( LIT ) if NAME : with NAME . NAME ( NAME , NAME ) : NAME [ LIT ] = NAME ( NAME ) # Extract marriage information if available NAME = [ NAME for NAME in NAME . NAME ( LIT , [ ] ) if NAME . NAME ( LIT ) == LIT and NAME in NAME . NAME ( LIT , [ ] ) ] if NAME : NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) NAME [ LIT ] = NAME NAME [ LIT ] = NAME NAME [ LIT ] . NAME ( NAME ) # Process children NAME = [ NAME for NAME in NAME if NAME . NAME ( LIT ) in [ LIT ] ] for NAME in NAME : NAME = NAME . NAME ( LIT ) if not NAME : continue NAME = { LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) , LIT : None , LIT : LIT , LIT : None , LIT : LIT , } # Extract birth/death years if available NAME = NAME . NAME ( LIT ) if NAME : with NAME . NAME ( NAME , NAME ) : NAME [ LIT ] = NAME ( NAME ) NAME = NAME . NAME ( LIT ) if NAME : with NAME . NAME ( NAME , NAME ) : NAME [ LIT ] = NAME ( NAME ) NAME [ LIT ] . NAME ( NAME ) # Process siblings NAME = [ NAME for NAME in NAME if NAME . NAME ( LIT ) in [ LIT ] ] for NAME in NAME : NAME = NAME . NAME ( LIT ) if not NAME : continue NAME = { LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) , LIT : None , LIT : LIT , LIT : None , LIT : LIT , } # Extract birth/death years if available NAME = NAME . NAME ( LIT ) if NAME : with NAME . NAME ( NAME , NAME ) : NAME [ LIT ] = NAME ( NAME ) NAME = NAME . NAME ( LIT ) if NAME : with NAME . NAME ( NAME , NAME ) : NAME [ LIT ] = NAME ( NAME ) NAME [ LIT ] . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error extracting family details from facts data: { NAME } \" , NAME = True ) return NAME"
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "get_api_relationship_path",
      "lineno": 773,
      "end_lineno": 839,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 11,
      "loc": 67,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(session_manager, person_id, reference_id, reference_name, tree_id)",
      "fingerprint": "93eb82001d723167ce4e1fb308e9a2307de3f0d2",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = LIT , NAME : NAME [ NAME ] = None , ) -> NAME : LIT # Step 1: Check if session is active if not NAME or not NAME . NAME ( ) : NAME . NAME ( LIT ) return LIT # Step 2: Get tree ID if not provided if not NAME : NAME = NAME . NAME if not NAME : NAME = NAME ( NAME . NAME , LIT , LIT ) if not NAME : NAME . NAME ( LIT ) return LIT # Step 3: Get reference ID if not provided if not NAME : NAME = NAME . NAME if not NAME : NAME . NAME ( LIT ) return LIT # Step 4: Get base URL NAME = NAME . NAME . NAME # Step 5: Call the getladder API to get relationship path NAME . NAME ( f\" Getting relationship path from { NAME } to { NAME } in tree { NAME } \" ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) if not NAME : NAME . NAME ( f\" No ladder data returned for person { NAME } \" ) return f\" (No relationship path found to { NAME } ) \" try : # Format the relationship path directly using the API formatter return NAME ( NAME , NAME or LIT , LIT ) except NAME as NAME : NAME . NAME ( f\" Error formatting relationship path: { NAME } \" , NAME = True ) return f\" (Error formatting relationship path: { NAME ! NAME } ) \""
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "api_search_utils_module_tests",
      "lineno": 842,
      "end_lineno": 1028,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 187,
      "tags": [
        "impure",
        "time",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "557950fb781fbd18710b60cc850f486fb839590b",
      "simhash64": 5146448920951297067,
      "normalized": "def NAME ( ) -> NAME : # Comprehensive test suite for api_search_utils.py NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # INITIALIZATION TESTS def NAME ( ) : # Test module initialization and configuration # Test configuration access NAME = NAME ( NAME , LIT , LIT ) assert NAME ( NAME , NAME ) , LIT assert NAME == LIT , LIT # Test configuration structure assert NAME ( NAME . NAME , NAME ) , LIT assert ( LIT in NAME . NAME ) , LIT assert NAME ( NAME . NAME , ( NAME , NAME ) ) , LIT # CORE FUNCTIONALITY TESTS def NAME ( ) : # Test all core API search and scoring functions # Test _extract_year_from_date function NAME = NAME ( LIT ) assert NAME == LIT , LIT NAME = NAME ( LIT ) assert NAME == LIT , LIT NAME = NAME ( LIT ) assert NAME is None , LIT # Test _run_simple_suggestion_scoring function NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } NAME , NAME , NAME = NAME ( NAME , NAME ) assert NAME ( NAME , ( NAME , NAME ) ) , LIT assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME , NAME ) , LIT assert NAME > LIT , LIT # EDGE CASE TESTS def NAME ( ) : # Test edge cases and boundary conditions # Test _extract_year_from_date with edge cases NAME = NAME ( LIT ) assert NAME is None , LIT NAME = NAME ( None ) assert NAME is None , LIT NAME = NAME ( LIT ) assert NAME == LIT , LIT # Test scoring with empty data NAME , NAME , NAME = NAME ( { } , { } ) assert NAME == LIT , LIT assert NAME ( NAME ) == LIT , LIT # INTEGRATION TESTS def NAME ( ) : # Test integration with mocked external dependencies from NAME . NAME import NAME , NAME # Test search_api_for_criteria with mock session NAME = NAME ( ) NAME . NAME . NAME = True with NAME ( LIT ) as NAME : NAME . NAME = [ { LIT : LIT } ] NAME = NAME ( NAME , { LIT : LIT , LIT : LIT } ) assert NAME ( NAME , NAME ) , LIT # PERFORMANCE TESTS def NAME ( ) : # Test performance of scoring operations import NAME # Test multiple scoring operations NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( { LIT : f\" Test { NAME } _12345 \" } , { LIT : f\" Test { NAME } _12345 \" } ) NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 100 scoring operations should be fast, took { NAME : .3f } s \" # ERROR HANDLING TESTS def NAME ( ) : # Test error handling scenarios from NAME . NAME import NAME # Test configuration access with error NAME = NAME ( NAME , LIT , LIT ) assert NAME == LIT , LIT # Test search_api_for_criteria with invalid session NAME = NAME ( ) NAME . NAME . NAME = NAME ( LIT ) NAME = NAME ( NAME , { LIT : LIT } ) assert NAME == [ ] , LIT # Run all tests with suppress_logging with NAME ( ) : # INITIALIZATION TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # CORE FUNCTIONALITY TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # EDGE CASE TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # INTEGRATION TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # PERFORMANCE TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) # ERROR HANDLING TESTS NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "test_module_initialization",
      "lineno": 851,
      "end_lineno": 867,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f24bf6d773219bd0a5ecb8a359c2978cb55b639e",
      "simhash64": 7451728980478432299,
      "normalized": "def NAME ( ) : # Test module initialization and configuration # Test configuration access NAME = NAME ( NAME , LIT , LIT ) assert NAME ( NAME , NAME ) , LIT assert NAME == LIT , LIT # Test configuration structure assert NAME ( NAME . NAME , NAME ) , LIT assert ( LIT in NAME . NAME ) , LIT assert NAME ( NAME . NAME , ( NAME , NAME ) ) , LIT"
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "test_core_functionality",
      "lineno": 870,
      "end_lineno": 902,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 33,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "d6ddc2805861d7ce5d343b7639e7b2db2b78300a",
      "simhash64": 5145885970992633387,
      "normalized": "def NAME ( ) : # Test all core API search and scoring functions # Test _extract_year_from_date function NAME = NAME ( LIT ) assert NAME == LIT , LIT NAME = NAME ( LIT ) assert NAME == LIT , LIT NAME = NAME ( LIT ) assert NAME is None , LIT # Test _run_simple_suggestion_scoring function NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } NAME , NAME , NAME = NAME ( NAME , NAME ) assert NAME ( NAME , ( NAME , NAME ) ) , LIT assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME , NAME ) , LIT assert NAME > LIT , LIT"
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "test_edge_cases",
      "lineno": 905,
      "end_lineno": 920,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 16,
      "tags": [
        "impure",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ee204fd3fbf879eaee38a69c33ad97e227940dc9",
      "simhash64": 5146448920950249019,
      "normalized": "def NAME ( ) : # Test edge cases and boundary conditions # Test _extract_year_from_date with edge cases NAME = NAME ( LIT ) assert NAME is None , LIT NAME = NAME ( None ) assert NAME is None , LIT NAME = NAME ( LIT ) assert NAME == LIT , LIT # Test scoring with empty data NAME , NAME , NAME = NAME ( { } , { } ) assert NAME == LIT , LIT assert NAME ( NAME ) == LIT , LIT"
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "test_integration",
      "lineno": 923,
      "end_lineno": 937,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ea36b4789cc6bfc7460d29e925b7795f0026de98",
      "simhash64": 7452221561419240507,
      "normalized": "def NAME ( ) : # Test integration with mocked external dependencies from NAME . NAME import NAME , NAME # Test search_api_for_criteria with mock session NAME = NAME ( ) NAME . NAME . NAME = True with NAME ( LIT ) as NAME : NAME . NAME = [ { LIT : LIT } ] NAME = NAME ( NAME , { LIT : LIT , LIT : LIT } ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "test_performance",
      "lineno": 940,
      "end_lineno": 954,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9ffb1fea99d1136ff6e0bb1bac2becfde1cb19e6",
      "simhash64": 8605248619143403067,
      "normalized": "def NAME ( ) : # Test performance of scoring operations import NAME # Test multiple scoring operations NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( { LIT : f\" Test { NAME } _12345 \" } , { LIT : f\" Test { NAME } _12345 \" } ) NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 100 scoring operations should be fast, took { NAME : .3f } s \""
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "test_error_handling",
      "lineno": 957,
      "end_lineno": 970,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "0235e2a9f7ab0a45730a59447423652b36ecf638",
      "simhash64": 7452291929089684543,
      "normalized": "def NAME ( ) : # Test error handling scenarios from NAME . NAME import NAME # Test configuration access with error NAME = NAME ( NAME , LIT , LIT ) assert NAME == LIT , LIT # Test search_api_for_criteria with invalid session NAME = NAME ( ) NAME . NAME . NAME = NAME ( LIT ) NAME = NAME ( NAME , { LIT : LIT } ) assert NAME == [ ] , LIT"
    },
    {
      "module_path": "api_search_utils.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 1031,
      "end_lineno": 1033,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "PersonSuggestResponse.from_dict",
      "lineno": 176,
      "end_lineno": 178,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(cls, data)",
      "fingerprint": "75dcd08f49560f004dead4151512d891f257e423",
      "simhash64": 7488109654235853939,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> LIT : LIT return NAME ( ** { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME in NAME . NAME } )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "PersonSuggestResponse.dict",
      "lineno": 180,
      "end_lineno": 186,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, exclude_none)",
      "fingerprint": "6bb98c31c4c71b9b3f6d90ac8b6329ed284074c7",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME = False ) -> NAME [ NAME , NAME ] : LIT from NAME import NAME NAME = NAME ( NAME ) if NAME : NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None } return NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "ProfileDetailsResponse.__init__",
      "lineno": 192,
      "end_lineno": 196,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, **kwargs)",
      "fingerprint": "2058c20bf3cd6f93163e9b22a829a8bbece4e52b",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME , ** NAME : NAME ) -> None : NAME . NAME : NAME [ NAME ] = NAME . NAME ( LIT ) NAME . NAME : NAME [ NAME ] = NAME . NAME ( LIT ) NAME . NAME : NAME [ NAME ] = NAME . NAME ( LIT ) NAME . NAME : NAME [ NAME ] = NAME . NAME ( LIT )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "ProfileDetailsResponse.dict",
      "lineno": 198,
      "end_lineno": 208,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, exclude_none)",
      "fingerprint": "7faf213bf74c4a01c08a399d6cdf37590213ac3d",
      "simhash64": 7452151225961059347,
      "normalized": "def NAME ( NAME , NAME : NAME = False ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , } if NAME : NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None } return NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "TreeOwnerResponse.from_dict",
      "lineno": 223,
      "end_lineno": 240,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(cls, data)",
      "fingerprint": "386f05ca187c7548cda566de58022f104a037555",
      "simhash64": 7488109654235853875,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> LIT : LIT if not NAME ( NAME , NAME ) : NAME = { } NAME = NAME ( NAME ) # Alias mapping: treeMembersCount -> peopleCount (if peopleCount missing) if LIT not in NAME and LIT in NAME : try : NAME [ LIT ] = NAME ( NAME . NAME ( LIT ) or LIT ) except NAME : # Fallback to raw if not int-coercible NAME [ LIT ] = NAME . NAME ( LIT ) # Filter to known fields only NAME = { NAME : NAME [ NAME ] for NAME in NAME . NAME if NAME in NAME } return NAME ( ** NAME )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "TreeOwnerResponse.dict",
      "lineno": 242,
      "end_lineno": 248,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, exclude_none)",
      "fingerprint": "6bb98c31c4c71b9b3f6d90ac8b6329ed284074c7",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME = False ) -> NAME [ NAME , NAME ] : LIT from NAME import NAME NAME = NAME ( NAME ) if NAME : NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None } return NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "PersonFactsResponse.from_dict",
      "lineno": 263,
      "end_lineno": 265,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(cls, data)",
      "fingerprint": "75dcd08f49560f004dead4151512d891f257e423",
      "simhash64": 7488109654235853939,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> LIT : LIT return NAME ( ** { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME in NAME . NAME } )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "PersonFactsResponse.dict",
      "lineno": 267,
      "end_lineno": 273,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, exclude_none)",
      "fingerprint": "6bb98c31c4c71b9b3f6d90ac8b6329ed284074c7",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME = False ) -> NAME [ NAME , NAME ] : LIT from NAME import NAME NAME = NAME ( NAME ) if NAME : NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None } return NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "GetLadderResponse.from_dict",
      "lineno": 285,
      "end_lineno": 287,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(cls, data)",
      "fingerprint": "75dcd08f49560f004dead4151512d891f257e423",
      "simhash64": 7488109654235853939,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> LIT : LIT return NAME ( ** { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME in NAME . NAME } )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "GetLadderResponse.dict",
      "lineno": 289,
      "end_lineno": 295,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, exclude_none)",
      "fingerprint": "6bb98c31c4c71b9b3f6d90ac8b6329ed284074c7",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME = False ) -> NAME [ NAME , NAME ] : LIT from NAME import NAME NAME = NAME ( NAME ) if NAME : NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None } return NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "DiscoveryRelationshipResponse.__init__",
      "lineno": 301,
      "end_lineno": 304,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, **kwargs)",
      "fingerprint": "a7e323e536253b8f511851f35b347bcdd4103020",
      "simhash64": 7488180023047140435,
      "normalized": "def NAME ( NAME , ** NAME : NAME ) -> None : NAME . NAME : NAME [ NAME ] = NAME . NAME ( LIT ) NAME . NAME : NAME [ NAME [ NAME [ NAME , NAME ] ] ] = NAME . NAME ( LIT ) NAME . NAME : NAME [ NAME ] = NAME . NAME ( LIT )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "DiscoveryRelationshipResponse.dict",
      "lineno": 306,
      "end_lineno": 315,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, exclude_none)",
      "fingerprint": "94a3bf76dfe2159178ab2d9012677e21d4523034",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME , NAME : NAME = False ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , } if NAME : NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None } return NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "HeaderTreesResponse.__init__",
      "lineno": 321,
      "end_lineno": 324,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, **kwargs)",
      "fingerprint": "94b76411be4646635bca642453fcc044da784595",
      "simhash64": 7488180023047140435,
      "normalized": "def NAME ( NAME , ** NAME : NAME ) -> None : NAME . NAME : NAME [ NAME [ NAME [ NAME , NAME ] ] ] = NAME . NAME ( LIT ) NAME . NAME : NAME [ NAME ] = NAME . NAME ( LIT ) NAME . NAME : NAME [ NAME ] = NAME . NAME ( LIT )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "HeaderTreesResponse.dict",
      "lineno": 326,
      "end_lineno": 335,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, exclude_none)",
      "fingerprint": "94a3bf76dfe2159178ab2d9012677e21d4523034",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME , NAME : NAME = False ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , } if NAME : NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None } return NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "SendMessageResponse.__init__",
      "lineno": 341,
      "end_lineno": 345,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, **kwargs)",
      "fingerprint": "2058c20bf3cd6f93163e9b22a829a8bbece4e52b",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME , ** NAME : NAME ) -> None : NAME . NAME : NAME [ NAME ] = NAME . NAME ( LIT ) NAME . NAME : NAME [ NAME ] = NAME . NAME ( LIT ) NAME . NAME : NAME [ NAME ] = NAME . NAME ( LIT ) NAME . NAME : NAME [ NAME ] = NAME . NAME ( LIT )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "SendMessageResponse.dict",
      "lineno": 347,
      "end_lineno": 357,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, exclude_none)",
      "fingerprint": "7faf213bf74c4a01c08a399d6cdf37590213ac3d",
      "simhash64": 7452151225961059347,
      "normalized": "def NAME ( NAME , NAME : NAME = False ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , } if NAME : NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None } return NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "ApiRateLimiter.__init__",
      "lineno": 364,
      "end_lineno": 368,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, max_calls_per_minute, max_calls_per_hour)",
      "fingerprint": "d80af9c42861ed55222b9c268eaea6a865784403",
      "simhash64": 7452080857283998743,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , NAME : NAME = LIT ) -> None : NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = [ ] NAME . NAME = [ ]"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "ApiRateLimiter.can_make_request",
      "lineno": 370,
      "end_lineno": 385,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 16,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "97ccca539a9d69827fec33d2ebf66f686a9e0c18",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) # Clean old entries NAME . NAME = [ NAME for NAME in NAME . NAME if ( NAME - NAME ) . NAME < LIT ] NAME . NAME = [ NAME for NAME in NAME . NAME if ( NAME - NAME ) . NAME < LIT ] # Check limits if NAME ( NAME . NAME ) >= NAME . NAME : return False return not NAME ( NAME . NAME ) >= NAME . NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "ApiRateLimiter.record_request",
      "lineno": 387,
      "end_lineno": 391,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "c436edc82c70e3297fb88bdd22fb1e6101d0469c",
      "simhash64": 8641136716253930515,
      "normalized": "def NAME ( NAME ) : LIT NAME = NAME . NAME ( ) NAME . NAME . NAME ( NAME ) NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "ApiRateLimiter.wait_time_until_available",
      "lineno": 393,
      "end_lineno": 410,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 18,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "2d27afbf58be4ffdb62dfb3cc02df85da9f248fb",
      "simhash64": 7487652257398694915,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if NAME . NAME ( ) : return LIT NAME = NAME . NAME ( ) # Check minute limit if NAME ( NAME . NAME ) >= NAME . NAME : NAME = NAME ( NAME . NAME ) return NAME ( LIT , LIT - ( NAME - NAME ) . NAME ) # Check hour limit if NAME ( NAME . NAME ) >= NAME . NAME : NAME = NAME ( NAME . NAME ) return NAME ( LIT , LIT - ( NAME - NAME ) . NAME ) return LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "_extract_name_from_api_details",
      "lineno": 418,
      "end_lineno": 502,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 29,
      "loc": 85,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(person_card, facts_data)",
      "fingerprint": "c58669f045dd5511ee16368900de17b15f4a7d13",
      "simhash64": 7488180023047140379,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] ) -> NAME : LIT NAME = LIT NAME = NAME if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , { } ) if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , NAME ) # End of if if NAME == LIT : NAME = NAME . NAME ( LIT , NAME ) # End of if if NAME == LIT : NAME = NAME . NAME ( LIT , NAME ) # End of if if NAME == LIT : NAME = NAME . NAME ( LIT , NAME ) # End of if if NAME == LIT : NAME = NAME . NAME ( LIT , [ ] ) if NAME ( NAME , NAME ) : NAME = NAME ( ( NAME for NAME in NAME if NAME ( NAME , NAME ) and NAME . NAME ( LIT ) == LIT ) , None , ) if NAME and NAME . NAME ( LIT ) : NAME = NAME . NAME ( LIT , LIT ) # End of if # End of if # End of if if NAME == LIT : NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) if NAME or NAME : NAME = ( f\" { NAME or LIT } { NAME or LIT } \" . NAME ( ) or LIT ) # End of if # End of if # End of if if NAME == LIT and NAME : NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) if NAME : NAME = NAME elif NAME or NAME : NAME = f\" { NAME or LIT } { NAME or LIT } \" . NAME ( ) or LIT # End of if/elif if NAME == LIT : NAME = NAME . NAME ( LIT , LIT ) # End of if # End of if NAME = NAME ( NAME ) if NAME and NAME != LIT else LIT return LIT if NAME == LIT else NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "_extract_gender_from_api_details",
      "lineno": 508,
      "end_lineno": 578,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 20,
      "loc": 71,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(person_card, facts_data)",
      "fingerprint": "a150a397590b0579660476f5cdfbbff79cad09f4",
      "simhash64": 7488180023048188947,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] ) -> NAME [ NAME ] : LIT NAME = None NAME = None if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , { } ) if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT ) # End of if if not NAME : NAME = NAME . NAME ( LIT ) # End of if if not NAME : NAME = NAME . NAME ( LIT ) # End of if if not NAME : NAME = NAME . NAME ( LIT , [ ] ) if NAME ( NAME , NAME ) : NAME = NAME ( ( NAME for NAME in NAME if NAME ( NAME , NAME ) and NAME . NAME ( LIT ) == LIT ) , None , ) if NAME and NAME . NAME ( LIT ) : NAME = NAME . NAME ( LIT ) # End of if # End of if # End of if # End of if if not NAME and NAME : NAME = NAME . NAME ( LIT ) if not NAME : NAME = NAME . NAME ( LIT ) # End of if # End of if if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( ) if NAME == LIT : NAME = LIT elif NAME == LIT : NAME = LIT elif NAME in [ LIT , LIT ] : NAME = NAME . NAME ( ) # End of if/elif # End of if return NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "_extract_living_status_from_api_details",
      "lineno": 584,
      "end_lineno": 624,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 41,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(person_card, facts_data)",
      "fingerprint": "774ab535d176ad59fa372b7e2fe606b5607ab5e3",
      "simhash64": 8641102077410849811,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] ) -> NAME [ NAME ] : LIT NAME = None if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , { } ) if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT ) # End of if if NAME is None : NAME = NAME . NAME ( LIT ) # End of if if NAME is None : NAME = NAME . NAME ( LIT ) # End of if # End of if if NAME is None and NAME : NAME = NAME . NAME ( LIT ) if NAME is None : NAME = NAME . NAME ( LIT ) # End of if # End of if return NAME ( NAME ) if NAME is not None else None"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "_extract_event_from_api_details",
      "lineno": 630,
      "end_lineno": 784,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 35,
      "loc": 155,
      "tags": [
        "pure-ish",
        "time",
        "regex",
        "size:large"
      ],
      "signature": "(event_type, person_card, facts_data)",
      "fingerprint": "b9db6bb3cb16285a5f6e49786aaf25ef8be1006d",
      "simhash64": 7488180022981080083,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] ) -> NAME [ NAME [ NAME ] , NAME [ NAME ] , NAME [ NAME ] ] : LIT NAME : NAME [ NAME ] = None NAME : NAME [ NAME ] = None NAME : NAME [ NAME ] = None NAME = NAME NAME = NAME . NAME ( ) NAME = f\" { NAME } Year \" NAME = f\" { NAME } Place \" NAME = NAME NAME = f\" { NAME } Date \" NAME = NAME NAME = False if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , [ ] ) if NAME ( NAME , NAME ) : NAME = NAME ( ( NAME for NAME in NAME if NAME ( NAME , NAME ) and NAME . NAME ( LIT ) == NAME and not NAME . NAME ( LIT ) ) , None , ) if NAME : NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = True NAME . NAME ( f\" Found primary { NAME } fact in PersonFacts: Date=' { NAME } ', Place=' { NAME } ' \" ) if NAME ( NAME , NAME ) and NAME : NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) if NAME : try : NAME = NAME ( NAME ) if NAME : NAME += f\" - { NAME ( NAME ) . NAME ( LIT ) } \" # End of if if NAME : NAME += f\" - { NAME ( NAME ) . NAME ( LIT ) } \" # End of if NAME = NAME ( NAME ) NAME . NAME ( f\" Parsed { NAME } date object from ParsedDate: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Could not parse { NAME } date from ParsedDate { NAME } : { NAME } \" ) # End of try/except # End of if year # End of if parsed_date_data # End of if event_fact # End of if if not NAME : NAME = NAME . NAME ( LIT , { } ) . NAME ( NAME , [ ] ) if NAME and NAME ( NAME , NAME ) : NAME = NAME [ LIT ] if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , NAME . NAME ( LIT ) ) # End of if if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT ) # End of if NAME = True # End of if # End of if # End of if if not NAME : NAME = NAME . NAME ( NAME ) if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , NAME . NAME ( LIT ) ) NAME = NAME . NAME ( LIT , NAME ) NAME = True elif NAME ( NAME , NAME ) : NAME = NAME NAME = True # End of if/elif # End of if # End of if if not NAME and NAME : NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) if NAME : NAME = NAME ( NAME ) NAME = NAME NAME . NAME ( f\" Using Suggest API keys for { NAME } : Year=' { NAME } ', Place=' { NAME } ' \" ) else : NAME = NAME . NAME ( NAME , LIT ) if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , NAME , NAME = LIT ) NAME = NAME [ LIT ] . NAME ( ) if NAME else NAME if NAME is None and NAME ( NAME ) > LIT : NAME = NAME [ LIT ] . NAME ( ) # End of if elif NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , NAME ) if NAME is None : NAME = NAME . NAME ( LIT , NAME ) # End of if # End of if/elif # End of if/else # End of if if NAME is None and NAME and NAME : try : NAME = NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Failed to parse { NAME } date string ' { NAME } ': { NAME } \" ) # End of try/except # End of if return NAME , NAME , NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "_generate_person_link",
      "lineno": 790,
      "end_lineno": 821,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 32,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(person_id, tree_id, base_url)",
      "fingerprint": "2b674924315dd387235c6e8a42a97c288f0168b3",
      "simhash64": 7452221594706293779,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME [ NAME ] , NAME : NAME ) -> NAME : LIT if NAME and NAME : return f\" { NAME } /family-tree/person/tree/ { NAME } /person/ { NAME } /facts \" if NAME : return f\" { NAME } /discoveryui-matches/list/summary/ { NAME } \" # End of if/elif return LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "parse_ancestry_person_details",
      "lineno": 827,
      "end_lineno": 900,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 16,
      "loc": 74,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(person_card, facts_data)",
      "fingerprint": "c557f9cc16ca69cdb340141b99af5e1c78d8feae",
      "simhash64": 5146308217888216107,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] = None ) -> NAME [ NAME , NAME ] : NAME : NAME [ NAME , NAME ] = { LIT : LIT , LIT : LIT , LIT : None , LIT : None , LIT : LIT , LIT : None , LIT : None , LIT : None , LIT : None , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : LIT , } if not NAME [ LIT ] : NAME [ LIT ] = NAME . NAME ( LIT ) # End of if if not NAME [ LIT ] : NAME [ LIT ] = NAME . NAME ( LIT ) # End of if if NAME and NAME ( NAME , NAME ) : NAME [ LIT ] = NAME . NAME ( LIT , NAME [ LIT ] ) NAME [ LIT ] = NAME . NAME ( LIT , NAME [ LIT ] ) NAME [ LIT ] = NAME . NAME ( LIT , NAME [ LIT ] ) if not NAME [ LIT ] : NAME = NAME . NAME ( LIT , { } ) if NAME ( NAME , NAME ) : NAME [ LIT ] = NAME . NAME ( LIT , NAME [ LIT ] ) # End of if # End of if # End of if NAME [ LIT ] = NAME ( NAME , NAME ) NAME [ LIT ] = NAME ( NAME , NAME ) NAME [ LIT ] = NAME ( NAME , NAME ) NAME , NAME [ LIT ] , NAME [ LIT ] = ( NAME ( LIT , NAME , NAME ) ) NAME , NAME [ LIT ] , NAME [ LIT ] = ( NAME ( LIT , NAME , NAME ) ) NAME = NAME NAME [ LIT ] = NAME ( NAME ) if NAME else LIT NAME [ LIT ] = NAME ( NAME ) if NAME else LIT if NAME [ LIT ] == LIT and NAME [ LIT ] : NAME [ LIT ] = NAME ( NAME [ LIT ] . NAME ) # End of if if NAME [ LIT ] == LIT and NAME [ LIT ] : NAME [ LIT ] = NAME ( NAME [ LIT ] . NAME ) # End of if NAME = ( NAME . NAME . NAME or LIT ) . NAME ( LIT ) NAME = NAME [ LIT ] or NAME [ LIT ] NAME = NAME [ LIT ] if not NAME [ LIT ] else None NAME [ LIT ] = NAME ( NAME , NAME , NAME ) NAME . NAME ( f\" Parsed API details for ' { NAME . NAME ( LIT , LIT ) } ': PersonID= { NAME . NAME ( LIT ) } , TreeID= { NAME . NAME ( LIT , LIT ) } , UserID= { NAME . NAME ( LIT , LIT ) } , Born=' { NAME . NAME ( LIT ) } ' [ { NAME . NAME ( LIT ) } ] in ' { NAME . NAME ( LIT ) or LIT } ', Died=' { NAME . NAME ( LIT ) } ' [ { NAME . NAME ( LIT ) } ] in ' { NAME . NAME ( LIT ) or LIT } ', Gender=' { NAME . NAME ( LIT ) or LIT } ', Living= { NAME . NAME ( LIT ) } , Link=' { NAME . NAME ( LIT ) } ' \" ) return NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "print_group",
      "lineno": 910,
      "end_lineno": 919,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 10,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "(label, items)",
      "fingerprint": "7748fb34602e7525d5210cb15d2884fdf11be98c",
      "simhash64": 7488179988621333563,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] ) : NAME ( f\" \\n { NAME } : \" ) if NAME : NAME = NAME for NAME in NAME : NAME = NAME . NAME ( LIT ) if NAME ( NAME , NAME ) else None NAME ( f\" - { NAME ( NAME ) } \" ) # End of for else : NAME ( LIT )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "_get_api_timeout",
      "lineno": 923,
      "end_lineno": 951,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 29,
      "tags": [
        "impure",
        "network",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(default)",
      "fingerprint": "68fbfa3742d9099b53ed8251778d8b4b47c69c0b",
      "simhash64": 7488109654235853851,
      "normalized": "def NAME ( NAME : NAME = LIT ) -> NAME : LIT NAME = NAME if NAME . NAME and NAME ( NAME . NAME , LIT ) : NAME = NAME . NAME . NAME if NAME ( NAME , ( NAME , NAME ) ) and NAME > LIT : NAME = NAME ( NAME ) else : NAME . NAME ( f\" Invalid API_TIMEOUT value in config ( { NAME } ), using default { NAME } s. \" ) # End of if/else # End of if return NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "_get_owner_referer",
      "lineno": 957,
      "end_lineno": 988,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 32,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(session_manager, base_url)",
      "fingerprint": "200d2208bf26cc229a62b3370190b26ad2ffb696",
      "simhash64": 7487617074100343867,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME ) -> NAME : LIT NAME = NAME ( NAME , LIT , None ) NAME = NAME ( NAME , LIT , None ) if NAME and NAME : NAME = ( f\" /family-tree/tree/ { NAME } /person/ { NAME } /facts \" ) NAME = NAME ( NAME . NAME ( LIT ) + LIT , NAME . NAME ( LIT ) ) NAME . NAME ( f\" Using owner facts page as referer: { NAME } \" ) return NAME NAME . NAME ( LIT ) return NAME . NAME ( LIT ) + LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "call_suggest_api",
      "lineno": 999,
      "end_lineno": 1267,
      "is_method": false,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 31,
      "loc": 269,
      "tags": [
        "impure",
        "network",
        "time",
        "json",
        "size:large"
      ],
      "signature": "(session_manager, owner_tree_id, owner_profile_id, base_url, search_criteria, timeouts)",
      "fingerprint": "634017a7d6e823419d6f43503d15551eeabedebc",
      "simhash64": 7452151227034801179,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME [ NAME ] ] = None , ) -> NAME [ NAME [ NAME ] ] : # Validate inputs and raise appropriate exceptions if not NAME ( NAME ) : NAME . NAME ( LIT ) raise NAME ( LIT , NAME = LIT , NAME = LIT , NAME = LIT , ) if not NAME ( NAME , NAME ) and not NAME ( NAME , LIT ) : raise NAME ( LIT , NAME = LIT , NAME = LIT , NAME = LIT , ) if not NAME : raise NAME ( LIT , NAME = LIT , NAME = LIT , NAME = LIT , ) NAME = LIT # Apply rate limiting if available if NAME and NAME : if not NAME . NAME ( ) : NAME = NAME . NAME ( ) NAME . NAME ( f\" Rate limit reached for { NAME } . Waiting { NAME : .1f } s \" ) import NAME NAME . NAME ( NAME ) NAME . NAME ( ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT ) NAME = [ LIT ] if NAME : NAME . NAME ( f\" partialFirstName= { NAME ( NAME ) } \" ) # End of if if NAME : NAME . NAME ( f\" partialLastName= { NAME ( NAME ) } \" ) # End of if if NAME : NAME . NAME ( f\" birthYear= { NAME } \" ) # End of if NAME = LIT . NAME ( NAME ) NAME = NAME . NAME ( NAME = NAME ) NAME = ( NAME ( NAME . NAME ( LIT ) + LIT , NAME ) + f\" ? { NAME } \" ) NAME = NAME ( NAME , NAME ) NAME = NAME if NAME else [ LIT , LIT , LIT ] NAME = NAME ( NAME ) NAME . NAME ( f\" Attempting { NAME } search: { NAME } \" ) NAME = None for NAME , NAME in NAME ( NAME , LIT ) : NAME . NAME ( f\" { NAME } attempt { NAME } / { NAME } with timeout { NAME } s \" ) try : NAME = { LIT : LIT , LIT : NAME , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = False , ) if NAME ( NAME , NAME ) : # Validate response with Pydantic if available if NAME and NAME : NAME = [ ] NAME = LIT for NAME in NAME : try : NAME = NAME ( ** NAME ) NAME . NAME ( NAME . NAME ( NAME = True ) ) except NAME as NAME : NAME += LIT NAME . NAME ( f\" Response validation warning for item: { NAME } \" ) # Keep original item if validation fails NAME . NAME ( NAME ) if NAME > LIT : NAME . NAME ( f\" Response validation: { NAME } / { NAME ( NAME ) } items had validation issues \" ) NAME = NAME NAME . NAME ( f\" { NAME } call successful via _api_req (attempt { NAME } / { NAME } ), found { NAME ( NAME ) } results. \" ) return NAME if NAME is None : NAME . NAME ( f\" { NAME } call using _api_req returned None on attempt { NAME } / { NAME } . \" ) else : NAME . NAME ( f\" { NAME } call using _api_req returned unexpected type: { NAME ( NAME ) } \" ) NAME . NAME ( f\" Unexpected Response Content: { NAME ( NAME ) [ : LIT ] } \" ) NAME = None break # End of if/elif/else except NAME . NAME . NAME : NAME = NAME ( f\" API request timed out after { NAME } s \" , NAME = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , } , NAME = LIT , ) NAME . NAME ( NAME ( NAME ) ) if NAME == NAME : raise NAME except NAME . NAME . NAME as NAME : if LIT in NAME ( NAME ) . NAME ( ) or LIT in NAME ( NAME ) : # Enhanced 429 handling with progressive backoff import NAME NAME = LIT * ( LIT ** ( NAME - LIT ) ) # Progressive backoff starting at 5 seconds NAME = NAME ( NAME , LIT ) # Cap at 5 minutes NAME . NAME ( f\" Rate limit (429) on { NAME } , attempt { NAME } / { NAME } . \" f\" Waiting { NAME : .1f } s before retry... \" ) NAME . NAME ( NAME ) if NAME == NAME : raise NAME ( f\" API rate limit exceeded after { NAME } attempts: { NAME } \" , NAME = { LIT : NAME , LIT : NAME , LIT : NAME } , ) continue # Retry the request after delay raise NAME ( f\" Network request failed: { NAME } \" , NAME = { LIT : NAME , LIT : NAME } , ) except NAME as NAME : NAME . NAME ( f\" { NAME } _api_req call failed on attempt { NAME } / { NAME } : { NAME } \" , NAME = True , ) if NAME == NAME : raise NAME ( f\" API call failed after { NAME } attempts: { NAME } \" , NAME = { LIT : NAME , LIT : NAME , LIT : NAME , } , ) NAME = None continue # End of try/except # End of for if NAME is None : NAME . NAME ( f\" { NAME } failed via _api_req. Attempting direct requests fallback. \" ) NAME = None try : NAME = { } if NAME . NAME : NAME = NAME . NAME . NAME . NAME ( ) # End of if NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : NAME , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } NAME . NAME ( f\" Direct request URL: { NAME } \" ) NAME . NAME ( f\" Direct request headers: { NAME } \" ) NAME . NAME ( f\" Direct request cookies: { NAME ( NAME . NAME ( ) ) } \" ) NAME = NAME ( LIT ) NAME = NAME . NAME ( NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) if NAME . NAME == LIT : NAME = NAME . NAME ( ) if NAME ( NAME , NAME ) : NAME . NAME ( f\" Direct request fallback successful! Found { NAME ( NAME ) } results. \" ) return NAME NAME . NAME ( f\" Direct request succeeded (200 OK) but returned non-list data: { NAME ( NAME ) } \" ) NAME . NAME ( f\" Direct Response content: { NAME ( NAME ) [ : LIT ] } \" ) # End of if/else else : NAME . NAME ( f\" Direct request fallback failed: Status { NAME . NAME } \" ) NAME . NAME ( f\" Direct Response content: { NAME . NAME [ : LIT ] } \" ) # End of if/else except NAME . NAME . NAME : NAME . NAME ( f\" Direct request fallback timed out after { NAME } seconds \" ) except NAME . NAME as NAME : NAME . NAME ( f\" Direct request fallback failed to decode JSON: { NAME } \" ) if NAME : NAME . NAME ( f\" Direct Response content: { NAME . NAME [ : LIT ] } \" ) # End of if except NAME as NAME : NAME . NAME ( f\" Direct request fallback failed with error: { NAME } \" , NAME = True , ) # End of try/except # End of if NAME . NAME ( f\" { NAME } failed after all attempts and fallback. \" ) return None"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "call_facts_user_api",
      "lineno": 1273,
      "end_lineno": 1474,
      "is_method": false,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 24,
      "loc": 202,
      "tags": [
        "impure",
        "network",
        "time",
        "json",
        "size:large"
      ],
      "signature": "(session_manager, owner_profile_id, api_person_id, api_tree_id, base_url, timeouts)",
      "fingerprint": "31e1cbee81e863f68cba3eb2cf4cf54e8b759404",
      "simhash64": 7452151225961059355,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME [ NAME ] ] = None , ) -> NAME [ NAME ] : if not NAME ( NAME ) : NAME . NAME ( LIT ) raise NAME ( LIT ) # End of if if not NAME ( NAME , NAME ) : NAME . NAME ( LIT ) return None # End of if if not NAME ( [ NAME , NAME , NAME ] ) : NAME . NAME ( LIT ) return None # End of if NAME = LIT # Apply rate limiting if available if NAME and NAME : if not NAME . NAME ( ) : NAME = NAME . NAME ( ) NAME . NAME ( f\" Rate limit reached for { NAME } . Waiting { NAME : .1f } s \" ) import NAME NAME . NAME ( NAME ) NAME . NAME ( ) NAME = NAME . NAME ( NAME = NAME . NAME ( ) , NAME = NAME . NAME ( ) , NAME = NAME . NAME ( ) , ) NAME = NAME ( NAME . NAME ( LIT ) + LIT , NAME ) NAME = NAME ( NAME , NAME ) NAME = None NAME = NAME ( LIT ) NAME = NAME if NAME else [ LIT , LIT , LIT ] NAME . NAME ( f\" Attempting { NAME } via direct request: { NAME } \" ) NAME = None try : NAME = { } if NAME . NAME : NAME = NAME . NAME . NAME . NAME ( ) # End of if NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : NAME , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } NAME . NAME ( f\" Direct facts request headers: { NAME } \" ) NAME . NAME ( f\" Direct facts request cookies: { NAME ( NAME . NAME ( ) ) } \" ) NAME = NAME . NAME ( NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) if NAME . NAME == LIT : NAME = NAME . NAME ( ) if not NAME ( NAME , NAME ) : NAME . NAME ( f\" Direct facts request OK (200) but returned non-dict data: { NAME ( NAME ) } \" ) NAME . NAME ( f\" Response content: { NAME . NAME [ : LIT ] } \" ) NAME = None else : NAME . NAME ( f\" { NAME } call successful via direct request. \" ) # End of if/else else : NAME . NAME ( f\" Direct facts request failed: Status { NAME . NAME } \" ) NAME . NAME ( f\" Response content: { NAME . NAME [ : LIT ] } \" ) NAME = None # End of if/else except NAME . NAME . NAME : NAME . NAME ( f\" Direct facts request timed out after { NAME } seconds \" ) NAME = None except NAME . NAME as NAME : NAME . NAME ( f\" Direct facts request failed to decode JSON: { NAME } \" ) if NAME : NAME . NAME ( f\" Response content: { NAME . NAME [ : LIT ] } \" ) # End of if NAME = None except NAME as NAME : NAME . NAME ( f\" Direct facts request failed: { NAME } \" , NAME = True ) NAME = None # End of try/except if NAME is None : NAME . NAME ( f\" { NAME } direct request failed. Trying _api_req fallback. \" ) NAME = NAME ( NAME ) for NAME , NAME in NAME ( NAME , LIT ) : NAME . NAME ( f\" { NAME } _api_req attempt { NAME } / { NAME } with timeout { NAME } s \" ) try : NAME = { LIT : LIT , LIT : NAME , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) if NAME ( NAME , NAME ) : NAME = NAME NAME . NAME ( f\" { NAME } call successful via _api_req (attempt { NAME } / { NAME } ). \" ) break if NAME is None : NAME . NAME ( f\" { NAME } _api_req returned None (attempt { NAME } / { NAME } ). \" ) else : NAME . NAME ( f\" { NAME } _api_req returned unexpected type: { NAME ( NAME ) } \" ) NAME . NAME ( f\" Unexpected Response Value: { NAME ( NAME ) [ : LIT ] } \" ) # End of if/elif/else except NAME . NAME . NAME : NAME . NAME ( f\" { NAME } _api_req call timed out after { NAME } s on attempt { NAME } / { NAME } . \" ) except NAME as NAME : NAME . NAME ( f\" { NAME } call using _api_req failed on attempt { NAME } / { NAME } : { NAME } \" , NAME = True , ) NAME = None break # End of try/except # End of for # End of if if not NAME ( NAME , NAME ) : NAME . NAME ( f\" Failed to fetch valid { NAME } data after all attempts. \" ) return None # End of if NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT ) if not NAME ( NAME , NAME ) or not NAME : NAME . NAME ( f\" { NAME } response received, but missing 'data.personResearch' dictionary. \" ) NAME . NAME ( f\" Full raw response keys: { NAME ( NAME . NAME ( ) ) } \" ) if LIT in NAME and NAME ( NAME [ LIT ] , NAME ) : NAME . NAME ( f\" 'data' sub-keys: { NAME ( NAME [ LIT ] . NAME ( ) ) } \" ) else : NAME . NAME ( LIT ) # End of if/else return None # End of if # Validate response with Pydantic if available if NAME : try : NAME ( ** NAME ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Facts API response validation warning: { NAME } \" ) # Continue with original data if validation fails NAME . NAME ( f\" Successfully fetched and extracted 'personResearch' data for PersonID { NAME } . \" ) return NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "call_getladder_api",
      "lineno": 1480,
      "end_lineno": 1579,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 13,
      "loc": 100,
      "tags": [
        "impure",
        "network",
        "time",
        "json",
        "size:large"
      ],
      "signature": "(session_manager, owner_tree_id, target_person_id, base_url, timeout)",
      "fingerprint": "67796887064715c2ab77c2d73402bb05f20ead1c",
      "simhash64": 7488180022981071891,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME ] : if not NAME ( NAME ) : NAME . NAME ( LIT ) raise NAME ( LIT ) # End of if if not NAME ( NAME , NAME ) : NAME . NAME ( LIT ) return None # End of if if not NAME ( [ NAME , NAME ] ) : NAME . NAME ( LIT ) return None # End of if NAME = LIT # Apply rate limiting if available if NAME and NAME : if not NAME . NAME ( ) : NAME = NAME . NAME ( ) NAME . NAME ( f\" Rate limit reached for { NAME } . Waiting { NAME : .1f } s \" ) import NAME NAME . NAME ( NAME ) NAME . NAME ( ) NAME = NAME . NAME ( NAME = NAME , NAME = NAME ) NAME = NAME ( NAME . NAME ( LIT ) + LIT , NAME ) NAME = NAME ( { LIT : LIT } ) NAME = f\" { NAME } ? { NAME } \" NAME = ( f\" /family-tree/person/tree/ { NAME } /person/ { NAME } /facts \" ) NAME = NAME ( NAME . NAME ( LIT ) + LIT , NAME . NAME ( LIT ) ) NAME = NAME if NAME else NAME ( LIT ) NAME . NAME ( f\" Attempting { NAME } call: { NAME } \" ) try : NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , NAME = False , NAME = True , NAME = NAME , ) if NAME ( NAME , NAME ) and NAME ( NAME ) > LIT : # Validate response with Pydantic if available and try to parse as JSON if NAME : try : # Try to parse the string response as JSON for validation import NAME NAME = NAME . NAME ( NAME ) NAME ( ** NAME ) NAME . NAME ( LIT ) except NAME . NAME : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" GetLadder API response validation warning: { NAME } \" ) NAME . NAME ( f\" { NAME } call successful, received string response. \" ) return NAME if NAME ( NAME , NAME ) : NAME . NAME ( f\" { NAME } call returned a very short string: ' { NAME } ' \" ) return None NAME . NAME ( f\" { NAME } call returned non-string or None: { NAME ( NAME ) } \" ) return None # End of if/elif/else except NAME . NAME . NAME : NAME . NAME ( f\" { NAME } call timed out after { NAME } s. \" ) return None except NAME as NAME : NAME . NAME ( f\" API call ' { NAME } ' failed: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "call_discovery_relationship_api",
      "lineno": 1586,
      "end_lineno": 1721,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 15,
      "loc": 136,
      "tags": [
        "impure",
        "network",
        "time",
        "json",
        "size:large"
      ],
      "signature": "(session_manager, selected_person_global_id, owner_profile_id, base_url, timeout)",
      "fingerprint": "d9330cc853fa010b63ff3f357554ff5e5bf70a0c",
      "simhash64": 7488180022981071899,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME ] : LIT if not NAME ( NAME ) : NAME . NAME ( LIT ) raise NAME ( LIT ) # End of if if not NAME ( NAME , NAME ) : NAME . NAME ( LIT ) return None # End of if if not NAME ( [ NAME , NAME ] ) : NAME . NAME ( LIT ) return None # End of if NAME = LIT # Apply rate limiting if available if NAME and NAME : if not NAME . NAME ( ) : NAME = NAME . NAME ( ) NAME . NAME ( f\" Rate limit reached for { NAME } . Waiting { NAME : .1f } s \" ) import NAME NAME . NAME ( NAME ) NAME . NAME ( ) NAME = NAME NAME = ( NAME ( NAME . NAME ( LIT ) + LIT , NAME ) + f\" ?profileIdFrom= { NAME } &profileIdTo= { NAME } \" ) NAME = f\" { NAME . NAME ( LIT ) } /discoveryui-matches/list/summary/ { NAME } \" NAME = NAME if NAME else NAME ( LIT ) NAME . NAME ( f\" Attempting { NAME } call: { NAME } \" ) try : NAME = { LIT : LIT , LIT : NAME , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = False , ) if NAME ( NAME , NAME ) and LIT in NAME : # Validate response with Pydantic if available if NAME : try : NAME ( ** NAME ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Discovery Relationship API response validation warning: { NAME } \" ) NAME . NAME ( f\" { NAME } call successful, received valid JSON response with path data. \" ) return NAME if NAME ( NAME , NAME ) : # Validate response with Pydantic if available if NAME : try : NAME ( ** NAME ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Discovery Relationship API response validation warning: { NAME } \" ) NAME . NAME ( f\" { NAME } call returned JSON without 'path' key: { NAME ( NAME . NAME ( ) ) } \" ) return NAME # Still return the data for potential debugging NAME . NAME ( f\" { NAME } call returned unexpected type: { NAME ( NAME ) } \" ) return None # End of if/elif/else except NAME . NAME . NAME : NAME . NAME ( f\" { NAME } call timed out after { NAME } s. \" ) return None except NAME as NAME : NAME . NAME ( f\" API call ' { NAME } ' failed: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "call_treesui_list_api",
      "lineno": 1728,
      "end_lineno": 1847,
      "is_method": false,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 14,
      "loc": 120,
      "tags": [
        "impure",
        "network",
        "time",
        "json",
        "size:large"
      ],
      "signature": "(session_manager, owner_tree_id, owner_profile_id, base_url, search_criteria, timeouts)",
      "fingerprint": "64eeef761954b29d0dcee4a02bd08ba454f1c190",
      "simhash64": 7452151225962107931,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME [ NAME ] ] = None , ) -> NAME [ NAME [ NAME ] ] : if not NAME ( NAME ) : NAME . NAME ( LIT ) raise NAME ( LIT ) # End of if if not NAME ( NAME , NAME ) : NAME . NAME ( LIT ) return None # End of if if not NAME : NAME . NAME ( LIT ) return None # End of if NAME = LIT # Apply rate limiting if available if NAME and NAME : if not NAME . NAME ( ) : NAME = NAME . NAME ( ) NAME . NAME ( f\" Rate limit reached for { NAME } . Waiting { NAME : .1f } s \" ) import NAME NAME . NAME ( NAME ) NAME . NAME ( ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT ) if not NAME : NAME . NAME ( LIT ) return None # End of if NAME = [ LIT , LIT ] if NAME : NAME . NAME ( f\" fn= { NAME ( NAME ) } \" ) # End of if if NAME : NAME . NAME ( f\" ln= { NAME ( NAME ) } \" ) # End of if NAME . NAME ( f\" by= { NAME } \" ) NAME = LIT . NAME ( NAME ) NAME = NAME . NAME ( NAME = NAME ) NAME = ( NAME ( NAME . NAME ( LIT ) + LIT , NAME ) + f\" ? { NAME } \" ) NAME = NAME ( NAME , NAME ) NAME = NAME if NAME else [ LIT , LIT , LIT ] NAME = NAME ( NAME ) NAME . NAME ( f\" Attempting { NAME } search using _api_req: { NAME } \" ) NAME = None for NAME , NAME in NAME ( NAME , LIT ) : NAME . NAME ( f\" { NAME } attempt { NAME } / { NAME } with timeout { NAME } s \" ) try : NAME = { LIT : LIT , LIT : NAME , LIT : LIT , LIT : LIT , LIT : LIT , } NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = False , ) if NAME ( NAME , NAME ) : NAME . NAME ( f\" { NAME } call successful via _api_req (attempt { NAME } / { NAME } ), found { NAME ( NAME ) } results. \" ) return NAME if NAME is None : NAME . NAME ( f\" { NAME } _api_req returned None (attempt { NAME } / { NAME } ). \" ) else : NAME . NAME ( f\" { NAME } returned unexpected format via _api_req: { NAME ( NAME ) } \" ) NAME . NAME ( f\" Unexpected Response: { NAME ( NAME ) [ : LIT ] } \" ) return None # End of if/elif/else except NAME . NAME . NAME : NAME . NAME ( f\" { NAME } _api_req call timed out after { NAME } s on attempt { NAME } / { NAME } . \" ) except NAME as NAME : NAME . NAME ( f\" { NAME } _api_req call failed on attempt { NAME } / { NAME } : { NAME } \" , NAME = True , ) NAME = None break # End of try/except # End of for NAME . NAME ( f\" { NAME } failed after all attempts. \" ) return None"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "call_send_message_api",
      "lineno": 1853,
      "end_lineno": 2045,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 8,
      "yield_count": 0,
      "complexity": 28,
      "loc": 193,
      "tags": [
        "impure",
        "network",
        "size:large"
      ],
      "signature": "(session_manager, person, message_text, existing_conv_id, log_prefix)",
      "fingerprint": "7f7bc4f7db32a743107014802e2389886fa00a81",
      "simhash64": 7488180022981071891,
      "normalized": "def NAME ( NAME : LIT , NAME : LIT , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , ) -> NAME [ NAME , NAME [ NAME ] ] : if not NAME or not NAME . NAME : NAME . NAME ( f\" { NAME } : Cannot send message - SessionManager or own profile ID missing. \" ) return NAME , None # End of if if not NAME ( NAME , NAME ) or not NAME ( NAME , LIT , None ) : NAME . NAME ( f\" { NAME } : Cannot send message - Invalid Person object (Type: { NAME ( NAME ) } ) or missing profile ID. \" ) return NAME , None # End of if if not NAME ( NAME , NAME ) or not NAME . NAME ( ) : NAME . NAME ( f\" { NAME } : Cannot send message - Message text is empty or invalid. \" ) return NAME , None # End of if NAME = NAME . NAME if NAME == LIT : NAME = NAME NAME = NAME or f\" dryrun_ { NAME . NAME ( ) } \" NAME . NAME ( f\" { NAME } : Dry Run - Simulated message send to { NAME ( NAME , LIT , None ) or NAME ( NAME , LIT , LIT ) } . \" ) return NAME , NAME if NAME not in [ LIT , LIT ] : NAME . NAME ( f\" { NAME } : Logic Error - Unexpected APP_MODE ' { NAME } ' reached send logic. \" ) return NAME , None # End of if/elif NAME = NAME . NAME . NAME ( ) NAME = NAME . NAME . NAME ( ) NAME = NAME ( NAME , LIT , LIT ) . NAME ( ) NAME = not NAME NAME : NAME = LIT NAME : NAME [ NAME , NAME ] = { } NAME : NAME = LIT NAME : NAME [ NAME , NAME ] = { } try : NAME = NAME . NAME . NAME or LIT if NAME : NAME = NAME ( NAME . NAME ( LIT ) + LIT , NAME ) NAME = LIT NAME = { LIT : NAME , LIT : NAME , LIT : LIT , LIT : LIT , LIT : [ { LIT : NAME . NAME ( ) , LIT : [ ] , } , { LIT : NAME } , ] , } elif NAME : NAME = NAME . NAME ( NAME = NAME ) NAME = NAME ( NAME . NAME ( LIT ) + LIT , NAME ) NAME = LIT NAME = { LIT : NAME , LIT : NAME , } else : NAME . NAME ( f\" { NAME } : Logic Error - Cannot determine API URL/payload (existing_conv_id issue?). \" ) return NAME , None # End of if/elif/else NAME = NAME . NAME . NAME . NAME ( NAME , { } ) NAME = NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" { NAME } : Error preparing API request data: { NAME } \" , NAME = True ) return NAME , None # End of try/except NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = NAME , NAME = False , NAME = NAME , NAME = NAME , ) NAME = NAME NAME : NAME [ NAME ] = None NAME = False if NAME is None : NAME = NAME NAME . NAME ( f\" { NAME } : API POST ( { NAME } ) failed (No response/Retries exhausted). \" ) elif NAME ( NAME , NAME . NAME ) : NAME = f\" send_error (http_ { NAME . NAME } ) \" NAME . NAME ( f\" { NAME } : API POST ( { NAME } ) failed with status { NAME . NAME } . \" ) from NAME import NAME with NAME ( NAME ) : NAME . NAME ( f\" Error response body: { NAME . NAME [ : LIT ] } \" ) # End of try/except elif NAME ( NAME , NAME ) : try : if NAME : NAME = NAME ( NAME . NAME ( NAME , LIT ) ) NAME = NAME . NAME ( NAME , { } ) NAME = ( NAME ( NAME . NAME ( NAME , LIT ) ) . NAME ( ) if NAME ( NAME , NAME ) else None ) if NAME and NAME == NAME : NAME = True NAME = NAME else : NAME . NAME ( f\" { NAME } : API initial response format invalid (ConvID: ' { NAME } ', Author: ' { NAME } ', Expected Author: ' { NAME } '). \" ) NAME . NAME ( f\" API Response: { NAME } \" ) NAME = NAME # End of if/else else : NAME = NAME ( NAME . NAME ( NAME , LIT ) ) . NAME ( ) if NAME == NAME : NAME = True NAME = NAME else : NAME . NAME ( f\" { NAME } : API follow-up author validation failed (Author: ' { NAME } ', Expected Author: ' { NAME } '). \" ) NAME . NAME ( f\" API Response: { NAME } \" ) NAME = NAME # End of if/else # End of if/else if NAME : NAME = NAME NAME . NAME ( f\" { NAME } : Message send to { NAME ( NAME , LIT , None ) or NAME ( NAME , LIT , LIT ) } successful (ConvID: { NAME } ). \" ) # End of if except NAME as NAME : NAME . NAME ( f\" { NAME } : Error parsing successful API response ( { NAME } ): { NAME } \" , NAME = True , ) NAME . NAME ( f\" API Response received: { NAME } \" ) NAME = NAME # End of try/except else : NAME . NAME ( f\" { NAME } : API call ( { NAME } ) unexpected success format. Type: { NAME ( NAME ) } , Resp: { NAME ( NAME ) [ : LIT ] } \" ) NAME = NAME # End of if/elif/else if not NAME and NAME == NAME : NAME = NAME NAME . NAME ( f\" { NAME } : Message send attempt concluded with status: { NAME } \" ) # End of if return NAME , NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "call_profile_details_api",
      "lineno": 2051,
      "end_lineno": 2203,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 9,
      "yield_count": 0,
      "complexity": 27,
      "loc": 153,
      "tags": [
        "impure",
        "network",
        "time",
        "size:large"
      ],
      "signature": "(session_manager, profile_id)",
      "fingerprint": "b2763679993e48d00a288f5cc4d40bd40be1881b",
      "simhash64": 7488180022981071891,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : if not NAME or not NAME ( NAME , NAME ) : NAME . NAME ( LIT ) return None # End of if if not NAME or not NAME . NAME : NAME . NAME ( LIT ) return None # End of if if not NAME . NAME ( ) : NAME . NAME ( f\" call_profile_details_api: Session invalid for Profile ID { NAME } . \" ) return None # End of if NAME = LIT # Apply rate limiting if available if NAME and NAME : if not NAME . NAME ( ) : NAME = NAME . NAME ( ) NAME . NAME ( f\" Rate limit reached for { NAME } . Waiting { NAME : .1f } s \" ) import NAME NAME . NAME ( NAME ) NAME . NAME ( ) NAME = NAME . NAME . NAME or LIT NAME = NAME ( NAME , f\" { NAME } ?userId= { NAME . NAME ( ) } \" , ) NAME = NAME ( NAME , LIT ) NAME . NAME ( f\" Fetching profile details ( { NAME } ) for Profile ID { NAME } ... \" ) try : NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = { } , NAME = False , NAME = NAME , NAME = NAME , ) if NAME and NAME ( NAME , NAME ) : # Validate response with Pydantic if available if NAME : try : NAME ( ** NAME ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Profile Details API response validation warning: { NAME } \" ) NAME . NAME ( f\" Successfully fetched profile details for { NAME } . \" ) NAME : NAME [ NAME , NAME ] = { LIT : None , LIT : None , LIT : False , } NAME = NAME . NAME ( NAME ) if NAME and NAME ( NAME , NAME ) : NAME [ LIT ] = NAME ( NAME ) else : NAME = NAME . NAME ( NAME ) if NAME and NAME ( NAME , NAME ) : NAME = NAME ( NAME ) NAME [ LIT ] = ( NAME . NAME ( ) [ LIT ] if NAME != LIT else None ) else : NAME . NAME ( f\" Could not extract FirstName or DisplayName for profile { NAME } \" ) # End of if/else # End of if/else NAME = NAME . NAME ( NAME ) NAME [ LIT ] = ( NAME ( NAME ) if NAME is not None else False ) NAME = NAME . NAME ( NAME ) if NAME and NAME ( NAME , NAME ) : try : if NAME . NAME ( LIT ) : NAME = NAME . NAME ( NAME . NAME ( LIT , LIT ) ) elif LIT in NAME or LIT in NAME [ LIT : ] : NAME = NAME . NAME ( NAME ) else : NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME = NAME . NAME ) # End of if/elif/else NAME [ LIT ] = NAME . NAME ( NAME . NAME ) except ( NAME , NAME ) as NAME : NAME . NAME ( f\" Could not parse LastLoginDate ' { NAME } ' for { NAME } : { NAME } \" ) # End of try/except else : NAME . NAME ( f\" LastLoginDate missing or invalid for profile { NAME } \" ) # End of if/else return NAME if NAME ( NAME , NAME . NAME ) : NAME . NAME ( f\" Failed profile details fetch for { NAME } . Status: { NAME . NAME } . \" ) return None if NAME is None : NAME . NAME ( f\" Failed profile details fetch for { NAME } (_api_req returned None). \" ) return None NAME . NAME ( f\" Failed profile details fetch for { NAME } (Invalid response type: { NAME ( NAME ) } ). \" ) return None # End of if/elif/else except NAME . NAME . NAME as NAME : NAME . NAME ( f\" RequestException fetching profile details for { NAME } : { NAME } \" , NAME = False , ) return None # End of try/except except NAME as NAME : NAME . NAME ( f\" Unexpected error fetching profile details for { NAME } : { NAME } \" , NAME = True , ) return None"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "call_header_trees_api_for_tree_id",
      "lineno": 2210,
      "end_lineno": 2324,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 21,
      "loc": 115,
      "tags": [
        "impure",
        "network",
        "time",
        "regex",
        "json",
        "size:large"
      ],
      "signature": "(session_manager, tree_name_config)",
      "fingerprint": "6c627d6fc967a6302a69a8f678170b64ee77f869",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME ) -> NAME [ NAME ] : if not NAME : NAME . NAME ( LIT ) return None # End of if if not NAME . NAME ( ) : NAME . NAME ( LIT ) return None # End of if if not NAME ( NAME ) : NAME . NAME ( LIT ) raise NAME ( LIT ) # End of if NAME = NAME . NAME . NAME or LIT NAME = NAME ( NAME . NAME ( LIT ) + LIT , NAME ) NAME = LIT # Apply rate limiting if available if NAME and NAME : if not NAME . NAME ( ) : NAME = NAME . NAME ( ) NAME . NAME ( f\" Rate limit reached for { NAME } . Waiting { NAME : .1f } s \" ) import NAME NAME . NAME ( NAME ) NAME . NAME ( ) NAME = NAME ( NAME . NAME ( LIT ) + LIT , LIT ) NAME . NAME ( f\" Attempting to fetch tree ID for TREE_NAME=' { NAME } ' via { NAME } ( { NAME } ). Referer: { NAME } \" ) NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } try : NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = NAME , NAME = False , NAME = NAME , NAME = NAME , ) if ( NAME and NAME ( NAME , NAME ) and NAME in NAME and NAME ( NAME [ NAME ] , NAME ) ) : # Validate response with Pydantic if available if NAME : try : NAME ( ** NAME ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Header Trees API response validation warning: { NAME } \" ) for NAME in NAME [ NAME ] : if NAME ( NAME , NAME ) and NAME . NAME ( NAME ) == NAME : NAME = NAME . NAME ( NAME ) if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME = NAME . NAME ( LIT ) NAME . NAME ( f\" Found tree ID ' { NAME } ' for tree ' { NAME } '. \" ) return NAME NAME . NAME ( f\" Found tree ' { NAME } ', but URL format unexpected: { NAME } \" ) # End of if/else else : NAME . NAME ( f\" Found tree ' { NAME } ', but ' { NAME } ' key missing or invalid. \" ) # End of if/else break # End of if # End of for NAME . NAME ( f\" Could not find TREE_NAME ' { NAME } ' in { NAME } response. \" ) return None if NAME is None : NAME . NAME ( f\" { NAME } call failed (_api_req returned None). \" ) return None NAME = LIT if NAME ( NAME , NAME . NAME ) : NAME = NAME ( NAME . NAME ) # End of if NAME . NAME ( f\" Unexpected response format from { NAME } (Type: { NAME ( NAME ) } , Status: { NAME } ). \" ) NAME . NAME ( f\" Full { NAME } response data: { NAME ! NAME } \" ) return None # End of if/elif/else except NAME as NAME : NAME . NAME ( f\" Error during { NAME } : { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "call_tree_owner_api",
      "lineno": 2331,
      "end_lineno": 2432,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 8,
      "yield_count": 0,
      "complexity": 20,
      "loc": 102,
      "tags": [
        "impure",
        "network",
        "time",
        "size:large"
      ],
      "signature": "(session_manager, tree_id)",
      "fingerprint": "710dcaf7d5c38db242e78f9cedc46fed421c6163",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME ) -> NAME [ NAME ] : if not NAME : NAME . NAME ( LIT ) return None # End of if if not NAME ( NAME , NAME ) : NAME . NAME ( f\" Invalid tree_id type provided: { NAME ( NAME ) } . Expected string. \" ) return None # End of if if not NAME . NAME ( ) : NAME . NAME ( LIT ) return None # End of if if not NAME ( NAME ) : NAME . NAME ( LIT ) raise NAME ( LIT ) # End of if NAME = NAME . NAME . NAME or LIT NAME = NAME ( NAME . NAME ( LIT ) + LIT , f\" { NAME } ?tree_id= { NAME } \" ) NAME = LIT # Apply rate limiting if available if NAME and NAME : if not NAME . NAME ( ) : NAME = NAME . NAME ( ) NAME . NAME ( f\" Rate limit reached for { NAME } . Waiting { NAME : .1f } s \" ) import NAME NAME . NAME ( NAME ) NAME . NAME ( ) NAME . NAME ( f\" Attempting to fetch tree owner name for tree ID: { NAME } via { NAME } ... \" ) try : NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = False , NAME = NAME , ) if NAME and NAME ( NAME , NAME ) : # Validate response with Pydantic if available if NAME : try : NAME . NAME ( NAME ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Tree Owner API response validation warning: { NAME } \" ) NAME = NAME . NAME ( NAME ) if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( NAME ) if NAME and NAME ( NAME , NAME ) : NAME . NAME ( f\" Found tree owner ' { NAME } ' for tree ID { NAME } . \" ) return NAME NAME . NAME ( f\" Could not find ' { NAME } ' in owner data for tree { NAME } . \" ) # End of if/else else : NAME . NAME ( f\" Could not find ' { NAME } ' data in { NAME } response for tree { NAME } . \" ) # End of if/else NAME . NAME ( f\" Full { NAME } response data: { NAME } \" ) return None if NAME is None : NAME . NAME ( f\" { NAME } call failed (_api_req returned None). \" ) return None NAME = LIT if NAME ( NAME , NAME . NAME ) : NAME = NAME ( NAME . NAME ) # End of if NAME . NAME ( f\" { NAME } call returned unexpected data (Type: { NAME ( NAME ) } , Status: { NAME } ) or None. \" ) NAME . NAME ( f\" Response received: { NAME ! NAME } \" ) return None # End of if/elif/else except NAME as NAME : NAME . NAME ( f\" Error during { NAME } for tree { NAME } : { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "_sc_run_test",
      "lineno": 2440,
      "end_lineno": 2560,
      "is_method": false,
      "is_async": false,
      "args_count": 6,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 28,
      "loc": 121,
      "tags": [
        "pure-ish",
        "logging",
        "size:large"
      ],
      "signature": "(test_name, test_func, test_results_list, logger_instance, *args, **kwargs)",
      "fingerprint": "ce8441b684173cb01460a44a922580266f02d2bc",
      "simhash64": 7488180022981071891,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME , NAME ] ] , NAME : NAME . NAME , * NAME , ** NAME , ) -> NAME [ NAME , NAME , NAME ] : NAME . NAME ( f\" [ RUNNING SC ] { NAME } \" ) NAME = LIT NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , False ) NAME = NAME . NAME ( LIT , None ) NAME = NAME . NAME ( LIT , None ) NAME = NAME . NAME ( LIT , None ) NAME = NAME . NAME ( LIT , False ) NAME = NAME try : NAME = NAME ( * NAME , ** NAME ) NAME = False NAME = False if NAME : NAME = NAME is None if not NAME : NAME = f\" Expected None, got { NAME ( NAME ) . NAME } \" # End of if elif NAME is not None : if NAME is None : NAME = False NAME = f\" Expected type { NAME . NAME } , but function returned None (API/Parse issue?) \" if not NAME ( NAME , NAME ) or NAME != LIT : # type: ignore NAME . NAME ( f\" Test ' { NAME } ': { NAME } \" ) # End of if elif NAME ( NAME , NAME ) : NAME = True else : NAME = False NAME = ( f\" Expected type { NAME . NAME } , got { NAME ( NAME ) . NAME } \" ) # End of if/elif/else elif NAME is not None : NAME = NAME == NAME if not NAME : NAME = f\" Expected value ' { NAME ( NAME ) [ : LIT ] } ...', got ' { NAME ( NAME ) [ : LIT ] } ...' \" # End of if elif NAME is not None : if NAME ( NAME , NAME ) : if NAME ( NAME , ( NAME , NAME ) ) : NAME = [ NAME for NAME in NAME if NAME not in NAME ] NAME = not NAME if not NAME : NAME = f\" Expected result to contain all of: { NAME } . Missing: { NAME } \" # End of if elif NAME ( NAME , NAME ) : NAME = NAME in NAME if not NAME : NAME = f\" Expected result to contain ' { NAME } ', got ' { NAME ( NAME ) [ : LIT ] } ...' \" # End of if else : NAME = False NAME = ( f\" Invalid type for expect_contains: { NAME ( NAME ) } \" ) # End of if/elif/else else : NAME = False NAME = f\" Expected string result for contains check, got { NAME ( NAME ) . NAME } \" # End of if/else elif NAME : NAME = NAME ( NAME ) if not NAME : if NAME is None : NAME = LIT else : NAME = f\" Expected truthy value, got { NAME ( NAME ) [ : LIT ] } \" # End of if/else # End of if elif NAME ( NAME , NAME ) and NAME == LIT : # Don't skip tests, treat them as failures NAME = False NAME = False NAME = LIT NAME = NAME or LIT else : NAME = NAME is True if not NAME : NAME = ( f\" Default check failed: Expected True, got { NAME ( NAME ) [ : LIT ] } \" ) # End of if # End of if/elif chain if not NAME : NAME = LIT if NAME else LIT if NAME == LIT and not NAME : NAME = f\" Test condition not met (Result: { NAME ( NAME ) [ : LIT ] } ) \" # End of if # End of if except NAME as NAME : NAME = LIT NAME = f\" EXCEPTION: { NAME ( NAME ) . NAME } : { NAME } \" NAME . NAME ( f\" Exception during self-check test ' { NAME } ': { NAME } \\n { NAME . NAME ( ) } \" , NAME = False , ) # End of try/except NAME = ( NAME . NAME if NAME == LIT else ( NAME . NAME if NAME == LIT else NAME . NAME ) ) NAME = f\" [ { NAME : <7 } SC ] { NAME } { f' : { NAME } ' if NAME else LIT } \" NAME . NAME ( NAME , NAME ) NAME . NAME ( ( NAME , NAME , NAME if NAME != LIT else LIT ) ) return ( NAME , NAME , NAME )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "_sc_print_summary",
      "lineno": 2566,
      "end_lineno": 2623,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 9,
      "loc": 58,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(test_results_list, overall_status, logger_instance)",
      "fingerprint": "d434e3f8dba08fef398c85696f24e7a508e9ff3d",
      "simhash64": 7452291964523157051,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME , NAME ] ] , NAME : NAME , NAME : NAME . NAME , ) : NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME = LIT if NAME : try : NAME = NAME ( NAME ( NAME ) for NAME , NAME , NAME in NAME ) + LIT NAME = NAME ( NAME , LIT ) except NAME : pass NAME = LIT NAME = f\" { LIT : < { NAME } } | { LIT : < { NAME } } | { LIT } \" NAME ( NAME ) NAME ( LIT * ( NAME ( NAME ) + LIT ) ) NAME = LIT NAME = LIT NAME = LIT for NAME , NAME , NAME in NAME : # Add emoji indicators for consistency with test framework NAME = LIT if NAME == LIT else LIT if NAME == LIT else LIT NAME = f\" { NAME } { NAME } \" NAME ( f\" { NAME : < { NAME } } | { NAME : < { NAME + LIT } } | { NAME if NAME != LIT else LIT } \" ) if NAME == LIT : NAME += LIT elif NAME == LIT : NAME += LIT elif NAME == LIT : NAME += LIT NAME = NAME ( NAME ) NAME ( LIT * ( NAME ( NAME ) + LIT ) ) NAME = NAME == LIT NAME = NAME and NAME # Use consistent color scheme NAME = LIT if NAME else LIT NAME = ( f\" { NAME } Result: { LIT if NAME else LIT } \" f\" ( { NAME } passed, { NAME } failed, { NAME } skipped out of { NAME } executed tests) \" ) NAME ( f\" { NAME } \\n \" ) NAME . NAME ( NAME . NAME if NAME else NAME . NAME , f\" api_utils self-check overall status: { LIT if NAME else LIT } \" , )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "async_call_suggest_api",
      "lineno": 2631,
      "end_lineno": 2702,
      "is_method": false,
      "is_async": true,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 11,
      "loc": 72,
      "tags": [
        "async",
        "pure-ish",
        "size:medium"
      ],
      "signature": "(session_manager, owner_tree_id, owner_profile_id, base_url, search_criteria, timeout)",
      "fingerprint": "f94d3f7dec489fe4d3a91bae92c6519935e916e2",
      "simhash64": 7488180022980031507,
      "normalized": "async def NAME ( NAME : LIT , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME [ NAME ] ] : LIT from NAME import NAME # Build request URL and data (same logic as sync version) NAME = NAME ( NAME , LIT ) # Prepare request data NAME = { LIT : NAME , ** NAME } try : NAME . NAME ( f\" Async Suggest API call for tree { NAME } \" ) NAME = await NAME ( NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , NAME = NAME or LIT , NAME = LIT ) if not NAME : NAME . NAME ( LIT ) return None # Parse response into PersonSuggestResponse objects NAME = [ ] if NAME ( NAME , NAME ) : for NAME in NAME : if NAME ( NAME , NAME ) : NAME . NAME ( NAME . NAME ( NAME ) ) elif NAME ( NAME , NAME ) and LIT in NAME : for NAME in NAME [ LIT ] : if NAME ( NAME , NAME ) : NAME . NAME ( NAME . NAME ( NAME ) ) NAME . NAME ( f\" Async Suggest API returned { NAME ( NAME ) } suggestions \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Async Suggest API error: { NAME } \" ) return None"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "async_batch_person_lookup",
      "lineno": 2705,
      "end_lineno": 2772,
      "is_method": false,
      "is_async": true,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 68,
      "tags": [
        "async",
        "impure",
        "network",
        "logging",
        "size:medium"
      ],
      "signature": "(session_manager, person_ids, tree_id, base_url, max_concurrent, progress_callback)",
      "fingerprint": "8f4a400db826342c56f9a2904866ea20e21c9ca6",
      "simhash64": 7488109654236894227,
      "normalized": "async def NAME ( NAME : LIT , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME , NAME : NAME = LIT , NAME : NAME [ NAME [ [ NAME , NAME ] , None ] ] = None ) -> NAME [ NAME , NAME [ NAME ] ] : LIT from NAME import NAME # Prepare batch requests NAME = [ ] for NAME in NAME : NAME = NAME ( NAME , f\" trees/ { NAME } /persons/ { NAME } /facts \" ) NAME . NAME ( { LIT : NAME , LIT : LIT , LIT : f\" Facts for { NAME } \" } ) NAME . NAME ( f\" Starting async batch person lookup for { NAME ( NAME ) } persons \" ) # Execute batch requests NAME = await NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) # Parse results into PersonFactsResponse objects NAME = { } for NAME , ( NAME , NAME ) in NAME ( NAME ( NAME , NAME ) ) : if NAME : try : NAME [ NAME ] = NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Failed to parse facts for { NAME } : { NAME } \" ) NAME [ NAME ] = None else : NAME [ NAME ] = None NAME = NAME ( LIT for NAME in NAME . NAME ( ) if NAME is not None ) NAME . NAME ( f\" Async batch person lookup completed: { NAME } / { NAME ( NAME ) } successful \" ) return NAME"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "call_enhanced_api",
      "lineno": 2775,
      "end_lineno": 2861,
      "is_method": false,
      "is_async": false,
      "args_count": 9,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 7,
      "loc": 87,
      "tags": [
        "pure-ish",
        "logging",
        "size:medium"
      ],
      "signature": "(session_manager, endpoint, user_id, tree_id, person_id, method, data, api_description, use_csrf_token)",
      "fingerprint": "66ed92948df58427a1791404277926513022e4e8",
      "simhash64": 7488109654236902427,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME = LIT , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME = LIT , NAME : NAME = True ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME or not NAME . NAME ( ) : NAME . NAME ( f\" Invalid session manager for { NAME } \" ) return None try : # Import _api_req from utils from NAME import NAME # Construct full URL NAME = NAME . NAME . NAME . NAME ( LIT ) # Format endpoint with provided IDs NAME = NAME . NAME ( NAME = NAME , NAME = NAME , NAME = NAME ) NAME = f\" { NAME } { NAME } \" NAME = f\" { NAME } /family-tree/person/tree/ { NAME } /person/ { NAME } /facts \" NAME . NAME ( f\" Calling enhanced API: { NAME } \" ) # Sync cookies to ensure authentication state try : if NAME ( NAME , LIT ) : NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" Cookie sync failed: { NAME } \" ) # Use enhanced _api_req with special parameters for enhanced headers NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , # Pass additional parameters for enhanced headers NAME = { LIT : LIT , LIT : NAME , LIT : NAME } ) if NAME : NAME . NAME ( f\" { NAME } successful \" ) return NAME NAME . NAME ( f\" { NAME } returned no data \" ) return None except NAME as NAME : NAME . NAME ( f\" Error calling { NAME } : { NAME } \" ) return None"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "call_edit_relationships_api",
      "lineno": 2864,
      "end_lineno": 2891,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 28,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "(session_manager, user_id, tree_id, person_id)",
      "fingerprint": "61bf2f58bb5f4a503522b417dd0c2ababc318ddc",
      "simhash64": 7452221595778987027,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = LIT return NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , NAME = False # Disable CSRF token for cleaner logging )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "call_relationship_ladder_api",
      "lineno": 2894,
      "end_lineno": 2924,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 31,
      "tags": [
        "pure-ish",
        "logging",
        "size:medium"
      ],
      "signature": "(session_manager, user_id, tree_id, person_id)",
      "fingerprint": "61bf2f58bb5f4a503522b417dd0c2ababc318ddc",
      "simhash64": 7452221595778987027,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = LIT return NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = LIT , NAME = False # Disable CSRF token for cleaner logging )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "get_relationship_path_data",
      "lineno": 2927,
      "end_lineno": 2981,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 8,
      "loc": 55,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(session_manager, person_id, reference_person_id)",
      "fingerprint": "b36044add350af4eeffa283dcfaa6b0311a31689",
      "simhash64": 7488109654236894227,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME , NAME : NAME [ NAME ] = None ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : # Get user and tree IDs from SessionManager NAME = NAME . NAME or NAME . NAME NAME = NAME . NAME if not NAME or not NAME : NAME . NAME ( f\" Missing user_id ( { NAME } ) or tree_id ( { NAME } ) for relationship path data \" ) return None # Call the enhanced relationship ladder API NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) if NAME and NAME ( NAME , NAME ) : # Extract kinshipPersons data if available NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME . NAME ( f\" Found { NAME ( NAME ) } kinship relationships for person { NAME } \" ) return { LIT : NAME , LIT : NAME . NAME ( LIT ) , LIT : NAME , LIT : NAME } NAME . NAME ( f\" No kinship persons found in relationship data for { NAME } \" ) return None NAME . NAME ( f\" Invalid or empty relationship data for person { NAME } \" ) return None except NAME as NAME : NAME . NAME ( f\" Error getting relationship path data for { NAME } : { NAME } \" ) return None"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "api_utils_module_tests",
      "lineno": 2984,
      "end_lineno": 3443,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 34,
      "loc": 460,
      "tags": [
        "impure",
        "network",
        "logging",
        "time",
        "regex",
        "json",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "d4380b4aee004eca52732c9085273ce11ba72735",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME with NAME ( ) : NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # === INITIALIZATION TESTS === def NAME ( ) : LIT NAME = [ ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME in NAME : # Check if module is imported or available NAME = ( NAME in NAME . NAME or NAME in NAME ( ) or NAME ( NAME in NAME ( NAME ) for NAME in NAME ( ) . NAME ( ) if NAME ( NAME , LIT ) ) ) # Additional check for datetime and urllib.parse if not NAME and LIT in NAME : try : NAME ( NAME ) NAME = True NAME = LIT except NAME : NAME = LIT else : NAME = LIT NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } : { NAME } \" ) NAME ( f\" Method: { NAME } , Available: { NAME } \" ) NAME . NAME ( NAME ) assert NAME , f\" Required module { NAME } not available \" NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } required modules imported \" ) def NAME ( ) : LIT # Test pydantic availability detection assert NAME is not None , LIT assert NAME ( NAME , NAME ) , LIT # Test BeautifulSoup availability detection assert NAME is not None , LIT assert NAME ( NAME , NAME ) , LIT def NAME ( ) : LIT assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT # === CORE FUNCTIONALITY TESTS === def NAME ( ) : LIT NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : False , } assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT def NAME ( ) : LIT NAME = LIT try : NAME = NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT except NAME . NAME : raise NAME ( LIT ) def NAME ( ) : LIT from NAME . NAME import NAME , NAME NAME = LIT NAME = NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT NAME = { LIT : LIT , LIT : LIT } NAME = NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT # === EDGE CASE TESTS === def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT , ] for NAME in NAME : try : NAME . NAME ( NAME ) except ( NAME . NAME , NAME ) : pass # Expected behavior for invalid JSON def NAME ( ) : LIT NAME = [ { } , { LIT : LIT } , { LIT : None } , { LIT : [ ] } , { LIT : { } } , ] for NAME in NAME : assert NAME ( NAME , NAME ) , LIT def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , # Chinese characters LIT , # Arabic characters LIT , LIT , ] for NAME in NAME : assert NAME ( NAME , NAME ) , LIT NAME = NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT # === INTEGRATION TESTS === def NAME ( ) : LIT try : from NAME import NAME assert NAME is not None , LIT except NAME : pass # Config integration may not be available in test environment def NAME ( ) : LIT from NAME import NAME assert NAME ( NAME ) , LIT assert NAME is not None , LIT try : NAME . NAME ( LIT ) except NAME as NAME : raise NAME ( f\" Logging should work without errors: { NAME } \" ) def NAME ( ) : LIT from NAME import NAME , NAME NAME = NAME . NAME ( NAME . NAME ) assert NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT # === PERFORMANCE TESTS === def NAME ( ) : LIT NAME = { LIT : [ { LIT : NAME , LIT : f\" Person { NAME } \" } for NAME in NAME ( LIT ) ] } NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( ) NAME = NAME - NAME assert ( NAME < LIT ) , f\" JSON parsing took { NAME : .3f } s, should be < 1.0s \" assert NAME ( NAME , NAME ) , LIT def NAME ( ) : LIT NAME = [ f\" Person Name { NAME } & Family \" for NAME in NAME ( LIT ) ] NAME = NAME . NAME ( ) for NAME in NAME : NAME ( NAME ) NAME = NAME . NAME ( ) NAME = NAME - NAME assert ( NAME < LIT ) , f\" URL encoding took { NAME : .3f } s, should be < 0.1s \" def NAME ( ) : LIT NAME = [ { LIT : f\" Person { NAME } \" , LIT : LIT + NAME % LIT , LIT : f\" City { NAME % LIT } \" , } for NAME in NAME ( LIT ) ] NAME = NAME . NAME ( ) NAME = LIT for NAME in NAME : if NAME . NAME ( LIT , LIT ) > LIT : NAME += LIT NAME = NAME . NAME ( ) NAME = NAME - NAME assert ( NAME < LIT ) , f\" Data processing took { NAME : .3f } s, should be < 0.05s \" assert NAME > LIT , LIT # === ERROR HANDLING TESTS === def NAME ( ) : LIT NAME = [ NAME . NAME . NAME ( LIT ) , NAME . NAME . NAME ( LIT ) , NAME . NAME . NAME ( LIT ) , ] for NAME in NAME : assert NAME ( NAME , NAME . NAME . NAME ) , LIT def NAME ( ) : LIT NAME = [ { LIT : None } , # Missing required field { LIT : LIT } , # Empty required field { LIT : LIT } , # Wrong type { LIT : LIT , LIT : LIT } , # Invalid year ] for NAME in NAME : assert NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( LIT ) if NAME is None or NAME == LIT : assert ( NAME is None or NAME == LIT ) , LIT elif NAME ( NAME , NAME ) : assert NAME ( NAME , NAME ) , LIT def NAME ( ) : LIT NAME = [ None , { } , { LIT : LIT } , ] for NAME in NAME : if NAME is None : assert NAME is None , LIT elif NAME ( NAME , NAME ) and ( not NAME or LIT not in NAME ) : assert ( NAME ( NAME ) == LIT or LIT not in NAME ) , LIT # === RUN ALL TESTS === NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_module_imports",
      "lineno": 2998,
      "end_lineno": 3045,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 48,
      "tags": [
        "impure",
        "network",
        "logging",
        "time",
        "regex",
        "json",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "dd10d24473560f5dbffd0adb7facf9a516e784df",
      "simhash64": 7469743413080266283,
      "normalized": "def NAME ( ) : LIT NAME = [ ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME in NAME : # Check if module is imported or available NAME = ( NAME in NAME . NAME or NAME in NAME ( ) or NAME ( NAME in NAME ( NAME ) for NAME in NAME ( ) . NAME ( ) if NAME ( NAME , LIT ) ) ) # Additional check for datetime and urllib.parse if not NAME and LIT in NAME : try : NAME ( NAME ) NAME = True NAME = LIT except NAME : NAME = LIT else : NAME = LIT NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } : { NAME } \" ) NAME ( f\" Method: { NAME } , Available: { NAME } \" ) NAME . NAME ( NAME ) assert NAME , f\" Required module { NAME } not available \" NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } required modules imported \" )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_optional_dependencies",
      "lineno": 3047,
      "end_lineno": 3057,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "daf0da2ce2cc832706766f2c9a4dae011e369aca",
      "simhash64": 5146449058658685991,
      "normalized": "def NAME ( ) : LIT # Test pydantic availability detection assert NAME is not None , LIT assert NAME ( NAME , NAME ) , LIT # Test BeautifulSoup availability detection assert NAME is not None , LIT assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_logger_initialization",
      "lineno": 3059,
      "end_lineno": 3064,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "e18585f4a91f0e15ba31c2124b93a8508bfb93bc",
      "simhash64": 5145885970992108587,
      "normalized": "def NAME ( ) : LIT assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_person_detail_parsing",
      "lineno": 3067,
      "end_lineno": 3085,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "dfa8dd3d66d7b0c1d57d153aec4c421c7e05f2e6",
      "simhash64": 5726842660759967275,
      "normalized": "def NAME ( ) : LIT NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : False , } assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_api_response_parsing",
      "lineno": 3087,
      "end_lineno": 3095,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "json",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "3e45685a19d98baf150f801473056de6260ea337",
      "simhash64": 7487757811588699179,
      "normalized": "def NAME ( ) : LIT NAME = LIT try : NAME = NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT except NAME . NAME : raise NAME ( LIT )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_url_construction",
      "lineno": 3097,
      "end_lineno": 3109,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "impure",
        "network",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "45137e03430629fa632e16fd5d07582cb39087fd",
      "simhash64": 7452291964523156539,
      "normalized": "def NAME ( ) : LIT from NAME . NAME import NAME , NAME NAME = LIT NAME = NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT NAME = { LIT : LIT , LIT : LIT } NAME = NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_invalid_json_handling",
      "lineno": 3112,
      "end_lineno": 3125,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "json",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b5d96d6982bb0171bf6639be119d06b96943fa6d",
      "simhash64": 7451728980278154287,
      "normalized": "def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT , ] for NAME in NAME : try : NAME . NAME ( NAME ) except ( NAME . NAME , NAME ) : pass # Expected behavior for invalid JSON"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_empty_data_handling",
      "lineno": 3127,
      "end_lineno": 3138,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b6da61a9504af8f7f6616eebe95c22187057d361",
      "simhash64": 2823154461025145391,
      "normalized": "def NAME ( ) : LIT NAME = [ { } , { LIT : LIT } , { LIT : None } , { LIT : [ ] } , { LIT : { } } , ] for NAME in NAME : assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_special_characters",
      "lineno": 3140,
      "end_lineno": 3154,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "e85a67c5409c4071c3bb76465a6001c453b7d8b9",
      "simhash64": 5145885970992108591,
      "normalized": "def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , # Chinese characters LIT , # Arabic characters LIT , LIT , ] for NAME in NAME : assert NAME ( NAME , NAME ) , LIT NAME = NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_config_integration",
      "lineno": 3157,
      "end_lineno": 3164,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "2b6af1ff1f063c6da38e893b5154fdc9df92286d",
      "simhash64": 9223333565144929907,
      "normalized": "def NAME ( ) : LIT try : from NAME import NAME assert NAME is not None , LIT except NAME : pass # Config integration may not be available in test environment"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_logging_integration",
      "lineno": 3166,
      "end_lineno": 3176,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "logging",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5c14fb45b5e79d29092a6b56cbd05d3cc9846f5f",
      "simhash64": 8641242230715487291,
      "normalized": "def NAME ( ) : LIT from NAME import NAME assert NAME ( NAME ) , LIT assert NAME is not None , LIT try : NAME . NAME ( LIT ) except NAME as NAME : raise NAME ( f\" Logging should work without errors: { NAME } \" )"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_datetime_handling",
      "lineno": 3178,
      "end_lineno": 3187,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "394e800a1dbf43bb4484f5d638acbe0d2c7a62b1",
      "simhash64": 7488180022980027451,
      "normalized": "def NAME ( ) : LIT from NAME import NAME , NAME NAME = NAME . NAME ( NAME . NAME ) assert NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_json_parsing_performance",
      "lineno": 3190,
      "end_lineno": 3205,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "time",
        "json",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "32b2de2316298745693aa56bf0b2556a519ff31e",
      "simhash64": 7488180024054813755,
      "normalized": "def NAME ( ) : LIT NAME = { LIT : [ { LIT : NAME , LIT : f\" Person { NAME } \" } for NAME in NAME ( LIT ) ] } NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( ) NAME = NAME - NAME assert ( NAME < LIT ) , f\" JSON parsing took { NAME : .3f } s, should be < 1.0s \" assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_url_encoding_performance",
      "lineno": 3207,
      "end_lineno": 3220,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3fe398a50f879067bdc52a58fca696b39df12eb4",
      "simhash64": 7488180022981071931,
      "normalized": "def NAME ( ) : LIT NAME = [ f\" Person Name { NAME } & Family \" for NAME in NAME ( LIT ) ] NAME = NAME . NAME ( ) for NAME in NAME : NAME ( NAME ) NAME = NAME . NAME ( ) NAME = NAME - NAME assert ( NAME < LIT ) , f\" URL encoding took { NAME : .3f } s, should be < 0.1s \""
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_data_processing_efficiency",
      "lineno": 3222,
      "end_lineno": 3245,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 24,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3b53d5d37657f6c6b8d1151f5f8d645e740357a0",
      "simhash64": 7451729014561347131,
      "normalized": "def NAME ( ) : LIT NAME = [ { LIT : f\" Person { NAME } \" , LIT : LIT + NAME % LIT , LIT : f\" City { NAME % LIT } \" , } for NAME in NAME ( LIT ) ] NAME = NAME . NAME ( ) NAME = LIT for NAME in NAME : if NAME . NAME ( LIT , LIT ) > LIT : NAME += LIT NAME = NAME . NAME ( ) NAME = NAME - NAME assert ( NAME < LIT ) , f\" Data processing took { NAME : .3f } s, should be < 0.05s \" assert NAME > LIT , LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_network_error_simulation",
      "lineno": 3248,
      "end_lineno": 3259,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "impure",
        "network",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "8b22490975042299a890de510e8b94d37c1afd2c",
      "simhash64": 7487617073026610179,
      "normalized": "def NAME ( ) : LIT NAME = [ NAME . NAME . NAME ( LIT ) , NAME . NAME . NAME ( LIT ) , NAME . NAME . NAME ( LIT ) , ] for NAME in NAME : assert NAME ( NAME , NAME . NAME . NAME ) , LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_data_validation_errors",
      "lineno": 3261,
      "end_lineno": 3280,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "84f3d8e308d2ea1fea95d383dbdf638c9b4b4890",
      "simhash64": 7452854914536347179,
      "normalized": "def NAME ( ) : LIT NAME = [ { LIT : None } , # Missing required field { LIT : LIT } , # Empty required field { LIT : LIT } , # Wrong type { LIT : LIT , LIT : LIT } , # Invalid year ] for NAME in NAME : assert NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( LIT ) if NAME is None or NAME == LIT : assert ( NAME is None or NAME == LIT ) , LIT elif NAME ( NAME , NAME ) : assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "test_configuration_errors",
      "lineno": 3282,
      "end_lineno": 3296,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "8a2362c62cfd6a07effcd8d37a1c6912d407623e",
      "simhash64": 7488883711496590891,
      "normalized": "def NAME ( ) : LIT NAME = [ None , { } , { LIT : LIT } , ] for NAME in NAME : if NAME is None : assert NAME is None , LIT elif NAME ( NAME , NAME ) and ( not NAME or LIT not in NAME ) : assert ( NAME ( NAME ) == LIT or LIT not in NAME ) , LIT"
    },
    {
      "module_path": "api_utils.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 3446,
      "end_lineno": 3448,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "cache.py",
      "qualname": "CacheInterface.get_stats",
      "lineno": 105,
      "end_lineno": 107,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "4c3b523a3a94b03ba80c3a3006d80eff7c87a181",
      "simhash64": 5182337014840071267,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT raise NAME ( LIT )"
    },
    {
      "module_path": "cache.py",
      "qualname": "CacheInterface.clear",
      "lineno": 109,
      "end_lineno": 111,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "befe54632524b6bcafe4938f44cfdf7ad448515b",
      "simhash64": 7487784199867766379,
      "normalized": "def NAME ( NAME ) -> NAME : LIT raise NAME ( LIT )"
    },
    {
      "module_path": "cache.py",
      "qualname": "CacheInterface.warm",
      "lineno": 113,
      "end_lineno": 115,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "befe54632524b6bcafe4938f44cfdf7ad448515b",
      "simhash64": 7487784199867766379,
      "normalized": "def NAME ( NAME ) -> NAME : LIT raise NAME ( LIT )"
    },
    {
      "module_path": "cache.py",
      "qualname": "CacheInterface.get_module_name",
      "lineno": 117,
      "end_lineno": 119,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "befe54632524b6bcafe4938f44cfdf7ad448515b",
      "simhash64": 7487784199867766379,
      "normalized": "def NAME ( NAME ) -> NAME : LIT raise NAME ( LIT )"
    },
    {
      "module_path": "cache.py",
      "qualname": "CacheInterface.get_health_status",
      "lineno": 121,
      "end_lineno": 123,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "4c3b523a3a94b03ba80c3a3006d80eff7c87a181",
      "simhash64": 5182337014840071267,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT raise NAME ( LIT )"
    },
    {
      "module_path": "cache.py",
      "qualname": "BaseCacheModule.get_stats",
      "lineno": 131,
      "end_lineno": 133,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "ac443059340c0b30e36e883cf2e60967d9848beb",
      "simhash64": 7488180024054297699,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return NAME ( )"
    },
    {
      "module_path": "cache.py",
      "qualname": "BaseCacheModule.clear",
      "lineno": 135,
      "end_lineno": 137,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "878a676e24ed16e25ea0228c32e65c1cf9dbd4db",
      "simhash64": 7487784165508547619,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "cache.py",
      "qualname": "BaseCacheModule.warm",
      "lineno": 139,
      "end_lineno": 158,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 20,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "579a61d3436a6e7eafef74cbded7a53c005a2130",
      "simhash64": 7451764198941824555,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : # Traditional warming NAME ( LIT , { LIT : LIT , LIT : NAME . NAME ( ) } ) NAME ( LIT , { LIT : LIT , LIT : LIT } ) # === PHASE 12.4.1: INTELLIGENT CACHE WARMING === NAME = NAME ( ) NAME = NAME . NAME ( ) NAME . NAME ( f\" Base cache warming completed: { NAME } predictive entries warmed \" ) return True except NAME as NAME : NAME . NAME ( f\" Error warming base cache: { NAME } \" ) return False"
    },
    {
      "module_path": "cache.py",
      "qualname": "BaseCacheModule.get_module_name",
      "lineno": 160,
      "end_lineno": 162,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5bd6089ca6ab0b7a1cc5914ffd95afac8325cade",
      "simhash64": 5186409605900964899,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return LIT"
    },
    {
      "module_path": "cache.py",
      "qualname": "BaseCacheModule.get_health_status",
      "lineno": 164,
      "end_lineno": 206,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 43,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "8befecea954b395444eeb0af562ef5aeb4388bf2",
      "simhash64": 7452291964581877291,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT try : NAME = NAME . NAME ( ) NAME = NAME . NAME ( LIT , LIT ) + NAME . NAME ( LIT , LIT ) NAME = ( ( NAME . NAME ( LIT , LIT ) / NAME * LIT ) if NAME > LIT else LIT ) # Determine health based on hit rate and cache availability if NAME is None : NAME = LIT NAME = LIT elif NAME >= LIT : NAME = LIT NAME = f\" High performance: { NAME : .1f } % hit rate \" elif NAME >= LIT : NAME = LIT NAME = f\" Good performance: { NAME : .1f } % hit rate \" elif NAME >= LIT : NAME = LIT NAME = f\" Fair performance: { NAME : .1f } % hit rate \" else : NAME = LIT NAME = f\" Low performance: { NAME : .1f } % hit rate \" return { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME is not None , } except NAME as NAME : return { LIT : LIT , LIT : f\" Health check failed: { NAME } \" , LIT : LIT , LIT : LIT , LIT : False , }"
    },
    {
      "module_path": "cache.py",
      "qualname": "cache_result",
      "lineno": 216,
      "end_lineno": 338,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 9,
      "loc": 123,
      "tags": [
        "pure-ish",
        "time",
        "size:large"
      ],
      "signature": "(cache_key_prefix, expire, ignore_args)",
      "fingerprint": "0d675119240dddff5f15b9945b763239515803a3",
      "simhash64": 7452116041590019091,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] = None , # Time in seconds, overrides Cache default if set NAME : NAME = False , # Use only prefix as key if True ) -> NAME : LIT def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) # Preserves original function metadata (name, docstring) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # Step 1: Check if cache is available if NAME is None : NAME . NAME ( LIT ) return NAME ( * NAME , ** NAME ) # Step 2: Generate the final cache key if NAME : # Use only the prefix if arguments should be ignored NAME = NAME NAME . NAME ( f\" Using ignore_args=True, cache key: ' { NAME } ' \" ) else : # Generate key based on prefix, function name, args, and sorted kwargs # Note: Relies on stable string representation of arguments. # Complex objects might require custom serialization for reliable keys. try : NAME = ( f\" _args { NAME ! NAME } _kwargs { NAME ( NAME . NAME ( ) ) ! NAME } \" ) NAME = ( f\" { NAME } _ { NAME . NAME } { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Error generating cache key for { NAME . NAME } : { NAME } . Bypassing cache. \" ) return NAME ( * NAME , ** NAME ) # logger.debug(f\"Generated cache key: '{final_cache_key}'\") # Can be verbose # Step 3: Attempt to retrieve from cache try : # Use default=ENOVAL to distinguish a cache miss from a stored None value NAME = NAME . NAME ( NAME , NAME = NAME , NAME = True ) # Step 3a: Cache Hit - Return cached value if NAME is not NAME : NAME . NAME ( f\" Cache HIT for key: ' { NAME } ' \" ) # === PHASE 12.4.1: RECORD CACHE ACCESS PATTERNS === NAME ( ) . NAME ( NAME , NAME = True ) return NAME # Step 3b: Cache Miss - Log and proceed to function execution NAME . NAME ( f\" Cache MISS for key: ' { NAME } ' \" ) # === PHASE 12.4.1: RECORD CACHE ACCESS PATTERNS === NAME ( ) . NAME ( NAME , NAME = False ) except NAME as NAME : # Log errors during cache read but treat as cache miss NAME . NAME ( f\" Cache read error for key ' { NAME } ': { NAME } \" , NAME = True ) # Proceed to execute the function below # Step 4: Execute the original function (if cache miss or read error) try : NAME = NAME ( * NAME , ** NAME ) # Step 5: Store the result in the cache, enforcing size limit try : if NAME ( ) : NAME . NAME ( NAME , NAME , NAME = NAME , NAME = True ) NAME = ( f\" with expiry { NAME } s \" if NAME is not None else LIT ) NAME . NAME ( f\" Cached result for key: ' { NAME } ' { NAME } . \" ) else : NAME . NAME ( f\" Cache size limit reached. Skipping cache set for key: ' { NAME } ' \" ) except NAME as NAME : # Log error during cache set, but return the result anyway NAME . NAME ( f\" Failed to cache result for key ' { NAME } ': { NAME } \" , NAME = True , ) # Step 6: Return the live result return NAME except NAME as NAME : # Step 7: Handle errors during function execution NAME . NAME ( f\" Error during execution of function ' { NAME . NAME } ' or caching for key ' { NAME } ': { NAME } \" , NAME = True , ) # Do NOT cache the error or any partial result. # Re-raise the original exception to the caller. raise NAME # End of wrapper return NAME # End of decorator return NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "decorator",
      "lineno": 238,
      "end_lineno": 335,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 9,
      "loc": 98,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(func)",
      "fingerprint": "c19dafa79a58655729e12deb65396827383dc6e7",
      "simhash64": 7452116041590019091,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) # Preserves original function metadata (name, docstring) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # Step 1: Check if cache is available if NAME is None : NAME . NAME ( LIT ) return NAME ( * NAME , ** NAME ) # Step 2: Generate the final cache key if NAME : # Use only the prefix if arguments should be ignored NAME = NAME NAME . NAME ( f\" Using ignore_args=True, cache key: ' { NAME } ' \" ) else : # Generate key based on prefix, function name, args, and sorted kwargs # Note: Relies on stable string representation of arguments. # Complex objects might require custom serialization for reliable keys. try : NAME = ( f\" _args { NAME ! NAME } _kwargs { NAME ( NAME . NAME ( ) ) ! NAME } \" ) NAME = ( f\" { NAME } _ { NAME . NAME } { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Error generating cache key for { NAME . NAME } : { NAME } . Bypassing cache. \" ) return NAME ( * NAME , ** NAME ) # logger.debug(f\"Generated cache key: '{final_cache_key}'\") # Can be verbose # Step 3: Attempt to retrieve from cache try : # Use default=ENOVAL to distinguish a cache miss from a stored None value NAME = NAME . NAME ( NAME , NAME = NAME , NAME = True ) # Step 3a: Cache Hit - Return cached value if NAME is not NAME : NAME . NAME ( f\" Cache HIT for key: ' { NAME } ' \" ) # === PHASE 12.4.1: RECORD CACHE ACCESS PATTERNS === NAME ( ) . NAME ( NAME , NAME = True ) return NAME # Step 3b: Cache Miss - Log and proceed to function execution NAME . NAME ( f\" Cache MISS for key: ' { NAME } ' \" ) # === PHASE 12.4.1: RECORD CACHE ACCESS PATTERNS === NAME ( ) . NAME ( NAME , NAME = False ) except NAME as NAME : # Log errors during cache read but treat as cache miss NAME . NAME ( f\" Cache read error for key ' { NAME } ': { NAME } \" , NAME = True ) # Proceed to execute the function below # Step 4: Execute the original function (if cache miss or read error) try : NAME = NAME ( * NAME , ** NAME ) # Step 5: Store the result in the cache, enforcing size limit try : if NAME ( ) : NAME . NAME ( NAME , NAME , NAME = NAME , NAME = True ) NAME = ( f\" with expiry { NAME } s \" if NAME is not None else LIT ) NAME . NAME ( f\" Cached result for key: ' { NAME } ' { NAME } . \" ) else : NAME . NAME ( f\" Cache size limit reached. Skipping cache set for key: ' { NAME } ' \" ) except NAME as NAME : # Log error during cache set, but return the result anyway NAME . NAME ( f\" Failed to cache result for key ' { NAME } ': { NAME } \" , NAME = True , ) # Step 6: Return the live result return NAME except NAME as NAME : # Step 7: Handle errors during function execution NAME . NAME ( f\" Error during execution of function ' { NAME . NAME } ' or caching for key ' { NAME } ': { NAME } \" , NAME = True , ) # Do NOT cache the error or any partial result. # Re-raise the original exception to the caller. raise NAME # End of wrapper return NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "wrapper",
      "lineno": 240,
      "end_lineno": 332,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 9,
      "loc": 93,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "dd01c4a760ddd6e09d5db37a4a3acbee9f2e4743",
      "simhash64": 7452116041590019091,
      "normalized": "def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # Step 1: Check if cache is available if NAME is None : NAME . NAME ( LIT ) return NAME ( * NAME , ** NAME ) # Step 2: Generate the final cache key if NAME : # Use only the prefix if arguments should be ignored NAME = NAME NAME . NAME ( f\" Using ignore_args=True, cache key: ' { NAME } ' \" ) else : # Generate key based on prefix, function name, args, and sorted kwargs # Note: Relies on stable string representation of arguments. # Complex objects might require custom serialization for reliable keys. try : NAME = ( f\" _args { NAME ! NAME } _kwargs { NAME ( NAME . NAME ( ) ) ! NAME } \" ) NAME = ( f\" { NAME } _ { NAME . NAME } { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Error generating cache key for { NAME . NAME } : { NAME } . Bypassing cache. \" ) return NAME ( * NAME , ** NAME ) # logger.debug(f\"Generated cache key: '{final_cache_key}'\") # Can be verbose # Step 3: Attempt to retrieve from cache try : # Use default=ENOVAL to distinguish a cache miss from a stored None value NAME = NAME . NAME ( NAME , NAME = NAME , NAME = True ) # Step 3a: Cache Hit - Return cached value if NAME is not NAME : NAME . NAME ( f\" Cache HIT for key: ' { NAME } ' \" ) # === PHASE 12.4.1: RECORD CACHE ACCESS PATTERNS === NAME ( ) . NAME ( NAME , NAME = True ) return NAME # Step 3b: Cache Miss - Log and proceed to function execution NAME . NAME ( f\" Cache MISS for key: ' { NAME } ' \" ) # === PHASE 12.4.1: RECORD CACHE ACCESS PATTERNS === NAME ( ) . NAME ( NAME , NAME = False ) except NAME as NAME : # Log errors during cache read but treat as cache miss NAME . NAME ( f\" Cache read error for key ' { NAME } ': { NAME } \" , NAME = True ) # Proceed to execute the function below # Step 4: Execute the original function (if cache miss or read error) try : NAME = NAME ( * NAME , ** NAME ) # Step 5: Store the result in the cache, enforcing size limit try : if NAME ( ) : NAME . NAME ( NAME , NAME , NAME = NAME , NAME = True ) NAME = ( f\" with expiry { NAME } s \" if NAME is not None else LIT ) NAME . NAME ( f\" Cached result for key: ' { NAME } ' { NAME } . \" ) else : NAME . NAME ( f\" Cache size limit reached. Skipping cache set for key: ' { NAME } ' \" ) except NAME as NAME : # Log error during cache set, but return the result anyway NAME . NAME ( f\" Failed to cache result for key ' { NAME } ': { NAME } \" , NAME = True , ) # Step 6: Return the live result return NAME except NAME as NAME : # Step 7: Handle errors during function execution NAME . NAME ( f\" Error during execution of function ' { NAME . NAME } ' or caching for key ' { NAME } ': { NAME } \" , NAME = True , ) # Do NOT cache the error or any partial result. # Re-raise the original exception to the caller. raise NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "clear_cache",
      "lineno": 347,
      "end_lineno": 402,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 7,
      "loc": 56,
      "tags": [
        "impure",
        "filesystem",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "fdd00e55dc9228b53869a9bb5f0ae91b0a89430a",
      "simhash64": 7452116042125841427,
      "normalized": "def NAME ( ) : LIT # Step 1: Try clearing using the diskcache API if available if NAME : try : NAME = NAME . NAME ( ) NAME . NAME ( f\" Cache cleared successfully via API. { NAME } items removed from { NAME } . \" ) return True except NAME as NAME : NAME . NAME ( f\" Failed to clear cache via API: { NAME } . Attempting manual removal... \" , NAME = True , ) # Fall through to manual removal attempt # Step 2: Fallback - Attempt manual directory removal NAME . NAME ( LIT ) if NAME and NAME . NAME ( ) : try : NAME . NAME ( NAME ) NAME . NAME ( f\" Manually removed cache directory: { NAME } \" ) # Recreate the directory immediately after removing it try : NAME . NAME ( NAME = True , NAME = True ) NAME . NAME ( f\" Recreated empty cache directory: { NAME } \" ) return True # Manual removal and recreation successful except NAME as NAME : NAME . NAME ( f\" Failed to recreate cache directory { NAME } after manual removal: { NAME } \" ) return False # Failed to recreate directory except NAME as NAME : NAME . NAME ( f\" Failed to manually remove cache directory { NAME } : { NAME } \" , NAME = True , ) return False # Manual removal failed else : NAME . NAME ( LIT ) return True # Considered success as the directory is gone # Unreachable tail: kept for defensive clarity but return paths above are exhaustive # (Left intentionally; not executed under normal flow) return False"
    },
    {
      "module_path": "cache.py",
      "qualname": "close_cache",
      "lineno": 408,
      "end_lineno": 420,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5550151ac5d066947ca94ad43ce64ce81ae02123",
      "simhash64": 8640573762072646699,
      "normalized": "def NAME ( ) : LIT # Step 1: Check if cache object exists if NAME : # Step 2: Attempt to close the cache try : NAME . NAME ( LIT ) NAME . NAME ( ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error closing DiskCache connection: { NAME } \" , NAME = True ) else : NAME . NAME ( LIT )"
    },
    {
      "module_path": "cache.py",
      "qualname": "get_unified_cache_key",
      "lineno": 429,
      "end_lineno": 462,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 34,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(module, operation, *args, **kwargs)",
      "fingerprint": "f2cc662531b1ee989943e3e9719272e5bd152ed5",
      "simhash64": 7488180022980031547,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , * NAME , ** NAME ) -> NAME : LIT # Create base key components NAME = [ NAME , NAME ] # Add positional arguments for NAME in NAME : if NAME ( NAME , ( NAME , NAME , NAME ) ) or NAME ( NAME , LIT ) : NAME . NAME ( NAME ( NAME ) ) # Add keyword arguments in sorted order for consistency for NAME in NAME ( NAME . NAME ( ) ) : NAME = NAME [ NAME ] if NAME ( NAME , ( NAME , NAME , NAME , NAME ) ) : NAME . NAME ( f\" { NAME } = { NAME } \" ) # Generate hash for long keys to keep them manageable NAME = LIT . NAME ( NAME ) if NAME ( NAME ) > LIT : NAME = NAME . NAME ( NAME . NAME ( ) ) . NAME ( ) [ : LIT ] NAME = f\" { NAME } _ { NAME } _ { NAME } \" return NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "invalidate_related_caches",
      "lineno": 465,
      "end_lineno": 514,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 50,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(pattern, exclude_modules)",
      "fingerprint": "308238b240f7cf3599d4ec897d7bb799079baf62",
      "simhash64": 7452151226028176403,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME [ NAME ] ] = None ) -> NAME [ NAME , NAME ] : LIT NAME = NAME or [ ] NAME = { } # Invalidate base cache if LIT not in NAME : try : NAME = NAME ( NAME ) NAME [ LIT ] = NAME NAME . NAME ( f\" Invalidated { NAME } base cache entries matching pattern: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Error invalidating base cache pattern { NAME } : { NAME } \" ) NAME [ LIT ] = LIT # Invalidate GEDCOM cache if LIT not in NAME : try : from NAME import NAME NAME = NAME ( ) NAME [ LIT ] = NAME NAME . NAME ( f\" Cleared { NAME } GEDCOM memory cache entries \" ) except NAME : NAME . NAME ( LIT ) NAME [ LIT ] = LIT except NAME as NAME : NAME . NAME ( f\" Error invalidating GEDCOM cache: { NAME } \" ) NAME [ LIT ] = LIT # Note: API cache invalidation would be handled by api_cache module # This creates a standardized approach for cross-module coordination NAME = NAME ( NAME . NAME ( ) ) NAME . NAME ( f\" Total cache entries invalidated across modules: { NAME } \" ) return NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "get_cache_coordination_stats",
      "lineno": 517,
      "end_lineno": 611,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 10,
      "loc": 95,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "9c9920cc89bc984398cf7e7ddcbcc425c346a458",
      "simhash64": 5146308217879835707,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : NAME . NAME ( ) , LIT : { } , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } # Collect stats from available modules NAME = LIT NAME = LIT # Base cache stats try : NAME = NAME ( ) NAME [ LIT ] [ LIT ] = NAME NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME += NAME NAME += NAME + NAME NAME [ LIT ] += NAME . NAME ( LIT , LIT ) NAME [ LIT ] += NAME . NAME ( LIT , LIT ) except NAME as NAME : NAME . NAME ( f\" Error getting base cache stats for coordination: { NAME } \" ) NAME [ LIT ] [ LIT ] = { LIT : NAME ( NAME ) } # GEDCOM cache stats try : from NAME import NAME NAME = NAME ( ) NAME [ LIT ] [ LIT ] = NAME # Add to totals if available NAME = NAME . NAME ( LIT , LIT ) NAME [ LIT ] += NAME except NAME : NAME [ LIT ] [ LIT ] = { LIT : LIT } except NAME as NAME : NAME . NAME ( f\" Error getting GEDCOM cache stats for coordination: { NAME } \" ) NAME [ LIT ] [ LIT ] = { LIT : NAME ( NAME ) } # API cache stats try : from NAME import NAME NAME = NAME ( ) NAME [ LIT ] [ LIT ] = NAME # Add to totals if available NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME [ LIT ] += NAME + NAME + NAME except NAME : NAME [ LIT ] [ LIT ] = { LIT : LIT } except NAME as NAME : NAME . NAME ( f\" Error getting API cache stats for coordination: { NAME } \" ) NAME [ LIT ] [ LIT ] = { LIT : NAME ( NAME ) } # Calculate overall metrics if NAME > LIT : NAME [ LIT ] = ( NAME / NAME ) * LIT # Determine cross-module health NAME = NAME ( [ NAME for NAME in NAME [ LIT ] . NAME ( ) if LIT not in NAME and NAME . NAME ( LIT ) != LIT ] ) if NAME >= LIT : NAME [ LIT ] = LIT elif NAME >= LIT : NAME [ LIT ] = LIT elif NAME >= LIT : NAME [ LIT ] = LIT else : NAME [ LIT ] = LIT return NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "enforce_cache_size_limit",
      "lineno": 617,
      "end_lineno": 695,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 11,
      "loc": 79,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "0c6a54f833569d5f3943f408b0a044245006e1bb",
      "simhash64": 7451729014569735227,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT if not NAME or not NAME : return { LIT : LIT , LIT : LIT , LIT : LIT , } try : NAME = NAME ( ) NAME = NAME ( NAME . NAME , LIT , LIT ) if NAME <= NAME : return { LIT : LIT , LIT : NAME , LIT : NAME , LIT : LIT , LIT : ( NAME / NAME * LIT ) if NAME > LIT else LIT , } # Need to remove entries NAME = NAME - NAME NAME = NAME + LIT # Remove excess + 1 for buffer NAME = LIT try : # Manual LRU eviction by iterating through cache and removing oldest entries # diskcache stores entries in LRU order when iterating NAME = [ ] NAME = LIT # Collect keys to remove (oldest first) for NAME , NAME in NAME ( NAME , NAME = LIT ) : NAME . NAME ( NAME ) if NAME >= NAME : break # Remove the collected keys for NAME in NAME : try : NAME . NAME ( NAME ) NAME += LIT NAME . NAME ( f\" Evicted cache key: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Failed to delete cache key { NAME } : { NAME } \" ) NAME . NAME ( f\" Manually evicted { NAME } entries using LRU order \" ) except NAME as NAME : NAME . NAME ( f\" Error during manual cache eviction: { NAME } \" ) # Last resort: try using diskcache's built-in cull (size-based) try : NAME = NAME . NAME ( ) NAME . NAME ( f\" Fallback: diskcache culled { NAME } entries by size \" ) except NAME as NAME : NAME . NAME ( f\" Even fallback cull failed: { NAME } \" ) NAME = NAME ( ) NAME . NAME ( f\" Cache size enforcement: removed { NAME } entries \" ) NAME . NAME ( f\" Cache size: { NAME } \u2192 { NAME } (limit: { NAME } ) \" ) return { LIT : LIT , LIT : NAME , LIT : NAME , LIT : NAME , LIT : ( NAME / NAME * LIT ) if NAME > LIT else LIT , LIT : NAME , } except NAME as NAME : NAME . NAME ( f\" Error enforcing cache size limit: { NAME } \" ) return { LIT : LIT , LIT : NAME ( NAME ) , LIT : LIT }"
    },
    {
      "module_path": "cache.py",
      "qualname": "check_cache_size_before_add",
      "lineno": 698,
      "end_lineno": 727,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 5,
      "loc": 30,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(estimated_size)",
      "fingerprint": "b0c9b4c606c2d35a36879ac9f5c67831101918a9",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME : NAME = LIT ) -> NAME : LIT if not NAME or not NAME : return True # Allow if we can't check try : NAME = NAME ( ) NAME = NAME ( NAME . NAME , LIT , LIT ) if NAME + NAME <= NAME : return True # Would exceed limit - trigger enforcement NAME ( ) # Check again after enforcement NAME = NAME ( ) return NAME + NAME <= NAME except NAME as NAME : NAME . NAME ( f\" Error checking cache size limits: { NAME } \" ) return True # Allow on error"
    },
    {
      "module_path": "cache.py",
      "qualname": "get_cache_entry_count",
      "lineno": 730,
      "end_lineno": 748,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 5,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "577a48c4a56654a6ec775f8d61d2954a72e329ae",
      "simhash64": 7488180020825207827,
      "normalized": "def NAME ( ) -> NAME : LIT try : if NAME is not None : # Use len() which works correctly with diskcache # Type ignore for diskcache compatibility return NAME ( NAME ) # type: ignore return LIT except NAME as NAME : NAME . NAME ( f\" Error getting cache entry count: { NAME } \" ) # Fallback: try to count by iterating (slower but reliable) try : NAME = LIT for NAME in NAME : # type: ignore NAME += LIT return NAME except NAME as NAME : NAME . NAME ( f\" Fallback count also failed: { NAME } \" ) return LIT"
    },
    {
      "module_path": "cache.py",
      "qualname": "get_cache_stats",
      "lineno": 751,
      "end_lineno": 804,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 54,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "3230035473d2977c54e28f5cd31ca08f2eb43cda",
      "simhash64": 5146308208216159275,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT if NAME is None : NAME . NAME ( LIT ) return { } try : NAME = NAME . NAME ( NAME = True , NAME = False ) NAME = NAME ( ) NAME = { LIT : NAME [ LIT ] , LIT : NAME [ LIT ] , LIT : NAME , LIT : NAME . NAME ( ) , LIT : NAME ( NAME , LIT , LIT ) , } # Calculate hit rate NAME = NAME [ LIT ] + NAME [ LIT ] if NAME > LIT : NAME [ LIT ] = ( NAME [ LIT ] / NAME ) * LIT else : NAME [ LIT ] = LIT # Add cache configuration info NAME [ LIT ] = NAME ( NAME ) NAME [ LIT ] = LIT NAME [ LIT ] = LIT # Add size limit information from config if NAME : NAME = NAME ( NAME . NAME , LIT , LIT ) NAME = NAME [ LIT ] # Use the entries field NAME [ LIT ] = NAME NAME [ LIT ] = ( ( NAME / NAME * LIT ) if NAME > LIT else LIT ) NAME [ LIT ] = NAME <= NAME else : NAME [ LIT ] = LIT NAME [ LIT ] = LIT NAME [ LIT ] = LIT return NAME except NAME as NAME : NAME . NAME ( f\" Error retrieving cache statistics: { NAME } \" ) return { }"
    },
    {
      "module_path": "cache.py",
      "qualname": "cache_file_based_on_mtime",
      "lineno": 810,
      "end_lineno": 868,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 4,
      "loc": 59,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(cache_key_prefix, file_path, expire)",
      "fingerprint": "5125aafd81dece91a790462263e2740e1c3c14ae",
      "simhash64": 7488109654236894227,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None , ) -> NAME : LIT def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : if NAME is None : NAME . NAME ( LIT ) return NAME ( * NAME , ** NAME ) try : # Get file modification time from NAME import NAME NAME = NAME ( NAME ) . NAME ( ) . NAME # Create cache key that includes file mtime NAME = NAME . NAME ( NAME ( NAME ) . NAME ( ) ) . NAME ( ) [ : LIT ] NAME = ( f\" { NAME } _ { NAME . NAME } _mtime_ { NAME } \" ) # Try to get from cache NAME = NAME . NAME ( NAME , NAME = NAME , NAME = True ) if NAME is not NAME : NAME . NAME ( f\" Cache HIT for file-based key: ' { NAME } ' \" ) return NAME NAME . NAME ( f\" Cache MISS for file-based key: ' { NAME } ' \" ) # Execute function and cache result NAME = NAME ( * NAME , ** NAME ) NAME . NAME ( NAME , NAME , NAME = NAME , NAME = True ) NAME . NAME ( f\" Cached file-based result for key: ' { NAME } ' \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Error in file-based caching for { NAME . NAME } : { NAME } \" ) return NAME ( * NAME , ** NAME ) return NAME return NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "decorator",
      "lineno": 829,
      "end_lineno": 866,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 4,
      "loc": 38,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(func)",
      "fingerprint": "743830ec1e892fe0ef51398e22b40bace133b09b",
      "simhash64": 7488109654236902419,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : if NAME is None : NAME . NAME ( LIT ) return NAME ( * NAME , ** NAME ) try : # Get file modification time from NAME import NAME NAME = NAME ( NAME ) . NAME ( ) . NAME # Create cache key that includes file mtime NAME = NAME . NAME ( NAME ( NAME ) . NAME ( ) ) . NAME ( ) [ : LIT ] NAME = ( f\" { NAME } _ { NAME . NAME } _mtime_ { NAME } \" ) # Try to get from cache NAME = NAME . NAME ( NAME , NAME = NAME , NAME = True ) if NAME is not NAME : NAME . NAME ( f\" Cache HIT for file-based key: ' { NAME } ' \" ) return NAME NAME . NAME ( f\" Cache MISS for file-based key: ' { NAME } ' \" ) # Execute function and cache result NAME = NAME ( * NAME , ** NAME ) NAME . NAME ( NAME , NAME , NAME = NAME , NAME = True ) NAME . NAME ( f\" Cached file-based result for key: ' { NAME } ' \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Error in file-based caching for { NAME . NAME } : { NAME } \" ) return NAME ( * NAME , ** NAME ) return NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "wrapper",
      "lineno": 831,
      "end_lineno": 864,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 34,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "3e18f7c1f999f1fa0c91c4c887366d476d885389",
      "simhash64": 7488109654236902419,
      "normalized": "def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : if NAME is None : NAME . NAME ( LIT ) return NAME ( * NAME , ** NAME ) try : # Get file modification time from NAME import NAME NAME = NAME ( NAME ) . NAME ( ) . NAME # Create cache key that includes file mtime NAME = NAME . NAME ( NAME ( NAME ) . NAME ( ) ) . NAME ( ) [ : LIT ] NAME = ( f\" { NAME } _ { NAME . NAME } _mtime_ { NAME } \" ) # Try to get from cache NAME = NAME . NAME ( NAME , NAME = NAME , NAME = True ) if NAME is not NAME : NAME . NAME ( f\" Cache HIT for file-based key: ' { NAME } ' \" ) return NAME NAME . NAME ( f\" Cache MISS for file-based key: ' { NAME } ' \" ) # Execute function and cache result NAME = NAME ( * NAME , ** NAME ) NAME . NAME ( NAME , NAME , NAME = NAME , NAME = True ) NAME . NAME ( f\" Cached file-based result for key: ' { NAME } ' \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Error in file-based caching for { NAME . NAME } : { NAME } \" ) return NAME ( * NAME , ** NAME )"
    },
    {
      "module_path": "cache.py",
      "qualname": "warm_cache_with_data",
      "lineno": 874,
      "end_lineno": 898,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 25,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(cache_key, data, expire)",
      "fingerprint": "be236958e6e5d3916988b80c316c41b5e10d462f",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT if NAME is None : NAME . NAME ( LIT ) return False try : NAME . NAME ( NAME , NAME , NAME = NAME , NAME = True ) NAME . NAME ( f\" Cache warmed with key: ' { NAME } ' \" ) return True except NAME as NAME : NAME . NAME ( f\" Error warming cache with key ' { NAME } ': { NAME } \" ) return False"
    },
    {
      "module_path": "cache.py",
      "qualname": "IntelligentCacheWarmer.__init__",
      "lineno": 909,
      "end_lineno": 913,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "744a6c2f251006f8a2a05b0a486d09e99aea97ec",
      "simhash64": 7452080857216889943,
      "normalized": "def NAME ( NAME ) : NAME . NAME : NAME [ NAME , NAME [ NAME , NAME ] ] = { } NAME . NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] NAME . NAME : NAME [ NAME ] = NAME ( ) NAME . NAME : NAME [ NAME , NAME [ NAME ] ] = { }"
    },
    {
      "module_path": "cache.py",
      "qualname": "IntelligentCacheWarmer.record_cache_access",
      "lineno": 915,
      "end_lineno": 944,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 30,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, cache_key, hit, access_time)",
      "fingerprint": "5655557281d46f4f7896c3994b0da228be82eaf3",
      "simhash64": 5146308216806093859,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None ) : LIT if NAME is None : NAME = NAME . NAME ( ) if NAME not in NAME . NAME : NAME . NAME [ NAME ] = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : NAME , LIT : LIT , LIT : NAME ( NAME = LIT ) } NAME = NAME . NAME [ NAME ] NAME [ LIT ] += LIT NAME [ LIT ] = NAME NAME [ LIT ] . NAME ( NAME ) if NAME : NAME [ LIT ] += LIT else : NAME [ LIT ] += LIT # Calculate access frequency (accesses per hour) if NAME ( NAME [ LIT ] ) > LIT : NAME = NAME [ LIT ] [ - LIT ] - NAME [ LIT ] [ LIT ] if NAME > LIT : NAME [ LIT ] = NAME ( NAME [ LIT ] ) / ( NAME / LIT )"
    },
    {
      "module_path": "cache.py",
      "qualname": "IntelligentCacheWarmer.get_warming_candidates",
      "lineno": 946,
      "end_lineno": 973,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 28,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self, max_candidates)",
      "fingerprint": "cc558e0d4340eb09fc5ecb0fca9c7646b85bbadf",
      "simhash64": 7452151226028176387,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) -> NAME [ NAME ] : LIT NAME = [ ] for NAME , NAME in NAME . NAME . NAME ( ) : # Calculate warming score based on multiple factors NAME = LIT # Frequency score (higher frequency = higher score) NAME += NAME ( NAME [ LIT ] * LIT , LIT ) # Recency score (more recent access = higher score) NAME = NAME . NAME ( ) - NAME [ LIT ] if NAME < LIT : # Within last hour NAME += LIT elif NAME < LIT : # Within last day NAME += LIT # Miss rate penalty (high miss rate = lower score) if NAME [ LIT ] > LIT : NAME = NAME [ LIT ] / NAME [ LIT ] NAME += NAME * LIT NAME . NAME ( ( NAME , NAME ) ) # Sort by score and return top candidates NAME . NAME ( NAME = lambda NAME : NAME [ LIT ] , NAME = True ) return [ NAME for NAME , NAME in NAME [ : NAME ] if NAME > LIT ]"
    },
    {
      "module_path": "cache.py",
      "qualname": "IntelligentCacheWarmer.warm_predictive_cache",
      "lineno": 975,
      "end_lineno": 1000,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 26,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, session_manager)",
      "fingerprint": "9570eb4ad77346ec417982549fe172dfe8699ee6",
      "simhash64": 7488180022981071899,
      "normalized": "def NAME ( NAME , NAME = None ) -> NAME : LIT NAME = LIT NAME = NAME . NAME ( ) NAME . NAME ( f\" Starting predictive cache warming for { NAME ( NAME ) } candidates \" ) for NAME in NAME : try : # Try to regenerate data for high-value cache keys if NAME . NAME ( NAME ) : NAME = NAME . NAME ( NAME , NAME ) if NAME : NAME += LIT NAME . NAME ( f\" Predictively warmed cache key: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Failed to warm cache key { NAME } : { NAME } \" ) NAME . NAME . NAME ( { LIT : NAME . NAME ( ) , LIT : NAME ( NAME ) , LIT : NAME } ) NAME . NAME ( f\" Predictive cache warming completed: { NAME } / { NAME ( NAME ) } keys warmed \" ) return NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "IntelligentCacheWarmer._should_regenerate_cache_data",
      "lineno": 1002,
      "end_lineno": 1010,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, cache_key)",
      "fingerprint": "a442a9a73d1df33406ae8c92923f842eaa5a5f51",
      "simhash64": 7488180022980023347,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT # Check if key is in our predictive set if NAME in NAME . NAME : return True # Check usage patterns NAME = NAME . NAME . NAME ( NAME , { } ) return NAME . NAME ( LIT , LIT ) > LIT # More than 1 access per hour"
    },
    {
      "module_path": "cache.py",
      "qualname": "IntelligentCacheWarmer._regenerate_cache_data",
      "lineno": 1012,
      "end_lineno": 1026,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 15,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, cache_key, session_manager)",
      "fingerprint": "36ff0fa9dd828c6ce5aff884eb729ac43200ffa2",
      "simhash64": 7487617073026602027,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME = None ) -> NAME : LIT try : # For genealogical data keys, try to regenerate if LIT in NAME . NAME ( ) : return NAME . NAME ( NAME ) if LIT in NAME . NAME ( ) : return NAME . NAME ( NAME , NAME ) if LIT in NAME . NAME ( ) : return NAME . NAME ( NAME , NAME ) # Generic warming with placeholder data return NAME ( NAME , { LIT : NAME . NAME ( ) } ) except NAME as NAME : NAME . NAME ( f\" Failed to regenerate cache data for { NAME } : { NAME } \" ) return False"
    },
    {
      "module_path": "cache.py",
      "qualname": "IntelligentCacheWarmer._warm_gedcom_data",
      "lineno": 1028,
      "end_lineno": 1046,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 19,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:small"
      ],
      "signature": "(self, cache_key)",
      "fingerprint": "386ae5ba7db60e3637a9f03465f31d0358ca9278",
      "simhash64": 7487617073026602011,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT try : # Try to load GEDCOM metadata from NAME import NAME if NAME ( NAME . NAME , LIT ) : NAME = NAME . NAME . NAME if NAME and NAME ( NAME ) . NAME ( ) : NAME = NAME ( NAME ) . NAME ( ) NAME = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME ( ) , LIT : True } return NAME ( NAME , NAME ) except NAME as NAME : NAME . NAME ( f\" Could not warm GEDCOM data for { NAME } : { NAME } \" ) return False"
    },
    {
      "module_path": "cache.py",
      "qualname": "IntelligentCacheWarmer._warm_api_data",
      "lineno": 1048,
      "end_lineno": 1060,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, cache_key, session_manager)",
      "fingerprint": "73384e4d7402e7b5c52aa044fa9c9218ec42afce",
      "simhash64": 7487757777228961323,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME = None ) -> NAME : LIT try : # Warm with API configuration data NAME = { LIT : NAME . NAME ( ) , LIT : True , LIT : NAME . NAME ( ) if NAME else False } return NAME ( NAME , NAME ) except NAME as NAME : NAME . NAME ( f\" Could not warm API data for { NAME } : { NAME } \" ) return False"
    },
    {
      "module_path": "cache.py",
      "qualname": "IntelligentCacheWarmer._warm_profile_data",
      "lineno": 1062,
      "end_lineno": 1074,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, cache_key, session_manager)",
      "fingerprint": "791f59e6272c6a3e24e99d9ff7cf30cd4cd02671",
      "simhash64": 7452291963449414715,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT try : # Warm with basic profile metadata NAME = { LIT : NAME . NAME ( ) , LIT : True , LIT : NAME } return NAME ( NAME , NAME ) except NAME as NAME : NAME . NAME ( f\" Could not warm profile data for { NAME } : { NAME } \" ) return False"
    },
    {
      "module_path": "cache.py",
      "qualname": "CacheDependencyTracker.__init__",
      "lineno": 1082,
      "end_lineno": 1084,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "2f629e5350d5fa309e3d3b9d4b9d6097145b7cf1",
      "simhash64": 7452151775783990357,
      "normalized": "def NAME ( NAME ) : NAME . NAME : NAME [ NAME , NAME [ NAME ] ] = { } # key -> set of dependent keys NAME . NAME : NAME [ NAME , NAME [ NAME ] ] = { } # key -> set of keys it depends on"
    },
    {
      "module_path": "cache.py",
      "qualname": "CacheDependencyTracker.add_dependency",
      "lineno": 1086,
      "end_lineno": 1096,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, parent_key, dependent_key)",
      "fingerprint": "0da391d2ed3343577008fc73b141f8322e5b2e60",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) : LIT if NAME not in NAME . NAME : NAME . NAME [ NAME ] = NAME ( ) if NAME not in NAME . NAME : NAME . NAME [ NAME ] = NAME ( ) NAME . NAME [ NAME ] . NAME ( NAME ) NAME . NAME [ NAME ] . NAME ( NAME ) NAME . NAME ( f\" Added cache dependency: { NAME } -> { NAME } \" )"
    },
    {
      "module_path": "cache.py",
      "qualname": "CacheDependencyTracker.invalidate_with_dependencies",
      "lineno": 1098,
      "end_lineno": 1122,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 25,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self, cache_key)",
      "fingerprint": "c9fd7a225ee22ded619ac2f4fa367e553b4eb826",
      "simhash64": 7452151225961067603,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT NAME = LIT # Invalidate the key itself if NAME and NAME in NAME : try : del NAME [ NAME ] NAME += LIT NAME . NAME ( f\" Invalidated cache key: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Failed to invalidate cache key { NAME } : { NAME } \" ) # Invalidate all dependent keys if NAME in NAME . NAME : for NAME in NAME . NAME [ NAME ] . NAME ( ) : try : if NAME and NAME in NAME : del NAME [ NAME ] NAME += LIT NAME . NAME ( f\" Invalidated dependent cache key: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Failed to invalidate dependent key { NAME } : { NAME } \" ) return NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "CacheDependencyTracker.get_dependency_chain",
      "lineno": 1124,
      "end_lineno": 1139,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self, cache_key)",
      "fingerprint": "b9e7cc113676c32d21659a99914349f4260f298a",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT NAME = [ ] NAME = NAME ( ) def NAME ( NAME : NAME ) : if NAME in NAME : return NAME . NAME ( NAME ) NAME . NAME ( NAME ) for NAME in NAME . NAME . NAME ( NAME , [ ] ) : NAME ( NAME ) NAME ( NAME ) return NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "CacheDependencyTracker._collect_dependencies",
      "lineno": 1129,
      "end_lineno": 1136,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(key)",
      "fingerprint": "e620b87e8a0ed749a5af36a7bf9b279476ce0299",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME : NAME ) : if NAME in NAME : return NAME . NAME ( NAME ) NAME . NAME ( NAME ) for NAME in NAME . NAME . NAME ( NAME , [ ] ) : NAME ( NAME )"
    },
    {
      "module_path": "cache.py",
      "qualname": "get_intelligent_cache_warmer",
      "lineno": 1147,
      "end_lineno": 1149,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "3140307c015cf6691ad5a38fc8fae0b0658afea9",
      "simhash64": 7492851299204895843,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "get_cache_dependency_tracker",
      "lineno": 1152,
      "end_lineno": 1154,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "3140307c015cf6691ad5a38fc8fae0b0658afea9",
      "simhash64": 7492851299204895843,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "invalidate_cache_pattern",
      "lineno": 1160,
      "end_lineno": 1188,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 29,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(pattern)",
      "fingerprint": "ef247604a0685eed971d142adcedb760cb544470",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if NAME is None : NAME . NAME ( LIT ) return LIT try : NAME = LIT # Get all keys and filter by pattern for NAME in NAME ( NAME ) : if NAME in NAME ( NAME ) : NAME . NAME ( NAME ) NAME += LIT NAME . NAME ( f\" Invalidated { NAME } cache entries matching pattern: ' { NAME } ' \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Error invalidating cache pattern ' { NAME } ': { NAME } \" ) return LIT"
    },
    {
      "module_path": "cache.py",
      "qualname": "cache_module_tests",
      "lineno": 1194,
      "end_lineno": 1456,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 20,
      "yield_count": 0,
      "complexity": 15,
      "loc": 263,
      "tags": [
        "pure-ish",
        "time",
        "regex",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "1578ccfc05b9d28ff7f050bd3999377f7184d84f",
      "simhash64": 7451729014569735203,
      "normalized": "def NAME ( ) -> NAME : LIT def NAME ( ) : LIT # Check if cache is initialized (may be None in some environments) NAME = NAME is not None if NAME : assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT return True def NAME ( ) : LIT NAME = NAME ( ) assert NAME . NAME ( ) == LIT # Test health status method NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT return True def NAME ( ) : LIT if NAME is None : return True # Skip if cache not available # Test basic set/get NAME = LIT NAME = LIT NAME . NAME ( NAME , NAME ) NAME = NAME . NAME ( NAME ) assert ( NAME == NAME ) , f\" Retrieved value { NAME } doesn't match set value { NAME } \" # Test delete NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) assert NAME is None , LIT return True def NAME ( ) : LIT NAME = LIT @ NAME ( LIT ) def NAME ( NAME , NAME ) : nonlocal NAME NAME += LIT return NAME + NAME # First call should execute function NAME = NAME ( LIT , LIT ) assert NAME == LIT assert NAME == LIT # Second call should use cache NAME = NAME ( LIT , LIT ) assert NAME == LIT assert NAME == LIT # Should not increment return True def NAME ( ) : LIT if NAME is None : return True NAME = LIT NAME = LIT # Set with very short TTL NAME . NAME ( NAME , NAME , NAME = LIT ) # 100ms # Should be available immediately assert NAME . NAME ( NAME ) == NAME # Wait for expiration import NAME NAME . NAME ( LIT ) # Should be expired NAME = NAME . NAME ( NAME ) assert NAME is None return True def NAME ( ) : LIT # This is a basic test - actual size management depends on diskcache config if NAME is None : return True # Set multiple values for NAME in NAME ( LIT ) : NAME . NAME ( f\" size_test_ { NAME } \" , f\" value_ { NAME } \" ) # Verify they're stored for NAME in NAME ( LIT ) : NAME = NAME . NAME ( f\" size_test_ { NAME } \" ) if NAME is not None : # May be evicted, that's okay assert NAME == f\" value_ { NAME } \" return True def NAME ( ) : LIT if NAME is None : return True # Set some test data NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) # Verify data exists assert NAME . NAME ( LIT ) == LIT assert NAME . NAME ( LIT ) == LIT # Clear cache NAME . NAME ( ) # Verify data is gone assert NAME . NAME ( LIT ) is None assert NAME . NAME ( LIT ) is None return True def NAME ( ) : LIT if NAME is None : return True # Test dictionary NAME = { LIT : LIT , LIT : { LIT : LIT } } NAME . NAME ( LIT , NAME ) NAME = NAME . NAME ( LIT ) assert NAME == NAME # Test list NAME = [ LIT , LIT , { LIT : LIT } , [ LIT , LIT ] ] NAME . NAME ( LIT , NAME ) NAME = NAME . NAME ( LIT ) assert NAME == NAME return True def NAME ( ) : LIT if NAME is None : return True # Performance test - basic operations should be fast import NAME NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME . NAME ( f\" perf_test_ { NAME } \" , f\" value_ { NAME } \" ) NAME . NAME ( f\" perf_test_ { NAME } \" ) NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 100 cache operations took { NAME } s, should be under 5s \" return True def NAME ( ) : LIT if NAME is None : return True # Test with None values NAME . NAME ( LIT , None ) NAME . NAME ( LIT ) # Note: this might be None due to the value OR due to key not found # The actual behavior depends on diskcache implementation # Test with empty string NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT ) assert NAME == LIT return True def NAME ( ) : LIT # Test module health functions if NAME ( LIT ) : NAME = NAME ( LIT ) NAME = NAME ( ) assert NAME ( NAME , NAME ) # Test cache directory health if NAME is not None : # Basic health check - cache should be operational NAME . NAME ( LIT , LIT ) assert NAME . NAME ( LIT ) == LIT return True # Create test suite and run tests NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # Run all tests NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "cache.py",
      "qualname": "test_cache_initialization",
      "lineno": 1202,
      "end_lineno": 1211,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "188d2049e07c9e2b28ed2020c60805fb0a79a361",
      "simhash64": 5181914768015266859,
      "normalized": "def NAME ( ) : LIT # Check if cache is initialized (may be None in some environments) NAME = NAME is not None if NAME : assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT return True"
    },
    {
      "module_path": "cache.py",
      "qualname": "test_cache_interfaces",
      "lineno": 1213,
      "end_lineno": 1223,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2902cfcc2d9bc53b6fa1de097a66842c0587a5dc",
      "simhash64": 7487757777228960811,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) assert NAME . NAME ( ) == LIT # Test health status method NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT return True"
    },
    {
      "module_path": "cache.py",
      "qualname": "test_basic_cache_operations",
      "lineno": 1225,
      "end_lineno": 1244,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7458f39816e0e11d604517d94a16ed15a3aa6aad",
      "simhash64": 7488109658530812947,
      "normalized": "def NAME ( ) : LIT if NAME is None : return True # Skip if cache not available # Test basic set/get NAME = LIT NAME = LIT NAME . NAME ( NAME , NAME ) NAME = NAME . NAME ( NAME ) assert ( NAME == NAME ) , f\" Retrieved value { NAME } doesn't match set value { NAME } \" # Test delete NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) assert NAME is None , LIT return True"
    },
    {
      "module_path": "cache.py",
      "qualname": "test_cache_decorator",
      "lineno": 1246,
      "end_lineno": 1265,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 1,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6b72b8168afc60d9fff754f7bbed762aab85c9a2",
      "simhash64": 7452291964514767907,
      "normalized": "def NAME ( ) : LIT NAME = LIT @ NAME ( LIT ) def NAME ( NAME , NAME ) : nonlocal NAME NAME += LIT return NAME + NAME # First call should execute function NAME = NAME ( LIT , LIT ) assert NAME == LIT assert NAME == LIT # Second call should use cache NAME = NAME ( LIT , LIT ) assert NAME == LIT assert NAME == LIT # Should not increment return True"
    },
    {
      "module_path": "cache.py",
      "qualname": "test_function",
      "lineno": 1251,
      "end_lineno": 1254,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(x, y)",
      "fingerprint": "c1936ebb2ac33a0144011158e5a1bdd8409b287b",
      "simhash64": 7488109654235841619,
      "normalized": "def NAME ( NAME , NAME ) : nonlocal NAME NAME += LIT return NAME + NAME"
    },
    {
      "module_path": "cache.py",
      "qualname": "test_cache_expiration",
      "lineno": 1267,
      "end_lineno": 1289,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 23,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "e745d4f4395a9a684a104ced613660788e0ac99b",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( ) : LIT if NAME is None : return True NAME = LIT NAME = LIT # Set with very short TTL NAME . NAME ( NAME , NAME , NAME = LIT ) # 100ms # Should be available immediately assert NAME . NAME ( NAME ) == NAME # Wait for expiration import NAME NAME . NAME ( LIT ) # Should be expired NAME = NAME . NAME ( NAME ) assert NAME is None return True"
    },
    {
      "module_path": "cache.py",
      "qualname": "test_cache_size_management",
      "lineno": 1291,
      "end_lineno": 1306,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 16,
      "tags": [
        "pure-ish",
        "regex",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2b24568ca37662ee6b38497a190cf467743b9ee1",
      "simhash64": 7452186410325808667,
      "normalized": "def NAME ( ) : LIT # This is a basic test - actual size management depends on diskcache config if NAME is None : return True # Set multiple values for NAME in NAME ( LIT ) : NAME . NAME ( f\" size_test_ { NAME } \" , f\" value_ { NAME } \" ) # Verify they're stored for NAME in NAME ( LIT ) : NAME = NAME . NAME ( f\" size_test_ { NAME } \" ) if NAME is not None : # May be evicted, that's okay assert NAME == f\" value_ { NAME } \" return True"
    },
    {
      "module_path": "cache.py",
      "qualname": "test_cache_clearing",
      "lineno": 1308,
      "end_lineno": 1327,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3397d96ee9fd4687f91fa8b7242908b412262694",
      "simhash64": 7487618310581163043,
      "normalized": "def NAME ( ) : LIT if NAME is None : return True # Set some test data NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) # Verify data exists assert NAME . NAME ( LIT ) == LIT assert NAME . NAME ( LIT ) == LIT # Clear cache NAME . NAME ( ) # Verify data is gone assert NAME . NAME ( LIT ) is None assert NAME . NAME ( LIT ) is None return True"
    },
    {
      "module_path": "cache.py",
      "qualname": "test_complex_data_types",
      "lineno": 1329,
      "end_lineno": 1345,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "4ece95c739fbcd05c2b5bd2ce6f7e636b539c368",
      "simhash64": 7451729014569735723,
      "normalized": "def NAME ( ) : LIT if NAME is None : return True # Test dictionary NAME = { LIT : LIT , LIT : { LIT : LIT } } NAME . NAME ( LIT , NAME ) NAME = NAME . NAME ( LIT ) assert NAME == NAME # Test list NAME = [ LIT , LIT , { LIT : LIT } , [ LIT , LIT ] ] NAME . NAME ( LIT , NAME ) NAME = NAME . NAME ( LIT ) assert NAME == NAME return True"
    },
    {
      "module_path": "cache.py",
      "qualname": "test_cache_performance",
      "lineno": 1347,
      "end_lineno": 1365,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 19,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f1e7ec609bd914d44b549f1b4b32755c2368a516",
      "simhash64": 8641136711960007707,
      "normalized": "def NAME ( ) : LIT if NAME is None : return True # Performance test - basic operations should be fast import NAME NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME . NAME ( f\" perf_test_ { NAME } \" , f\" value_ { NAME } \" ) NAME . NAME ( f\" perf_test_ { NAME } \" ) NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 100 cache operations took { NAME } s, should be under 5s \" return True"
    },
    {
      "module_path": "cache.py",
      "qualname": "test_error_handling",
      "lineno": 1367,
      "end_lineno": 1382,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d79ebc104a37981383a343badaa20245ee2a0dc9",
      "simhash64": 5181949956733244419,
      "normalized": "def NAME ( ) : LIT if NAME is None : return True # Test with None values NAME . NAME ( LIT , None ) NAME . NAME ( LIT ) # Note: this might be None due to the value OR due to key not found # The actual behavior depends on diskcache implementation # Test with empty string NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT ) assert NAME == LIT return True"
    },
    {
      "module_path": "cache.py",
      "qualname": "test_health_monitoring",
      "lineno": 1384,
      "end_lineno": 1397,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "bf5f11e131ef7e393e6178367262b3a6a3bb1384",
      "simhash64": 7488355911623152687,
      "normalized": "def NAME ( ) : LIT # Test module health functions if NAME ( LIT ) : NAME = NAME ( LIT ) NAME = NAME ( ) assert NAME ( NAME , NAME ) # Test cache directory health if NAME is not None : # Basic health check - cache should be operational NAME . NAME ( LIT , LIT ) assert NAME . NAME ( LIT ) == LIT return True"
    },
    {
      "module_path": "cache.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 1459,
      "end_lineno": 1461,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "SessionComponentCache.__init__",
      "lineno": 94,
      "end_lineno": 102,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "f7dbff59a6dafcf83d8dce901c551f3c3b7d3368",
      "simhash64": 7452854914543686703,
      "normalized": "def NAME ( NAME ) : NAME . NAME : NAME [ NAME , NAME . NAME ] = { } NAME . NAME = NAME . NAME ( ) NAME . NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , }"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "SessionComponentCache.cache_component",
      "lineno": 104,
      "end_lineno": 134,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 31,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, component_type, component)",
      "fingerprint": "a769bab4ee1cb267be8dec0e979913dccb76f1ca",
      "simhash64": 7452151225961059339,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT if not NAME : return False try : NAME = NAME . NAME ( ) NAME = NAME ( LIT , NAME , NAME ) # Wrap component with metadata NAME = { LIT : NAME , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , } # Use existing cache with component TTL NAME . NAME ( NAME , NAME , NAME = NAME . NAME , NAME = True , ) NAME . NAME ( f\" Cached component: { NAME } \" ) NAME . NAME [ LIT ] += LIT return True except NAME as NAME : NAME . NAME ( f\" Error caching component { NAME } : { NAME } \" ) return False"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "SessionComponentCache.get_cached_component",
      "lineno": 136,
      "end_lineno": 162,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 8,
      "loc": 27,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self, component_type)",
      "fingerprint": "3d7cf21914bed338638f85b0e4d124d55d484259",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT if not NAME : return None try : NAME = NAME . NAME ( ) NAME = NAME ( LIT , NAME , NAME ) NAME = NAME . NAME ( NAME , NAME = True ) if NAME and NAME ( NAME , NAME ) : # Validate cache data structure if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT ] ) : # Check if cache is still valid NAME = NAME . NAME ( ) - NAME [ LIT ] if NAME < NAME . NAME : NAME . NAME ( f\" Cache hit for component: { NAME } \" ) NAME . NAME [ LIT ] += LIT return NAME [ LIT ] NAME . NAME [ LIT ] += LIT return None except NAME as NAME : NAME . NAME ( f\" Error retrieving cached component { NAME } : { NAME } \" ) NAME . NAME [ LIT ] += LIT return None"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "SessionComponentCache._get_config_hash",
      "lineno": 164,
      "end_lineno": 177,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "474c8cf7339d961c4ce6dc8d4cd0e1699e4cdbb9",
      "simhash64": 7487617074100343819,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : import NAME NAME = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME ( NAME ( NAME ( NAME . NAME . NAME ( ) ) ) ) , } NAME = NAME . NAME ( NAME , NAME = True ) return NAME . NAME ( NAME . NAME ( ) ) . NAME ( ) [ : LIT ] except NAME : return LIT"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "SessionComponentCache.get_stats",
      "lineno": 179,
      "end_lineno": 187,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "8ba3f95741c2533790c64eacca498c029b8910a4",
      "simhash64": 7487617073026601987,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME . NAME ( ) NAME . NAME ( { LIT : NAME ( NAME . NAME ) , LIT : NAME is not None , LIT : NAME . NAME , } ) return NAME"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "APICacheManager.__init__",
      "lineno": 200,
      "end_lineno": 206,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "736d3c74be7404346268796ae1ab224de51f80ef",
      "simhash64": 5727968560672052783,
      "normalized": "def NAME ( NAME ) : NAME . NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , }"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "APICacheManager.create_api_cache_key",
      "lineno": 208,
      "end_lineno": 213,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "json",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self, endpoint, params)",
      "fingerprint": "d2b2c504b37134cabad9a132d81e51650eeda0bf",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT # Sort parameters for consistent key generation NAME = NAME . NAME ( NAME , NAME = True , NAME = NAME ) NAME = NAME . NAME ( NAME . NAME ( ) ) . NAME ( ) [ : LIT ] return f\" api_ { NAME } _ { NAME } \""
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "APICacheManager.cache_api_response",
      "lineno": 215,
      "end_lineno": 243,
      "is_method": true,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 29,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, service, method, params, response, ttl)",
      "fingerprint": "4bee33dd4a181c91e6f60febb342a0bd45ed4db0",
      "simhash64": 7488180022980023307,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT if not NAME : return False try : # Determine TTL based on service type if NAME is None : NAME = NAME . NAME ( NAME ) NAME = NAME ( LIT , NAME , NAME , NAME ( NAME ( NAME ( NAME ) ) ) ) NAME = { LIT : NAME , LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , LIT : NAME , } NAME . NAME ( NAME , NAME , NAME = NAME , NAME = True ) NAME . NAME [ LIT ] += LIT NAME . NAME ( f\" Cached API response: { NAME } . { NAME } \" ) return True except NAME as NAME : NAME . NAME ( f\" Error caching API response for { NAME } . { NAME } : { NAME } \" ) return False"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "APICacheManager.get_cached_api_response",
      "lineno": 245,
      "end_lineno": 266,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 7,
      "loc": 22,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self, service, method, params)",
      "fingerprint": "516c5f1a58695396809e6544e9b03113d1835a3c",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT if not NAME : return None try : NAME = NAME ( LIT , NAME , NAME , NAME ( NAME ( NAME ( NAME ) ) ) ) NAME = NAME . NAME ( NAME , NAME = True ) if NAME and NAME ( NAME , NAME ) : if LIT in NAME and LIT in NAME : NAME . NAME [ LIT ] += LIT NAME . NAME ( f\" API cache hit: { NAME } . { NAME } \" ) return NAME [ LIT ] NAME . NAME [ LIT ] += LIT return None except NAME as NAME : NAME . NAME ( f\" Error retrieving cached API response for { NAME } . { NAME } : { NAME } \" ) NAME . NAME [ LIT ] += LIT return None"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "APICacheManager._get_service_ttl",
      "lineno": 268,
      "end_lineno": 276,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self, service)",
      "fingerprint": "a752bf3fa6e66070d4d57b48fc7aa8b26d5861be",
      "simhash64": 7451588277081379875,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT NAME = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME , } return NAME . NAME ( NAME . NAME ( ) , NAME [ LIT ] )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "APICacheManager.get_stats",
      "lineno": 278,
      "end_lineno": 280,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "6398eb8336c9c8bfc916e0763205a055cdfd525f",
      "simhash64": 7488180022980031555,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return NAME . NAME . NAME ( )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "SystemCacheManager.__init__",
      "lineno": 293,
      "end_lineno": 300,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5b923d0583572f1331b606250c23de3007aac42f",
      "simhash64": 7456233713767454251,
      "normalized": "def NAME ( NAME ) : NAME . NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } NAME . NAME = NAME . NAME ( )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "SystemCacheManager.warm_system_caches",
      "lineno": 302,
      "end_lineno": 325,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 24,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "d8f6ee31c94c4b3e6e0927d0c4455de27641fd96",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : NAME . NAME ( LIT ) # Warm with system metadata NAME = NAME ( LIT , LIT , LIT ) NAME = { LIT : LIT , LIT : NAME . NAME ( ) , LIT : { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , } , } NAME ( NAME , NAME , NAME = LIT ) NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" Error warming system caches: { NAME } \" ) return False"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "SystemCacheManager.get_memory_usage_mb",
      "lineno": 327,
      "end_lineno": 336,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "ff3a54c024958a6ebe0005b676c924cac32dd739",
      "simhash64": 7488109654302962707,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : import NAME NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) . NAME / LIT / LIT NAME . NAME [ LIT ] = NAME return NAME except NAME : return LIT"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "SystemCacheManager.optimize_memory",
      "lineno": 338,
      "end_lineno": 363,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "c1f0fd3501b8bf81ae469f6504454b94d0d8323a",
      "simhash64": 7452151227034801195,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT try : import NAME NAME = NAME . NAME ( ) # Trigger garbage collection NAME = NAME . NAME ( ) NAME . NAME [ LIT ] += LIT NAME = NAME . NAME ( ) NAME = NAME ( LIT , NAME - NAME ) NAME . NAME [ LIT ] += NAME return { LIT : True , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , } except NAME as NAME : NAME . NAME ( f\" Error optimizing memory: { NAME } \" ) return { LIT : False , LIT : NAME ( NAME ) }"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "SystemCacheManager.get_stats",
      "lineno": 365,
      "end_lineno": 367,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "6398eb8336c9c8bfc916e0763205a055cdfd525f",
      "simhash64": 7488180022980031555,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return NAME . NAME . NAME ( )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "UnifiedCacheManager.__init__",
      "lineno": 380,
      "end_lineno": 383,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "b55cd5955f185f2fa78ddaddab44df1c78406703",
      "simhash64": 8641066347509752851,
      "normalized": "def NAME ( NAME ) : NAME . NAME = NAME ( ) NAME . NAME = NAME ( ) NAME . NAME = NAME ( )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "UnifiedCacheManager.get_comprehensive_stats",
      "lineno": 385,
      "end_lineno": 396,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "ce9480c1236b861346e689f76d1fe566f97aa04c",
      "simhash64": 7452854914476577835,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME . NAME ( ) , LIT : NAME . NAME . NAME ( ) , LIT : NAME . NAME . NAME ( ) , LIT : { LIT : LIT , LIT : NAME is not None , LIT : NAME . NAME ( ) , } }"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "UnifiedCacheManager.warm_all_caches",
      "lineno": 398,
      "end_lineno": 410,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "6505ae167e5420b681d889ea33a1e5b2c449042c",
      "simhash64": 8641136716857914371,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = [ ] try : NAME . NAME ( NAME . NAME . NAME ( ) ) except NAME : NAME . NAME ( False ) try : NAME . NAME ( NAME . NAME . NAME ( ) ) except NAME : NAME . NAME ( False ) NAME . NAME ( NAME . NAME . NAME ( ) ) return NAME ( NAME ) # Return True if at least one cache warmed successfully"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "UnifiedCacheManager.get_module_name",
      "lineno": 412,
      "end_lineno": 414,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5bd6089ca6ab0b7a1cc5914ffd95afac8325cade",
      "simhash64": 5186409605900964899,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return LIT"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "get_unified_cache_manager",
      "lineno": 425,
      "end_lineno": 427,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "3140307c015cf6691ad5a38fc8fae0b0658afea9",
      "simhash64": 7492851299204895843,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "get_session_cache_stats",
      "lineno": 430,
      "end_lineno": 432,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "10525ad99de774eb860ba61bdbae4609af26d0f0",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return NAME . NAME . NAME ( )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "get_api_cache_stats",
      "lineno": 435,
      "end_lineno": 437,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "10525ad99de774eb860ba61bdbae4609af26d0f0",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return NAME . NAME . NAME ( )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "get_system_cache_stats",
      "lineno": 440,
      "end_lineno": 442,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "10525ad99de774eb860ba61bdbae4609af26d0f0",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return NAME . NAME . NAME ( )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "warm_all_caches",
      "lineno": 445,
      "end_lineno": 447,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d47288f6127502799f806b1d647827a7f4d80a3e",
      "simhash64": 8645218654783181859,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME . NAME ( )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "cached_session_component",
      "lineno": 456,
      "end_lineno": 471,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(component_type)",
      "fingerprint": "efb154544df1a9ca07363ec5ee02583dd5ce332d",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ [ NAME ] , NAME ] : LIT def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : # Try to get cached component NAME = NAME . NAME . NAME ( NAME ) if NAME is not None : return NAME # Create and cache component NAME = NAME ( * NAME , ** NAME ) NAME . NAME . NAME ( NAME , NAME ) return NAME return NAME return NAME"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "decorator",
      "lineno": 458,
      "end_lineno": 470,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(func)",
      "fingerprint": "41e3e80e801daf5a6c6d9b16fc5738b90c4332df",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : # Try to get cached component NAME = NAME . NAME . NAME ( NAME ) if NAME is not None : return NAME # Create and cache component NAME = NAME ( * NAME , ** NAME ) NAME . NAME . NAME ( NAME , NAME ) return NAME return NAME"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "wrapper",
      "lineno": 460,
      "end_lineno": 469,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "cb013d0cc30077f0c93448a5177d099eadf50a9b",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( * NAME , ** NAME ) : # Try to get cached component NAME = NAME . NAME . NAME ( NAME ) if NAME is not None : return NAME # Create and cache component NAME = NAME ( * NAME , ** NAME ) NAME . NAME . NAME ( NAME , NAME ) return NAME"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "cached_api_call",
      "lineno": 474,
      "end_lineno": 492,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 2,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(endpoint, ttl)",
      "fingerprint": "b5ef0c6bd8c61d7c3163f3787af44f4613cf85fe",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME = LIT ) -> NAME [ [ NAME ] , NAME ] : LIT def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : # Create cache key from endpoint and parameters NAME = NAME . NAME . NAME ( NAME , NAME ) # Try to get cached result NAME = NAME . NAME . NAME ( NAME , NAME ) if NAME is not None : return NAME # Call function and cache result NAME = NAME ( * NAME , ** NAME ) NAME . NAME . NAME ( NAME , NAME , NAME , NAME ) return NAME return NAME return NAME"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "decorator",
      "lineno": 476,
      "end_lineno": 491,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(func)",
      "fingerprint": "72e4d90999f3a2310c80ea0804671befab6d434b",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : # Create cache key from endpoint and parameters NAME = NAME . NAME . NAME ( NAME , NAME ) # Try to get cached result NAME = NAME . NAME . NAME ( NAME , NAME ) if NAME is not None : return NAME # Call function and cache result NAME = NAME ( * NAME , ** NAME ) NAME . NAME . NAME ( NAME , NAME , NAME , NAME ) return NAME return NAME"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "wrapper",
      "lineno": 478,
      "end_lineno": 490,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "007b727fc802def6c148967665c4407c870f5b61",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( * NAME , ** NAME ) : # Create cache key from endpoint and parameters NAME = NAME . NAME . NAME ( NAME , NAME ) # Try to get cached result NAME = NAME . NAME . NAME ( NAME , NAME ) if NAME is not None : return NAME # Call function and cache result NAME = NAME ( * NAME , ** NAME ) NAME . NAME . NAME ( NAME , NAME , NAME , NAME ) return NAME"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "cache_session_component",
      "lineno": 500,
      "end_lineno": 502,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(component_type, component)",
      "fingerprint": "15f0c51a9c962e5a6f3f63397f81a00718a5ab53",
      "simhash64": 7488180022980027459,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT return NAME . NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "get_cached_session_component",
      "lineno": 505,
      "end_lineno": 507,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(component_type)",
      "fingerprint": "18c3c81495b53da088094e39a73294012e681016",
      "simhash64": 7488180022980027459,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT return NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "create_api_cache_key",
      "lineno": 510,
      "end_lineno": 512,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(endpoint, params)",
      "fingerprint": "0c74f091b2792b24d6746052c774de2186dca3fc",
      "simhash64": 7488180022980027459,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT return NAME . NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "cache_manager_module_tests",
      "lineno": 515,
      "end_lineno": 751,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 22,
      "yield_count": 0,
      "complexity": 10,
      "loc": 237,
      "tags": [
        "pure-ish",
        "logging",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "736bdf201188a1db27feafeae87fcfa6db26d163",
      "simhash64": 5181949956683895843,
      "normalized": "def NAME ( ) -> NAME : LIT def NAME ( ) -> NAME : # Test cache manager initialization if NAME ( LIT ) : NAME = NAME ( LIT ) if NAME : NAME = NAME ( ) assert NAME is not None # suite.log_test_result(True, \"Cache manager created successfully\") return True # CORE FUNCTIONALITY TESTS def NAME ( ) -> NAME : # Test basic cache operations if NAME ( LIT ) : NAME = NAME ( LIT ) if NAME : NAME = NAME ( ) # Test set and get operations NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT ) assert NAME == LIT return True def NAME ( ) -> NAME : # Test cache statistics collection pass return True def NAME ( ) -> NAME : # Test cache invalidation patterns pass return True # EDGE CASE TESTS def NAME ( ) -> NAME : # Test cache eviction when full if NAME ( LIT ) : NAME = NAME ( LIT ) if NAME : NAME = NAME ( NAME = LIT ) NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) # Should evict key1 NAME = NAME . NAME ( LIT ) # Oldest key should be evicted assert NAME is None or NAME == LIT return True def NAME ( ) -> NAME : # Test performance monitoring features if NAME ( LIT ) : NAME = NAME ( LIT ) if NAME : NAME ( ) # Test performance tracking return True # PERFORMANCE TESTS def NAME ( ) -> NAME : # Test cache performance under load pass return True def NAME ( ) -> NAME : # Test thread-safe cache operations pass return True def NAME ( ) -> NAME : # Test memory usage and cleanup pass return True # INTEGRATION TESTS def NAME ( ) -> NAME : # Test cache integration with database pass return True def NAME ( ) -> NAME : # Test cache integration with API calls pass return True def NAME ( ) -> NAME : # Test cache session handling pass return True # ERROR HANDLING TESTS def NAME ( ) -> NAME : # Test cache error scenarios pass return True def NAME ( ) -> NAME : # Test cache recovery after failures pass return True def NAME ( ) -> NAME : # Test handling of corrupted cache data pass return True # SECURITY TESTS def NAME ( ) -> NAME : # Test encrypted cache storage pass return True def NAME ( ) -> NAME : # Test cache access permissions pass return True def NAME ( ) -> NAME : # Test cache operation logging pass return True # CONFIGURATION TESTS def NAME ( ) -> NAME : # Test cache configuration pass return True def NAME ( ) -> NAME : # Test cache behavior in different environments pass return True def NAME ( ) -> NAME : # Test cache feature flags pass return True # Create test suite and run tests NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # Run tests using the suite's run_test method NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT ) # Complete the test suite return NAME . NAME ( )"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_cache_manager_initialization",
      "lineno": 523,
      "end_lineno": 531,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "bdcb4aa5621ac6ba3989dc7db50a6e81e350618d",
      "simhash64": 8641277416230000163,
      "normalized": "def NAME ( ) -> NAME : # Test cache manager initialization if NAME ( LIT ) : NAME = NAME ( LIT ) if NAME : NAME = NAME ( ) assert NAME is not None # suite.log_test_result(True, \"Cache manager created successfully\") return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_cache_operations",
      "lineno": 535,
      "end_lineno": 545,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "1f9ece1544cf3abd63ff6595a907f5aa4843c240",
      "simhash64": 8641277450522105387,
      "normalized": "def NAME ( ) -> NAME : # Test basic cache operations if NAME ( LIT ) : NAME = NAME ( LIT ) if NAME : NAME = NAME ( ) # Test set and get operations NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT ) assert NAME == LIT return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_cache_statistics",
      "lineno": 547,
      "end_lineno": 550,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "58d6e38a5df3926b6911d7c5ebf3e565f39cfbc6",
      "simhash64": 14405524834643514467,
      "normalized": "def NAME ( ) -> NAME : # Test cache statistics collection pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_cache_invalidation",
      "lineno": 552,
      "end_lineno": 555,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "5a25e841704eeb968f0b2dd430fcfa910e954ad0",
      "simhash64": 7452037374767174723,
      "normalized": "def NAME ( ) -> NAME : # Test cache invalidation patterns pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_eviction_policies",
      "lineno": 559,
      "end_lineno": 571,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "e7bfd0a12f26d5ea9b5c22c7e5cf4d0540ba0567",
      "simhash64": 7487792995960788011,
      "normalized": "def NAME ( ) -> NAME : # Test cache eviction when full if NAME ( LIT ) : NAME = NAME ( LIT ) if NAME : NAME = NAME ( NAME = LIT ) NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) # Should evict key1 NAME = NAME . NAME ( LIT ) # Oldest key should be evicted assert NAME is None or NAME == LIT return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_performance_monitoring",
      "lineno": 573,
      "end_lineno": 580,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "9558dad9783d26f2ef118592c8b4dc7cd888539a",
      "simhash64": 8641277970280780843,
      "normalized": "def NAME ( ) -> NAME : # Test performance monitoring features if NAME ( LIT ) : NAME = NAME ( LIT ) if NAME : NAME ( ) # Test performance tracking return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_cache_performance",
      "lineno": 584,
      "end_lineno": 587,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d4668b0ebfcd383cc657f468acf4ab22092f60e3",
      "simhash64": 5183349272932701267,
      "normalized": "def NAME ( ) -> NAME : # Test cache performance under load pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_concurrent_access",
      "lineno": 589,
      "end_lineno": 592,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "1e71ea554c7992c114433759cba6f1e7143215f4",
      "simhash64": 7486095851178071107,
      "normalized": "def NAME ( ) -> NAME : # Test thread-safe cache operations pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_memory_management",
      "lineno": 594,
      "end_lineno": 597,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "98220a1dd0b8db64fe3840c995a5d298c2b317f2",
      "simhash64": 8064808403361240675,
      "normalized": "def NAME ( ) -> NAME : # Test memory usage and cleanup pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_database_integration",
      "lineno": 601,
      "end_lineno": 604,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "c4266b1588aeb8c6bd5767dad10ab2edba365530",
      "simhash64": 7488286284566148723,
      "normalized": "def NAME ( ) -> NAME : # Test cache integration with database pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_api_integration",
      "lineno": 606,
      "end_lineno": 609,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "1113c38d98aae8d27ea28c268a2471a32e6938da",
      "simhash64": 7487995876057454147,
      "normalized": "def NAME ( ) -> NAME : # Test cache integration with API calls pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_session_management",
      "lineno": 611,
      "end_lineno": 614,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "2d13d631304936bc62fcf8be351871b973da1ff5",
      "simhash64": 7488075109614130259,
      "normalized": "def NAME ( ) -> NAME : # Test cache session handling pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_error_handling",
      "lineno": 618,
      "end_lineno": 621,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "f41bca6c23555194bbe44479911b6a8cff32e491",
      "simhash64": 5146203165924693077,
      "normalized": "def NAME ( ) -> NAME : # Test cache error scenarios pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_recovery_mechanisms",
      "lineno": 623,
      "end_lineno": 626,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "619e741c6387f4c5bd50cd6b4742f428780361a9",
      "simhash64": 16675409501741831523,
      "normalized": "def NAME ( ) -> NAME : # Test cache recovery after failures pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_data_corruption_handling",
      "lineno": 628,
      "end_lineno": 631,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "b587386f13fcb858bd93c757f2dc5baf38062d39",
      "simhash64": 8029628493466338387,
      "normalized": "def NAME ( ) -> NAME : # Test handling of corrupted cache data pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_data_encryption",
      "lineno": 635,
      "end_lineno": 638,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "66571c7b0fcc7d5d746e9ea565eb469d7429469e",
      "simhash64": 7452318373003564097,
      "normalized": "def NAME ( ) -> NAME : # Test encrypted cache storage pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_access_control",
      "lineno": 640,
      "end_lineno": 643,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "1ea35f376a0312609b5c0fabd828f11e080eb6de",
      "simhash64": 5146484159881843781,
      "normalized": "def NAME ( ) -> NAME : # Test cache access permissions pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_audit_logging",
      "lineno": 645,
      "end_lineno": 648,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "0b65cc73f1807fe1d2805e9e661aa206d5f72e84",
      "simhash64": 5144224251170952275,
      "normalized": "def NAME ( ) -> NAME : # Test cache operation logging pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_configuration_loading",
      "lineno": 652,
      "end_lineno": 655,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "80d7b945bbb665f0fc0fce19c5613f249ae41057",
      "simhash64": 14369566612862702675,
      "normalized": "def NAME ( ) -> NAME : # Test cache configuration pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_environment_adaptation",
      "lineno": 657,
      "end_lineno": 660,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "1269dca15f111ecb4475d3bc2e98e2db338591c3",
      "simhash64": 7452006729874576449,
      "normalized": "def NAME ( ) -> NAME : # Test cache behavior in different environments pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "test_feature_toggles",
      "lineno": 662,
      "end_lineno": 665,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "6194ee35f8c92111b81d0ab3fb50d866eb92c7ee",
      "simhash64": 5179909995998647393,
      "normalized": "def NAME ( ) -> NAME : # Test cache feature flags pass return True"
    },
    {
      "module_path": "cache_manager.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 754,
      "end_lineno": 756,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "reset_preferences_file",
      "lineno": 73,
      "end_lineno": 119,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 47,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "e1f909371891ce5917eae11bae29dc4a8c10fd2e",
      "simhash64": 3422133213688403499,
      "normalized": "def NAME ( ) -> None : LIT try : # Create the directory if it does not exist from NAME import NAME NAME ( NAME ) . NAME ( NAME = True , NAME = True ) NAME = { LIT : { LIT : LIT , LIT : True } , LIT : { LIT : True , LIT : { LIT : LIT , LIT : LIT , LIT : False , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } , } , LIT : { LIT : { LIT : False , LIT : True , LIT : True , LIT : False , LIT : False , } } , LIT : { LIT : False } , LIT : { LIT : { LIT : True } } , LIT : { LIT : LIT , LIT : [ ] } , } try : from NAME import NAME NAME ( NAME ) . NAME ( LIT , NAME = LIT ) . NAME ( NAME . NAME ( NAME , NAME = LIT ) ) except NAME as NAME : NAME . NAME ( f\" IOError writing Preferences file: { NAME } \" , NAME = True ) raise except NAME as NAME : NAME . NAME ( f\" OSError creating directory: { NAME } \" , NAME = True ) raise except NAME as NAME : NAME . NAME ( f\" Unexpected error in reset_preferences_file: { NAME } \" , NAME = True ) raise"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "set_win_size",
      "lineno": 125,
      "end_lineno": 144,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(driver)",
      "fingerprint": "8cfde975655b23e574dc640e9fa862d3ebdabcf7",
      "simhash64": 7452080858290631699,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT try : # Get screen dimensions NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) # Calculate window size and position for the right half of the screen NAME = NAME // LIT NAME = NAME ( NAME * LIT ) # % of screen height (using 96.5% as per prev version) NAME = NAME // LIT # Position on the right NAME = LIT # Position at the top NAME . NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) except NAME as NAME : NAME . NAME ( f\" Failed to set window size and position: { NAME } \" , NAME = True )"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "close_tabs",
      "lineno": 150,
      "end_lineno": 164,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(driver)",
      "fingerprint": "9063886f70981a1ed37185e52aae240e23a48bdf",
      "simhash64": 8640538577700566019,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT NAME . NAME ( LIT ) try : while NAME ( NAME . NAME ) > LIT : NAME . NAME . NAME ( NAME . NAME [ - LIT ] ) NAME . NAME ( ) NAME . NAME . NAME ( NAME . NAME [ LIT ] ) # Switch back to the first tab NAME . NAME ( LIT ) except NAME : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error in close_tabs: { NAME } \" , NAME = True )"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "init_webdvr",
      "lineno": 170,
      "end_lineno": 380,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 29,
      "loc": 211,
      "tags": [
        "impure",
        "network",
        "filesystem",
        "randomness",
        "time",
        "size:large"
      ],
      "signature": "(attach_attempt)",
      "fingerprint": "83f7a37b8b1605a4e31f13bfa94feef4cccaa37d",
      "simhash64": 7488215207352112155,
      "normalized": "def NAME ( NAME = False ) -> NAME [ NAME ] : LIT NAME = NAME . NAME # Use selenium config instance # --- 1. Pre-Initialization Cleanup --- NAME ( ) # Kill existing processes NAME ( ) # Reset Chrome preferences # --- Retry Loop --- NAME = NAME . NAME NAME = NAME . NAME NAME = None for NAME in NAME ( LIT , NAME + LIT ) : NAME . NAME ( f\" WebDriver initialization attempt { NAME } / { NAME } ... \" ) # --- Create FRESH Options object INSIDE the loop --- NAME = NAME . NAME ( ) # --- Configure Options --- if NAME . NAME : NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME = NAME . NAME if NAME : NAME = NAME ( NAME . NAME ( ) ) NAME . NAME ( f\" --user-data-dir= { NAME } \" ) NAME . NAME ( f\" User data directory (no --profile-directory):\\n { NAME } \" ) # Removed --profile-directory option for correct Chrome profile persistence # profile_dir_str = config.PROFILE_DIR # if profile_dir_str: #     options.add_argument(f\"--profile-directory={profile_dir_str}\") #     logger.debug(f\"Using profile directory: {profile_dir_str}\") NAME = NAME . NAME if NAME : NAME = NAME ( NAME . NAME ( ) ) from NAME import NAME if NAME ( NAME ) . NAME ( ) : NAME . NAME = NAME NAME . NAME ( f\" Using browser executable:\\n { NAME } \" ) else : NAME . NAME ( f\" Specified browser path not found: { NAME } . Relying on system default. \" ) else : NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) if not NAME . NAME : NAME . NAME ( LIT ) NAME = NAME . NAME ( NAME ( NAME , LIT , [ LIT ] , ) ) NAME . NAME ( f\" --user-agent= { NAME } \" ) NAME . NAME ( f\" Setting User-Agent:\\n { NAME } \" ) NAME . NAME ( LIT ) # --- End Configure Options --- # --- Attempt Driver Initialization --- try : # Use standard Selenium WebDriver with automatic ChromeDriver management NAME . NAME ( LIT ) try : NAME . NAME ( f\" [init_webdvr] Attempting Chrome WebDriver initialization (attempt { NAME } )... \" ) NAME = NAME . NAME ( ) # Use undetected_chromedriver for anti-bot protection # Target Chrome v138 specifically for compatibility NAME = NAME . NAME ( NAME = NAME , NAME = LIT ) NAME . NAME ( f\" [init_webdvr] Chrome WebDriver initialization succeeded in { NAME . NAME ( ) - NAME : .2f } s (attempt { NAME } ) \" ) NAME . NAME ( f\" WebDriver instance object created successfully (attempt { NAME } ). \" ) except NAME as NAME : NAME . NAME ( f\" [init_webdvr] Chrome WebDriver initialization failed on attempt { NAME } : { NAME } \" , NAME = True , ) if ( LIT in NAME ( NAME ) . NAME ( ) or LIT in NAME ( NAME ) . NAME ( ) ) : NAME . NAME ( LIT ) # undetected_chromedriver handles driver management automatically NAME . NAME ( LIT ) NAME = None # Only proceed with driver setup if driver is not None if NAME is not None : # Post-Initialization Settings (still within the inner try) try : NAME . NAME ( LIT , { LIT : NAME } ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" CDP command failed: { NAME } \" ) if not NAME . NAME : NAME . NAME ( LIT ) try : NAME . NAME ( ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Could not minimize window: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Unexpected error minimizing window: { NAME } \" , NAME = True , ) NAME . NAME ( NAME . NAME ) NAME . NAME ( NAME ( NAME , LIT , LIT ) ) # Check for extra tabs immediately after init try : if NAME ( NAME . NAME ) > LIT : NAME . NAME ( f\" Multiple tabs ( { NAME ( NAME . NAME ) } ) detected immediately after init. Closing extras. \" ) NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error checking/closing tabs immediately after init: { NAME } \" ) NAME . NAME ( f\" WebDriver instance fully configured successfully (attempt { NAME } ). \" ) return NAME # SUCCESS! # --- Handle Specific Exceptions During Outer Initialization Attempt --- except NAME as NAME : NAME . NAME ( f\" Timeout during WebDriver init attempt { NAME } : { NAME } \" ) if NAME : with NAME . NAME ( NAME ) : NAME . NAME ( ) NAME = None except NAME as NAME : # Catches errors before/during webdriver.Chrome call NAME = NAME ( NAME ) . NAME ( ) if LIT in NAME or LIT in NAME : NAME . NAME ( f\" Failed to connect/start Chrome (attempt { NAME } ): { NAME } \" ) elif LIT in NAME : NAME . NAME ( f\" ChromeDriver/Chrome version mismatch (attempt { NAME } ): { NAME } . \" ) elif LIT in NAME and LIT in NAME : NAME . NAME ( f\" Service executable exited unexpectedly (Attempt { NAME } ): { NAME } \" ) else : NAME . NAME ( f\" WebDriverException during init attempt { NAME } : { NAME } \" ) if NAME : with NAME . NAME ( NAME ) : NAME . NAME ( ) NAME = None except NAME as NAME : # Catch-all for other unexpected errors NAME . NAME ( f\" Unexpected error during WebDriver init attempt { NAME } : { NAME } \" , NAME = True , ) if NAME : with NAME . NAME ( NAME ) : NAME . NAME ( ) NAME = None # --- Wait Before Retrying --- if NAME < NAME : NAME . NAME ( f\" Waiting { NAME } seconds before retrying initialization... \" ) NAME . NAME ( NAME ) else : NAME . NAME ( f\" Failed to initialize WebDriver after { NAME } attempts. \" ) return None NAME . NAME ( LIT ) return None"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "cleanup_webdrv",
      "lineno": 386,
      "end_lineno": 412,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 27,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ebe492a49fe6f648efb85e21001a9583fccae876",
      "simhash64": 5145886009718117419,
      "normalized": "def NAME ( ) -> None : LIT try : # Kill all Chrome processes. if NAME . NAME == LIT : # Windows NAME . NAME ( [ LIT , LIT , LIT , LIT , LIT ] , NAME = False , NAME = True , ) NAME = NAME . NAME ( [ LIT , LIT , LIT , LIT ] , NAME = False , NAME = True , NAME = True ) if NAME . NAME == LIT : NAME . NAME ( f\" Cleaned { NAME . NAME . NAME ( LIT ) } chrome processes. \" ) else : # Linux/macOS # pkill is more reliable than killall on some systems. NAME . NAME ( [ LIT , LIT , LIT ] , NAME = False ) NAME . NAME ( [ LIT , LIT , LIT ] , NAME = False ) # Kill Chrome itself except NAME as NAME : NAME . NAME ( f\" Error during cleanup: { NAME } \" , NAME = True )"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "test_preferences_file",
      "lineno": 423,
      "end_lineno": 446,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 24,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "json",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7aa137e5d9787d70ff6032584cd32edea37527bc",
      "simhash64": 8641136711960003643,
      "normalized": "def NAME ( ) -> NAME : LIT NAME ( LIT ) try : NAME ( ) from NAME import NAME if NAME ( NAME ) . NAME ( ) : NAME ( f\" \u2713 Preferences file created successfully at: { NAME } \" ) # Verify the file contains valid JSON from NAME import NAME with NAME ( NAME ) . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( NAME ) if NAME ( NAME , NAME ) and LIT in NAME : NAME ( LIT ) else : NAME ( LIT ) else : NAME ( f\" \u2717 Failed to create preferences file at: { NAME } \" ) return True except NAME as NAME : NAME ( f\" \u2717 Error in test_preferences_file: { NAME } \" ) return False"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "test_cleanup",
      "lineno": 449,
      "end_lineno": 501,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 9,
      "loc": 53,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "25186c91a4c63a7bfb767946e9d1fcf6ffb5a34b",
      "simhash64": 7452291963516524091,
      "normalized": "def NAME ( ) -> NAME : LIT NAME ( LIT ) try : # First check if any Chrome processes are running NAME = False if NAME . NAME == LIT : # Windows try : NAME = NAME . NAME ( [ LIT , LIT , LIT ] , NAME = True , NAME = True , NAME = False , ) NAME = LIT in NAME . NAME except NAME as NAME : NAME ( f\" Warning: Could not check for Chrome processes: { NAME } \" ) NAME ( f\" Chrome processes { LIT if NAME else LIT } before cleanup \" ) # Run the cleanup function NAME ( ) NAME ( LIT ) # Check again after cleanup if NAME . NAME == LIT : # Windows try : NAME = NAME . NAME ( [ LIT , LIT , LIT ] , NAME = True , NAME = True , NAME = False , ) NAME = LIT in NAME . NAME if NAME and not NAME : NAME ( LIT ) elif not NAME : NAME ( LIT ) else : NAME ( LIT ) except NAME as NAME : NAME ( f\" Warning: Could not check for Chrome processes after cleanup: { NAME } \" ) return True except NAME as NAME : NAME ( f\" \u2717 Error in test_cleanup: { NAME } \" ) return False"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "test_driver_initialization",
      "lineno": 504,
      "end_lineno": 576,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 9,
      "loc": 73,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(headless)",
      "fingerprint": "394503fb0215b5ad7b2c12619cc04da965dcf862",
      "simhash64": 8623087129078445115,
      "normalized": "def NAME ( NAME : NAME = True ) -> NAME : LIT NAME ( LIT ) NAME = None try : # Note: Cannot modify config_schema directly as it's immutable NAME ( f\" Initializing WebDriver (headless= { NAME } )... \" ) NAME = NAME . NAME ( ) NAME = NAME ( ) NAME = NAME . NAME ( ) - NAME if NAME : NAME ( f\" \u2713 WebDriver initialized successfully in { NAME : .2f } seconds \" ) # Test navigation try : NAME ( LIT ) NAME . NAME ( NAME . NAME . NAME ) NAME ( f\" \u2713 Successfully navigated to { NAME . NAME . NAME } \" ) NAME ( f\" Page title: { NAME . NAME } \" ) except NAME as NAME : NAME ( f\" \u2717 Navigation failed: { NAME } \" ) # Test window management try : NAME ( LIT ) NAME ( NAME ) NAME = NAME . NAME ( ) NAME ( f\" \u2713 Window size set: { NAME [ LIT ] } x { NAME [ LIT ] } at position ( { NAME [ LIT ] } , { NAME [ LIT ] } ) \" ) except NAME as NAME : NAME ( f\" \u2717 Window management failed: { NAME } \" ) # Test closing tabs try : NAME ( LIT ) # Open a new tab NAME . NAME ( LIT ) NAME = NAME ( NAME . NAME ) NAME ( f\" Created new tab. Total tabs: { NAME } \" ) # Close extra tabs NAME ( NAME ) NAME = NAME ( NAME . NAME ) if NAME == LIT : NAME ( LIT ) else : NAME ( f\" \u2717 Failed to close all extra tabs. Remaining: { NAME } \" ) except NAME as NAME : NAME ( f\" \u2717 Tab management failed: { NAME } \" ) # Clean up NAME ( LIT ) NAME . NAME ( ) NAME ( LIT ) # Note: Cannot restore original headless mode as config is immutable return True NAME ( LIT ) # Note: Cannot restore original headless mode as config is immutable return False except NAME as NAME : NAME ( f\" \u2717 Error in test_driver_initialization: { NAME } \" ) if NAME : try : NAME . NAME ( ) NAME ( LIT ) except NAME : pass # Note: Cannot restore original headless mode as config is immutable return False"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "run_all_tests",
      "lineno": 579,
      "end_lineno": 628,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 50,
      "tags": [
        "impure",
        "network",
        "filesystem",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(interactive)",
      "fingerprint": "59d9acee9ac1c908c0a210b3eaa7d2aa95b7a74d",
      "simhash64": 7488215207353160763,
      "normalized": "def NAME ( NAME : NAME = False ) -> NAME : LIT NAME ( LIT ) NAME ( f\" Date/Time: { NAME . NAME ( LIT ) } \" ) NAME ( f\" Python Version: { NAME . NAME . NAME ( ) [ LIT ] } \" ) NAME ( f\" OS: { NAME . NAME . NAME ( ) } \" ) # Configuration info NAME ( LIT ) NAME ( f\" CHROME_USER_DATA_DIR: { NAME } \" ) NAME ( f\" DEFAULT_PROFILE_PATH: { NAME } \" ) NAME ( f\" HEADLESS_MODE: { NAME . NAME . NAME } \" ) NAME ( f\" CHROME_MAX_RETRIES: { NAME . NAME . NAME } \" ) NAME ( f\" CHROME_BROWSER_PATH: { NAME . NAME . NAME } \" ) NAME ( f\" CHROME_DRIVER_PATH: { NAME . NAME . NAME } \" ) # Run tests NAME = { } # Preferences File NAME [ LIT ] = NAME ( ) # Cleanup NAME [ LIT ] = NAME ( ) # Driver Initialization (always headless for automated testing) NAME [ LIT ] = NAME ( NAME = True ) # Summary NAME ( LIT ) NAME = NAME ( LIT for NAME in NAME . NAME ( ) if NAME ) NAME = NAME ( NAME ) NAME ( f\" Passed: { NAME } / { NAME } tests ( { NAME / NAME * LIT : .1f } %) \" ) for NAME , NAME in NAME . NAME ( ) : NAME = LIT if NAME else LIT NAME ( f\" { NAME } : { NAME } \" ) # Interactive mode for manual testing if NAME and NAME [ LIT ] : NAME ( LIT ) NAME = ( NAME ( LIT ) . NAME ( ) . NAME ( ) ) if NAME == LIT : NAME ( LIT ) NAME ( NAME = False ) NAME ( LIT ) return NAME ( NAME . NAME ( ) )"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "main",
      "lineno": 636,
      "end_lineno": 659,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 24,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b296e75a04557ee47680d5d8be801b47517ddb61",
      "simhash64": 7451588276074746939,
      "normalized": "def NAME ( ) -> None : LIT import NAME # Import here to avoid potential circular imports # Configure logging NAME ( NAME = LIT ) # Parse command line arguments NAME = False if NAME ( NAME . NAME ) > LIT and NAME . NAME [ LIT ] . NAME ( ) in [ LIT , LIT ] : NAME = True # Run tests try : NAME = NAME ( NAME = NAME ) if NAME : NAME ( LIT ) return LIT NAME ( LIT ) return LIT except NAME as NAME : NAME ( f\" \\nCritical error during testing: { NAME } \" ) NAME . NAME ( f\" Critical error during testing: { NAME } \" , NAME = True ) return LIT"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "test_chromedriver_initialization",
      "lineno": 665,
      "end_lineno": 670,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "e8f5462cb7517494a285d45c5b0295457cd3db9f",
      "simhash64": 6335434407016306211,
      "normalized": "def NAME ( ) -> None : LIT if NAME ( LIT ) : NAME = NAME ( LIT ) # Test that function exists and is callable assert NAME ( NAME )"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "test_preferences_file_reset",
      "lineno": 673,
      "end_lineno": 684,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9fe35fca2b75c7defe5eb5e5124a93962af638a2",
      "simhash64": 7452291930164991035,
      "normalized": "def NAME ( ) -> None : LIT # Test that preference management functions are properly defined NAME = [ LIT , LIT , LIT , ] for NAME in NAME : if NAME in NAME ( ) : NAME = NAME ( ) [ NAME ] assert NAME ( NAME ) , f\" { NAME } should be callable \""
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "test_chrome_process_cleanup",
      "lineno": 687,
      "end_lineno": 699,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ac7f3b87414ceebf12e0576670be108d16d00a8f",
      "simhash64": 7452151225962116219,
      "normalized": "def NAME ( ) -> None : LIT # Test that cleanup functions exist and are properly structured NAME = [ LIT , LIT ] for NAME in NAME : if NAME in NAME ( ) : NAME = NAME ( ) [ NAME ] assert NAME ( NAME ) , f\" { NAME } should be callable \" # Test function signature import NAME NAME = NAME . NAME ( NAME ) assert NAME ( NAME . NAME ) >= LIT , f\" { NAME } should have valid parameters \""
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "test_webdriver_initialization",
      "lineno": 702,
      "end_lineno": 706,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "93bc73707b7ebd528e79a56fca00653a50607aa3",
      "simhash64": 8640714466276578859,
      "normalized": "def NAME ( ) -> None : LIT if NAME ( LIT ) : NAME = NAME ( LIT ) assert NAME ( NAME )"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "test_chrome_options_creation",
      "lineno": 708,
      "end_lineno": 726,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3547b885e96487d0e051c498938b61f639f209af",
      "simhash64": 7488180022980023867,
      "normalized": "def NAME ( ) -> None : LIT try : # This should work with undetected_chromedriver NAME = NAME . NAME ( ) assert NAME is not None , LIT # Test basic option setting NAME . NAME ( LIT ) assert LIT in NAME . NAME , LIT NAME . NAME ( LIT ) return True except NAME as NAME : if LIT in NAME ( NAME ) : raise NAME ( f\" NameError indicates missing undetected_chromedriver import: { NAME } \" ) raise NAME ( f\" Unexpected NameError: { NAME } \" ) except NAME as NAME : raise NAME ( f\" undetected_chromedriver ChromeOptions creation failed: { NAME } \" )"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "chromedriver_module_tests",
      "lineno": 729,
      "end_lineno": 769,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 41,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "390787ecce827d98d70adda9c5c248ef2cf067cc",
      "simhash64": 5163900408160490539,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( LIT , NAME ) NAME . NAME ( ) # Run all tests using the suite NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "chromedriver.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 772,
      "end_lineno": 775,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "043ee952770f33f57268c1e56a4cb157b4aa2180",
      "simhash64": 15555913076875109435,
      "normalized": "def NAME ( ) -> NAME : LIT # Run module tests directly (no unified framework needed) return NAME ( )"
    },
    {
      "module_path": "code_quality_checker.py",
      "qualname": "QualityMetrics.type_hint_coverage",
      "lineno": 56,
      "end_lineno": 60,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "cddad632a566129b5a3826d176efba611a2c6e55",
      "simhash64": 7492120672721089539,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if NAME . NAME == LIT : return LIT return ( NAME . NAME / NAME . NAME ) * LIT"
    },
    {
      "module_path": "code_quality_checker.py",
      "qualname": "QualityMetrics.quality_score",
      "lineno": 63,
      "end_lineno": 75,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "6ce2678b35c6cd58c13955f447e42730524a3585",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if NAME . NAME == LIT : return LIT # Weighted scoring NAME = NAME . NAME NAME = ( NAME . NAME / NAME . NAME ) * LIT NAME = ( NAME . NAME / NAME . NAME ) * LIT NAME = NAME ( NAME . NAME ) * LIT NAME = NAME - NAME - NAME - NAME return NAME ( LIT , NAME ( LIT , NAME ) )"
    },
    {
      "module_path": "code_quality_checker.py",
      "qualname": "CodeQualityChecker.__init__",
      "lineno": 81,
      "end_lineno": 84,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "c6aae3b6664808b1e408dd0d4e084052ef443a4c",
      "simhash64": 7452151226028176407,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME : NAME [ NAME , NAME ] = { }"
    },
    {
      "module_path": "code_quality_checker.py",
      "qualname": "CodeQualityChecker.check_file",
      "lineno": 86,
      "end_lineno": 113,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 28,
      "tags": [
        "impure",
        "filesystem",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self, file_path)",
      "fingerprint": "8614663572406d13c23e85a0ad27ebe0f8acdc12",
      "simhash64": 7488109654235845659,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT try : from NAME import NAME with NAME ( NAME ) . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( ) NAME = NAME . NAME ( NAME ) return NAME . NAME ( NAME , NAME ( NAME ) ) except NAME as NAME : NAME . NAME ( f\" Failed to analyze { NAME } : { NAME } \" ) return NAME ( NAME = NAME ( NAME ) , NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = [ f\" Analysis failed: { NAME } \" ] )"
    },
    {
      "module_path": "code_quality_checker.py",
      "qualname": "CodeQualityChecker._analyze_ast",
      "lineno": 115,
      "end_lineno": 159,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 45,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, tree, file_path)",
      "fingerprint": "2d4f8fa2b74211952f41c68e4ba59c914cd75624",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME , NAME : NAME ) -> NAME : LIT NAME = [ NAME for NAME in NAME . NAME ( NAME ) if NAME ( NAME , NAME . NAME ) ] NAME = NAME ( NAME ) NAME = LIT NAME = LIT NAME = LIT NAME = [ ] for NAME in NAME : # Check type hints (skip test functions) if LIT not in NAME . NAME . NAME ( ) : if NAME . NAME ( NAME ) : NAME += LIT else : NAME . NAME ( f\" Function ' { NAME . NAME } ' missing type hints \" ) else : # Count test functions as having type hints for scoring purposes NAME += LIT # Check function length NAME = NAME . NAME - NAME . NAME if NAME . NAME else LIT if NAME > LIT : NAME += LIT NAME . NAME ( f\" Function ' { NAME . NAME } ' is too long ( { NAME } lines) \" ) # Check complexity (simplified) NAME = NAME . NAME ( NAME ) if NAME > LIT : NAME += LIT NAME . NAME ( f\" Function ' { NAME . NAME } ' is too complex (complexity: { NAME } ) \" ) # Check for mutable defaults if NAME . NAME ( NAME ) : NAME . NAME ( f\" Function ' { NAME . NAME } ' has mutable default arguments \" ) return NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME )"
    },
    {
      "module_path": "code_quality_checker.py",
      "qualname": "CodeQualityChecker._has_type_hints",
      "lineno": 161,
      "end_lineno": 171,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, func)",
      "fingerprint": "6ce69c253941ca00e086876991a4b659653ae34f",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME ) -> NAME : LIT # Check return annotation NAME = NAME . NAME is not None # Check argument annotations NAME = NAME ( NAME . NAME is not None for NAME in NAME . NAME . NAME ) return NAME or NAME"
    },
    {
      "module_path": "code_quality_checker.py",
      "qualname": "CodeQualityChecker._calculate_complexity",
      "lineno": 173,
      "end_lineno": 181,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, func)",
      "fingerprint": "b0526bb4b26d863b0e8fae230c6d232cced3b92e",
      "simhash64": 7488180022980027395,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME ) -> NAME : LIT NAME = LIT # Base complexity for NAME in NAME . NAME ( NAME ) : if NAME ( NAME , ( NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME ) ) : NAME += LIT return NAME"
    },
    {
      "module_path": "code_quality_checker.py",
      "qualname": "CodeQualityChecker._has_mutable_defaults",
      "lineno": 183,
      "end_lineno": 188,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, func)",
      "fingerprint": "f019f4c79a71d167232863357f169bf45af214cb",
      "simhash64": 7487617073026606083,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME ) -> NAME : LIT return NAME ( NAME ( NAME , ( NAME . NAME , NAME . NAME , NAME . NAME ) ) for NAME in NAME . NAME . NAME )"
    },
    {
      "module_path": "code_quality_checker.py",
      "qualname": "CodeQualityChecker.check_directory",
      "lineno": 190,
      "end_lineno": 223,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 34,
      "tags": [
        "impure",
        "filesystem",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, directory, exclude_patterns)",
      "fingerprint": "bc48d3aedf737d6c8874b85c09780a1f039207bf",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] | None = None ) -> NAME [ NAME , NAME ] : LIT if NAME is None : NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] NAME = { } for NAME in NAME . NAME ( LIT ) : # Skip hidden files if NAME . NAME . NAME ( LIT ) : continue # Skip excluded directories if NAME ( NAME in NAME ( NAME ) for NAME in NAME ) : continue # Only check files in the root directory or specific subdirectories NAME = NAME . NAME ( NAME ) if NAME ( NAME . NAME ) > LIT : # Skip deeply nested files continue NAME = NAME . NAME ( NAME ) NAME [ NAME ( NAME ) ] = NAME return NAME"
    },
    {
      "module_path": "code_quality_checker.py",
      "qualname": "CodeQualityChecker.generate_report",
      "lineno": 225,
      "end_lineno": 265,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 9,
      "loc": 41,
      "tags": [
        "impure",
        "filesystem",
        "size:medium"
      ],
      "signature": "(self, metrics)",
      "fingerprint": "9c5fbc15c47ed43de6391935eaa5c817b5511746",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT if not NAME : return LIT NAME = NAME ( NAME ) NAME = NAME ( NAME . NAME for NAME in NAME . NAME ( ) ) NAME = NAME ( NAME . NAME for NAME in NAME . NAME ( ) ) / NAME NAME = NAME ( NAME . NAME for NAME in NAME . NAME ( ) ) / NAME NAME = [ LIT , LIT * LIT , f\" \ud83d\udcc1 Files analyzed: { NAME } \" , f\" \ud83d\udd27 Total functions: { NAME } \" , f\" \ud83d\udcdd Average type hint coverage: { NAME : .1f } % \" , f\" \u2b50 Average quality score: { NAME : .1f } /100 \" , LIT , LIT , LIT * LIT , ] # Sort by quality score (lowest first) NAME = NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ LIT ] . NAME ) for NAME , NAME in NAME : NAME = NAME ( NAME ) . NAME NAME . NAME ( f\" \ud83d\udcc4 { NAME } \" ) NAME . NAME ( f\" Quality Score: { NAME . NAME : .1f } /100 \" ) NAME . NAME ( f\" Type Hints: { NAME . NAME : .1f } % \" ) NAME . NAME ( f\" Functions: { NAME . NAME } \" ) if NAME . NAME : NAME . NAME ( LIT ) for NAME in NAME . NAME [ : LIT ] : # Show first 3 violations NAME . NAME ( f\" \u2022 { NAME } \" ) if NAME ( NAME . NAME ) > LIT : NAME . NAME ( f\" \u2022 ... and { NAME ( NAME . NAME ) - LIT } more \" ) NAME . NAME ( LIT ) return LIT . NAME ( NAME )"
    },
    {
      "module_path": "code_quality_checker.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 270,
      "end_lineno": 317,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 48,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "bf767c0cf5ef7c0d728302a138acea1ce17bf092",
      "simhash64": 5145886005356041259,
      "normalized": "def NAME ( ) -> NAME : LIT try : from NAME import NAME NAME = NAME ( LIT , LIT ) def NAME ( ) -> None : LIT NAME = NAME ( NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = [ LIT ] ) assert NAME . NAME == LIT assert LIT <= NAME . NAME <= LIT def NAME ( ) -> None : LIT NAME = NAME ( ) assert NAME ( NAME . NAME , NAME ) assert NAME ( NAME . NAME , NAME ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) return NAME . NAME ( ) except NAME : NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "code_quality_checker.py",
      "qualname": "test_quality_metrics",
      "lineno": 277,
      "end_lineno": 289,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "aa60abfb8792446097d6e1ca6f29523724c52ca7",
      "simhash64": 5146448955376571451,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = [ LIT ] ) assert NAME . NAME == LIT assert LIT <= NAME . NAME <= LIT"
    },
    {
      "module_path": "code_quality_checker.py",
      "qualname": "test_checker_initialization",
      "lineno": 291,
      "end_lineno": 295,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "ce7eee9a27b1aee6a93e807e00644e477b21ec7a",
      "simhash64": 8641136678672966691,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) assert NAME ( NAME . NAME , NAME ) assert NAME ( NAME . NAME , NAME )"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_safe_read",
      "lineno": 127,
      "end_lineno": 131,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "impure",
        "filesystem",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(path)",
      "fingerprint": "a1c2865094b87cdf5087dd0fd443d1ff76fa30d0",
      "simhash64": 8641233440058807299,
      "normalized": "def NAME ( NAME : NAME ) -> NAME | None : try : return NAME . NAME ( NAME = LIT ) except ( NAME , NAME ) : return None"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_end_lineno",
      "lineno": 134,
      "end_lineno": 135,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(node)",
      "fingerprint": "14bfa9833a2f7ca44bf71c3f3b7f73c9668b0960",
      "simhash64": 7487757811589223467,
      "normalized": "def NAME ( NAME : NAME . NAME ) -> NAME : return NAME ( NAME , LIT , NAME ( NAME , LIT , LIT ) )"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_rough_complexity",
      "lineno": 138,
      "end_lineno": 144,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(node)",
      "fingerprint": "6446514e0578df597172f5e643f6461349df15f2",
      "simhash64": 7488109654235849731,
      "normalized": "def NAME ( NAME : NAME . NAME ) -> NAME : # simple proxy: 1 + decision points NAME = LIT for NAME in NAME . NAME ( NAME ) : if NAME ( NAME , ( NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME ) ) : NAME += LIT return NAME"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_collect_tags",
      "lineno": 147,
      "end_lineno": 197,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 23,
      "loc": 51,
      "tags": [
        "impure",
        "network",
        "db",
        "filesystem",
        "logging",
        "randomness",
        "time",
        "regex",
        "json",
        "size:medium"
      ],
      "signature": "(src, node, is_async)",
      "fingerprint": "c071b71b1d3289ece7e66e6f09a84e8f9edfa2a4",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME . NAME , NAME : NAME ) -> NAME [ NAME ] : NAME : NAME [ NAME ] = [ ] if NAME : NAME . NAME ( LIT ) # purity / effects NAME = NAME def NAME ( NAME : NAME ) -> NAME : return NAME . NAME ( rf\" \\b { NAME . NAME ( NAME ) } \\b \" , NAME ) is not None NAME = NAME ( NAME ( NAME ) for NAME in NAME ) if NAME : NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) # Technology/domain tags if NAME ( NAME ( NAME ) for NAME in ( LIT , LIT , LIT , LIT ) ) : NAME . NAME ( LIT ) if NAME ( NAME ( NAME ) for NAME in ( LIT , LIT , LIT ) ) : NAME . NAME ( LIT ) if NAME ( NAME ( NAME ) for NAME in ( LIT , LIT , LIT , LIT ) ) : NAME . NAME ( LIT ) if NAME ( NAME ( NAME ) for NAME in ( LIT , LIT ) ) : NAME . NAME ( LIT ) if NAME ( NAME ( NAME ) for NAME in ( LIT , ) ) : NAME . NAME ( LIT ) if NAME ( NAME ( NAME ) for NAME in ( LIT , LIT ) ) : NAME . NAME ( LIT ) if NAME ( NAME ( NAME ) for NAME in ( LIT , ) ) : NAME . NAME ( LIT ) if NAME ( NAME ( NAME ) for NAME in ( LIT , ) ) : NAME . NAME ( LIT ) # Enhanced semantic classification for DRY analysis NAME . NAME ( NAME ( NAME , NAME ) ) NAME . NAME ( NAME ( NAME , NAME ) ) # size bucket NAME = NAME . NAME ( ) NAME = NAME ( NAME ) if NAME < LIT : NAME . NAME ( LIT ) elif NAME < LIT : NAME . NAME ( LIT ) elif NAME < LIT : NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "has",
      "lineno": 154,
      "end_lineno": 155,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "regex",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(word)",
      "fingerprint": "7efd21b838a5a1f1294d671aa213904dc5769711",
      "simhash64": 8641101528660608019,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : return NAME . NAME ( rf\" \\b { NAME . NAME ( NAME ) } \\b \" , NAME ) is not None"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_classify_function_purpose",
      "lineno": 200,
      "end_lineno": 237,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 18,
      "loc": 38,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "size:medium"
      ],
      "signature": "(src, node)",
      "fingerprint": "5259e220f352f664c05cc78479c5396b3cfe9f11",
      "simhash64": 7487617073093710891,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME . NAME ) -> NAME [ NAME ] : LIT NAME = [ ] NAME = NAME . NAME ( ) . NAME ( ) # Get function name NAME = NAME ( NAME , LIT , LIT ) . NAME ( ) # Test runner pattern if NAME == LIT or LIT in NAME : NAME . NAME ( LIT ) # Initialization pattern if NAME == LIT or NAME . NAME ( LIT ) : NAME . NAME ( LIT ) # Validation pattern if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT ] ) : NAME . NAME ( LIT ) # Formatting pattern if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT ] ) : NAME . NAME ( LIT ) # Factory pattern if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT ] ) : NAME . NAME ( LIT ) # Property getter pattern if ( NAME . NAME ( LIT ) or NAME . NAME ( LIT ) or ( NAME ( NAME ) <= LIT and NAME ( LIT in NAME for NAME in NAME ) ) ) : NAME . NAME ( LIT ) # Stub function pattern (very simple functions) if NAME ( NAME ) <= LIT and NAME ( LIT in NAME for NAME in NAME ) : NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_classify_implementation_pattern",
      "lineno": 240,
      "end_lineno": 261,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 14,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(src, node)",
      "fingerprint": "aa2a30410e9738b8e7c57dbd516918afc49e1adb",
      "simhash64": 7488180023047136291,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME . NAME ) -> NAME [ NAME ] : LIT NAME = [ ] NAME = [ NAME . NAME ( ) for NAME in NAME . NAME ( ) . NAME ( ) if NAME . NAME ( ) ] # Simple delegation pattern if NAME ( NAME ) <= LIT and NAME ( LIT in NAME and LIT in NAME for NAME in NAME ) : NAME . NAME ( LIT ) # Error handling wrapper pattern if LIT in NAME and LIT in NAME and NAME ( NAME ) <= LIT : NAME . NAME ( LIT ) # Simple return pattern if NAME ( NAME ) <= LIT and NAME ( NAME . NAME ( LIT ) for NAME in NAME ) : NAME . NAME ( LIT ) # Empty or pass pattern if NAME ( NAME ) <= LIT and ( LIT in NAME or NAME ( NAME ) == LIT ) : NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_normalize_tokens",
      "lineno": 264,
      "end_lineno": 288,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 8,
      "loc": 25,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(code)",
      "fingerprint": "185ad86ec5f563a292703b11f58cd5e60dd3c875",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : # Replace identifiers and literals with placeholders; keep punctuation/operators/keywords NAME : NAME [ NAME ] = [ ] NAME = NAME ( NAME . NAME ) try : NAME = NAME . NAME ( NAME ) . NAME for NAME in NAME . NAME ( NAME ) : NAME , NAME = NAME . NAME , NAME . NAME if NAME == NAME . NAME : if NAME in NAME : NAME . NAME ( NAME ) else : NAME . NAME ( LIT ) elif NAME in ( NAME . NAME , NAME . NAME ) : NAME . NAME ( LIT ) elif NAME in ( NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME ) : continue else : # keep operators, punctuation NAME = NAME . NAME ( ) if NAME : NAME . NAME ( NAME ) except NAME : return NAME return LIT . NAME ( NAME )"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_simhash64",
      "lineno": 291,
      "end_lineno": 303,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(tokens)",
      "fingerprint": "3741137f0531b6cf17029d3757817d53e5349744",
      "simhash64": 7488180023047132203,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME : # Simple 64-bit simhash NAME = [ LIT ] * LIT for NAME in NAME : NAME = NAME ( NAME . NAME ( NAME . NAME ( LIT ) , NAME = LIT ) . NAME ( ) , LIT ) for NAME in NAME ( LIT ) : NAME = LIT if ( NAME >> NAME ) & LIT else - LIT NAME [ NAME ] += NAME NAME = LIT for NAME in NAME ( LIT ) : if NAME [ NAME ] >= LIT : NAME |= ( LIT << NAME ) return NAME"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_hamming",
      "lineno": 306,
      "end_lineno": 307,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(a, b)",
      "fingerprint": "86168bb7d50ed1d58b0ebcfef19795a28d2c4721",
      "simhash64": 7488215174066644067,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : return ( NAME ^ NAME ) . NAME ( )"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_signature_from_node",
      "lineno": 310,
      "end_lineno": 322,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 7,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(node)",
      "fingerprint": "0d465df0a52fd40fcb872ff3aa15e5ab4cab897c",
      "simhash64": 7487617073026610179,
      "normalized": "def NAME ( NAME : NAME . NAME ) -> NAME [ NAME , NAME , NAME , NAME ] : if not NAME ( NAME , ( NAME . NAME , NAME . NAME ) ) : return LIT , LIT , False , False NAME = NAME . NAME NAME = [ NAME ( NAME , LIT , LIT ) for NAME in NAME ( NAME . NAME ) + NAME ( NAME . NAME ) ] if NAME . NAME : NAME . NAME ( LIT ) if NAME . NAME : NAME . NAME ( [ NAME ( NAME , LIT , LIT ) for NAME in NAME . NAME ] ) if NAME . NAME : NAME . NAME ( LIT ) NAME = f\" ( { LIT . NAME ( NAME ) } ) \" return NAME , NAME ( NAME ) , NAME ( NAME . NAME ) , NAME ( NAME . NAME )"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_FuncVisitor.__init__",
      "lineno": 326,
      "end_lineno": 330,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, module_path, source)",
      "fingerprint": "0070ac14f82fb01456a75a6b05e4dbe7211d8da8",
      "simhash64": 7452080857283998807,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> None : NAME . NAME = NAME NAME . NAME = NAME NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME : NAME [ NAME ] = [ ]"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_FuncVisitor.visit_ClassDef",
      "lineno": 332,
      "end_lineno": 335,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, node)",
      "fingerprint": "7c3e72d8239a3cb0c01d9960fbc9675c206d01e8",
      "simhash64": 7488144838607938643,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME ) -> NAME : # type: ignore[override] NAME . NAME . NAME ( NAME . NAME ) NAME . NAME ( NAME ) NAME . NAME . NAME ( )"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_FuncVisitor.visit_FunctionDef",
      "lineno": 337,
      "end_lineno": 339,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, node)",
      "fingerprint": "ff883d55e9ac9e2312ed8b3c74dd7894da3b98db",
      "simhash64": 7488144838607938643,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME ) -> NAME : # type: ignore[override] NAME . NAME ( NAME , NAME = False ) NAME . NAME ( NAME )"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_FuncVisitor.visit_AsyncFunctionDef",
      "lineno": 341,
      "end_lineno": 343,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, node)",
      "fingerprint": "97c71606e5c53079f0c75bb8dc381d0c9712c086",
      "simhash64": 7488144804248200275,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME ) -> NAME : # type: ignore[override] NAME . NAME ( NAME , NAME = True ) NAME . NAME ( NAME )"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_FuncVisitor._capture",
      "lineno": 345,
      "end_lineno": 382,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 38,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, node, is_async)",
      "fingerprint": "a5e002c07cedc53789b8ae8c48b74e3b982b3102",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME , NAME : NAME ) -> None : try : NAME , NAME = NAME ( NAME , LIT , LIT ) , NAME ( NAME ) NAME = NAME . NAME . NAME ( ) NAME = LIT . NAME ( NAME [ NAME - LIT : NAME ] ) if LIT <= NAME <= NAME ( NAME ) else LIT NAME , NAME , NAME , NAME = NAME ( NAME ) NAME = NAME ( NAME ( NAME , NAME . NAME ) for NAME in NAME . NAME ( NAME ) ) NAME = NAME ( NAME ( NAME , ( NAME . NAME , NAME . NAME ) ) for NAME in NAME . NAME ( NAME ) ) NAME = NAME ( NAME ) NAME = NAME ( NAME , NAME , NAME ) NAME = NAME ( NAME ) NAME = NAME . NAME ( NAME . NAME ( LIT ) ) . NAME ( ) NAME = NAME ( NAME . NAME ( ) ) NAME = ( LIT . NAME ( NAME . NAME ) + LIT if NAME . NAME else LIT ) + NAME ( NAME , LIT , LIT ) NAME = NAME ( NAME = NAME . NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ( NAME . NAME ) , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ( LIT , NAME - NAME + LIT ) , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) NAME . NAME . NAME ( NAME ) except NAME : # best effort; skip broken nodes pass"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier.__init__",
      "lineno": 399,
      "end_lineno": 403,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "impure",
        "filesystem",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, root)",
      "fingerprint": "a8fc0c4fefea8ab253bd1788281cf2f4c73961cf",
      "simhash64": 7453277125935019029,
      "normalized": "def NAME ( NAME , NAME : NAME | None = None ) -> None : LIT NAME . NAME = NAME or NAME ( ) NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME : NAME [ NAME ] = [ ]"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier._iter_py_files",
      "lineno": 405,
      "end_lineno": 412,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 1,
      "complexity": 7,
      "loc": 8,
      "tags": [
        "impure",
        "filesystem",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "e53c54b60459419bdf178d6ab235449ceb02909f",
      "simhash64": 7488109654235849843,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : for NAME in NAME . NAME . NAME ( LIT ) : NAME = NAME ( NAME ) if NAME ( NAME in NAME for NAME in NAME ) : continue if NAME ( NAME . NAME ( NAME ) or ( NAME in NAME ) for NAME in NAME ) : continue yield NAME"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier.scan",
      "lineno": 414,
      "end_lineno": 434,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "d1dfbe0b92f86524b9e0a3157e6db7ef524e5901",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME : NAME [ NAME ] = [ ] for NAME in NAME . NAME ( ) : NAME = NAME ( NAME ) if not NAME : continue try : NAME = NAME . NAME ( NAME ) except NAME : continue NAME = NAME ( NAME ( NAME ) , NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME . NAME ) NAME . NAME = NAME return NAME"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier._bin_key",
      "lineno": 437,
      "end_lineno": 441,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(fi)",
      "fingerprint": "42750a507c40c5a8bb62a21571f669ea07a3c2f7",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME , NAME , NAME ] : # group by async + size + coarse purity bucket NAME = NAME ( ( NAME for NAME in NAME . NAME if NAME . NAME ( LIT ) ) , LIT ) NAME = LIT if LIT in NAME . NAME else LIT return NAME , NAME , NAME . NAME"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier._eligible",
      "lineno": 443,
      "end_lineno": 452,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 7,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, a, b)",
      "fingerprint": "d5c3d802c6db2bb9839753bf49e2e09df2e1b22f",
      "simhash64": 7492120672653980707,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME : if NAME is NAME : return False # Similar size (\u00b130%) if NAME . NAME == LIT or NAME . NAME == LIT : return False if not ( LIT <= NAME . NAME / NAME . NAME <= LIT ) : return False # Avoid comparing a method to a top-level function unless sizes are tiny return not ( NAME . NAME != NAME . NAME and not ( NAME . NAME < LIT and NAME . NAME < LIT ) )"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier.find_similar",
      "lineno": 454,
      "end_lineno": 510,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 11,
      "loc": 57,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, min_ratio, max_hamming)",
      "fingerprint": "6f67d306a67ae8350b9ebbcb70261a07fc1ce5f1",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , NAME : NAME = LIT ) -> NAME [ NAME ] : LIT NAME : NAME [ NAME ] = [ ] if not NAME . NAME : return NAME # index by bins NAME : NAME [ NAME [ NAME , NAME , NAME ] , NAME [ NAME ] ] = { } for NAME , NAME in NAME ( NAME . NAME ) : NAME . NAME ( NAME . NAME ( NAME ) , [ ] ) . NAME ( NAME ) for NAME , NAME in NAME . NAME ( ) : NAME = NAME ( NAME ) if NAME < LIT : continue # Cap worst-case work if NAME > LIT : NAME = NAME [ : LIT ] NAME = NAME ( NAME ) for NAME in NAME ( NAME ) : NAME = NAME . NAME [ NAME [ NAME ] ] for NAME in NAME ( NAME + LIT , NAME ) : NAME = NAME . NAME [ NAME [ NAME ] ] if not NAME . NAME ( NAME , NAME ) : continue NAME = NAME ( NAME . NAME , NAME . NAME ) if NAME > NAME : continue # quick name heuristic: ignore totally different verbs when tiny NAME = NAME . NAME ( None , NAME . NAME . NAME ( LIT ) [ - LIT ] , NAME . NAME . NAME ( LIT ) [ - LIT ] ) . NAME ( ) # detailed ratio on normalized token streams NAME = NAME . NAME ( None , NAME . NAME , NAME . NAME ) . NAME ( ) if NAME >= NAME : # Enhanced analysis for consolidation potential NAME = NAME . NAME ( NAME , NAME , NAME , NAME ) NAME = f\" sequence_match= { NAME : .2f } , simhash_hamming= { NAME } , name_sim= { NAME : .2f } \" NAME . NAME ( NAME ( NAME = NAME [ NAME ] , NAME = NAME [ NAME ] , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME [ LIT ] , NAME = NAME [ LIT ] , NAME = NAME [ LIT ] ) ) # sort high to low NAME . NAME ( NAME = lambda NAME : ( NAME . NAME , - NAME . NAME ) , NAME = True ) NAME . NAME = NAME return NAME"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier._analyze_consolidation_potential",
      "lineno": 512,
      "end_lineno": 544,
      "is_method": true,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 8,
      "loc": 33,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, a, b, ratio, hamming)",
      "fingerprint": "4c526fc618e3b6a9d46c7fbe68d14a6e40622aac",
      "simhash64": 7451729014636844075,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT # Perfect matches (identical code) if NAME >= LIT and NAME == LIT : return { LIT : LIT , LIT : LIT if NAME . NAME . NAME ( LIT ) [ - LIT ] == NAME . NAME . NAME ( LIT ) [ - LIT ] else LIT , LIT : NAME ( NAME . NAME , NAME . NAME ) } # Very similar with same purpose tags NAME = NAME ( NAME for NAME in NAME . NAME if NAME . NAME ( LIT ) ) & NAME ( NAME for NAME in NAME . NAME if NAME . NAME ( LIT ) ) if NAME and NAME >= LIT : return { LIT : LIT , LIT : LIT if NAME ( NAME ) > LIT else LIT , LIT : NAME ( NAME . NAME , NAME . NAME ) } # Similar structure, different details if NAME >= LIT : return { LIT : LIT , LIT : LIT if NAME . NAME > LIT else LIT , LIT : NAME ( NAME . NAME , NAME . NAME ) // LIT } # Default case return { LIT : LIT , LIT : LIT , LIT : NAME ( NAME . NAME , NAME . NAME ) // LIT }"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier.clusters",
      "lineno": 546,
      "end_lineno": 567,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 7,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "c8d0b95c20475d024059d41ce2dd8790cf6e915d",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME [ NAME ] ] : # Build components over function indices using current similar_pairs NAME : NAME [ NAME , NAME ] = { } def NAME ( NAME : NAME ) -> NAME : NAME . NAME ( NAME , NAME ) if NAME [ NAME ] != NAME : NAME [ NAME ] = NAME ( NAME [ NAME ] ) return NAME [ NAME ] def NAME ( NAME : NAME , NAME : NAME ) -> None : NAME , NAME = NAME ( NAME ) , NAME ( NAME ) if NAME != NAME : NAME [ NAME ] = NAME for NAME in NAME . NAME : NAME ( NAME . NAME , NAME . NAME ) NAME : NAME [ NAME , NAME [ NAME ] ] = { } for NAME in NAME ( [ NAME . NAME for NAME in NAME . NAME ] + [ NAME . NAME for NAME in NAME . NAME ] ) : NAME = NAME ( NAME ) NAME . NAME ( NAME , [ ] ) . NAME ( NAME ) return NAME ( NAME . NAME ( ) )"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier.find",
      "lineno": 550,
      "end_lineno": 554,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(x)",
      "fingerprint": "47fd0fc338766db5f523d3959c227dbb2471b789",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : NAME . NAME ( NAME , NAME ) if NAME [ NAME ] != NAME : NAME [ NAME ] = NAME ( NAME [ NAME ] ) return NAME [ NAME ]"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier.union",
      "lineno": 556,
      "end_lineno": 559,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(a, b)",
      "fingerprint": "b83892b100b38cb07ed1c9cad52e32a4c4cfcb2d",
      "simhash64": 7488109620951426131,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : NAME , NAME = NAME ( NAME ) , NAME ( NAME ) if NAME != NAME : NAME [ NAME ] = NAME"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier.get_consolidation_clusters",
      "lineno": 569,
      "end_lineno": 600,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 32,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "375d8012d02f9204bfb455501b6797cb335c3fc3",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME = [ ] NAME = NAME . NAME ( ) for NAME in NAME : if NAME ( NAME ) < LIT : continue # Analyze cluster characteristics NAME = [ NAME . NAME [ NAME ] for NAME in NAME ] # Determine cluster type NAME = NAME . NAME ( NAME ) # Calculate consolidation strategy and savings NAME , NAME = NAME . NAME ( NAME ) # Calculate priority score (higher = more valuable) NAME = NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) ) # Sort by priority (highest first) NAME . NAME ( NAME = lambda NAME : NAME . NAME , NAME = True ) return NAME"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier._determine_cluster_type",
      "lineno": 602,
      "end_lineno": 616,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 5,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, functions)",
      "fingerprint": "fc930d3673fb82f5e20fed6659684b4749943d59",
      "simhash64": 7488180023047140387,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] ) -> NAME : LIT if NAME ( NAME ) < LIT : return LIT # Check if all functions have identical normalized code NAME = NAME [ LIT ] . NAME if NAME ( NAME . NAME == NAME for NAME in NAME ) : return LIT # Check if functions follow a template pattern (same structure, different literals) if NAME . NAME ( NAME ) : return LIT return LIT"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier._is_template_pattern",
      "lineno": 618,
      "end_lineno": 635,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 8,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, functions)",
      "fingerprint": "a11226eadf9d41896f586781c1eb859bdf3d5bfb",
      "simhash64": 7488180023047140395,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] ) -> NAME : LIT if NAME ( NAME ) < LIT : return False # Simple heuristic: if functions have very similar structure but different names/literals # This could be enhanced with more sophisticated AST analysis NAME = NAME [ LIT ] . NAME . NAME ( ) for NAME in NAME [ LIT : ] : NAME = NAME . NAME . NAME ( ) if NAME ( NAME ) != NAME ( NAME ) : return False # Check if structure is same (keywords and operators match) NAME = NAME ( LIT for NAME , NAME in NAME ( NAME , NAME ) if NAME == NAME or ( NAME in [ LIT , LIT ] and NAME in [ LIT , LIT ] ) ) if NAME / NAME ( NAME ) < LIT : return False return True"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier._calculate_cluster_consolidation",
      "lineno": 637,
      "end_lineno": 660,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 11,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, functions)",
      "fingerprint": "2504d7727e07ce223cdeb0eacfea519efa04e637",
      "simhash64": 7487617073093710883,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] ) -> NAME [ NAME , NAME ] : LIT if not NAME : return LIT , LIT NAME = NAME ( NAME . NAME for NAME in NAME ) # Check for common purpose tags NAME = NAME ( NAME [ LIT ] . NAME ) & NAME ( ) . NAME ( * ( NAME . NAME for NAME in NAME [ LIT : ] ) ) NAME = [ NAME for NAME in NAME if NAME . NAME ( LIT ) ] if LIT in NAME and NAME ( NAME ) > LIT : return LIT , NAME - LIT # Keep one implementation if LIT in NAME and NAME ( NAME ) > LIT : return LIT , NAME - LIT if LIT in NAME : return LIT , NAME - LIT if NAME ( NAME ) > LIT : return LIT , NAME // LIT return LIT , NAME // LIT"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier._calculate_priority_score",
      "lineno": 662,
      "end_lineno": 680,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, functions, savings)",
      "fingerprint": "65504089300a103ef54812a4034a599134a5608e",
      "simhash64": 7488109655310644331,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME ) -> NAME : LIT # Base score from savings potential NAME = NAME * NAME ( NAME ) # Bonus for high-value patterns NAME = NAME ( ) . NAME ( * ( NAME . NAME for NAME in NAME ) ) if LIT in NAME : NAME *= LIT # Test runners are high-value targets if LIT in NAME : NAME *= LIT # Stub functions are easy wins # Bonus for large clusters if NAME ( NAME ) > LIT : NAME *= LIT elif NAME ( NAME ) > LIT : NAME *= LIT return NAME"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier.to_json",
      "lineno": 682,
      "end_lineno": 690,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "baa8b02c050c93b7d7d2e07b2d80036ebebbca11",
      "simhash64": 7488180022980023331,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : NAME = NAME . NAME ( ) return { LIT : [ NAME ( NAME ) for NAME in NAME . NAME ] , LIT : [ NAME ( NAME ) for NAME in NAME . NAME ] , LIT : NAME . NAME ( ) , LIT : [ NAME ( NAME ) for NAME in NAME ] , LIT : NAME . NAME ( NAME ) , }"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "CodeSimilarityClassifier._generate_consolidation_summary",
      "lineno": 692,
      "end_lineno": 720,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 7,
      "loc": 29,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, clusters)",
      "fingerprint": "88edd15d01a94ba3f87736269207effcb82cb5bb",
      "simhash64": 7452151226028168243,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] ) -> NAME [ NAME , NAME ] : LIT if not NAME : return { LIT : LIT , LIT : LIT , LIT : [ ] } NAME = NAME ( NAME . NAME for NAME in NAME ) NAME = NAME ( [ NAME for NAME in NAME if NAME . NAME > LIT ] ) # Top recommendations NAME = [ ] for NAME in NAME [ : LIT ] : # Top 10 clusters NAME = [ NAME . NAME [ NAME ] . NAME for NAME in NAME . NAME [ : LIT ] ] if NAME ( NAME . NAME ) > LIT : NAME . NAME ( f\" ... and { NAME ( NAME . NAME ) - LIT } more \" ) NAME . NAME ( { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME , LIT : NAME . NAME , LIT : NAME . NAME } ) return { LIT : NAME , LIT : NAME , LIT : NAME ( NAME ) , LIT : NAME }"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_print_summary",
      "lineno": 725,
      "end_lineno": 769,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 10,
      "loc": 45,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:medium"
      ],
      "signature": "(clsfr, top_n)",
      "fingerprint": "0d4674cfaf33d3a96a6b62a961dde37ec1b84bc5",
      "simhash64": 7470165624470541339,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME = LIT ) -> None : NAME ( LIT ) NAME ( f\" Total functions/methods analyzed: { NAME ( NAME . NAME ) } \" ) # Tag analysis NAME : NAME [ NAME , NAME ] = { } for NAME in NAME . NAME : for NAME in NAME . NAME : NAME [ NAME ] = NAME . NAME ( NAME , LIT ) + LIT NAME = LIT . NAME ( f\" { NAME } : { NAME } \" for NAME , NAME in NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ LIT ] , NAME = True ) [ : LIT ] ) NAME ( f\" Top tags: { NAME } \" ) # Purpose analysis for DRY opportunities NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME . NAME ( LIT ) } if NAME : NAME ( LIT ) for NAME , NAME in NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ LIT ] , NAME = True ) : if NAME > LIT : NAME ( f\" { NAME } : { NAME } functions (potential for consolidation) \" ) # Consolidation analysis NAME = NAME . NAME ( ) NAME = NAME . NAME ( NAME ) NAME ( f\" \\n=== CONSOLIDATION ANALYSIS === \" ) NAME ( f\" Total estimated LOC savings: { NAME [ LIT ] } \" ) NAME ( f\" High-priority clusters: { NAME [ LIT ] } \" ) NAME ( f\" Total consolidation clusters: { NAME [ LIT ] } \" ) NAME ( f\" \\n=== TOP CONSOLIDATION RECOMMENDATIONS === \" ) for NAME , NAME in NAME ( NAME [ LIT ] [ : LIT ] , LIT ) : NAME ( f\" { NAME } . { NAME [ LIT ] . NAME ( ) } - { NAME [ LIT ] } \" ) NAME ( f\" Functions: { LIT . NAME ( NAME [ LIT ] ) } \" ) NAME ( f\" Savings: { NAME [ LIT ] } LOC, Priority: { NAME [ LIT ] : .1f } \" ) NAME ( ) NAME ( f\" === SIMILAR PAIRS DETAILS === \" ) NAME ( f\" Similar pairs found: { NAME ( NAME . NAME ) } (showing top { NAME ( NAME , NAME ( NAME . NAME ) ) } ) \" ) for NAME in NAME . NAME [ : NAME ] : NAME = NAME . NAME [ NAME . NAME ] NAME = NAME . NAME [ NAME . NAME ] NAME ( f\" - { NAME ( NAME . NAME ) . NAME } : { NAME . NAME } <-> { NAME ( NAME . NAME ) . NAME } : { NAME . NAME } \" ) NAME ( f\" { NAME . NAME } | { NAME . NAME } potential, strategy: { NAME . NAME } \" ) NAME ( LIT )"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "_print_detailed_consolidation_report",
      "lineno": 772,
      "end_lineno": 802,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 31,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:medium"
      ],
      "signature": "(clsfr)",
      "fingerprint": "064fdcd31661e5f004514255fcbd5949b813b197",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME = NAME . NAME ( ) for NAME , NAME in NAME ( NAME [ : LIT ] , LIT ) : # Top 20 clusters NAME ( f\" \\n--- CLUSTER { NAME } : { NAME . NAME . NAME ( ) } --- \" ) NAME ( f\" Strategy: { NAME . NAME } \" ) NAME ( f\" Estimated savings: { NAME . NAME } LOC \" ) NAME ( f\" Priority score: { NAME . NAME : .1f } \" ) NAME ( f\" Functions ( { NAME ( NAME . NAME ) } ): \" ) for NAME in NAME . NAME [ : LIT ] : # Show up to 10 functions NAME = NAME . NAME [ NAME ] NAME ( f\" \u2022 { NAME ( NAME . NAME ) . NAME } : { NAME . NAME } ( { NAME . NAME } LOC) \" ) NAME ( f\" Tags: { LIT . NAME ( NAME . NAME [ : LIT ] ) } \" ) if NAME ( NAME . NAME ) > LIT : NAME ( f\" ... and { NAME ( NAME . NAME ) - LIT } more functions \" ) # Show a sample of the code for identical clusters if NAME . NAME == LIT and NAME . NAME : NAME = NAME . NAME [ NAME . NAME [ LIT ] ] NAME ( f\" \\n  Sample code (from { NAME . NAME } ): \" ) # This would need access to the original source code NAME ( f\" Lines { NAME . NAME } - { NAME . NAME } in { NAME ( NAME . NAME ) . NAME } \" ) NAME ( LIT * LIT )"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "main",
      "lineno": 805,
      "end_lineno": 833,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 29,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "json",
        "size:small"
      ],
      "signature": "(argv)",
      "fingerprint": "f5198cd52cd9a48ddd1541d479e7473fd15aa21f",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME [ NAME ] | None = None ) -> NAME : import NAME NAME = NAME . NAME ( NAME = LIT ) NAME . NAME ( LIT , NAME = LIT , NAME = LIT ) NAME . NAME ( LIT , NAME = NAME , NAME = LIT ) NAME . NAME ( LIT , NAME = NAME , NAME = LIT ) NAME . NAME ( LIT , NAME = NAME , NAME = LIT , NAME = LIT ) NAME . NAME ( LIT , NAME = NAME , NAME = LIT , NAME = LIT ) NAME . NAME ( LIT , NAME = LIT , NAME = LIT ) NAME = NAME . NAME ( NAME ) NAME = NAME ( NAME ( NAME . NAME ) ) NAME . NAME ( ) NAME . NAME ( NAME = NAME . NAME , NAME = NAME . NAME ) NAME ( NAME , NAME = NAME . NAME ) if NAME . NAME : NAME ( NAME ) if NAME . NAME : try : NAME = NAME ( NAME . NAME ) NAME . NAME . NAME ( NAME = True , NAME = True ) NAME . NAME ( NAME . NAME ( NAME . NAME ( ) , NAME = LIT ) , NAME = LIT ) NAME ( f\" Saved JSON report to { NAME } \" ) except NAME as NAME : NAME ( f\" Failed to save JSON report: { NAME } \" ) return LIT return LIT"
    },
    {
      "module_path": "code_similarity_classifier.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 838,
      "end_lineno": 863,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 26,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "purpose:test_runner",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "aaa3029495da3158ed1d7724669d3dccf2c87951",
      "simhash64": 7452151225961059387,
      "normalized": "def NAME ( ) -> NAME : LIT try : NAME = NAME ( NAME ( ) ) NAME = NAME . NAME ( ) # Expect a nontrivial codebase: require at least 40 functions discovered assert NAME ( NAME ) >= LIT , f\" Too few functions discovered: { NAME ( NAME ) } \" # Sanity check of fields NAME = NAME [ NAME ( LIT , NAME ( NAME ) - LIT ) ] assert NAME . NAME . NAME ( LIT ) , LIT assert NAME . NAME and NAME ( NAME . NAME , NAME ) assert NAME . NAME >= LIT and NAME . NAME >= LIT # Similarity should find at least a few candidates in a real repo NAME = NAME . NAME ( NAME = LIT , NAME = LIT ) # Not required to be many, but expect at least 1 in a sizable repo assert NAME ( NAME ) >= LIT , LIT # JSON serialization NAME = NAME . NAME ( ) assert LIT in NAME and LIT in NAME and LIT in NAME return True except NAME as NAME : NAME ( f\" TEST FAILURE (code_similarity_classifier): { NAME } \" ) return False except NAME as NAME : NAME ( f\" TEST ERROR (code_similarity_classifier): { NAME } \" ) return False"
    },
    {
      "module_path": "config.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 20,
      "end_lineno": 162,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 13,
      "yield_count": 0,
      "complexity": 11,
      "loc": 143,
      "tags": [
        "impure",
        "logging",
        "regex",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "0c086d7b042ab5fe2200a409ced303cc9f757a2b",
      "simhash64": 7488320726108640291,
      "normalized": "def NAME ( ) -> NAME : LIT try : from NAME import NAME NAME = NAME ( LIT , NAME ) NAME . NAME ( ) def NAME ( ) : LIT try : assert NAME is not None assert NAME ( NAME , LIT ) return True except NAME : return False def NAME ( ) : LIT try : assert NAME is not None assert NAME is not None assert NAME ( NAME , NAME ) return True except NAME : return False def NAME ( ) : LIT try : # Test that config_manager has expected methods assert NAME ( NAME , LIT ) assert NAME ( NAME . NAME ) # Test that get_config returns something NAME = NAME . NAME ( ) assert NAME is not None return True except NAME : return False def NAME ( ) : LIT try : NAME = [ LIT , LIT , LIT ] assert NAME == NAME # Test that all exported items are accessible import NAME NAME = NAME . NAME [ NAME ] for NAME in NAME : assert NAME ( NAME , NAME ) assert NAME ( NAME , NAME ) is not None return True except NAME : return False def NAME ( ) : LIT try : # config_schema should be the result of get_config() assert NAME is not None # Should be some kind of configuration object/dict # At minimum, should be iterable or have attributes try : # Try dict-like access or attribute access assert NAME ( NAME , LIT ) or NAME ( NAME , LIT ) except NAME : # If neither, at least should be a non-empty object assert NAME ( NAME ) != LIT return True except NAME : return False # Run all tests NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) return NAME . NAME ( ) except NAME : NAME ( LIT ) # Basic fallback tests try : assert NAME is not None assert NAME is not None assert NAME is not None assert NAME ( NAME . NAME ) NAME ( LIT ) return True except NAME as NAME : NAME ( f\" \u274c Basic config.py validation failed: { NAME } \" ) return False"
    },
    {
      "module_path": "config.py",
      "qualname": "test_config_manager_import",
      "lineno": 36,
      "end_lineno": 43,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "1b5f134514b5082ea1bc2cd340de31a92eaa8a8f",
      "simhash64": 9216850842180032035,
      "normalized": "def NAME ( ) : LIT try : assert NAME is not None assert NAME ( NAME , LIT ) return True except NAME : return False"
    },
    {
      "module_path": "config.py",
      "qualname": "test_global_instances",
      "lineno": 45,
      "end_lineno": 53,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "246069fe1a2ca26ce9d5b1fd52278f074b5c04dd",
      "simhash64": 8642360432430847507,
      "normalized": "def NAME ( ) : LIT try : assert NAME is not None assert NAME is not None assert NAME ( NAME , NAME ) return True except NAME : return False"
    },
    {
      "module_path": "config.py",
      "qualname": "test_config_manager_functionality",
      "lineno": 55,
      "end_lineno": 68,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "22b6d7fafbcf1aef8c3123d88883930971469d41",
      "simhash64": 8641278515405034615,
      "normalized": "def NAME ( ) : LIT try : # Test that config_manager has expected methods assert NAME ( NAME , LIT ) assert NAME ( NAME . NAME ) # Test that get_config returns something NAME = NAME . NAME ( ) assert NAME is not None return True except NAME : return False"
    },
    {
      "module_path": "config.py",
      "qualname": "test_module_exports",
      "lineno": 70,
      "end_lineno": 85,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "555574b0983fa398544c502659367853f5579a4e",
      "simhash64": 7488180022980031571,
      "normalized": "def NAME ( ) : LIT try : NAME = [ LIT , LIT , LIT ] assert NAME == NAME # Test that all exported items are accessible import NAME NAME = NAME . NAME [ NAME ] for NAME in NAME : assert NAME ( NAME , NAME ) assert NAME ( NAME , NAME ) is not None return True except NAME : return False"
    },
    {
      "module_path": "config.py",
      "qualname": "test_config_schema_validity",
      "lineno": 87,
      "end_lineno": 104,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "e08262970b112e62a77b56be9130280c43704010",
      "simhash64": 9181710453031474731,
      "normalized": "def NAME ( ) : LIT try : # config_schema should be the result of get_config() assert NAME is not None # Should be some kind of configuration object/dict # At minimum, should be iterable or have attributes try : # Try dict-like access or attribute access assert NAME ( NAME , LIT ) or NAME ( NAME , LIT ) except NAME : # If neither, at least should be a non-empty object assert NAME ( NAME ) != LIT return True except NAME : return False"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "get_import_stats",
      "lineno": 39,
      "end_lineno": 52,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "20599d6fec0e549e67a3944fded7a4b2230f1864",
      "simhash64": 7451588277081379883,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT with NAME : return { ** NAME . NAME ( ) , LIT : NAME ( NAME ) , LIT : NAME ( NAME ) , LIT : NAME ( NAME ) , LIT : ( NAME [ LIT ] / NAME ( LIT , NAME [ LIT ] + NAME [ LIT ] ) ) * LIT , }"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "get_project_root",
      "lineno": 55,
      "end_lineno": 97,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 7,
      "loc": 43,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "493d53def334277ce037ecacf31d9aceb33e21d9",
      "simhash64": 7452151225961067547,
      "normalized": "def NAME ( ) -> NAME : LIT global NAME with NAME : if NAME is None : try : # Start from current file and work up NAME = NAME ( NAME ) . NAME ( ) # Look for project markers in order of preference NAME = [ LIT , LIT , LIT , LIT , LIT , ] for NAME in [ NAME . NAME , NAME . NAME . NAME , NAME . NAME . NAME . NAME , ] : for NAME in NAME : if ( NAME / NAME ) . NAME ( ) : NAME = NAME NAME ( f\" Project root identified: { NAME } (marker: { NAME } ) \" ) return NAME # Fallback to current file's parent NAME = NAME . NAME NAME ( f\" Using fallback project root: { NAME } \" ) except NAME as NAME : # Ultimate fallback NAME = NAME . NAME ( ) NAME ( f\" Error determining project root, using CWD: { NAME } \" ) NAME [ LIT ] += LIT return NAME"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "_log_info",
      "lineno": 100,
      "end_lineno": 105,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "impure",
        "logging",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(message)",
      "fingerprint": "d87e6de98edc5d59cc21fc0ebb66af9c1a5c73e8",
      "simhash64": 8641136713032709163,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT try : NAME . NAME ( NAME ) . NAME ( NAME ) except NAME : NAME ( f\" INFO: { NAME } \" )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "_log_warning",
      "lineno": 108,
      "end_lineno": 113,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "impure",
        "logging",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(message)",
      "fingerprint": "e0cbc884f0d112bef5b457d10331d26e5fbe7b31",
      "simhash64": 8641136713032709163,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT try : NAME . NAME ( NAME ) . NAME ( NAME ) except NAME : NAME ( f\" WARNING: { NAME } \" )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "_log_error",
      "lineno": 116,
      "end_lineno": 128,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:small"
      ],
      "signature": "(message)",
      "fingerprint": "72308652c1af25b0a0d8dc47a97a3ac5117dbe82",
      "simhash64": 8604685703548671019,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT try : NAME . NAME ( NAME ) . NAME ( NAME ) NAME . NAME ( { LIT : NAME . NAME ( ) , LIT : NAME , LIT : LIT , } ) except NAME : NAME ( f\" ERROR: { NAME } \" )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "ensure_imports",
      "lineno": 131,
      "end_lineno": 144,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "435bcf4879333ea296a6e831e435be8fa8cad6a1",
      "simhash64": 7488180023047140355,
      "normalized": "def NAME ( ) -> None : LIT global NAME if NAME : return NAME = NAME . NAME ( ) NAME = NAME ( NAME ( ) ) if NAME not in NAME . NAME : NAME . NAME . NAME ( LIT , NAME ) NAME [ LIT ] = NAME . NAME ( ) - NAME NAME [ LIT ] += LIT NAME = True"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "import_context",
      "lineno": 148,
      "end_lineno": 155,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 1,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "29f449a47dc0215b3e44fb54789eb64db9d6847f",
      "simhash64": 8605107915007112225,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME . NAME . NAME ( ) try : NAME ( ) yield finally : NAME . NAME [ : ] = NAME"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "register_function",
      "lineno": 158,
      "end_lineno": 164,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(name, func)",
      "fingerprint": "d391f124ad5d1c58c956ada50bd7c518b916a8f1",
      "simhash64": 7452151227102966883,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT if NAME ( NAME ) : NAME [ NAME ] = NAME NAME [ LIT ] += LIT # Clear cache when registry changes NAME . NAME ( )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "register_many",
      "lineno": 167,
      "end_lineno": 173,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(**kwargs)",
      "fingerprint": "6ce64d415114dfce712fb5b0e5b48746c7758c18",
      "simhash64": 7488180023047140387,
      "normalized": "def NAME ( ** NAME ) -> None : LIT for NAME , NAME in NAME . NAME ( ) : if NAME ( NAME ) : NAME [ NAME ] = NAME NAME [ LIT ] += LIT NAME . NAME ( )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "get_function",
      "lineno": 176,
      "end_lineno": 178,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(name, default)",
      "fingerprint": "60d8cbd04355e362665d816b3123c0e8843d220c",
      "simhash64": 7488320761542644739,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME = None ) -> NAME : LIT return NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "is_function_available",
      "lineno": 181,
      "end_lineno": 189,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(name)",
      "fingerprint": "afaca3d1298097936a009dc37edfc8d2af44cbdc",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if NAME in NAME : NAME [ LIT ] += LIT return NAME [ NAME ] NAME = NAME in NAME and NAME ( NAME [ NAME ] ) NAME [ NAME ] = NAME return NAME"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "call_function",
      "lineno": 192,
      "end_lineno": 196,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(name, *args, **kwargs)",
      "fingerprint": "32950491e24e1091c7225017b923421e4de1daff",
      "simhash64": 7488109654235845747,
      "normalized": "def NAME ( NAME : NAME , * NAME , ** NAME ) -> NAME : LIT if NAME ( NAME ) : return NAME [ NAME ] ( * NAME , ** NAME ) raise NAME ( f\" Function ' { NAME } ' not available in registry \" )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "get_available_functions",
      "lineno": 199,
      "end_lineno": 201,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "224740f71efa4057d0d3d92956ed349b4a73db37",
      "simhash64": 7488180023047139443,
      "normalized": "def NAME ( ) -> NAME [ NAME ] : LIT return [ NAME for NAME in NAME if NAME ( NAME [ NAME ] ) ]"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "auto_register_module",
      "lineno": 204,
      "end_lineno": 230,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 27,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "size:small"
      ],
      "signature": "(module_globals, module_name)",
      "fingerprint": "451e0f8e4694a591a50b2a829473b68891b217b8",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> None : LIT NAME = LIT for NAME , NAME in NAME . NAME ( ) : if NAME ( NAME ) and not NAME . NAME ( LIT ) : NAME ( f\" { NAME } . { NAME } \" , NAME ) NAME += LIT # Also register with simple names for commonly used functions for NAME , NAME in NAME . NAME ( ) : if ( NAME ( NAME ) and not NAME . NAME ( LIT ) and NAME in [ LIT , LIT , LIT , LIT , LIT , LIT , ] ) : NAME ( NAME , NAME )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "standardize_module_imports",
      "lineno": 233,
      "end_lineno": 255,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 23,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7d6d77612ded379d21260adb6163c5cbf7018a67",
      "simhash64": 7487617073026610179,
      "normalized": "def NAME ( ) -> NAME : LIT try : NAME ( ) return True except NAME : # Try common fallback patterns NAME = [ NAME ( NAME ( NAME ) . NAME . NAME ) , NAME ( NAME ( NAME ) . NAME ( ) . NAME . NAME ) , ] for NAME in NAME : try : if NAME not in NAME . NAME : NAME . NAME . NAME ( LIT , NAME ) return True except NAME : continue return False"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "get_stats",
      "lineno": 258,
      "end_lineno": 268,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d74babb0119b97f29b595a099b65ba80f8ecc853",
      "simhash64": 5145745267867685931,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return { ** NAME , LIT : NAME ( NAME ) , LIT : NAME ( NAME ) , LIT : ( NAME [ LIT ] / NAME ( LIT , NAME [ LIT ] + NAME ( NAME ) ) ) * LIT , }"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "get_logger",
      "lineno": 272,
      "end_lineno": 284,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(name)",
      "fingerprint": "78c585217fb232b5778e97d6b7c6fbb7bbaa0d85",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME : NAME [ NAME ] = None ) -> NAME . NAME : LIT try : from NAME import NAME return NAME except NAME : # Fallback logger with basic configuration NAME . NAME ( NAME = NAME . NAME , NAME = LIT , ) return NAME . NAME ( NAME or NAME )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "safe_execute",
      "lineno": 287,
      "end_lineno": 315,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 29,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(func, default_return, suppress_errors, log_errors)",
      "fingerprint": "b375be8ab3eed2a602a86872df9f19aa637d334f",
      "simhash64": 7488180022980547587,
      "normalized": "def NAME ( NAME : NAME [ NAME ] = None , * , NAME : NAME = None , NAME : NAME = True , NAME : NAME = True , ) : LIT def NAME ( NAME : NAME [ ... , NAME ] ) -> NAME [ ... , NAME ] : def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : if NAME : NAME = NAME ( ) NAME . NAME ( f\" Error in { NAME . NAME } : { NAME } \" , NAME = True ) if not NAME : raise return NAME return NAME if NAME is None : return NAME return NAME ( NAME )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "decorator",
      "lineno": 299,
      "end_lineno": 311,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(f)",
      "fingerprint": "03adfa6d144f80f31f55accafa93f3ccbd382319",
      "simhash64": 7488109654235849843,
      "normalized": "def NAME ( NAME : NAME [ ... , NAME ] ) -> NAME [ ... , NAME ] : def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : if NAME : NAME = NAME ( ) NAME . NAME ( f\" Error in { NAME . NAME } : { NAME } \" , NAME = True ) if not NAME : raise return NAME return NAME"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "wrapper",
      "lineno": 300,
      "end_lineno": 309,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 10,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "eaec8895a6e973006b4e395225a82529449c81d9",
      "simhash64": 7488109654235841563,
      "normalized": "def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : if NAME : NAME = NAME ( ) NAME . NAME ( f\" Error in { NAME . NAME } : { NAME } \" , NAME = True ) if not NAME : raise return NAME"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "cleanup_registry",
      "lineno": 318,
      "end_lineno": 328,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "a0ce4a661fbd309909456b3ac763574a718002e0",
      "simhash64": 7457349683710957099,
      "normalized": "def NAME ( ) -> None : LIT global NAME NAME . NAME ( ) NAME . NAME ( ) NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , }"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "core_imports_module_tests",
      "lineno": 331,
      "end_lineno": 379,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 49,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "4685572c88ffcd22f4c049907a0d5e0e1cfa790b",
      "simhash64": 7452327148895245355,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Test 1: Function registration and retrieval def NAME ( NAME : NAME ) -> NAME : return NAME * LIT NAME ( LIT , NAME ) assert NAME ( LIT ) , LIT assert NAME ( LIT , LIT ) == LIT , LIT # Test 2: Auto-registration NAME = { LIT : lambda : LIT , LIT : lambda : LIT } NAME ( NAME , LIT ) assert NAME ( LIT ) , LIT # Test 3: Performance caching NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( LIT ) NAME = NAME . NAME ( ) - NAME NAME = NAME ( ) NAME = NAME [ LIT ] assert NAME < LIT , f\" 1000 lookups should be fast, took { NAME : .3f } s \" assert ( NAME > LIT ) , f\" Cache hit rate should be high, got { NAME : .1f } % \" # Test 4: Import standardization NAME = NAME ( ) assert NAME , LIT # Test 5: Context manager NAME = NAME . NAME . NAME ( ) with NAME ( ) : pass assert NAME . NAME == NAME , LIT return True except NAME as NAME : NAME = NAME ( NAME ) NAME . NAME ( f\" Core imports module tests failed: { NAME } \" ) return False"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_func",
      "lineno": 335,
      "end_lineno": 336,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(x)",
      "fingerprint": "b9636e24e966fdffe04a2a79cdd615963d71bc11",
      "simhash64": 7488347699577521251,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : return NAME * LIT"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 382,
      "end_lineno": 680,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 6,
      "loc": 299,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "d13c59a992af2ae51bd84b688cc186dd8491c14d",
      "simhash64": 5145885970996302891,
      "normalized": "def NAME ( ) -> NAME : LIT try : from NAME import NAME except NAME : NAME ( LIT ) return NAME ( ) NAME = NAME ( LIT , LIT ) def NAME ( ) -> None : LIT # Test basic registration def NAME ( ) -> NAME : return LIT NAME ( LIT , NAME ) assert NAME ( LIT ) NAME = NAME ( LIT ) assert NAME is not None assert NAME ( ) == LIT # Test function call NAME = NAME ( LIT ) assert NAME == LIT def NAME ( ) -> None : LIT # Test using **kwargs format NAME ( NAME = lambda : LIT , NAME = lambda : LIT ) assert NAME ( LIT ) assert NAME ( LIT ) assert NAME ( LIT ) == LIT assert NAME ( LIT ) == LIT def NAME ( ) -> None : LIT # Create mock module globals with test functions NAME = { LIT : lambda : LIT , LIT : lambda : LIT , LIT : LIT } # Test auto registration NAME ( NAME , LIT ) # Functions are registered with module prefix assert NAME ( LIT ) assert NAME ( LIT ) == LIT assert NAME ( LIT ) assert NAME ( LIT ) == LIT def NAME ( ) -> None : LIT NAME = NAME ( ) assert NAME is not None assert NAME ( NAME , NAME ) assert NAME . NAME ( ) def NAME ( ) -> None : LIT NAME = NAME ( LIT ) assert NAME is not None assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Test logger naming NAME = NAME ( LIT ) assert NAME is not None def NAME ( ) -> None : LIT NAME = NAME . NAME . NAME ( ) with NAME ( ) : # Context manager should preserve sys.path pass assert NAME . NAME == NAME def NAME ( ) -> None : LIT def NAME ( ) -> NAME : return LIT def NAME ( ) -> None : raise NAME ( LIT ) # Test successful execution using decorator @ NAME def NAME ( ) -> NAME : return LIT NAME = NAME ( ) assert NAME == LIT # Test error handling using decorator with default return @ NAME ( NAME = LIT ) def NAME ( ) -> None : raise NAME ( LIT ) NAME = NAME ( ) assert NAME == LIT def NAME ( ) -> None : LIT # Clear cache first NAME . NAME ( ) NAME [ LIT ] = LIT NAME [ LIT ] = LIT # Register a test function NAME ( LIT , lambda : LIT ) # Multiple lookups should hit cache for NAME in NAME ( LIT ) : assert NAME ( LIT ) # Should have cache hits NAME = NAME ( ) assert NAME [ LIT ] > LIT def NAME ( ) -> None : LIT NAME = NAME ( ) assert NAME ( NAME , NAME ) assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME def NAME ( ) -> None : LIT # Register some test functions NAME ( LIT , lambda : LIT ) NAME ( LIT , lambda : LIT ) # Verify functions are available before cleanup assert NAME ( LIT ) assert NAME ( LIT ) NAME = NAME ( NAME ) assert NAME >= LIT # Should have at least our test functions # Test cleanup NAME ( ) # Registry should be empty after cleanup assert NAME ( NAME ) == LIT assert not NAME ( LIT ) assert not NAME ( LIT ) # Registry should still work after cleanup - register new functions NAME ( LIT , lambda : LIT ) assert NAME ( LIT ) def NAME ( ) -> None : LIT # Test with non-existent function assert not NAME ( LIT ) # Test that call_function raises ValueError for non-existent function try : NAME ( LIT ) raise NAME ( LIT ) except NAME as NAME : assert LIT in NAME ( NAME ) # Test with invalid module registration (empty globals) try : NAME ( { } , LIT ) # Should handle gracefully without error except NAME : raise NAME ( LIT ) def NAME ( ) -> None : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ] from NAME import NAME NAME ( NAME , NAME ( ) , LIT ) # Run all tests NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) return NAME . NAME ( )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_function_registry",
      "lineno": 400,
      "end_lineno": 415,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7c88e92c081e6f0b68fc7f39618e932a63baf810",
      "simhash64": 6299361629465122339,
      "normalized": "def NAME ( ) -> None : LIT # Test basic registration def NAME ( ) -> NAME : return LIT NAME ( LIT , NAME ) assert NAME ( LIT ) NAME = NAME ( LIT ) assert NAME is not None assert NAME ( ) == LIT # Test function call NAME = NAME ( LIT ) assert NAME == LIT"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_func",
      "lineno": 403,
      "end_lineno": 404,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "4ff6433adac1c61a1c491c1fbf35dfa2a3834dff",
      "simhash64": 5186445305669653539,
      "normalized": "def NAME ( ) -> NAME : return LIT"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_bulk_registration",
      "lineno": 417,
      "end_lineno": 428,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c325bcddc25ea9aa3a70db6e21771c75900504f6",
      "simhash64": 7451755360500487723,
      "normalized": "def NAME ( ) -> None : LIT # Test using **kwargs format NAME ( NAME = lambda : LIT , NAME = lambda : LIT ) assert NAME ( LIT ) assert NAME ( LIT ) assert NAME ( LIT ) == LIT assert NAME ( LIT ) == LIT"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_module_auto_registration",
      "lineno": 430,
      "end_lineno": 446,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7fa49f19e663134594e92f5a8ec9353a0b459523",
      "simhash64": 5722375439505593899,
      "normalized": "def NAME ( ) -> None : LIT # Create mock module globals with test functions NAME = { LIT : lambda : LIT , LIT : lambda : LIT , LIT : LIT } # Test auto registration NAME ( NAME , LIT ) # Functions are registered with module prefix assert NAME ( LIT ) assert NAME ( LIT ) == LIT assert NAME ( LIT ) assert NAME ( LIT ) == LIT"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_project_root_detection",
      "lineno": 448,
      "end_lineno": 453,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "impure",
        "filesystem",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "e8e2748a13217f32387f57c1394ad466d8e47b97",
      "simhash64": 8642262579117196339,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) assert NAME is not None assert NAME ( NAME , NAME ) assert NAME . NAME ( )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_logger_functionality",
      "lineno": 455,
      "end_lineno": 465,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "4d0447c3ecec2f3fbc1efa8e7ec809fdd93a12e9",
      "simhash64": 8641242231789753891,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( LIT ) assert NAME is not None assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Test logger naming NAME = NAME ( LIT ) assert NAME is not None"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_import_context_manager",
      "lineno": 467,
      "end_lineno": 475,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "bd7f9c58ed4f03b553b1a544f3315c72a806118b",
      "simhash64": 8642262582405018631,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME . NAME . NAME ( ) with NAME ( ) : # Context manager should preserve sys.path pass assert NAME . NAME == NAME"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_safe_execution",
      "lineno": 477,
      "end_lineno": 499,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 1,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6f68713c6a7b861ef9a22b95aa170faff3dc914a",
      "simhash64": 6335425615688012835,
      "normalized": "def NAME ( ) -> None : LIT def NAME ( ) -> NAME : return LIT def NAME ( ) -> None : raise NAME ( LIT ) # Test successful execution using decorator @ NAME def NAME ( ) -> NAME : return LIT NAME = NAME ( ) assert NAME == LIT # Test error handling using decorator with default return @ NAME ( NAME = LIT ) def NAME ( ) -> None : raise NAME ( LIT ) NAME = NAME ( ) assert NAME == LIT"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "safe_func",
      "lineno": 479,
      "end_lineno": 480,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "4ff6433adac1c61a1c491c1fbf35dfa2a3834dff",
      "simhash64": 5186445305669653539,
      "normalized": "def NAME ( ) -> NAME : return LIT"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "error_func",
      "lineno": 482,
      "end_lineno": 483,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "c531484c745604b5b943758c4924642d73062afa",
      "simhash64": 6335989115430802987,
      "normalized": "def NAME ( ) -> None : raise NAME ( LIT )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "decorated_safe_func",
      "lineno": 487,
      "end_lineno": 488,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "4ff6433adac1c61a1c491c1fbf35dfa2a3834dff",
      "simhash64": 5186445305669653539,
      "normalized": "def NAME ( ) -> NAME : return LIT"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "decorated_error_func",
      "lineno": 495,
      "end_lineno": 496,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "c531484c745604b5b943758c4924642d73062afa",
      "simhash64": 6335989115430802987,
      "normalized": "def NAME ( ) -> None : raise NAME ( LIT )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_performance_caching",
      "lineno": 501,
      "end_lineno": 517,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "4addd552c73756cb2c57b32f34ace8e06911c9c8",
      "simhash64": 5146448912419558443,
      "normalized": "def NAME ( ) -> None : LIT # Clear cache first NAME . NAME ( ) NAME [ LIT ] = LIT NAME [ LIT ] = LIT # Register a test function NAME ( LIT , lambda : LIT ) # Multiple lookups should hit cache for NAME in NAME ( LIT ) : assert NAME ( LIT ) # Should have cache hits NAME = NAME ( ) assert NAME [ LIT ] > LIT"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_statistics_tracking",
      "lineno": 519,
      "end_lineno": 526,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "13c95901bf34de5cf2ae4e47f63b4f3e199880ce",
      "simhash64": 8641242265075226235,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) assert NAME ( NAME , NAME ) assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_cleanup_functionality",
      "lineno": 528,
      "end_lineno": 551,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5fc14bff4cb77ee334accf6e3090978b90b5f6fb",
      "simhash64": 8640716665223288427,
      "normalized": "def NAME ( ) -> None : LIT # Register some test functions NAME ( LIT , lambda : LIT ) NAME ( LIT , lambda : LIT ) # Verify functions are available before cleanup assert NAME ( LIT ) assert NAME ( LIT ) NAME = NAME ( NAME ) assert NAME >= LIT # Should have at least our test functions # Test cleanup NAME ( ) # Registry should be empty after cleanup assert NAME ( NAME ) == LIT assert not NAME ( LIT ) assert not NAME ( LIT ) # Registry should still work after cleanup - register new functions NAME ( LIT , lambda : LIT ) assert NAME ( LIT )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_error_handling",
      "lineno": 553,
      "end_lineno": 570,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "4452c86c9853a6c7d5582d0802e2072b2ee47d0c",
      "simhash64": 8641268620035266091,
      "normalized": "def NAME ( ) -> None : LIT # Test with non-existent function assert not NAME ( LIT ) # Test that call_function raises ValueError for non-existent function try : NAME ( LIT ) raise NAME ( LIT ) except NAME as NAME : assert LIT in NAME ( NAME ) # Test with invalid module registration (empty globals) try : NAME ( { } , LIT ) # Should handle gracefully without error except NAME : raise NAME ( LIT )"
    },
    {
      "module_path": "core_imports.py",
      "qualname": "test_function_availability",
      "lineno": 572,
      "end_lineno": 581,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "80a82cdc1f10de7207b95871ee33a5e5be9cb4ce",
      "simhash64": 5145885970993157163,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ] from NAME import NAME NAME ( NAME , NAME ( ) , LIT )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager.__init__",
      "lineno": 71,
      "end_lineno": 74,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "b8e5ed774d77acabca3e8ad0dd8a2deb43f71398",
      "simhash64": 8641137267085055019,
      "normalized": "def NAME ( NAME ) -> None : if not NAME : raise NAME ( LIT ) NAME . NAME = NAME ( )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager.check_and_install_dependencies",
      "lineno": 77,
      "end_lineno": 163,
      "is_method": true,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 8,
      "loc": 87,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "regex",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "c2236baf1670d512a0e91fccecf0968514970cf2",
      "simhash64": 7487617074167452715,
      "normalized": "def NAME ( ) -> NAME : LIT if NAME : return True NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME = ( NAME ( LIT ) . NAME ( ) . NAME ( ) ) if NAME != LIT : NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) return False try : import NAME NAME ( LIT ) NAME . NAME ( [ NAME . NAME , LIT , LIT , LIT , LIT , LIT ] ) NAME ( LIT ) # For Linux systems, also install keyrings.alt if NAME . NAME != LIT : # Not Windows NAME ( LIT ) NAME = ( NAME ( LIT ) . NAME ( ) . NAME ( ) ) if NAME != LIT : try : NAME ( LIT ) NAME . NAME ( [ NAME . NAME , LIT , LIT , LIT , LIT ] ) NAME ( LIT ) except NAME as NAME : NAME ( f\" \u26a0\ufe0f Could not install alternative backend: { NAME } \" ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT * LIT ) return True except NAME as NAME : NAME ( f\" \\n\u274c Failed to install dependencies: { NAME } \" ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) if NAME . NAME != LIT : NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) return False"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager.display_main_menu",
      "lineno": 165,
      "end_lineno": 182,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 18,
      "tags": [
        "impure",
        "logging",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "97990e22e744da0f7b3e2abc68b6cc0ac57f7518",
      "simhash64": 14405280371030005291,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT + LIT * LIT )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager.view_credentials",
      "lineno": 184,
      "end_lineno": 221,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 7,
      "loc": 38,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "fee58e4f7a071161fa0c1700cf1c8f87293343d0",
      "simhash64": 8640573763146388523,
      "normalized": "def NAME ( NAME ) -> None : LIT # Check if encrypted file exists but can't be decrypted if NAME . NAME . NAME . NAME ( ) : NAME = NAME . NAME . NAME ( ) if NAME is None : NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) return else : NAME = NAME . NAME . NAME ( ) if not NAME : NAME ( LIT ) NAME ( LIT ) return NAME ( f\" \\n\u2705 Found { NAME ( NAME ) } stored credentials: \" ) NAME ( LIT * LIT ) for NAME , NAME in NAME ( NAME . NAME ( ) ) : # Better masking for different credential types if NAME ( NAME ) <= LIT : NAME = LIT * NAME ( NAME ) elif NAME ( NAME ) <= LIT : NAME = NAME [ : LIT ] + LIT * ( NAME ( NAME ) - LIT ) else : NAME = NAME [ : LIT ] + LIT * ( NAME ( NAME ) - LIT ) + NAME [ - LIT : ] NAME ( f\" { NAME : <25 } : { NAME } \" ) NAME ( LIT * LIT )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager.setup_credentials",
      "lineno": 223,
      "end_lineno": 283,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 16,
      "loc": 61,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "f6d61628355b5908ce5efa94237b9329274dfc22",
      "simhash64": 8640538577634497595,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) # Check existing credentials NAME = NAME . NAME . NAME ( ) if NAME : NAME ( f\" \u2713 Found { NAME ( NAME ) } existing credentials \" ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME = NAME ( LIT ) . NAME ( ) . NAME ( ) if NAME == LIT : return if NAME == LIT : if not NAME . NAME ( LIT ) : return NAME = { } else : NAME = { } NAME ( LIT ) # Load credential types from configuration file NAME , NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) # Setup required credentials NAME ( LIT ) for NAME , NAME in NAME . NAME ( ) : NAME = NAME . NAME ( NAME , LIT ) if NAME : NAME ( f\" { NAME } : ***existing*** (press Enter to keep) \" ) NAME = NAME ( f\" { NAME } : \" ) . NAME ( ) if NAME or not NAME : if not NAME and not NAME : NAME ( f\" \u26a0\ufe0f Warning: { NAME } is required for basic functionality \" ) if NAME : NAME [ NAME ] = NAME # Setup optional credentials NAME ( LIT ) for NAME , NAME in NAME . NAME ( ) : NAME = NAME . NAME ( NAME , LIT ) if NAME : NAME ( f\" { NAME } : ***existing*** (press Enter to keep) \" ) NAME = NAME ( f\" { NAME } : \" ) . NAME ( ) if NAME : NAME [ NAME ] = NAME # Save credentials if NAME . NAME . NAME ( NAME ) : NAME ( f\" \\n\u2705 Successfully saved { NAME ( NAME ) } credentials! \" ) else : NAME ( LIT )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager.remove_credential",
      "lineno": 285,
      "end_lineno": 316,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 32,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "a762b3ff9bbdd1d3692f2f64f708ae74652b7169",
      "simhash64": 8623122313450525755,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME = NAME . NAME . NAME ( ) if not NAME : NAME ( LIT ) return NAME ( LIT ) for NAME , NAME in NAME ( NAME ( NAME . NAME ( ) ) , LIT ) : NAME ( f\" { NAME } . { NAME } \" ) try : NAME = NAME ( f\" \\nEnter number to remove (1- { NAME ( NAME ) } ): \" ) . NAME ( ) NAME = NAME ( NAME ) - LIT NAME = NAME ( NAME . NAME ( ) ) if LIT <= NAME < NAME ( NAME ) : NAME = NAME [ NAME ] if NAME . NAME ( f\" remove ' { NAME } ' \" ) : del NAME [ NAME ] if NAME . NAME . NAME ( NAME ) : NAME ( f\" \u2705 Removed ' { NAME } ' successfully! \" ) else : NAME ( f\" \u274c Failed to remove ' { NAME } ' \" ) else : NAME ( LIT ) except NAME : NAME ( LIT )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager.delete_all_credentials",
      "lineno": 318,
      "end_lineno": 331,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 14,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "a2cb2a46881f375a4c1cf16be8d230aae37940ec",
      "simhash64": 8640573763146388523,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME = NAME . NAME . NAME ( ) if not NAME : NAME ( LIT ) return NAME ( f\" \\n\u26a0\ufe0f This will delete ALL { NAME ( NAME ) } stored credentials! \" ) if NAME . NAME ( LIT ) : if NAME . NAME . NAME ( ) : NAME ( LIT ) else : NAME ( LIT )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager.setup_test_credentials",
      "lineno": 333,
      "end_lineno": 358,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 26,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "1b15b41e6edea6bbcfb770511f28a316ea77b916",
      "simhash64": 7492261411274790443,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME = NAME . NAME . NAME ( ) if NAME : NAME ( LIT ) if not NAME . NAME ( LIT ) : return NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } if NAME . NAME . NAME ( NAME ) : NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) else : NAME ( LIT )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager.import_from_env",
      "lineno": 360,
      "end_lineno": 511,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 30,
      "loc": 152,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:large"
      ],
      "signature": "(self)",
      "fingerprint": "c56525edc317e6b9753dd80bc8109db3616d56d8",
      "simhash64": 7488180022980023355,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) # Ask for .env file path when in interactive mode NAME = NAME ( LIT ) . NAME ( ) if not NAME : NAME = LIT # Try multiple locations for the .env file NAME = [ ] NAME = NAME ( NAME ) # 1. Check user-provided path (absolute or relative) if NAME . NAME ( ) : NAME . NAME ( NAME ) else : # 2. Check relative to current directory NAME . NAME ( NAME . NAME ( ) / NAME ) # 3. Check relative to script directory NAME = NAME ( NAME ) . NAME . NAME ( ) NAME . NAME ( NAME / NAME ) # 4. Check parent directory (project root) NAME = NAME . NAME NAME . NAME ( NAME / NAME ) # Find the first existing file from potential paths NAME = None for NAME in NAME : if NAME . NAME ( ) : NAME = NAME ( NAME ) break if not NAME : NAME ( f\" \u274c File not found: { NAME } \" ) NAME ( LIT ) for NAME in NAME : NAME ( f\" - { NAME } \" ) return try : NAME ( f\" \ud83d\udcc2 Using .env file: { NAME } \" ) # Read and parse .env file NAME = { } with NAME . NAME ( NAME = LIT ) as NAME : for NAME , NAME in NAME ( NAME , LIT ) : NAME = NAME . NAME ( ) # Skip empty lines and comments if not NAME or NAME . NAME ( LIT ) : continue # Parse KEY=VALUE format if LIT not in NAME : NAME ( f\" \u26a0\ufe0f Warning: Skipping invalid line { NAME } : { NAME } \" ) continue NAME , NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) # Remove quotes if present if ( NAME . NAME ( LIT ) and NAME . NAME ( LIT ) ) or ( NAME . NAME ( LIT ) and NAME . NAME ( LIT ) ) : NAME = NAME [ LIT : - LIT ] NAME [ NAME ] = NAME if not NAME : NAME ( LIT ) return NAME ( f\" \ud83d\udccb Found { NAME ( NAME ) } credentials in .env file: \" ) for NAME in NAME ( NAME . NAME ( ) ) : # Show masked preview NAME = ( NAME [ NAME ] [ : LIT ] + LIT * NAME ( LIT , NAME ( NAME [ NAME ] ) - LIT ) + NAME [ NAME ] [ - LIT : ] if NAME ( NAME [ NAME ] ) > LIT else LIT * NAME ( NAME [ NAME ] ) ) NAME ( f\" { NAME } : { NAME } \" ) # Check for existing credentials NAME = NAME . NAME . NAME ( ) if NAME : NAME ( f\" \\n\u26a0\ufe0f You already have { NAME ( NAME ) } stored credentials. \" ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME = NAME ( LIT ) . NAME ( ) . NAME ( ) if NAME == LIT : return if NAME == LIT : # Merge: existing credentials take precedence NAME = NAME . NAME ( ) NAME . NAME ( NAME ) # existing wins on conflicts NAME = LIT elif NAME == LIT : # Overwrite: .env credentials take precedence NAME = NAME . NAME ( ) NAME . NAME ( NAME ) # .env wins on conflicts NAME = LIT elif NAME == LIT : # Replace: only use .env credentials if not NAME . NAME ( LIT ) : return NAME = NAME NAME = LIT else : NAME ( LIT ) return else : NAME = NAME NAME = LIT # Save the credentials if NAME . NAME . NAME ( NAME ) : NAME ( f\" \u2705 Successfully { NAME } { NAME ( NAME ) } credentials from .env file! \" ) # Show summary NAME = [ LIT , LIT ] NAME = [ NAME for NAME in NAME if NAME in NAME ] if NAME : NAME ( f\" \u2705 Required credentials found: { LIT . NAME ( NAME ) } \" ) NAME = [ NAME for NAME in NAME if NAME not in NAME ] if NAME : NAME ( f\" \u26a0\ufe0f Missing required credentials: { LIT . NAME ( NAME ) } \" ) NAME ( LIT ) else : NAME ( LIT ) except NAME as NAME : NAME ( f\" \u274c Error reading .env file: { NAME } \" ) NAME ( LIT )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager.export_credentials",
      "lineno": 513,
      "end_lineno": 555,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 43,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "json",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "415e51ab24347136add93a164414718298bc80e9",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME = NAME . NAME . NAME ( ) if not NAME : NAME ( LIT ) return NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME = NAME ( LIT ) . NAME ( ) if NAME == LIT : NAME ( LIT ) NAME ( LIT * LIT ) for NAME , NAME in NAME ( NAME . NAME ( ) ) : NAME ( f\" { NAME } = { NAME } \" ) NAME ( LIT * LIT ) NAME ( LIT ) elif NAME == LIT : NAME = NAME ( LIT ) . NAME ( ) if not NAME : NAME = LIT try : import NAME from NAME import NAME with NAME ( NAME ) . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME , NAME = LIT ) NAME ( f\" \u2705 Credentials exported to ' { NAME } ' \" ) NAME ( LIT ) except NAME as NAME : NAME ( f\" \u274c Export failed: { NAME } \" )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager.check_status",
      "lineno": 557,
      "end_lineno": 686,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 23,
      "loc": 130,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "purpose:validation",
        "size:large"
      ],
      "signature": "(self)",
      "fingerprint": "06c598310b08bb4908cc7cf0c413fe03e4e3b71d",
      "simhash64": 8641136712026068539,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) # Check dependencies NAME = True try : import NAME NAME = NAME . NAME NAME = f\" \u2705 Installed (v { NAME } ) \" except NAME : NAME = LIT NAME = False try : import NAME NAME = LIT try : # Try to get version if available NAME = NAME ( NAME , LIT , LIT ) if NAME != LIT : NAME = f\" \u2705 Installed (v { NAME } ) \" except NAME : pass except NAME : NAME = LIT NAME = False NAME ( LIT ) NAME ( f\" - cryptography: { NAME } \" ) NAME ( f\" - keyring: { NAME } \" ) # Check if alt keyring is needed (for Linux/macOS) if NAME . NAME != LIT and LIT in NAME : try : import NAME . NAME NAME = LIT try : NAME = NAME ( NAME . NAME , LIT , LIT ) if NAME != LIT : NAME = f\" \u2705 Installed (v { NAME } ) \" except NAME : pass except NAME : NAME = LIT NAME ( f\" - keyrings.alt: { NAME } \" ) # Show installation instructions if any dependencies are missing if LIT in NAME or LIT in NAME : NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) if NAME . NAME != LIT : NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) # Check SecurityManager status NAME ( f\" \ud83d\udd10 Security Manager: { LIT if NAME else LIT } \" ) if not NAME : NAME = False # Check credentials NAME = NAME . NAME . NAME ( ) if NAME : NAME ( f\" \ud83d\udddd\ufe0f  Stored Credentials: \u2705 { NAME ( NAME ) } credentials found \" ) # Get credential types from configuration NAME , NAME = NAME . NAME ( ) NAME = NAME ( NAME . NAME ( ) ) | NAME ( NAME . NAME ( ) ) # Check for required credentials NAME = [ NAME for NAME in NAME if NAME not in NAME ] if NAME : NAME ( f\" \u26a0\ufe0f  Missing Required: { LIT . NAME ( NAME ) } \" ) NAME = False else : NAME ( LIT ) # Check for optional credentials NAME = [ NAME for NAME in NAME if NAME in NAME ] if NAME : NAME ( f\" \ud83d\udd39 Optional Credentials: { LIT . NAME ( NAME ) } \" ) # Check for credentials not in configuration NAME = [ NAME for NAME in NAME if NAME not in NAME ] if NAME : NAME ( f\" i  Additional Credentials: { LIT . NAME ( NAME ) } \" ) else : NAME ( LIT ) NAME = False # Check encryption status try : NAME = { LIT : LIT } NAME = NAME . NAME . NAME ( NAME ) NAME . NAME . NAME ( ) # Clean up test NAME ( f\" \ud83d\udd12 Encryption Test: { LIT if NAME else LIT } \" ) if not NAME : NAME = False except NAME as NAME : NAME ( f\" \ud83d\udd12 Encryption Test: \u274c Error - { NAME } \" ) NAME = False return NAME"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager.edit_credential_types",
      "lineno": 688,
      "end_lineno": 842,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 28,
      "loc": 155,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "json",
        "size:large"
      ],
      "signature": "(self)",
      "fingerprint": "e20b767e910a8cd1e0ca6086a49ca28932ef8040",
      "simhash64": 7487617074101392443,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME = NAME ( NAME ) . NAME / LIT # Load current configuration if NAME . NAME ( ) : try : with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) NAME ( LIT ) except NAME as NAME : NAME ( f\" \u26a0\ufe0f Error loading credential types: { NAME } , using defaults \" ) NAME , NAME = NAME . NAME ( ) else : NAME ( LIT ) NAME , NAME = NAME . NAME ( ) NAME ( LIT ) NAME ( LIT ) for NAME , NAME in NAME . NAME ( ) : NAME ( f\" { NAME } : { NAME } \" ) NAME ( LIT ) for NAME , NAME in NAME . NAME ( ) : NAME ( f\" { NAME } : { NAME } \" ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) while True : NAME = NAME ( LIT ) . NAME ( ) if NAME == LIT : # Add/Edit Required Credential NAME = NAME ( LIT ) . NAME ( ) . NAME ( ) if not NAME : NAME ( LIT ) continue NAME = NAME ( f\" Description for { NAME } : \" ) . NAME ( ) if not NAME : NAME = f\" { NAME } (required) \" NAME [ NAME ] = NAME NAME ( f\" \u2705 Added/Updated required credential: { NAME } \" ) elif NAME == LIT : # Add/Edit Optional Credential NAME = NAME ( LIT ) . NAME ( ) . NAME ( ) if not NAME : NAME ( LIT ) continue NAME = NAME ( f\" Description for { NAME } : \" ) . NAME ( ) if not NAME : NAME = f\" { NAME } (optional) \" NAME [ NAME ] = NAME NAME ( f\" \u2705 Added/Updated optional credential: { NAME } \" ) elif NAME == LIT : # Move Credential NAME ( LIT ) NAME ( LIT ) for NAME , ( NAME , NAME ) in NAME ( NAME . NAME ( ) , LIT ) : NAME ( f\" { NAME } . { NAME } \" ) NAME ( LIT ) for NAME , ( NAME , NAME ) in NAME ( NAME . NAME ( ) , NAME ( NAME ) + LIT ) : NAME ( f\" { NAME } . { NAME } \" ) try : NAME = NAME ( NAME ( LIT ) . NAME ( ) ) if LIT <= NAME <= NAME ( NAME ) : # Move from required to optional NAME = NAME ( NAME . NAME ( ) ) [ NAME - LIT ] NAME = NAME . NAME ( NAME ) NAME [ NAME ] = NAME NAME ( f\" \u2705 Moved { NAME } from Required to Optional \" ) elif ( NAME ( NAME ) < NAME <= NAME ( NAME ) + NAME ( NAME ) ) : # Move from optional to required NAME = NAME ( NAME . NAME ( ) ) [ NAME - NAME ( NAME ) - LIT ] NAME = NAME . NAME ( NAME ) NAME [ NAME ] = NAME NAME ( f\" \u2705 Moved { NAME } from Optional to Required \" ) else : NAME ( LIT ) except ( NAME , NAME ) : NAME ( LIT ) elif NAME == LIT : # Remove Credential NAME ( LIT ) NAME = [ ] NAME ( LIT ) for NAME , ( NAME , NAME ) in NAME ( NAME . NAME ( ) ) : NAME . NAME ( ( LIT , NAME ) ) NAME ( f\" { NAME + LIT } . { NAME } \" ) NAME ( LIT ) for NAME , ( NAME , NAME ) in NAME ( NAME . NAME ( ) ) : NAME . NAME ( ( LIT , NAME ) ) NAME ( f\" { NAME + NAME ( NAME ) + LIT } . { NAME } \" ) try : NAME = NAME ( NAME ( LIT ) . NAME ( ) ) if LIT <= NAME <= NAME ( NAME ) : NAME , NAME = NAME [ NAME - LIT ] if NAME == LIT : del NAME [ NAME ] else : del NAME [ NAME ] NAME ( f\" \u2705 Removed { NAME } \" ) else : NAME ( LIT ) except ( NAME , NAME ) : NAME ( LIT ) elif NAME == LIT : # Save and return try : # Create updated configuration NAME = { LIT : NAME , LIT : NAME , } # Save to file with NAME . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME , NAME = LIT ) NAME ( f\" \u2705 Saved credential types configuration to { NAME } \" ) break except NAME as NAME : NAME ( f\" \u274c Error saving configuration: { NAME } \" ) else : NAME ( LIT )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager._confirm_action",
      "lineno": 844,
      "end_lineno": 849,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "impure",
        "size:tiny"
      ],
      "signature": "(self, action)",
      "fingerprint": "27779dff13dca87826a795cae54466d575e8f2ed",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT NAME = ( NAME ( f\" Are you sure you want to { NAME } ? (yes/no): \" ) . NAME ( ) . NAME ( ) ) return NAME in [ LIT , LIT ]"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager.run",
      "lineno": 851,
      "end_lineno": 896,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 15,
      "loc": 46,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "0458228b770e5f0a03c0136381b76a5e40d74943",
      "simhash64": 8640573763079279659,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME : return False NAME ( LIT ) while True : try : NAME . NAME ( ) NAME = NAME ( LIT ) . NAME ( ) if NAME == LIT : NAME ( LIT ) break if NAME == LIT : NAME . NAME ( ) elif NAME == LIT : NAME . NAME ( ) elif NAME == LIT : NAME . NAME ( ) elif NAME == LIT : NAME . NAME ( ) elif NAME == LIT : NAME . NAME ( ) elif NAME == LIT : NAME . NAME ( ) elif NAME == LIT : NAME . NAME ( ) elif NAME == LIT : NAME . NAME ( ) elif NAME == LIT : NAME . NAME ( ) else : NAME ( LIT ) if NAME != LIT : NAME ( LIT ) except NAME : NAME ( LIT ) break except NAME as NAME : NAME ( f\" \\n\u274c Error: { NAME } \" ) NAME ( LIT ) return True"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager._load_credential_types",
      "lineno": 898,
      "end_lineno": 938,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 41,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "json",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "48e78ab21ac33c15ccd26992fc2656fe80443832",
      "simhash64": 7451729014570783787,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME [ NAME , NAME ] , NAME [ NAME , NAME ] ] : LIT NAME = NAME ( NAME ) . NAME / LIT try : if NAME . NAME ( ) : with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) return NAME , NAME # Fallback to default credential types if file doesn't exist NAME ( LIT ) return ( { LIT : LIT , LIT : LIT , } , { LIT : LIT , LIT : LIT , } , ) except NAME as NAME : NAME ( f\" \u26a0\ufe0f Error loading credential types: { NAME } , using defaults \" ) # Fallback to default credential types if there's an error return ( { LIT : LIT , LIT : LIT , } , { LIT : LIT , LIT : LIT , } , )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager._save_credential",
      "lineno": 940,
      "end_lineno": 965,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 26,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "(self, key, value, description)",
      "fingerprint": "06387cc8abfdc99fc522d48494a4f319749c8336",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT try : if not NAME or not NAME : return False # Get existing credentials NAME = NAME . NAME . NAME ( ) or { } # Add or update credential NAME [ NAME ] = NAME # Save back to secure store return NAME . NAME . NAME ( NAME ) except NAME as NAME : NAME ( f\" \u274c Error saving credential: { NAME } \" ) return False"
    },
    {
      "module_path": "credentials.py",
      "qualname": "UnifiedCredentialManager._save_credential_types",
      "lineno": 967,
      "end_lineno": 997,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 31,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "json",
        "size:medium"
      ],
      "signature": "(self, required_creds, optional_creds)",
      "fingerprint": "1258ce674384d61e456726abd27e720e150a3354",
      "simhash64": 7452151225961067547,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT try : NAME = NAME ( NAME ) . NAME / LIT NAME = { LIT : NAME , LIT : NAME , } try : import NAME # Use builtins.open so tests that patch builtins.open can simulate failures with NAME . NAME ( NAME , LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME , NAME = LIT ) except NAME as NAME : NAME ( f\" \u274c Error saving credential types: { NAME } \" ) return False return True except NAME as NAME : NAME ( f\" \u274c Error preparing credential types for save: { NAME } \" ) return False"
    },
    {
      "module_path": "credentials.py",
      "qualname": "credentials_module_tests",
      "lineno": 1000,
      "end_lineno": 1324,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 25,
      "loc": 325,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "f944691adf2fa395bff6dc7f5f7877790ab73555",
      "simhash64": 7451728980209996843,
      "normalized": "def NAME ( ) -> NAME : LIT import NAME import NAME from NAME import NAME from NAME . NAME import NAME from NAME import NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # Create temporary directory for test files NAME = NAME . NAME ( ) NAME = NAME ( NAME . NAME ) # Helper functions for test setup def NAME ( NAME = True ) : LIT NAME = NAME / LIT if NAME : NAME = { LIT : { LIT : LIT } , LIT : { LIT : LIT } , } else : # Invalid JSON structure NAME = { LIT : { LIT : LIT } } with NAME ( NAME ) . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME ) return NAME def NAME ( ) : LIT assert NAME , LIT assert NAME is not None , LIT def NAME ( ) : LIT if NAME : NAME = NAME ( ) assert ( NAME . NAME is not None ) , LIT def NAME ( ) : LIT # Temporarily set SECURITY_AVAILABLE to False global NAME NAME = NAME NAME = False try : # Should raise ImportError NAME = False try : NAME ( ) except NAME : NAME = True assert NAME , LIT finally : # Restore original value NAME = NAME def NAME ( ) : LIT if NAME : NAME = NAME ( ) NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME ( NAME , NAME ) , f\" Manager should have { NAME } method \" assert NAME ( NAME ( NAME , NAME ) ) , f\" { NAME } should be callable \" def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Create a valid test credential file NAME = NAME ( NAME = True ) # Mock Path's parent/__truediv__ combination that's used in _load_credential_types with NAME . NAME ( NAME , LIT , NAME = NAME ) : # Mock exists to return True with NAME . NAME ( NAME , LIT , NAME = True ) : # Load credential types NAME , NAME = NAME . NAME ( ) # Verify loaded credentials assert ( LIT in NAME ) , LIT assert ( LIT in NAME ) , LIT def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Mock file operations with NAME ( LIT , NAME = False ) : # Load credential types NAME , NAME = NAME . NAME ( ) # Verify default credentials are used assert NAME ( NAME ) > LIT , LIT assert NAME ( NAME ) > LIT , LIT assert ( LIT in NAME ) , LIT def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Create an invalid test credential file NAME = NAME / LIT with NAME . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( LIT ) # Mock file operations with NAME ( LIT , NAME = lambda * NAME , ** NAME : NAME ( NAME ) . NAME ( * NAME [ LIT : ] , ** NAME ) , ) , NAME ( LIT , NAME = True ) : # Load credential types NAME , NAME = NAME . NAME ( ) # Verify default credentials are used assert ( NAME ( NAME ) > LIT ) , LIT assert ( NAME ( NAME ) > LIT ) , LIT def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Create a test credential file with invalid structure NAME = NAME ( NAME = False ) # Mock file operations with NAME ( LIT , NAME = lambda * NAME , ** NAME : NAME ( NAME ) . NAME ( * NAME [ LIT : ] , ** NAME ) , ) , NAME ( LIT , NAME = True ) : # Load credential types NAME , NAME = NAME . NAME ( ) # Verify default credentials are used when structure is invalid assert ( LIT in NAME ) , LIT assert ( LIT in NAME ) , LIT def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Mock open to simulate file access error with NAME ( LIT , NAME = NAME ( LIT ) ) : # This should handle the error gracefully without crashing NAME = NAME . NAME ( { } , { } ) assert not NAME , LIT def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Mock the decrypt_credentials method with NAME . NAME ( NAME . NAME , LIT , NAME = None ) : # Call check_status and verify it doesn't crash NAME = NAME . NAME ( ) assert NAME is not None , LIT assert ( not NAME ) , LIT def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Mock encrypt_credentials to simulate error with NAME . NAME ( NAME . NAME , LIT , NAME = NAME ( LIT ) , ) : # This should handle the error gracefully NAME = NAME . NAME ( LIT , LIT , LIT ) assert not NAME , LIT with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Clean up temporary directory NAME . NAME ( ) return NAME . NAME ( )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "create_test_credential_file",
      "lineno": 1017,
      "end_lineno": 1032,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(valid)",
      "fingerprint": "6110745cb751a147378d112b8f425595d4cf47ff",
      "simhash64": 7456232614256875051,
      "normalized": "def NAME ( NAME = True ) : LIT NAME = NAME / LIT if NAME : NAME = { LIT : { LIT : LIT } , LIT : { LIT : LIT } , } else : # Invalid JSON structure NAME = { LIT : { LIT : LIT } } with NAME ( NAME ) . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME ) return NAME"
    },
    {
      "module_path": "credentials.py",
      "qualname": "test_security_availability",
      "lineno": 1034,
      "end_lineno": 1037,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "b041c2734b9386d8f6ecca4c7ce6b3ac9f1967a6",
      "simhash64": 5147004174321751587,
      "normalized": "def NAME ( ) : LIT assert NAME , LIT assert NAME is not None , LIT"
    },
    {
      "module_path": "credentials.py",
      "qualname": "test_manager_initialization",
      "lineno": 1039,
      "end_lineno": 1045,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "1a42c69274adeb5eefe7fcde929708d0b81c8d7b",
      "simhash64": 8640714466209469483,
      "normalized": "def NAME ( ) : LIT if NAME : NAME = NAME ( ) assert ( NAME . NAME is not None ) , LIT"
    },
    {
      "module_path": "credentials.py",
      "qualname": "test_manager_initialization_with_security_unavailable",
      "lineno": 1047,
      "end_lineno": 1064,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "e2b28e0168c1d5cadebd3ac1320aa353086d1ec4",
      "simhash64": 7452249048203302523,
      "normalized": "def NAME ( ) : LIT # Temporarily set SECURITY_AVAILABLE to False global NAME NAME = NAME NAME = False try : # Should raise ImportError NAME = False try : NAME ( ) except NAME : NAME = True assert NAME , LIT finally : # Restore original value NAME = NAME"
    },
    {
      "module_path": "credentials.py",
      "qualname": "test_menu_methods",
      "lineno": 1066,
      "end_lineno": 1085,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "fb6443e09f7f581ceac110a46fe614d599b9383c",
      "simhash64": 7451728980211045419,
      "normalized": "def NAME ( ) : LIT if NAME : NAME = NAME ( ) NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME ( NAME , NAME ) , f\" Manager should have { NAME } method \" assert NAME ( NAME ( NAME , NAME ) ) , f\" { NAME } should be callable \""
    },
    {
      "module_path": "credentials.py",
      "qualname": "test_load_credential_types_with_valid_file",
      "lineno": 1087,
      "end_lineno": 1108,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 22,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3a5c9e9fbd69354a3caa13dfb63dc7280bb203c4",
      "simhash64": 7488109620950373419,
      "normalized": "def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Create a valid test credential file NAME = NAME ( NAME = True ) # Mock Path's parent/__truediv__ combination that's used in _load_credential_types with NAME . NAME ( NAME , LIT , NAME = NAME ) : # Mock exists to return True with NAME . NAME ( NAME , LIT , NAME = True ) : # Load credential types NAME , NAME = NAME . NAME ( ) # Verify loaded credentials assert ( LIT in NAME ) , LIT assert ( LIT in NAME ) , LIT"
    },
    {
      "module_path": "credentials.py",
      "qualname": "test_load_credential_types_with_missing_file",
      "lineno": 1110,
      "end_lineno": 1126,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5ebc9c4546ef74e5e43110cc49e1afa3972f720a",
      "simhash64": 7487792961668159019,
      "normalized": "def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Mock file operations with NAME ( LIT , NAME = False ) : # Load credential types NAME , NAME = NAME . NAME ( ) # Verify default credentials are used assert NAME ( NAME ) > LIT , LIT assert NAME ( NAME ) > LIT , LIT assert ( LIT in NAME ) , LIT"
    },
    {
      "module_path": "credentials.py",
      "qualname": "test_load_credential_types_with_invalid_json",
      "lineno": 1128,
      "end_lineno": 1155,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 28,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "feb49ec013258d36530fab05868737e901f7b1f5",
      "simhash64": 7487617078462944299,
      "normalized": "def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Create an invalid test credential file NAME = NAME / LIT with NAME . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( LIT ) # Mock file operations with NAME ( LIT , NAME = lambda * NAME , ** NAME : NAME ( NAME ) . NAME ( * NAME [ LIT : ] , ** NAME ) , ) , NAME ( LIT , NAME = True ) : # Load credential types NAME , NAME = NAME . NAME ( ) # Verify default credentials are used assert ( NAME ( NAME ) > LIT ) , LIT assert ( NAME ( NAME ) > LIT ) , LIT"
    },
    {
      "module_path": "credentials.py",
      "qualname": "test_load_credential_types_with_invalid_structure",
      "lineno": 1157,
      "end_lineno": 1181,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 25,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "34fad1cec4cd328917cc66473959b6308e68dde0",
      "simhash64": 7487652227335492651,
      "normalized": "def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Create a test credential file with invalid structure NAME = NAME ( NAME = False ) # Mock file operations with NAME ( LIT , NAME = lambda * NAME , ** NAME : NAME ( NAME ) . NAME ( * NAME [ LIT : ] , ** NAME ) , ) , NAME ( LIT , NAME = True ) : # Load credential types NAME , NAME = NAME . NAME ( ) # Verify default credentials are used when structure is invalid assert ( LIT in NAME ) , LIT assert ( LIT in NAME ) , LIT"
    },
    {
      "module_path": "credentials.py",
      "qualname": "test_edit_credential_types_error_handling",
      "lineno": 1183,
      "end_lineno": 1195,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "a1afd680c36cb27b0004ce623d6802f06b60fbba",
      "simhash64": 8605248619143926847,
      "normalized": "def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Mock open to simulate file access error with NAME ( LIT , NAME = NAME ( LIT ) ) : # This should handle the error gracefully without crashing NAME = NAME . NAME ( { } , { } ) assert not NAME , LIT"
    },
    {
      "module_path": "credentials.py",
      "qualname": "test_check_status_with_missing_credentials",
      "lineno": 1197,
      "end_lineno": 1212,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "10dfd1d99417c54137e495326c94578e7c229546",
      "simhash64": 8642262578581378091,
      "normalized": "def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Mock the decrypt_credentials method with NAME . NAME ( NAME . NAME , LIT , NAME = None ) : # Call check_status and verify it doesn't crash NAME = NAME . NAME ( ) assert NAME is not None , LIT assert ( not NAME ) , LIT"
    },
    {
      "module_path": "credentials.py",
      "qualname": "test_setup_credentials_permission_error",
      "lineno": 1214,
      "end_lineno": 1230,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "373515da281a5fc9a1401432e8bcb521e6fe9fc0",
      "simhash64": 5182512936701039663,
      "normalized": "def NAME ( ) : LIT if NAME : NAME = NAME ( ) # Mock encrypt_credentials to simulate error with NAME . NAME ( NAME . NAME , LIT , NAME = NAME ( LIT ) , ) : # This should handle the error gracefully NAME = NAME . NAME ( LIT , LIT , LIT ) assert not NAME , LIT"
    },
    {
      "module_path": "credentials.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 1327,
      "end_lineno": 1329,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "credentials.py",
      "qualname": "main",
      "lineno": 1332,
      "end_lineno": 1406,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 12,
      "yield_count": 0,
      "complexity": 17,
      "loc": 75,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "purpose:test_runner",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "a218181242daff72a3c2580221734fe85bb30e58",
      "simhash64": 7487617073093710891,
      "normalized": "def NAME ( ) -> NAME : LIT # Support non-interactive .env import if NAME ( NAME . NAME ) > LIT and NAME . NAME [ LIT ] == LIT : if not NAME : NAME ( LIT ) NAME . NAME ( ) return False try : NAME = NAME ( ) # Use default .env path, non-interactive NAME ( LIT ) NAME . NAME = NAME . NAME . NAME . NAME ( NAME ) # Patch input to always use default .env and merge import NAME NAME = NAME . NAME def NAME ( NAME = LIT ) : if LIT in NAME : return LIT if LIT in NAME : return LIT # Overwrite existing with .env values if LIT in NAME : return LIT return LIT NAME . NAME = NAME try : NAME . NAME ( ) finally : NAME . NAME = NAME NAME ( LIT ) return True except NAME as NAME : NAME ( f\" \u274c Error during .env import: { NAME } \" ) return False # Auto-detect if being run as part of the test harness if NAME . NAME . NAME ( LIT ) == LIT : NAME ( LIT ) return NAME ( ) # Time-based auto-test detection (add a short timeout to avoid hanging in test suites) from NAME import NAME if NAME . NAME ( ) > LIT and NAME ( NAME . NAME [ LIT ] ) . NAME == LIT : if not NAME . NAME . NAME ( ) or NAME . NAME . NAME ( LIT ) == LIT : NAME ( LIT ) return NAME ( ) if not NAME : NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME ( LIT ) NAME ( LIT ) if NAME . NAME ( ) : NAME ( LIT ) NAME ( LIT ) else : NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) return False try : NAME = NAME ( ) return NAME . NAME ( ) except NAME as NAME : NAME ( f\" \u274c Failed to start credential manager: { NAME } \" ) return False"
    },
    {
      "module_path": "credentials.py",
      "qualname": "fake_input",
      "lineno": 1350,
      "end_lineno": 1357,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(prompt)",
      "fingerprint": "143060edc7da09ffdf349b9c9b101136b81b15e4",
      "simhash64": 5762867599829275179,
      "normalized": "def NAME ( NAME = LIT ) : if LIT in NAME : return LIT if LIT in NAME : return LIT # Overwrite existing with .env values if LIT in NAME : return LIT return LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "DnaMatch.uuid",
      "lineno": 396,
      "end_lineno": 398,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "1c25f5691015de9d0081cca0ef3bedbd91615fa1",
      "simhash64": 7488180023047140419,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT return NAME . NAME . NAME if NAME . NAME else None"
    },
    {
      "module_path": "database.py",
      "qualname": "FamilyTree.uuid",
      "lineno": 477,
      "end_lineno": 479,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "1c25f5691015de9d0081cca0ef3bedbd91615fa1",
      "simhash64": 7488180023047140419,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT return NAME . NAME . NAME if NAME . NAME else None"
    },
    {
      "module_path": "database.py",
      "qualname": "_create_views",
      "lineno": 638,
      "end_lineno": 645,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(_target, connection, **kwargs)",
      "fingerprint": "adfef7fff1a65c2d35cc0e3e2f51596f1c2adcaf",
      "simhash64": 8640573763079283731,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , ** NAME : NAME ) -> None : LIT NAME . NAME ( LIT ) try : NAME . NAME ( NAME ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error creating 'messages' database view: { NAME } \" , NAME = True )"
    },
    {
      "module_path": "database.py",
      "qualname": "db_transn",
      "lineno": 656,
      "end_lineno": 780,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 1,
      "complexity": 6,
      "loc": 125,
      "tags": [
        "impure",
        "db",
        "time",
        "size:large"
      ],
      "signature": "(session)",
      "fingerprint": "238bedc4070b66890381171ef51e2e06b2b47b9c",
      "simhash64": 7451553092710339611,
      "normalized": "def NAME ( NAME : NAME ) : LIT NAME = NAME . NAME ( ) NAME = NAME ( NAME ) # Create enhanced error context NAME = NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = { LIT : NAME } , ) NAME . NAME ( ) try : # Step 1: Validate session state if not NAME ( NAME , LIT ) : raise NAME ( LIT , NAME = { LIT : NAME , LIT : NAME ( NAME ) . NAME , } , ) NAME . NAME ( f\" --- Entering enhanced db_transn block (Session: { NAME } ) --- \" ) yield NAME # Step 2: Attempt commit with timeout protection NAME = NAME . NAME ( ) NAME . NAME ( f\" Attempting commit... (Session: { NAME } ) \" ) try : NAME . NAME ( ) NAME = NAME . NAME ( ) - NAME NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Commit successful in { NAME : .3f } s. Total transaction: { NAME : .3f } s (Session: { NAME } ) \" ) except NAME as NAME : raise NAME ( f\" Database commit failed: { NAME } \" , NAME = { LIT : NAME , LIT : NAME . NAME ( ) - NAME , LIT : NAME . NAME ( ) - NAME , } , NAME = LIT , ) except NAME : # Re-raise database-specific errors raise except NAME as NAME : # Wrap other exceptions in appropriate error types NAME = NAME ( NAME ) . NAME NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Exception occurred in db_transn block: { NAME } . Rolling back... (Session: { NAME } ) \" , NAME = True , ) # Enhanced rollback with error handling try : NAME = NAME . NAME ( ) NAME . NAME ( ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Rollback successful in { NAME : .3f } s. (Session: { NAME } ) \" ) # Determine if error is retryable if NAME ( NAME , ( NAME . NAME , NAME . NAME ) ) : # Pass recovery_hint only once via kwargs supported by DatabaseConnectionError raise NAME ( f\" Database operation failed: { NAME } \" , NAME = { LIT : NAME , LIT : NAME , LIT : NAME ( NAME ) , } , NAME = LIT , ) else : # Avoid passing duplicate keyword args; RetryableError accepts context via kwargs only raise NAME ( f\" Transaction failed: { NAME } \" , NAME = { LIT : NAME , LIT : NAME , LIT : NAME , } , ) except NAME as NAME : # Critical rollback failure raise NAME ( f\" CRITICAL: Failed during rollback: { NAME } \" , NAME = { LIT : NAME , LIT : NAME ( NAME ) , LIT : NAME ( NAME ) , } , NAME = LIT , ) finally : NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" --- db_transn finally block reached in { NAME : .3f } s (Session: { NAME } ). --- \" )"
    },
    {
      "module_path": "database.py",
      "qualname": "create_person",
      "lineno": 793,
      "end_lineno": 940,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 8,
      "yield_count": 0,
      "complexity": 20,
      "loc": 148,
      "tags": [
        "impure",
        "logging",
        "time",
        "purpose:factory",
        "size:large"
      ],
      "signature": "(session, person_data)",
      "fingerprint": "01d6664e4201f76211cdd3ba549c9dfaee580ac4",
      "simhash64": 7452151225961059347,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT # Step 1: Basic validation of required fields NAME = ( LIT , ) # UUID/ProfileID can be nullable initially if not NAME ( NAME in NAME and NAME [ NAME ] is not None for NAME in NAME ) : NAME . NAME ( f\" create_person: Missing required data (username). Data: { NAME } \" ) return LIT # Step 2: Prepare identifiers and log reference NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( ) if NAME else None NAME = NAME . NAME ( LIT ) NAME = NAME ( NAME ) . NAME ( ) if NAME else None NAME = NAME [ LIT ] NAME = f\" UUID= { NAME or LIT } / ProfileID= { NAME or LIT } / User=' { NAME } ' \" # Step 3: Pre-check for existing records (improves logging, not strictly necessary due to constraints) try : if NAME : NAME = ( NAME . NAME ( NAME . NAME ) . NAME ( NAME . NAME == NAME ) . NAME ( ) ) if NAME : NAME . NAME ( f\" Create FAILED { NAME } : Profile ID already exists (ID { NAME } ). \" ) return LIT # Return 0 to indicate failure due to duplicate if NAME : NAME = ( NAME . NAME ( NAME . NAME ) . NAME ( NAME . NAME == NAME ) . NAME ( ) ) if NAME : NAME . NAME ( f\" Create FAILED { NAME } : UUID already exists (ID { NAME } ). \" ) return LIT # Return 0 to indicate failure due to duplicate # Step 4: Prepare data for the new Person object NAME . NAME ( f\" Proceeding with Person creation for { NAME } . \" ) # Ensure datetime objects are timezone-aware (UTC) NAME = NAME . NAME ( LIT ) if NAME ( NAME , NAME ) and NAME . NAME is None : NAME = NAME . NAME ( NAME = NAME . NAME ) # Handle status enum conversion NAME = NAME . NAME ( LIT , NAME . NAME ) # Default to ACTIVE if NAME ( NAME , NAME ) : NAME = NAME else : try : NAME = NAME ( NAME ( NAME ) . NAME ( ) ) # Try conversion except NAME : NAME . NAME ( f\" Invalid status ' { NAME } ' for { NAME } , defaulting to ACTIVE. \" ) NAME = NAME . NAME # Map input data to Person model attributes NAME = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : ( NAME . NAME ( LIT , LIT ) . NAME ( ) if NAME . NAME ( LIT ) else None ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME ( NAME . NAME ( LIT , False ) ) , LIT : NAME , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME ( NAME . NAME ( LIT , True ) ) , # Default True LIT : NAME , } # Step 5: Create and add the new Person object NAME = NAME ( ** NAME ) NAME . NAME ( NAME ) NAME . NAME ( ) # Flush to assign ID and trigger constraints immediately # Step 6: Verify ID assignment and return if NAME . NAME is None : # Should not happen if flush succeeds without error, but safety check NAME . NAME ( f\" ID not assigned after flush for { NAME } ! Rolling back. \" ) NAME . NAME ( ) # Explicit rollback on unexpected failure return LIT # Get the ID safely using SQLAlchemy's inspection API NAME = LIT try : # Use the SQLAlchemy inspection API to get the actual value NAME = NAME . NAME ( NAME ( NAME . NAME ) . NAME ( NAME . NAME == NAME . NAME ) ) if NAME is None : NAME = LIT except NAME as NAME : NAME . NAME ( f\" Error getting person ID: { NAME } \" ) NAME = LIT NAME . NAME ( f\" Created Person ID { NAME } for { NAME } . \" ) return NAME # Return the new ID as int # Step 7: Handle specific database errors except NAME as NAME : # Catch UNIQUE constraint violations (redundant with pre-check but safe) NAME . NAME ( ) NAME . NAME ( f\" IntegrityError create_person { NAME } : { NAME } . \" , NAME = False ) return LIT # Return 0 on integrity error except NAME as NAME : NAME . NAME ( f\" DB error create_person { NAME } : { NAME } \" , NAME = True ) try : NAME . NAME ( ) # Attempt rollback except NAME : pass return LIT # Return 0 on general DB error # Step 8: Handle unexpected errors except NAME as NAME : NAME . NAME ( f\" Unexpected error create_person { NAME } : { NAME } \" , NAME = True ) try : NAME . NAME ( ) # Attempt rollback except NAME : pass return LIT # Return 0 on critical error"
    },
    {
      "module_path": "database.py",
      "qualname": "create_or_update_dna_match",
      "lineno": 946,
      "end_lineno": 1101,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 12,
      "yield_count": 0,
      "complexity": 27,
      "loc": 156,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "size:large"
      ],
      "signature": "(session, match_data)",
      "fingerprint": "d437f50bdf090abfb9a46da447078c16684101b3",
      "simhash64": 7488180022980023323,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ LIT , LIT , LIT , LIT ] : LIT # Step 1: Validate people_id NAME = NAME . NAME ( LIT ) NAME = f\" PersonID= { NAME } , KitUUID= { NAME . NAME ( LIT , LIT ) } \" if not NAME or not NAME ( NAME , NAME ) or NAME <= LIT : NAME . NAME ( f\" create_or_update_dna_match: Invalid people_id { NAME } . \" ) return LIT # Step 2: Validate and prepare incoming data NAME : NAME [ NAME , NAME ] = { LIT : NAME } try : # Required fields NAME [ LIT ] = NAME [ LIT ] NAME [ LIT ] = NAME [ LIT ] try : NAME = NAME ( NAME ( NAME [ LIT ] ) ) # Handle float strings if NAME < LIT : raise NAME ( LIT ) NAME [ LIT ] = NAME except ( NAME , NAME ) as NAME : NAME . NAME ( f\" Invalid cM_DNA value ' { NAME . NAME ( LIT ) } ' for { NAME } : { NAME } \" ) raise NAME ( f\" Invalid cM_DNA value: { NAME } \" ) except ( NAME , NAME , NAME ) as NAME : NAME . NAME ( f\" create_or_update_dna_match: Missing/Invalid required data for { NAME } : { NAME } \" ) return LIT # Optional numeric fields validation helper def NAME ( NAME : NAME , NAME : NAME , NAME : NAME = False ) -> NAME [ NAME [ NAME , NAME ] ] : if NAME is None : return None try : if NAME ( NAME , NAME ) and not NAME . NAME ( LIT , LIT , LIT ) . NAME ( ) : return None return NAME ( NAME ) if NAME else NAME ( NAME ) except ( NAME , NAME ) : return None # Populate validated_data with optional fields NAME [ LIT ] = NAME ( LIT , NAME . NAME ( LIT ) ) NAME [ LIT ] = NAME ( LIT , NAME . NAME ( LIT ) , NAME = True , ) NAME [ LIT ] = NAME ( LIT , NAME . NAME ( LIT ) ) NAME [ LIT ] = NAME ( NAME . NAME ( LIT , False ) ) NAME [ LIT ] = NAME ( NAME . NAME ( LIT , False ) ) # Step 3: Check if DnaMatch record exists try : NAME = ( NAME . NAME ( NAME ) . NAME ( NAME = NAME ) . NAME ( ) ) if NAME : # Step 4: UPDATE existing record if changes detected NAME = False for NAME , NAME in NAME . NAME ( ) : # Skip people_id comparison if NAME == LIT : continue NAME = NAME ( NAME , NAME , None ) # Handle float comparison with tolerance if NAME ( NAME , NAME ) or NAME ( NAME , NAME ) : # Treat None as 0.0 for comparison to avoid errors, but check explicitly NAME = NAME ( NAME ) if NAME is not None else None NAME = NAME ( NAME ) if NAME is not None else None if ( NAME is None and NAME is not None ) or ( NAME is not None and NAME is None ) : NAME = True elif ( NAME is not None and NAME is not None and NAME ( NAME - NAME ) > LIT ) : # Tolerance NAME = True else : # Both None or difference within tolerance NAME = False # Handle boolean comparison carefully elif NAME ( NAME , NAME ) or NAME ( NAME , NAME ) : NAME = NAME ( NAME ) != NAME ( NAME ) # General comparison for other types elif NAME != NAME : NAME = True else : NAME = False if NAME : NAME . NAME ( f\" DNA Change Detected for { NAME } : Field ' { NAME } ' (' { NAME } ' -> ' { NAME } ') \" ) NAME ( NAME , NAME , NAME ) NAME = True if NAME : # Use setattr to avoid type checking issues with SQLAlchemy columns NAME . NAME = NAME . NAME ( NAME . NAME ) # Update timestamp NAME . NAME ( f\" Updating existing DnaMatch record for { NAME } . \" ) # No need to session.add() for updates if object fetched within session return LIT NAME . NAME ( f\" Existing DnaMatch found for { NAME } , no changes needed. Skipping. \" ) return LIT # Step 5: Create new record NAME . NAME ( f\" Creating new DnaMatch record for { NAME } . \" ) NAME = NAME ( ** NAME ) NAME . NAME ( NAME ) NAME . NAME ( f\" DnaMatch record added to session for { NAME } . \" ) return LIT # Step 6: Handle database errors except ( NAME ) as NAME : # Should not happen if unique=True on people_id logic correct NAME . NAME ( ) NAME . NAME ( f\" IntegrityError create/update DNA Match { NAME } : { NAME } . \" , NAME = False ) return LIT except NAME as NAME : NAME . NAME ( f\" DB error create/update DNA Match { NAME } : { NAME } \" , NAME = True ) return LIT except NAME as NAME : NAME . NAME ( f\" Unexpected error create/update DNA Match { NAME } : { NAME } \" , NAME = True ) return LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "validate_optional_numeric",
      "lineno": 991,
      "end_lineno": 1001,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 5,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(_key, value, allow_float)",
      "fingerprint": "dd2c5436b40da623ef6d25051051cd5af1b70bd9",
      "simhash64": 7488320760468902947,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME = False ) -> NAME [ NAME [ NAME , NAME ] ] : if NAME is None : return None try : if NAME ( NAME , NAME ) and not NAME . NAME ( LIT , LIT , LIT ) . NAME ( ) : return None return NAME ( NAME ) if NAME else NAME ( NAME ) except ( NAME , NAME ) : return None"
    },
    {
      "module_path": "database.py",
      "qualname": "create_or_update_family_tree",
      "lineno": 1107,
      "end_lineno": 1201,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 8,
      "yield_count": 0,
      "complexity": 12,
      "loc": 95,
      "tags": [
        "impure",
        "time",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(session, tree_data)",
      "fingerprint": "380ca9a51a4386303ff29d2c6e81dfe925c16a0b",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ LIT , LIT , LIT , LIT ] : LIT # Step 1: Validate people_id NAME = NAME . NAME ( LIT ) if not NAME or not NAME ( NAME , NAME ) or NAME <= LIT : NAME . NAME ( LIT ) return LIT # Step 2: Prepare log reference and incoming data dictionary NAME = NAME . NAME ( LIT ) NAME = f\" PersonID= { NAME } , CFPID= { NAME or LIT } \" # Filter only valid columns for the FamilyTree model from input NAME = { NAME . NAME : NAME . NAME ( NAME . NAME ) for NAME in NAME . NAME . NAME if NAME . NAME in NAME and NAME . NAME not in ( LIT , LIT , LIT ) } # Ensure people_id is included NAME [ LIT ] = NAME # Step 3: Check if FamilyTree record exists try : NAME = NAME . NAME ( NAME ) . NAME ( NAME = NAME ) . NAME ( ) if NAME : # Step 4: Update existing record if changes detected NAME = False for NAME , NAME in NAME . NAME ( ) : if NAME == LIT : continue # Skip key comparison NAME = NAME ( NAME , NAME , None ) # Compare values, treating None consistently if NAME != NAME : NAME . NAME ( f\" Tree Change Detected for { NAME } : Field ' { NAME } ' (' { NAME } ' -> ' { NAME } ') \" ) NAME ( NAME , NAME , NAME ) NAME = True if NAME : # Use setattr to avoid type checking issues with SQLAlchemy columns NAME . NAME = NAME . NAME ( NAME . NAME ) # Update timestamp NAME . NAME ( f\" Updating existing FamilyTree record for { NAME } . \" ) # No need to session.add() for updates return LIT NAME . NAME ( f\" Existing FamilyTree record found for { NAME } , no changes needed. Skipping. \" ) return LIT # Step 5: Create new record NAME . NAME ( f\" Creating new FamilyTree record for { NAME } . \" ) NAME = NAME ( ** NAME ) NAME . NAME ( NAME ) NAME . NAME ( f\" FamilyTree record added to session for { NAME } . \" ) return LIT # Step 6: Handle database errors except NAME as NAME : NAME . NAME ( f\" TypeError create/update FamilyTree { NAME } : { NAME } . Args: { NAME } \" , NAME = True , ) return LIT except NAME as NAME : NAME . NAME ( ) NAME . NAME ( f\" IntegrityError create/update FamilyTree { NAME } : { NAME } \" , NAME = False ) return LIT except NAME as NAME : NAME . NAME ( f\" SQLAlchemyError create/update FamilyTree { NAME } : { NAME } \" , NAME = True ) return LIT except NAME as NAME : NAME . NAME ( f\" Unexpected error create_or_update_family_tree { NAME } : { NAME } \" , NAME = True , ) return LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "create_or_update_person",
      "lineno": 1207,
      "end_lineno": 1432,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 9,
      "yield_count": 0,
      "complexity": 35,
      "loc": 226,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "size:large"
      ],
      "signature": "(session, person_data)",
      "fingerprint": "b8e66bdac2c96610fbbec6ae2128b9a9db93a71c",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME ] , NAME [ LIT , LIT , LIT , LIT ] ] : LIT # Step 1: Extract and validate mandatory identifiers NAME = NAME . NAME ( LIT ) NAME = NAME ( NAME ) . NAME ( ) if NAME else None NAME = NAME . NAME ( LIT ) if not NAME or not NAME : NAME . NAME ( f\" Cannot create/update person: UUID or Username missing. Data: { NAME } \" ) return None , LIT # Step 2: Prepare log reference NAME = ( NAME ( NAME . NAME ( LIT ) ) . NAME ( ) if NAME . NAME ( LIT ) else None ) NAME = f\" UUID= { NAME } / ProfileID= { NAME or LIT } / User=' { NAME } ' \" try : # Step 3: Attempt to find the person definitively by UUID # Use with_for_update() if optimistic locking is needed and supported by DB dialect NAME = ( NAME . NAME ( NAME ) . NAME ( NAME . NAME == NAME ) . NAME ( ) ) # .with_for_update() if NAME : # --- Step 4: UPDATE existing person --- NAME = False # Flag to track if any field actually changed NAME . NAME ( f\" { NAME } : Updating existing Person ID { NAME . NAME } . \" ) # Step 4a: Define fields to compare and potentially update NAME = { LIT : NAME , # Update Profile ID if provided and different LIT : NAME , # Update username LIT : ( NAME . NAME ( LIT , LIT ) . NAME ( ) if NAME . NAME ( LIT ) else None ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME ( NAME . NAME ( LIT , False ) ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME ( NAME . NAME ( LIT , True ) ) , # Ensure boolean LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , # Allow status update } # Step 4b: Iterate and compare fields for NAME , NAME in NAME . NAME ( ) : NAME = NAME ( NAME , NAME , None ) NAME = False # Handle specific comparisons and type conversions if NAME == LIT : # Compare datetimes timezone-aware (UTC) and ignore microseconds NAME = None if NAME ( NAME , NAME ) : NAME = ( NAME . NAME ( NAME . NAME ) if NAME . NAME else NAME . NAME ( NAME = NAME . NAME ) ) . NAME ( NAME = LIT ) NAME = None if NAME ( NAME , NAME ) : NAME = ( NAME . NAME ( NAME . NAME ) if NAME . NAME else NAME . NAME ( NAME = NAME . NAME ) ) . NAME ( NAME = LIT ) if ( NAME != NAME ) : # Handles None comparison correctly NAME = True # Value to set is the original new_value (which might have tz info) NAME = ( NAME if NAME ( NAME , NAME ) else None ) else : NAME = NAME # Keep existing if unchanged elif NAME == LIT : # Convert new status to Enum for comparison/setting NAME = NAME # Already an Enum NAME = None if NAME ( NAME , NAME ) : NAME = NAME elif NAME is not None : # Try converting string/other try : NAME = NAME ( NAME ( NAME ) . NAME ( ) ) except NAME : NAME . NAME ( f\" Invalid status value ' { NAME } ' for update { NAME } . Skipping status update. \" ) continue if NAME is not None and NAME != NAME : NAME = True NAME = NAME else : NAME = NAME elif NAME == LIT : # Only update birth year if new value is valid int and current is None if NAME is not None and NAME is None : try : NAME = NAME ( NAME ) NAME = True except ( NAME , NAME ) : NAME . NAME ( f\" Invalid birth_year ' { NAME } ' for update { NAME } . Skipping. \" ) continue else : NAME = NAME # Keep existing elif NAME == LIT : # Only update gender if new value is valid ('f'/'m') and current is None if ( NAME is not None and NAME is None and NAME ( NAME , NAME ) and NAME . NAME ( ) in ( LIT , LIT ) ) : NAME = NAME . NAME ( ) NAME = True else : NAME = NAME # General comparison for other fields # Ensure boolean comparisons work correctly elif NAME ( NAME , NAME ) or NAME ( NAME , NAME ) : if NAME ( NAME ) != NAME ( NAME ) : NAME = True NAME = NAME ( NAME ) else : NAME = NAME # Standard comparison for other types elif NAME != NAME : NAME = True NAME = NAME else : NAME = NAME # Apply the update if value changed if NAME : NAME ( NAME , NAME , NAME ) NAME = True # logger.debug(f\"  Updating {key} for Person {existing_person.id}\") # Verbose log # Step 4c: Set updated_at timestamp if any field changed if NAME : # Use setattr to avoid type checking issues with SQLAlchemy columns NAME . NAME = NAME . NAME ( NAME . NAME ) NAME . NAME ( ) # Apply updates to DB session state return NAME , LIT NAME . NAME ( f\" { NAME } : No updates needed for existing person. \" ) return NAME , LIT # --- Step 5: CREATE new person --- NAME . NAME ( f\" { NAME } : Creating new Person. \" ) # Use the helper function for creation NAME = NAME ( NAME , NAME ) if NAME > LIT : # Fetch the newly created object to return it NAME = NAME . NAME ( NAME , NAME ) if NAME : return NAME , LIT # This indicates a problem if create_person returned an ID but get() failed NAME . NAME ( f\" Failed to fetch newly created person { NAME } ID { NAME } after successful creation report. \" ) # Rollback might be needed if state is inconsistent with NAME . NAME ( NAME ) : NAME . NAME ( ) return None , LIT # create_person already logged the error NAME . NAME ( f\" create_person helper failed for { NAME } . \" ) return None , LIT # --- Step 6: Handle Exceptions --- except NAME as NAME : NAME . NAME ( ) NAME . NAME ( f\" IntegrityError processing person { NAME } : { NAME } . Rolling back. \" , NAME = False , ) return None , LIT except NAME as NAME : try : NAME . NAME ( ) # Attempt rollback on DB errors except NAME : pass NAME . NAME ( f\" SQLAlchemyError processing person { NAME } : { NAME } \" , NAME = True ) return None , LIT except NAME as NAME : try : NAME . NAME ( ) # Attempt rollback on unexpected errors except NAME : pass NAME . NAME ( f\" Unexpected critical error processing person { NAME } : { NAME } \" , NAME = True ) return None , LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "get_person_by_profile_id_and_username",
      "lineno": 1443,
      "end_lineno": 1490,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 5,
      "loc": 48,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(session, profile_id, username, include_deleted)",
      "fingerprint": "648417c2f1dc0a1b15b88ee69a377db8cd4a5b96",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME = False ) -> NAME [ NAME ] : LIT # Step 1: Validate inputs if not NAME or not NAME : NAME . NAME ( LIT ) return None # Step 2: Query database try : NAME = NAME . NAME ( NAME ) . NAME ( NAME . NAME ( NAME . NAME ) == NAME . NAME ( ) , # Case-insensitive profile ID compare NAME . NAME == NAME , # Case-sensitive username compare (default SQLite) ) # Apply deleted filter unless include_deleted is True if not NAME : NAME = NAME ( NAME ) return NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" DB error retrieving person by profile_id/username ' { NAME } / { NAME } ': { NAME } \" , NAME = True , ) return None except NAME as NAME : NAME . NAME ( f\" Unexpected error retrieving person by profile_id/username: { NAME } \" , NAME = True , ) return None"
    },
    {
      "module_path": "database.py",
      "qualname": "get_person_by_profile_id",
      "lineno": 1496,
      "end_lineno": 1539,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 44,
      "tags": [
        "impure",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(session, profile_id, include_deleted)",
      "fingerprint": "3a0c27170d789839659170cc8de7d7b6d812a678",
      "simhash64": 8641066343214789651,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME = False ) -> NAME [ NAME ] : LIT # Step 1: Validate input if not NAME : NAME . NAME ( LIT ) return None # Step 2: Query database try : # Use func.upper for case-insensitive comparison if needed (depends on DB collation) # For SQLite, default is often case-sensitive, so explicit upper is safer. NAME = NAME . NAME ( NAME ) . NAME ( NAME . NAME ( NAME . NAME ) == NAME . NAME ( ) ) # Apply deleted filter unless include_deleted is True if not NAME : NAME = NAME ( NAME ) return NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" DB error retrieving person by profile_id ' { NAME } ': { NAME } \" , NAME = True , ) return None except NAME as NAME : NAME . NAME ( f\" Unexpected error retrieving person by profile_id ' { NAME } ': { NAME } \" , NAME = True , ) return None"
    },
    {
      "module_path": "database.py",
      "qualname": "_extract_person_identifiers",
      "lineno": 1545,
      "end_lineno": 1549,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(match_data)",
      "fingerprint": "bfe74ddd59eb8fafbdad1d3ed8e00c2b2a87127f",
      "simhash64": 7488180022980031571,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME ] , NAME [ NAME ] ] : LIT NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) return NAME , NAME"
    },
    {
      "module_path": "database.py",
      "qualname": "_validate_person_identifiers",
      "lineno": 1552,
      "end_lineno": 1557,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:tiny"
      ],
      "signature": "(profile_id, username)",
      "fingerprint": "0a2086d04d09bbafd390fcb6b933b405aabdb52f",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME [ NAME ] ) -> NAME : LIT if not NAME or not NAME : NAME . NAME ( LIT ) return False return True"
    },
    {
      "module_path": "database.py",
      "qualname": "_build_person_query",
      "lineno": 1560,
      "end_lineno": 1576,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(session, profile_id, username, include_deleted)",
      "fingerprint": "50c910312bbbe68c3a3d5124f3de75a3b9406521",
      "simhash64": 7488215207352116243,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT NAME = ( NAME . NAME ( NAME ) . NAME ( NAME ( NAME . NAME ) ) # Eager load DnaMatch relationship . NAME ( NAME . NAME ( NAME . NAME ) == NAME . NAME ( ) , # Case-insensitive profile ID NAME . NAME == NAME , # Case-sensitive username ) ) # Apply deleted filter unless include_deleted is True if not NAME : NAME = NAME ( NAME ) return NAME"
    },
    {
      "module_path": "database.py",
      "qualname": "_handle_person_query_error",
      "lineno": 1579,
      "end_lineno": 1591,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(profile_id, username, error)",
      "fingerprint": "28a06be94c42eb1affe3c52c98f0120bc38b3c52",
      "simhash64": 2841661477242704923,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME [ None , None ] : LIT if NAME ( NAME , NAME ) : NAME . NAME ( f\" DB error retrieving person/DNA match for profile { NAME } / { NAME } : { NAME } \" , NAME = True , ) else : NAME . NAME ( f\" Unexpected error retrieving person/DNA match for profile { NAME } / { NAME } : { NAME } \" , NAME = True , ) return None , None"
    },
    {
      "module_path": "database.py",
      "qualname": "get_person_and_dna_match",
      "lineno": 1594,
      "end_lineno": 1626,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 33,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(session, match_data, include_deleted)",
      "fingerprint": "0a0e6ed1cecb55dac8f4ffc773732c722a069b44",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME = False ) -> NAME [ NAME [ NAME ] , NAME [ NAME ] ] : LIT # Extract and validate identifiers NAME , NAME = NAME ( NAME ) if not NAME ( NAME , NAME ) : return None , None # Query database with eager loading try : NAME = NAME ( NAME , NAME , NAME , NAME ) NAME = NAME . NAME ( ) # Return results if NAME : return NAME , NAME . NAME # dna_match is already loaded return None , None except NAME as NAME : return NAME ( NAME , NAME , NAME )"
    },
    {
      "module_path": "database.py",
      "qualname": "exclude_deleted_persons",
      "lineno": 1632,
      "end_lineno": 1642,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(query)",
      "fingerprint": "c199b69b08ed00d1d814e4e3413e4c16dc927cc2",
      "simhash64": 8640573762005541891,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return NAME . NAME ( NAME . NAME . NAME ( None ) )"
    },
    {
      "module_path": "database.py",
      "qualname": "find_existing_person",
      "lineno": 1648,
      "end_lineno": 1760,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 9,
      "yield_count": 0,
      "complexity": 20,
      "loc": 113,
      "tags": [
        "pure-ish",
        "size:large"
      ],
      "signature": "(session, identifier_data, include_deleted)",
      "fingerprint": "d7699b3470e7154d091f7ff5314bdf442aa7de93",
      "simhash64": 7488285576097346611,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME = False ) -> NAME [ NAME ] : LIT # Step 1: Extract identifiers and create log reference NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) # Keep case as provided for potential disambiguation NAME = NAME ( NAME ) . NAME ( ) if NAME else None NAME = ( NAME ( NAME ) . NAME ( ) if NAME else None ) NAME = [ ] if NAME : NAME . NAME ( f\" UUID=' { NAME } ' \" ) if NAME : NAME . NAME ( f\" ProfileID=' { NAME } ' \" ) if NAME : NAME . NAME ( f\" User=' { NAME } ' \" ) NAME = LIT . NAME ( NAME ) or LIT NAME : NAME [ NAME ] = None try : # Create base query NAME = NAME . NAME ( NAME ) # Apply deleted filter unless include_deleted is True if not NAME : NAME = NAME ( NAME ) # Step 2: Prioritize lookup by UUID (should be unique) if NAME : NAME = NAME . NAME ( NAME . NAME == NAME ) . NAME ( ) if NAME : # logger.debug(f\"Found existing person by UUID for {log_ref} (ID: {person.id}).\") return NAME # Found by UUID, return immediately # Step 3: If not found by UUID, try lookup by Profile ID (case-insensitive) if NAME is None and NAME : # Find all potential matches for the profile ID NAME = NAME . NAME ( NAME . NAME == NAME ) . NAME ( ) if not NAME : pass # No matches found by profile ID, proceed to final check elif NAME ( NAME ) == LIT : return NAME [ LIT ] # Unique match found by profile ID # logger.debug(f\"Found unique person by ProfileID for {log_ref} (ID: {person.id}).\") else : # Multiple matches found for the same profile ID NAME . NAME ( f\" Multiple ( { NAME ( NAME ) } ) people found for Profile ID: { NAME } . Attempting disambiguation... \" ) # Step 3a: Attempt disambiguation using username (case-sensitive) if NAME : NAME : NAME [ NAME ] = None NAME = LIT for NAME in NAME : # Compare exact username provided if NAME . NAME == NAME : NAME = NAME NAME += LIT if NAME == LIT and NAME : NAME . NAME ( f\" Disambiguated multiple ProfileID matches using exact Username ' { NAME } ' for { NAME } (ID: { NAME . NAME } ). \" ) return NAME if NAME > LIT : NAME . NAME ( f\" CRITICAL AMBIGUITY: Found { NAME } people matching BOTH ProfileID { NAME } AND Username ' { NAME } '. Cannot reliably identify. \" ) return None # Cannot safely return a match # No username match among the profile ID matches NAME . NAME ( f\" Multiple matches for ProfileID { NAME } , but none matched exact Username ' { NAME } '. \" ) return None # Cannot safely return a match # Multiple profile ID matches, but no username provided for disambiguation NAME . NAME ( f\" Multiple matches for ProfileID { NAME } , but no Username provided for disambiguation. \" ) return None # Cannot safely return a match # Step 4: Log if no reliable match found if NAME is None : NAME . NAME ( f\" No existing person reliably identified for { NAME } . \" ) # Step 5: Handle potential database errors except NAME as NAME : NAME . NAME ( f\" DB error find_existing_person for { NAME } : { NAME } \" , NAME = True ) return None # Step 6: Handle unexpected errors except NAME as NAME : NAME . NAME ( f\" Unexpected error find_existing_person for { NAME } : { NAME } \" , NAME = True ) return None # Step 7: Return the found person or None return NAME"
    },
    {
      "module_path": "database.py",
      "qualname": "get_person_by_uuid",
      "lineno": 1766,
      "end_lineno": 1808,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 43,
      "tags": [
        "impure",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(session, uuid, include_deleted)",
      "fingerprint": "dab8910bed0b5ef233cedb959a313408279c1edc",
      "simhash64": 7488144838607942675,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME = False ) -> NAME [ NAME ] : LIT # Step 1: Validate input if not NAME : NAME . NAME ( LIT ) return None # Step 2: Query database with eager loading try : NAME = ( NAME . NAME ( NAME ) . NAME ( NAME ( NAME . NAME ) , # Eager load DnaMatch NAME ( NAME . NAME ) , # Eager load FamilyTree ) . NAME ( NAME . NAME == NAME ( NAME ) . NAME ( ) ) # Ensure uppercase comparison ) # Apply deleted filter unless include_deleted is True if not NAME : NAME = NAME ( NAME ) return NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" DB error retrieving person by UUID { NAME } : { NAME } \" , NAME = True ) return None except NAME as NAME : NAME . NAME ( f\" Unexpected error retrieving person by UUID { NAME } : { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "database.py",
      "qualname": "commit_bulk_data",
      "lineno": 1816,
      "end_lineno": 1989,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 20,
      "loc": 174,
      "tags": [
        "impure",
        "db",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "(session, log_upserts, person_updates, context)",
      "fingerprint": "29d17b25cf7a4c72acf1bbc07600311661921493",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] , # List of dicts for ConversationLog NAME : NAME [ NAME , NAME ] , # Dict of {person_id: status_enum} NAME : NAME = LIT , # Optional context for logging ) -> NAME [ NAME , NAME ] : LIT # Step 1: Initialization NAME = LIT NAME = LIT NAME = [ ] # For bulk insert # Step 2: Check if there's data to commit if not NAME and not NAME : NAME . NAME ( f\" { NAME } : No data provided for commit. \" ) return LIT , LIT NAME = f\" [ { NAME } ] \" NAME . NAME ( f\" { NAME } Preparing commit: { NAME ( NAME ) } logs, { NAME ( NAME ) } person updates. \" ) # Step 3: Perform DB operations within a transaction context try : # Use the db_transn context manager to handle commit/rollback with NAME ( NAME ) as NAME : NAME . NAME ( f\" { NAME } Entered transaction block. \" ) # --- Step 3a: Prepare ConversationLog Data for Insert --- if NAME : NAME . NAME ( f\" { NAME } Preparing { NAME ( NAME ) } ConversationLog entries for insert... \" ) for NAME in NAME : NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) # Basic validation if not NAME ( [ NAME , NAME , NAME , NAME ( NAME , NAME ) , ] ) : NAME . NAME ( f\" { NAME } Skipping invalid log data (missing keys/ts): ConvID= { NAME } , Dir= { NAME } , PID= { NAME } , TS= { NAME } \" ) continue # Normalize direction to Enum try : if NAME ( NAME , NAME ) : NAME = NAME else : # Assume string value like 'IN' or 'OUT' NAME = NAME ( NAME ( NAME ) . NAME ( ) ) except NAME : NAME . NAME ( f\" { NAME } Invalid direction ' { NAME } ' in log data ConvID { NAME } . Skipping. \" ) continue # Normalize timestamp to aware UTC if NAME is not None : NAME = ( NAME . NAME ( NAME . NAME ) if NAME ( NAME , LIT ) and NAME . NAME else NAME . NAME ( NAME = NAME . NAME ) ) NAME [ LIT ] = NAME else : # Use current time if timestamp is None NAME [ LIT ] = NAME . NAME ( NAME . NAME ) # Update dict with normalized enum NAME [ LIT ] = NAME # Add to insert list (no need to check for existing records) NAME . NAME ( NAME ) # --- Step 3b: Bulk Insert ConversationLog Records --- if NAME : NAME . NAME ( f\" { NAME } Bulk inserting { NAME ( NAME ) } ConversationLog entries... \" ) NAME . NAME ( NAME , NAME ) NAME = NAME ( NAME ) NAME . NAME ( f\" { NAME } Successfully inserted { NAME } ConversationLog entries. \" ) # --- Step 3c: Person Update Logic (Bulk Update) --- if NAME : NAME = [ ] NAME . NAME ( f\" { NAME } Preparing { NAME ( NAME ) } Person status updates... \" ) for NAME , NAME in NAME . NAME ( ) : if not NAME ( NAME , NAME ) or NAME <= LIT : NAME . NAME ( f\" Invalid Person ID ' { NAME } ' in updates. Skipping. \" ) continue if not NAME ( NAME , NAME ) : NAME . NAME ( f\" Invalid status type ' { NAME ( NAME ) } ' for Person ID { NAME } . Skipping update. \" ) continue NAME . NAME ( { LIT : NAME , LIT : NAME , # Pass Enum directly, SQLAlchemy handles it LIT : NAME . NAME ( NAME . NAME ) , } ) if NAME : NAME . NAME ( f\" { NAME } Attempting bulk update for { NAME ( NAME ) } persons... \" ) try : from NAME import NAME NAME . NAME ( NAME ( NAME ) , NAME ) NAME = NAME ( NAME ) NAME . NAME ( f\" { NAME } Bulk update successful for { NAME } persons. \" ) except NAME as NAME : NAME . NAME ( f\" { NAME } Error during Person bulk update: { NAME } \" , NAME = True , ) raise # Re-raise to trigger transaction rollback else : NAME . NAME ( f\" { NAME } No valid Person updates prepared for bulk operation. \" ) NAME . NAME ( f\" { NAME } Exiting transaction block (commit follows). \" ) # --- Commit happens implicitly here when 'with db_transn' exits --- NAME . NAME ( f\" { NAME } Transaction committed successfully via db_transn. \" ) return NAME , NAME # Step 4: Handle exceptions during commit process except NAME as NAME : # db_transn handles rollback logging, just log overall failure here NAME . NAME ( f\" { NAME } DB Commit FAILED: { NAME } \" , NAME = True ) return LIT , LIT # Return 0 counts on failure"
    },
    {
      "module_path": "database.py",
      "qualname": "soft_delete_person",
      "lineno": 1998,
      "end_lineno": 2066,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 7,
      "loc": 69,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(session, profile_id, username)",
      "fingerprint": "c8b3b6b326b36cd8ce55c09b65517c4819ba3101",
      "simhash64": 7452116041588978707,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT # Step 1: Validate inputs if not NAME or not NAME : NAME . NAME ( LIT ) return False NAME = f\" ProfileID= { NAME } /User=' { NAME } ' \" # Step 2: Find the person to soft-delete try : NAME = ( NAME . NAME ( NAME ) . NAME ( NAME . NAME ( NAME . NAME ) == NAME . NAME ( ) , NAME . NAME == NAME , NAME . NAME . NAME ( None ) , # Only consider non-deleted records ) . NAME ( ) ) # Step 3: Handle case where person not found if not NAME : NAME . NAME ( f\" soft_delete_person: Person { NAME } not found or already deleted. Cannot soft-delete. \" ) return False # Indicate person wasn't found # Step 4: Set the deleted_at timestamp NAME = NAME . NAME # Get ID for logging NAME . NAME ( f\" Soft-deleting Person ID { NAME } ( { NAME } )... \" ) # Use setattr to avoid type checking issues with SQLAlchemy columns NAME . NAME = NAME . NAME ( NAME . NAME ) NAME . NAME = NAME . NAME # Also set status to ARCHIVE NAME . NAME ( ) # Apply changes to session state immediately NAME . NAME ( f\" Soft-deleted Person ID { NAME } ( { NAME } ) successfully. \" ) return True # Indicate success # Step 5: Handle database errors except NAME as NAME : NAME . NAME ( f\" DB error soft-deleting person { NAME } : { NAME } \" , NAME = True ) try : NAME . NAME ( ) # Attempt rollback except NAME : pass return False # Step 6: Handle unexpected errors except NAME as NAME : NAME . NAME ( f\" Unexpected error soft_delete_person { NAME } : { NAME } \" , NAME = True ) try : NAME . NAME ( ) # Attempt rollback except NAME : pass return False"
    },
    {
      "module_path": "database.py",
      "qualname": "hard_delete_person",
      "lineno": 2072,
      "end_lineno": 2141,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 7,
      "loc": 70,
      "tags": [
        "pure-ish",
        "logging",
        "size:medium"
      ],
      "signature": "(session, profile_id, username)",
      "fingerprint": "6f471c8a7b2444f87fe563b6f6ff900bad6173d6",
      "simhash64": 7452116041588978707,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT # Step 1: Validate inputs if not NAME or not NAME : NAME . NAME ( LIT ) return False NAME = f\" ProfileID= { NAME } /User=' { NAME } ' \" # Step 2: Find the person to delete try : NAME = ( NAME . NAME ( NAME ) . NAME ( NAME . NAME ( NAME . NAME ) == NAME . NAME ( ) , NAME . NAME == NAME , ) . NAME ( ) ) # Step 3: Handle case where person not found if not NAME : NAME . NAME ( f\" hard_delete_person: Person { NAME } not found. Cannot delete. \" ) return False # Indicate person wasn't found # Step 4: Delete the person object (cascades should handle related records) NAME = NAME . NAME # Get ID for logging before deletion NAME . NAME ( f\" Permanently deleting Person ID { NAME } ( { NAME } )... \" ) NAME . NAME ( NAME ) NAME . NAME ( ) # Apply deletion to session state immediately NAME . NAME ( f\" Permanently deleted Person ID { NAME } ( { NAME } ) successfully. \" ) return True # Indicate success # Step 5: Handle database errors except NAME as NAME : NAME . NAME ( f\" DB error hard-deleting person { NAME } : { NAME } \" , NAME = True ) try : NAME . NAME ( ) # Attempt rollback except NAME : pass return False # Step 6: Handle unexpected errors except NAME as NAME : NAME . NAME ( f\" Unexpected error hard_delete_person { NAME } : { NAME } \" , NAME = True ) try : NAME . NAME ( ) # Attempt rollback except NAME : pass return False"
    },
    {
      "module_path": "database.py",
      "qualname": "delete_person",
      "lineno": 2147,
      "end_lineno": 2166,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(session, profile_id, username, soft_delete)",
      "fingerprint": "37743274181ac2db8f3b41ef9a2349cc426881f8",
      "simhash64": 7488250392798463011,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME = True ) -> NAME : LIT if NAME : return NAME ( NAME , NAME , NAME ) return NAME ( NAME , NAME , NAME )"
    },
    {
      "module_path": "database.py",
      "qualname": "delete_database",
      "lineno": 2172,
      "end_lineno": 2281,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 11,
      "loc": 110,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "(_session_manager, db_path, max_attempts)",
      "fingerprint": "c48662379762b4b8f6cacb7fab1836f7ff414328",
      "simhash64": 7488144838608983059,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME = LIT ) : LIT # Step 1: Validate db_path type if not NAME ( NAME , NAME ) : try : NAME = NAME ( NAME ) NAME . NAME ( LIT ) except NAME : NAME . NAME ( f\" Cannot convert db_path { NAME } to Path object. Deletion aborted. \" ) return # Exit if path is invalid NAME . NAME ( f\" Attempting to delete database file: { NAME } \" ) NAME : NAME [ NAME ] = None # Step 2: Retry loop for deletion for NAME in NAME ( NAME ) : NAME . NAME ( f\" Delete attempt { NAME + LIT } / { NAME } for { NAME . NAME } ... \" ) try : # Step 2a: Run garbage collection and pause before attempting deletion # This can help release potential file locks held by the Python process. NAME . NAME ( LIT ) NAME . NAME ( ) NAME . NAME ( LIT ) NAME . NAME ( ) NAME . NAME ( LIT + NAME ) # Increasing delay # Step 2b: Check if file exists if NAME . NAME ( ) : NAME . NAME ( f\" Attempting Path.unlink on { NAME } ... \" ) NAME . NAME ( NAME = True ) NAME . NAME ( LIT ) # Short pause to allow filesystem to update # Step 2c: Verify deletion if not NAME . NAME ( ) : NAME . NAME ( f\" Database file ' { NAME . NAME } ' deleted successfully. \" ) return # Success # This might happen if deletion fails silently or is delayed NAME . NAME ( f\" os.remove called, but file ' { NAME } ' still exists. \" ) NAME = NAME ( f\" File exists after os.remove attempt { NAME + LIT } \" ) else : # File doesn't exist, consider it deleted NAME . NAME ( f\" Database file ' { NAME . NAME } ' does not exist (already deleted?). \" ) return # Success (or already done) # Step 3: Handle specific errors during deletion attempt except NAME as NAME : NAME . NAME ( f\" Permission denied deleting ' { NAME } ' (Attempt { NAME + LIT } ): { NAME } . File locked? \" ) NAME = NAME except NAME as NAME : # Check for specific Windows error code for locked file if NAME . NAME == LIT and NAME ( NAME , LIT ) and NAME . NAME == LIT : NAME . NAME ( f\" OSError (WinError 32) deleting ' { NAME } ' (Attempt { NAME + LIT } ): { NAME } . File locked? \" ) else : NAME . NAME ( f\" OSError deleting ' { NAME } ' (Attempt { NAME + LIT } ): { NAME } \" , NAME = True , ) NAME = NAME except NAME as NAME : NAME . NAME ( f\" Unexpected error during delete attempt { NAME + LIT } for ' { NAME } ': { NAME } \" , NAME = True , ) NAME = NAME # Step 4: Wait before next retry if NAME < NAME - LIT : NAME = LIT ** NAME # Exponential backoff for wait NAME . NAME ( f\" Waiting { NAME } seconds before next delete attempt... \" ) NAME . NAME ( NAME ) else : # Step 5: Raise error if all attempts fail NAME . NAME ( f\" Failed to delete database file ' { NAME . NAME } ' after { NAME } attempts. \" ) # Raise the last encountered error, or a generic one if none were caught raise NAME or NAME ( f\" Failed to delete { NAME } after { NAME } attempts \" ) # Should not be reached if loop logic is correct NAME . NAME ( f\" Exited delete_database loop unexpectedly for { NAME } . \" )"
    },
    {
      "module_path": "database.py",
      "qualname": "backup_database",
      "lineno": 2293,
      "end_lineno": 2445,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 13,
      "loc": 153,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:large"
      ],
      "signature": "(_session_manager)",
      "fingerprint": "36ac1befd152837b09d160a423046a63ed6661b1",
      "simhash64": 7453277126941643803,
      "normalized": "def NAME ( NAME : NAME [ NAME ] = None ) -> NAME : LIT NAME = NAME . NAME ( ) try : # Step 1: Get paths from config with validation NAME = NAME . NAME . NAME NAME = NAME . NAME . NAME # Step 2: Enhanced path validation if NAME is None : raise NAME ( LIT , NAME = LIT , NAME = LIT , NAME = LIT , ) if NAME is None : raise NAME ( LIT , NAME = LIT , NAME = LIT , NAME = LIT , ) # Step 3: Check source database exists and is accessible if not NAME . NAME ( ) : raise NAME ( f\" Database file ' { NAME . NAME } ' not found \" , NAME = LIT , NAME = { LIT : NAME ( NAME ) } , NAME = LIT , ) # Check if database file is readable try : with NAME . NAME ( LIT ) as NAME : NAME . NAME ( LIT ) # Try to read first byte except NAME : raise NAME ( f\" Permission denied accessing database file ' { NAME } ' \" , NAME = { LIT : NAME ( NAME ) } , NAME = LIT , ) # Step 4: Ensure backup directory exists with error handling try : NAME . NAME ( NAME = True , NAME = True ) except NAME : raise NAME ( f\" Permission denied creating backup directory ' { NAME } ' \" , NAME = { LIT : NAME ( NAME ) } , NAME = LIT , ) NAME = NAME / LIT # Check available disk space import NAME as NAME try : NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( ) . NAME NAME = NAME . NAME if NAME < NAME * LIT : # Need 10% extra space raise NAME ( f\" Insufficient disk space for backup. Need { NAME * LIT / LIT / LIT : .1f } MB, available { NAME / LIT / LIT : .1f } MB \" , NAME = { LIT : NAME , LIT : NAME , LIT : NAME ( NAME ) , } , NAME = LIT , ) except NAME as NAME : NAME . NAME ( f\" Could not check disk space: { NAME } \" ) NAME . NAME ( f\" Starting database backup: ' { NAME . NAME } ' -> ' { NAME } ' \" f\" (Size: { NAME . NAME ( ) . NAME / LIT / LIT : .1f } MB) \" ) # Step 5: Perform backup with enhanced error handling try : # Use copy2 to preserve metadata (like modification time) NAME . NAME ( NAME , NAME ) # Verify backup integrity if not NAME . NAME ( ) : raise NAME ( LIT , NAME = { LIT : NAME ( NAME ) } , ) # Verify backup size matches original NAME = NAME . NAME ( ) . NAME NAME = NAME . NAME ( ) . NAME if NAME != NAME : raise NAME ( f\" Backup size mismatch: original { NAME } bytes, backup { NAME } bytes \" , NAME = { LIT : NAME , LIT : NAME , LIT : NAME ( NAME ) , } , ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Database backup completed successfully in { NAME : .2f } s: ' { NAME . NAME } ' \" f\" ( { NAME / LIT / LIT : .1f } MB) \" ) return True except NAME as NAME : raise NAME ( f\" Permission denied during backup operation: { NAME } \" , NAME = { LIT : NAME ( NAME ) , LIT : NAME ( NAME ) } , NAME = LIT , ) except NAME as NAME : raise NAME ( f\" File system error during backup: { NAME } \" , NAME = { LIT : NAME ( NAME ) , LIT : NAME ( NAME ) } , NAME = LIT , ) except NAME : # Re-raise our custom exceptions raise except NAME as NAME : NAME = NAME . NAME ( ) - NAME raise NAME ( f\" Unexpected error during database backup: { NAME } \" , NAME = { LIT : NAME , LIT : NAME ( NAME ) . NAME , } , NAME = LIT , )"
    },
    {
      "module_path": "database.py",
      "qualname": "cleanup_soft_deleted_records",
      "lineno": 2454,
      "end_lineno": 2523,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 70,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(session, older_than_days)",
      "fingerprint": "0c077a244a294a6406ca0d041e8cb187bee68232",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME = LIT ) -> NAME [ NAME , NAME ] : LIT # Calculate the cutoff date NAME = NAME . NAME ( NAME . NAME ) - NAME ( NAME = NAME ) # Initialize counters NAME = { LIT : LIT , # Related records will be deleted via cascade } try : # Find all Person records that were soft-deleted before the cutoff date NAME = NAME . NAME ( NAME ) . NAME ( NAME . NAME < NAME ) . NAME ( ) if not NAME : NAME . NAME ( f\" No soft-deleted records older than { NAME } days found. \" ) return NAME # Log the number of records to be deleted NAME . NAME ( f\" Found { NAME ( NAME ) } soft-deleted Person records older than { NAME } days. \" ) # Delete each record for NAME in NAME : NAME = NAME . NAME NAME = NAME . NAME NAME = NAME . NAME NAME = f\" ID= { NAME } /ProfileID= { NAME } /User=' { NAME } ' \" NAME . NAME ( f\" Permanently deleting soft-deleted Person { NAME } ... \" ) NAME . NAME ( NAME ) NAME [ LIT ] += LIT # Flush changes to the session NAME . NAME ( ) NAME . NAME ( f\" Permanently deleted { NAME [ LIT ] } soft-deleted Person records. \" ) return NAME except NAME as NAME : NAME . NAME ( f\" DB error cleaning up soft-deleted records: { NAME } \" , NAME = True ) with NAME . NAME ( NAME ) : NAME . NAME ( ) return NAME except NAME as NAME : NAME . NAME ( f\" Unexpected error cleaning up soft-deleted records: { NAME } \" , NAME = True ) with NAME . NAME ( NAME ) : NAME . NAME ( ) return NAME"
    },
    {
      "module_path": "database.py",
      "qualname": "test_soft_delete_functionality",
      "lineno": 2532,
      "end_lineno": 2679,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 11,
      "yield_count": 0,
      "complexity": 11,
      "loc": 148,
      "tags": [
        "pure-ish",
        "time",
        "size:large"
      ],
      "signature": "(session)",
      "fingerprint": "5ceb839e8ebd63d3b5a42e29a890171eea0efaac",
      "simhash64": 7488144838607934483,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT NAME . NAME ( LIT ) # Generate unique test data NAME = f\" TEST- { NAME ( ) } \" NAME = f\" TEST- { NAME ( ) } \" NAME = f\" Test User { NAME . NAME ( NAME . NAME ) . NAME ( LIT ) } \" # Step 1: Create a test person NAME . NAME ( f\" Creating test person: UUID= { NAME } , ProfileID= { NAME } , Username= { NAME } \" ) NAME = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME . NAME , } try : # Create the person NAME = NAME ( NAME , NAME ) if NAME == LIT : NAME . NAME ( LIT ) return False NAME . NAME ( f\" Created test person with ID: { NAME } \" ) # Step 2: Verify the person exists NAME = NAME ( NAME , NAME ) if not NAME : NAME . NAME ( f\" Test person with ProfileID= { NAME } not found after creation. \" ) return False NAME . NAME ( f\" Verified test person exists: ID= { NAME . NAME } , ProfileID= { NAME . NAME } \" ) # Step 3: Soft-delete the person NAME . NAME ( f\" Soft-deleting test person: ProfileID= { NAME } , Username= { NAME } \" ) NAME = NAME ( NAME , NAME , NAME ) if not NAME : NAME . NAME ( f\" Failed to soft-delete test person: ProfileID= { NAME } \" ) return False NAME . NAME ( f\" Soft-deleted test person: ProfileID= { NAME } \" ) # Step 4: Verify the person is not found in normal queries NAME = NAME ( NAME , NAME ) if NAME : NAME . NAME ( f\" Test person with ProfileID= { NAME } still found after soft-delete in normal query. \" ) return False NAME . NAME ( LIT ) # Step 5: Verify the person is found when include_deleted=True NAME = NAME ( NAME , NAME , NAME = True ) if not NAME : NAME . NAME ( f\" Test person with ProfileID= { NAME } not found after soft-delete with include_deleted=True. \" ) return False NAME . NAME ( LIT ) # Step 6: Verify deleted_at timestamp is set - use safer comparison NAME = NAME ( NAME , LIT , None ) if NAME is None : NAME . NAME ( f\" Test person with ProfileID= { NAME } has no deleted_at timestamp after soft-delete. \" ) return False NAME . NAME ( f\" Verified test person has deleted_at timestamp: { NAME } \" ) # Step 7: Verify status is set to ARCHIVE - use safer comparison NAME = NAME ( NAME , LIT , None ) if NAME != NAME . NAME : NAME . NAME ( f\" Test person with ProfileID= { NAME } has status { NAME } instead of ARCHIVE after soft-delete. \" ) return False NAME . NAME ( LIT ) # Step 8: Hard-delete the person to clean up NAME . NAME ( f\" Hard-deleting test person for cleanup: ProfileID= { NAME } , Username= { NAME } \" ) NAME = NAME ( NAME , NAME , NAME ) if not NAME : NAME . NAME ( f\" Failed to hard-delete test person for cleanup: ProfileID= { NAME } \" ) return False NAME . NAME ( f\" Hard-deleted test person for cleanup: ProfileID= { NAME } \" ) # Step 9: Verify the person is permanently deleted NAME = NAME ( NAME , NAME , NAME = True ) if NAME : NAME . NAME ( f\" Test person with ProfileID= { NAME } still found after hard-delete. \" ) return False NAME . NAME ( LIT ) NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" Error during soft delete test: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "database.py",
      "qualname": "test_cleanup_soft_deleted_records",
      "lineno": 2685,
      "end_lineno": 2826,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 10,
      "yield_count": 0,
      "complexity": 16,
      "loc": 142,
      "tags": [
        "pure-ish",
        "time",
        "size:large"
      ],
      "signature": "(session)",
      "fingerprint": "30b831990d4c787f897709d0cbda5561b760c2bb",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT NAME . NAME ( LIT ) # Create test data for multiple persons NAME = [ ] for NAME in NAME ( LIT ) : NAME = f\" TEST-CLEANUP- { NAME ( ) } \" NAME = f\" TEST-CLEANUP- { NAME ( ) } \" NAME = f\" Test Cleanup User { NAME } { NAME . NAME ( NAME . NAME ) . NAME ( LIT ) } \" NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME , } ) try : NAME = [ ] # Step 1: Create test persons for NAME , NAME in NAME ( NAME ) : NAME . NAME ( f\" Creating test person { NAME + LIT } : ProfileID= { NAME [ LIT ] } \" ) NAME = NAME ( NAME , NAME ) if NAME == LIT : NAME . NAME ( f\" Failed to create test person { NAME + LIT } . \" ) return False NAME . NAME ( NAME ) NAME . NAME ( f\" Created { NAME ( NAME ) } test persons with IDs: { NAME } \" ) # Step 2: Soft-delete the persons with different timestamps for NAME , NAME in NAME ( NAME ) : NAME . NAME ( f\" Soft-deleting test person { NAME + LIT } : ProfileID= { NAME [ LIT ] } \" ) NAME = NAME ( NAME , NAME [ LIT ] , NAME [ LIT ] ) if not NAME : NAME . NAME ( f\" Failed to soft-delete test person { NAME + LIT } . \" ) return False # Get the person and manually set the deleted_at timestamp for testing NAME = NAME ( NAME , NAME [ LIT ] , NAME = True ) if not NAME : NAME . NAME ( f\" Test person { NAME + LIT } not found after soft-delete. \" ) return False # Set different deleted_at timestamps using setattr to avoid type checking issues if NAME == LIT : # 40 days ago (should be cleaned up) NAME . NAME = NAME . NAME ( NAME . NAME ) - NAME ( NAME = LIT ) elif NAME == LIT : # 20 days ago (should not be cleaned up with 30-day cutoff) NAME . NAME = NAME . NAME ( NAME . NAME ) - NAME ( NAME = LIT ) # Leave the third person with the current timestamp NAME . NAME ( f\" Set deleted_at for test person { NAME + LIT } to { NAME . NAME } \" ) # Flush changes to the database NAME . NAME ( ) # Step 3: Run the cleanup function with a 30-day cutoff NAME . NAME ( LIT ) NAME = NAME ( NAME , NAME = LIT ) # Step 4: Verify only the appropriate records are deleted if NAME [ LIT ] != LIT : NAME . NAME ( f\" Expected 1 person to be deleted, but got { NAME [ LIT ] } . \" ) return False NAME . NAME ( f\" Cleanup deleted { NAME [ LIT ] } persons as expected. \" ) # Verify person 1 is deleted NAME = NAME ( NAME , NAME [ LIT ] [ LIT ] , NAME = True ) if NAME : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) # Verify person 2 still exists NAME = NAME ( NAME , NAME [ LIT ] [ LIT ] , NAME = True ) if not NAME : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) # Verify person 3 still exists NAME = NAME ( NAME , NAME [ LIT ] [ LIT ] , NAME = True ) if not NAME : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) # Clean up remaining test persons for NAME in NAME ( LIT , LIT ) : # Persons 2 and 3 NAME . NAME ( f\" Hard-deleting test person { NAME + LIT } for cleanup \" ) NAME = NAME ( NAME , NAME [ NAME ] [ LIT ] , NAME [ NAME ] [ LIT ] ) if not NAME : NAME . NAME ( f\" Failed to hard-delete test person { NAME + LIT } for cleanup. \" ) return False NAME . NAME ( LIT ) NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" Error during cleanup test: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "database.py",
      "qualname": "_get_default_message_templates",
      "lineno": 2836,
      "end_lineno": 3013,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 178,
      "tags": [
        "pure-ish",
        "time",
        "regex",
        "purpose:factory",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "324f2a42c7df6dae600c000e49a8fd0342aaaadf",
      "simhash64": 1115996632710026799,
      "normalized": "def NAME ( ) -> NAME [ NAME [ NAME , NAME ] ] : LIT return [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : LIT } ]"
    },
    {
      "module_path": "database.py",
      "qualname": "enable_sqlite_settings_standalone",
      "lineno": 3081,
      "end_lineno": 3095,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(dbapi_connection, _)",
      "fingerprint": "7f4b7a6e4c0192a537de22cf754434ff6bd3bf80",
      "simhash64": 8640573762005537803,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT NAME = NAME . NAME ( ) try : NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Failed setting PRAGMA in standalone: { NAME } \" ) finally : NAME . NAME ( )"
    },
    {
      "module_path": "database.py",
      "qualname": "database_module_tests",
      "lineno": 3227,
      "end_lineno": 3583,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 11,
      "loc": 357,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "29e25fce7f4e101fec124e2810e62c896230edeb",
      "simhash64": 5145885970997875755,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # INITIALIZATION TESTS def NAME ( ) -> None : LIT NAME = [ ( NAME , LIT , LIT ) , ( NAME , LIT , LIT ) , ( NAME , LIT , LIT ) , ( NAME , LIT , LIT ) , ( NAME , LIT , LIT ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME , NAME in NAME : # Test model existence NAME = NAME is not None # Test model instantiation NAME = False try : NAME = NAME ( ) NAME = NAME is not None NAME = NAME ( NAME ) . NAME # ensure attribute access is not useless except NAME as NAME : NAME ( f\" \u274c { NAME } instantiation failed: { NAME } \" ) NAME = False # Test table definition NAME = ( NAME ( NAME , LIT ) and NAME . NAME is not None ) NAME = ( NAME . NAME if NAME ( NAME , LIT ) else LIT ) NAME = LIT if NAME and NAME and NAME else LIT NAME ( f\" { NAME } { NAME } : { NAME } \" ) NAME ( f\" Exists: { NAME } , Instantiable: { NAME } , Table: { NAME } \" ) NAME = NAME and NAME and NAME NAME . NAME ( NAME ) assert NAME , f\" { NAME } model should be defined \" assert NAME , f\" { NAME } model should be instantiable \" assert NAME , f\" { NAME } should have table definition \" NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } database models properly defined \" ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) def NAME ( ) -> None : LIT # Test PersonStatusEnum assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT # Test MessageDirectionEnum assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT # Test RoleType assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) def NAME ( ) -> None : LIT assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # CORE FUNCTIONALITY TESTS def NAME ( ) -> None : LIT assert NAME ( NAME ) , LIT # Test basic structure (without actual database operations) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) def NAME ( ) -> None : LIT # Test Person model attributes NAME = NAME ( ) NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME ( NAME , NAME ) , f\" Person model should have { NAME } attribute \" # Test DnaMatch model attributes NAME = NAME ( ) NAME = [ LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME ( NAME , NAME ) , f\" DnaMatch model should have { NAME } attribute \" # Test FamilyTree model attributes NAME = NAME ( ) NAME = [ LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME ( NAME , NAME ) , f\" FamilyTree model should have { NAME } attribute \" NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) def NAME ( ) -> None : LIT # Test that utility functions exist assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # EDGE CASE TESTS def NAME ( ) -> None : LIT # Test enum value access assert ( NAME . NAME . NAME == LIT ) , LIT assert ( NAME . NAME . NAME == LIT ) , LIT assert ( NAME . NAME . NAME == LIT ) , LIT # Test enum comparison assert ( NAME . NAME != NAME . NAME ) , LIT NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) def NAME ( ) -> None : LIT # Test instantiation with no parameters NAME = NAME ( ) assert NAME is not None , LIT # Test multiple instantiations NAME = NAME ( ) assert ( NAME is not None ) , LIT assert ( NAME is not NAME ) , LIT NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # INTEGRATION TESTS def NAME ( ) -> None : LIT NAME = NAME ( ) # Test relationship attributes exist assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) def NAME ( ) -> None : LIT # Test that models are registered with Base assert NAME . NAME is not None , LIT assert ( NAME . NAME is not None ) , LIT assert ( NAME . NAME is not None ) , LIT NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # PERFORMANCE TESTS def NAME ( ) -> None : LIT import NAME NAME = NAME . NAME ( ) # Create multiple model instances for NAME in NAME ( LIT ) : NAME ( ) NAME ( ) NAME ( ) NAME = NAME . NAME ( ) NAME = NAME - NAME # Should be able to create 300 instances in reasonable time assert ( NAME < LIT ) , f\" Model creation took { NAME : .3f } s, should be under 1.0s \" NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # ERROR HANDLING TESTS def NAME ( ) -> None : LIT # Test that test framework is available assert NAME is not None , LIT assert NAME is not None , LIT NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) def NAME ( ) -> None : LIT # Test that config_schema is available assert NAME is not None , LIT # Test that logger is available assert NAME is not None , LIT NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "database.py",
      "qualname": "test_database_model_definitions",
      "lineno": 3237,
      "end_lineno": 3289,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 53,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "c83ae1320e864d51926273ce049dd5c7864c66f3",
      "simhash64": 7452291964524205083,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ ( NAME , LIT , LIT ) , ( NAME , LIT , LIT ) , ( NAME , LIT , LIT ) , ( NAME , LIT , LIT ) , ( NAME , LIT , LIT ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME , NAME in NAME : # Test model existence NAME = NAME is not None # Test model instantiation NAME = False try : NAME = NAME ( ) NAME = NAME is not None NAME = NAME ( NAME ) . NAME # ensure attribute access is not useless except NAME as NAME : NAME ( f\" \u274c { NAME } instantiation failed: { NAME } \" ) NAME = False # Test table definition NAME = ( NAME ( NAME , LIT ) and NAME . NAME is not None ) NAME = ( NAME . NAME if NAME ( NAME , LIT ) else LIT ) NAME = LIT if NAME and NAME and NAME else LIT NAME ( f\" { NAME } { NAME } : { NAME } \" ) NAME ( f\" Exists: { NAME } , Instantiable: { NAME } , Table: { NAME } \" ) NAME = NAME and NAME and NAME NAME . NAME ( NAME ) assert NAME , f\" { NAME } model should be defined \" assert NAME , f\" { NAME } model should be instantiable \" assert NAME , f\" { NAME } should have table definition \" NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } database models properly defined \" )"
    },
    {
      "module_path": "database.py",
      "qualname": "test_enum_definitions",
      "lineno": 3300,
      "end_lineno": 3329,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "f87ec95136ac6848a7d054b9da2032db779c02fa",
      "simhash64": 5143634171179996203,
      "normalized": "def NAME ( ) -> None : LIT # Test PersonStatusEnum assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT # Test MessageDirectionEnum assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT # Test RoleType assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "test_database_base_setup",
      "lineno": 3339,
      "end_lineno": 3342,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "079125e9cf19cf3cb7586be8571872b15f7d4a75",
      "simhash64": 6299924579418543659,
      "normalized": "def NAME ( ) -> None : LIT assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "test_transaction_context_manager",
      "lineno": 3353,
      "end_lineno": 3355,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "693d9a53055d3edbd406c0c23430f18044bb2a6e",
      "simhash64": 6298833863883789355,
      "normalized": "def NAME ( ) -> None : LIT assert NAME ( NAME ) , LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "test_model_attributes",
      "lineno": 3366,
      "end_lineno": 3409,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 44,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "420ce7987743b50b7926f8c15b898567f8806164",
      "simhash64": 5146448920947102779,
      "normalized": "def NAME ( ) -> None : LIT # Test Person model attributes NAME = NAME ( ) NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME ( NAME , NAME ) , f\" Person model should have { NAME } attribute \" # Test DnaMatch model attributes NAME = NAME ( ) NAME = [ LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME ( NAME , NAME ) , f\" DnaMatch model should have { NAME } attribute \" # Test FamilyTree model attributes NAME = NAME ( ) NAME = [ LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME ( NAME , NAME ) , f\" FamilyTree model should have { NAME } attribute \""
    },
    {
      "module_path": "database.py",
      "qualname": "test_database_utilities",
      "lineno": 3419,
      "end_lineno": 3423,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "06292837a9df12a0217cebbe90bfa87da91fb67b",
      "simhash64": 8642403316069733475,
      "normalized": "def NAME ( ) -> None : LIT # Test that utility functions exist assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "test_enum_edge_cases",
      "lineno": 3434,
      "end_lineno": 3450,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "40c82d70e2843838b6f64f24c5dfdeea77a05ca3",
      "simhash64": 7451623464674702375,
      "normalized": "def NAME ( ) -> None : LIT # Test enum value access assert ( NAME . NAME . NAME == LIT ) , LIT assert ( NAME . NAME . NAME == LIT ) , LIT assert ( NAME . NAME . NAME == LIT ) , LIT # Test enum comparison assert ( NAME . NAME != NAME . NAME ) , LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "test_model_instantiation_edge_cases",
      "lineno": 3460,
      "end_lineno": 3473,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b009f8b75a0523c30188b0cb6dfed2399eb511f2",
      "simhash64": 8641242229643318819,
      "normalized": "def NAME ( ) -> None : LIT # Test instantiation with no parameters NAME = NAME ( ) assert NAME is not None , LIT # Test multiple instantiations NAME = NAME ( ) assert ( NAME is not None ) , LIT assert ( NAME is not NAME ) , LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "test_model_relationships",
      "lineno": 3484,
      "end_lineno": 3494,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3c433e1bdff44e3efe220c939352b5806288f5e3",
      "simhash64": 5145885970997875755,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) # Test relationship attributes exist assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "test_schema_integration",
      "lineno": 3504,
      "end_lineno": 3513,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9fe8886ce2d2cf6243cef5e751f96da6288e3094",
      "simhash64": 6300497459821843459,
      "normalized": "def NAME ( ) -> None : LIT # Test that models are registered with Base assert NAME . NAME is not None , LIT assert ( NAME . NAME is not None ) , LIT assert ( NAME . NAME is not None ) , LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "test_model_creation_performance",
      "lineno": 3524,
      "end_lineno": 3542,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 19,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "afa069071c717178f8ab782a85ea1028c85ebf97",
      "simhash64": 8641136717329241147,
      "normalized": "def NAME ( ) -> None : LIT import NAME NAME = NAME . NAME ( ) # Create multiple model instances for NAME in NAME ( LIT ) : NAME ( ) NAME ( ) NAME ( ) NAME = NAME . NAME ( ) NAME = NAME - NAME # Should be able to create 300 instances in reasonable time assert ( NAME < LIT ) , f\" Model creation took { NAME : .3f } s, should be under 1.0s \""
    },
    {
      "module_path": "database.py",
      "qualname": "test_import_error_handling",
      "lineno": 3553,
      "end_lineno": 3557,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "9d3aa9965ad8a33b46dc778d90b0a3ee51e40e4c",
      "simhash64": 6300488764124730963,
      "normalized": "def NAME ( ) -> None : LIT # Test that test framework is available assert NAME is not None , LIT assert NAME is not None , LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "test_configuration_error_handling",
      "lineno": 3567,
      "end_lineno": 3573,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "a9b3a2685abc27a90e7920b9e1fbdcefa0af8baa",
      "simhash64": 6876949396454299223,
      "normalized": "def NAME ( ) -> None : LIT # Test that config_schema is available assert NAME is not None , LIT # Test that logger is available assert NAME is not None , LIT"
    },
    {
      "module_path": "database.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 3586,
      "end_lineno": 3588,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer.__init__",
      "lineno": 86,
      "end_lineno": 90,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "2a56f4134d242e66151460f6f1c359e0df047c90",
      "simhash64": 7452151226028176469,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME : NAME [ NAME [ NAME , NAME ] ] = [ ]"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer.analyze_dna_gedcom_connections",
      "lineno": 92,
      "end_lineno": 146,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 55,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, dna_matches, gedcom_data, tree_owner_info)",
      "fingerprint": "c773fb8202af0c3628b4ccf9d78986be456729ca",
      "simhash64": 7487617073026610195,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None ) -> NAME [ NAME , NAME ] : LIT try : NAME . NAME ( f\" Starting DNA-GEDCOM cross-reference analysis with { NAME ( NAME ) } DNA matches \" ) # Clear previous analysis NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) # Extract GEDCOM people data NAME = NAME . NAME ( NAME ) NAME . NAME ( f\" Extracted { NAME ( NAME ) } people from GEDCOM data \" ) # Perform cross-reference analysis for NAME in NAME : NAME . NAME ( NAME , NAME , NAME ) # Identify conflicts and verification opportunities NAME . NAME ( NAME , NAME ) NAME . NAME ( ) # Generate analysis results NAME = { LIT : NAME . NAME ( ) . NAME ( ) , LIT : NAME ( NAME ) , LIT : NAME ( NAME ) , LIT : [ NAME . NAME ( NAME ) for NAME in NAME . NAME ] , LIT : [ NAME . NAME ( NAME ) for NAME in NAME . NAME ] , LIT : NAME . NAME , LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) } NAME . NAME ( f\" DNA-GEDCOM cross-reference completed: { NAME ( NAME . NAME ) } matches, { NAME ( NAME . NAME ) } conflicts \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Error during DNA-GEDCOM cross-reference analysis: { NAME } \" ) return NAME . NAME ( )"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._extract_gedcom_people",
      "lineno": 148,
      "end_lineno": 189,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 42,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, gedcom_data)",
      "fingerprint": "cfc0553e4ee1ed59179d8a9e7d1a5e04557b8759",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT NAME = [ ] try : if not NAME or not NAME ( NAME , LIT ) : return NAME for NAME , NAME in NAME . NAME . NAME ( ) : try : # Extract basic information NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) # Extract family relationships NAME = NAME ( NAME . NAME . NAME ( NAME , [ ] ) ) NAME = NAME ( NAME . NAME . NAME ( NAME , [ ] ) ) NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error extracting data for person { NAME } : { NAME } \" ) continue except NAME as NAME : NAME . NAME ( f\" Error extracting GEDCOM people: { NAME } \" ) return NAME"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._analyze_single_dna_match",
      "lineno": 191,
      "end_lineno": 234,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 44,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, dna_match, gedcom_people, tree_owner_info)",
      "fingerprint": "e3eaf0417be090ead1f1139ea4a6c0337bed3bac",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME [ NAME , NAME ] ] ) : LIT try : NAME = [ ] # Look for name matches NAME = NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME ) # Look for relationship pattern matches NAME = NAME . NAME ( NAME , NAME , NAME ) NAME . NAME ( NAME ) # Look for geographic/timeline matches NAME = NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME ) # Remove duplicates and score matches NAME = NAME . NAME ( NAME ) if NAME : # Create cross-reference match NAME = NAME ( NAME [ LIT ] for NAME in NAME ) NAME = NAME ( { NAME [ LIT ] for NAME in NAME } ) NAME = NAME ( NAME = f\" crossref_ { NAME . NAME } \" , NAME = NAME , NAME = [ NAME [ LIT ] for NAME in NAME ] , NAME = NAME , NAME = LIT . NAME ( NAME ) , NAME = NAME . NAME ( NAME , NAME ) , NAME = NAME . NAME ( NAME , NAME ) ) NAME . NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error analyzing DNA match { NAME . NAME } : { NAME } \" )"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._find_name_matches",
      "lineno": 236,
      "end_lineno": 257,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, dna_match, gedcom_people)",
      "fingerprint": "4ccba4f8d6e0bf33d8d3c595b3e10d06e10d0aa1",
      "simhash64": 7487617073026610195,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] NAME = NAME . NAME . NAME ( ) . NAME ( ) for NAME in NAME : NAME = NAME . NAME . NAME ( ) . NAME ( ) # Calculate name similarity NAME = NAME ( NAME ) & NAME ( NAME ) NAME = NAME ( NAME ) / NAME ( NAME ( NAME ) , NAME ( NAME ) ) if NAME > LIT : # At least 50% name similarity NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : LIT , LIT : f\" Name similarity: { NAME : .2f } \" } ) return NAME"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._find_relationship_matches",
      "lineno": 259,
      "end_lineno": 290,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 32,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, dna_match, gedcom_people, tree_owner_info)",
      "fingerprint": "66935db5fe854a111da64f571d4575f95509da1d",
      "simhash64": 7452151225961067575,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] if not NAME . NAME or not NAME : return NAME # This would implement relationship distance calculations # For now, providing basic framework NAME = NAME . NAME ( NAME . NAME ) if NAME : # Find GEDCOM people at similar relationship distances for NAME in NAME : # Calculate relationship distance from tree owner to this person # This would require implementing relationship path calculation # For now, using placeholder logic if NAME . NAME ( NAME , NAME , NAME ) : NAME . NAME ( { LIT : NAME , LIT : LIT , # Placeholder confidence LIT : LIT , LIT : f\" Relationship distance match: { NAME . NAME } \" } ) return NAME"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._find_context_matches",
      "lineno": 292,
      "end_lineno": 309,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 18,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, dna_match, gedcom_people)",
      "fingerprint": "69defcc9cde1062069a3f3524e311d42f7cabaab",
      "simhash64": 7452151226028168251,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] # This would analyze shared ancestors, locations, time periods # For now, providing basic framework for NAME in NAME . NAME : for NAME in NAME : if NAME . NAME ( ) in NAME . NAME . NAME ( ) : NAME . NAME ( { LIT : NAME , LIT : LIT , LIT : LIT , LIT : f\" Shared ancestor: { NAME } \" } ) return NAME"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._deduplicate_and_score_matches",
      "lineno": 311,
      "end_lineno": 335,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 25,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, potential_matches)",
      "fingerprint": "02cb3962d25eb1d91df17ee28cb10909de60ff32",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT # Group by GEDCOM person NAME = { } for NAME in NAME : NAME = NAME [ LIT ] . NAME if NAME not in NAME : NAME [ NAME ] = [ ] NAME [ NAME ] . NAME ( NAME ) # Calculate combined scores for each person NAME = [ ] for NAME , NAME in NAME . NAME ( ) : # Take the best match for each person NAME = NAME ( NAME , NAME = lambda NAME : NAME [ LIT ] ) # Boost confidence if multiple match types if NAME ( NAME ) > LIT : NAME [ LIT ] = NAME ( LIT , NAME [ LIT ] * LIT ) NAME [ LIT ] = LIT . NAME ( { NAME [ LIT ] for NAME in NAME } ) NAME . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._generate_verification_tasks",
      "lineno": 337,
      "end_lineno": 352,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, dna_match, matches)",
      "fingerprint": "7d647dba774b9af10f6b26e8c4940345f0d8db3c",
      "simhash64": 7452151225961067539,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME [ NAME ] : LIT NAME = [ ] for NAME in NAME : NAME = NAME [ LIT ] NAME . NAME ( f\" Verify relationship between DNA match { NAME . NAME } and { NAME . NAME } \" ) if NAME . NAME : NAME . NAME ( f\" Check if { NAME . NAME } has family connections around { NAME . NAME } \" ) if NAME . NAME : NAME . NAME ( f\" Research { NAME . NAME } 's family connections to { NAME . NAME } \" ) return NAME [ : LIT ] # Limit to top 5 tasks"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._generate_research_suggestions",
      "lineno": 354,
      "end_lineno": 369,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, dna_match, matches)",
      "fingerprint": "185cca1e13d2984fb7bec6851bb2f9193bc1f7b4",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME [ NAME ] : LIT NAME = [ ] NAME . NAME ( f\" Compare { NAME . NAME } 's family tree with potential GEDCOM matches \" ) NAME . NAME ( LIT ) if NAME . NAME : NAME . NAME ( f\" Verify { NAME . NAME } cM shared DNA is consistent with estimated relationship \" ) for NAME in NAME : NAME = NAME [ LIT ] if NAME . NAME : NAME . NAME ( LIT ) return NAME [ : LIT ] # Limit to top 5 suggestions"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._identify_relationship_conflicts",
      "lineno": 371,
      "end_lineno": 397,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 27,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, dna_matches, gedcom_people)",
      "fingerprint": "607db666ff4eb3790ba206bd0e2303f61e48cdef",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME ] ) : LIT # This would implement conflict detection logic # For now, providing framework for NAME in NAME . NAME : NAME = NAME . NAME # Check for relationship inconsistencies if NAME . NAME and NAME . NAME : NAME = NAME . NAME ( NAME . NAME ) if NAME and not NAME . NAME ( NAME . NAME , NAME ) : NAME = NAME ( NAME = f\" cm_conflict_ { NAME . NAME } \" , NAME = LIT , NAME = f\" Shared DNA ( { NAME . NAME } cM) inconsistent with estimated relationship ( { NAME . NAME } ) \" , NAME = f\" { NAME . NAME } cM shared DNA \" , NAME = f\" Estimated relationship: { NAME . NAME } \" , NAME = LIT , NAME = [ LIT , LIT , LIT ] ) NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._identify_verification_opportunities",
      "lineno": 399,
      "end_lineno": 411,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "f59f76212cdfc4da973002b2089e369e77c22fda",
      "simhash64": 7456232614264215083,
      "normalized": "def NAME ( NAME ) -> None : LIT for NAME in NAME . NAME : if NAME . NAME > LIT : NAME = { LIT : f\" verify_ { NAME . NAME } \" , LIT : LIT , LIT : f\" High-confidence match between { NAME . NAME . NAME } and GEDCOM data \" , LIT : LIT , LIT : NAME . NAME , LIT : LIT } NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._extract_person_name",
      "lineno": 414,
      "end_lineno": 421,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self, person_record)",
      "fingerprint": "012fe9a5e1a5200c3ce3201cc3d913f7f2869625",
      "simhash64": 7487757810582066211,
      "normalized": "def NAME ( NAME , NAME ) -> NAME : LIT try : if NAME ( NAME , LIT ) and NAME . NAME : return NAME ( NAME . NAME [ LIT ] ) return LIT except NAME : return LIT"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._extract_birth_year",
      "lineno": 423,
      "end_lineno": 426,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, person_record)",
      "fingerprint": "c4bf850287cec76b53a127f29221221d4c86789e",
      "simhash64": 5146440124925391971,
      "normalized": "def NAME ( NAME , NAME ) -> NAME [ NAME ] : LIT # Placeholder implementation return None"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._extract_death_year",
      "lineno": 428,
      "end_lineno": 431,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, person_record)",
      "fingerprint": "c4bf850287cec76b53a127f29221221d4c86789e",
      "simhash64": 5146440124925391971,
      "normalized": "def NAME ( NAME , NAME ) -> NAME [ NAME ] : LIT # Placeholder implementation return None"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._extract_birth_place",
      "lineno": 433,
      "end_lineno": 436,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, person_record)",
      "fingerprint": "c4bf850287cec76b53a127f29221221d4c86789e",
      "simhash64": 5146440124925391971,
      "normalized": "def NAME ( NAME , NAME ) -> NAME [ NAME ] : LIT # Placeholder implementation return None"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._extract_death_place",
      "lineno": 438,
      "end_lineno": 441,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, person_record)",
      "fingerprint": "c4bf850287cec76b53a127f29221221d4c86789e",
      "simhash64": 5146440124925391971,
      "normalized": "def NAME ( NAME , NAME ) -> NAME [ NAME ] : LIT # Placeholder implementation return None"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._parse_relationship_distance",
      "lineno": 443,
      "end_lineno": 461,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, relationship)",
      "fingerprint": "05f8b1e053d40fe947d1eba07620137f5e0a4def",
      "simhash64": 5726842660761015851,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT # Simple implementation for common relationships NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME . NAME ( ) for NAME , NAME in NAME . NAME ( ) : if NAME in NAME : return NAME return None"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._is_plausible_relationship_match",
      "lineno": 463,
      "end_lineno": 466,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, dna_match, gedcom_person, relationship_distance)",
      "fingerprint": "9c7c83e75bd6b440bbc8628c7acc339e3bf88c22",
      "simhash64": 7488250358439785571,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT # Placeholder implementation return True"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._get_expected_cm_range",
      "lineno": 468,
      "end_lineno": 486,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, relationship)",
      "fingerprint": "3e964e2d9e7e8f0ebe1e04a5b9eced25086a4d9e",
      "simhash64": 5150380774586750507,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT # Simplified ranges for common relationships NAME = { LIT : ( LIT , LIT ) , LIT : ( LIT , LIT ) , LIT : ( LIT , LIT ) , LIT : ( LIT , LIT ) , LIT : ( LIT , LIT ) , LIT : ( LIT , LIT ) , LIT : ( LIT , LIT ) , LIT : ( LIT , LIT ) , LIT : ( LIT , LIT ) , LIT : ( LIT , LIT ) , LIT : ( LIT , LIT ) , LIT : ( LIT , LIT ) , LIT : ( LIT , LIT ) } NAME = NAME . NAME ( ) for NAME , NAME in NAME . NAME ( ) : if NAME in NAME : return NAME return None"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._is_cm_in_range",
      "lineno": 488,
      "end_lineno": 493,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, actual_cm, expected_range)",
      "fingerprint": "e61dde0cbb8fcf63b2985c79338e8c39437340e9",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME , NAME = NAME # Allow 20% tolerance outside the range NAME = ( NAME - NAME ) * LIT return ( NAME - NAME ) <= NAME <= ( NAME + NAME )"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._generate_crossref_summary",
      "lineno": 495,
      "end_lineno": 502,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "64f36d9c137b299ca062faf59b755daf407f14ef",
      "simhash64": 7487617073026610211,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME ( NAME . NAME ) , LIT : NAME ( [ NAME for NAME in NAME . NAME if NAME . NAME > LIT ] ) , LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) }"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._generate_crossref_recommendations",
      "lineno": 504,
      "end_lineno": 521,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "fdecb241108e2d9d1398c5a6234171632eff132d",
      "simhash64": 7487617073093714979,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME = [ ] NAME = NAME ( [ NAME for NAME in NAME . NAME if NAME . NAME > LIT ] ) if NAME > LIT : NAME . NAME ( f\" Prioritize verification of { NAME } high-confidence DNA-GEDCOM matches \" ) if NAME ( NAME . NAME ) > LIT : NAME . NAME ( f\" Resolve { NAME ( NAME . NAME ) } identified conflicts between DNA and tree data \" ) if NAME ( NAME . NAME ) > LIT : NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._empty_crossref_result",
      "lineno": 523,
      "end_lineno": 535,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "4bd5d8222c4d2f53186b39a3625e7e28a9b09d9d",
      "simhash64": 5151507774004696623,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME ( ) . NAME ( ) , LIT : LIT , LIT : LIT , LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , LIT : [ ] , LIT : LIT }"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._crossref_to_dict",
      "lineno": 537,
      "end_lineno": 557,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, crossref_match)",
      "fingerprint": "9f028338ae7f7b09a287127066af3e3a4078680f",
      "simhash64": 7451588276007646211,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME , LIT : NAME . NAME . NAME , LIT : NAME . NAME . NAME , LIT : NAME . NAME . NAME , LIT : [ { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME } for NAME in NAME . NAME ] , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME }"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "DNAGedcomCrossReferencer._conflict_to_dict",
      "lineno": 559,
      "end_lineno": 569,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, conflict)",
      "fingerprint": "2d703168796e53dbd3f22f56532f8ba9567e37e5",
      "simhash64": 7451729014569743395,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME }"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "test_dna_gedcom_crossref",
      "lineno": 573,
      "end_lineno": 604,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 32,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "0627f37c6627a3b90a7abe0fd297ff4866701a91",
      "simhash64": 5145885970996303403,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) NAME = NAME ( ) # Test with mock data NAME = [ NAME ( NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = [ LIT ] ) ] NAME = NAME ( LIT , ( ) , { LIT : { LIT : NAME ( LIT , ( ) , { LIT : [ LIT ] } ) ( ) } , LIT : { } , LIT : { } } ) ( ) NAME = NAME . NAME ( NAME , NAME ) assert LIT in NAME , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "test_name_match_and_confidence_boost",
      "lineno": 607,
      "end_lineno": 622,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d49b869bed40788d1a77b16068bded509fd508c5",
      "simhash64": 5146448955368183339,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) NAME ( NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = [ LIT ] ) # Create GEDCOM person with overlapping name and ancestor NAME = NAME ( NAME = LIT , NAME = LIT ) # Manually craft potential matches representing two types NAME = [ { LIT : NAME , LIT : LIT , LIT : LIT } , { LIT : NAME , LIT : LIT , LIT : LIT } , ] NAME = NAME . NAME ( NAME ) assert NAME ( NAME ) == LIT NAME = NAME [ LIT ] [ LIT ] assert NAME >= LIT , LIT assert NAME <= LIT"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "test_conflict_identification_out_of_range_cm",
      "lineno": 625,
      "end_lineno": 640,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2020da547c7ae3543e48ec04d40211dd40c961d2",
      "simhash64": 5146308222116074507,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) # Construct a cross_reference_matches entry with mismatch cM NAME = NAME ( NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT ) NAME . NAME . NAME ( NAME ( NAME = LIT , NAME = NAME , NAME = [ ] , NAME = LIT , NAME = LIT , ) ) NAME . NAME ( [ NAME ] , [ ] ) assert NAME ( NAME . NAME . NAME ( LIT ) for NAME in NAME . NAME ) , LIT"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "test_verification_opportunity_threshold",
      "lineno": 643,
      "end_lineno": 657,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "0cb197fda930f2875158356f15e4959363a8c383",
      "simhash64": 5146448959604429835,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) NAME = NAME ( NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT ) NAME . NAME . NAME ( NAME ( NAME = LIT , NAME = NAME , NAME = [ ] , NAME = LIT , NAME = LIT , ) ) NAME . NAME ( ) assert NAME ( NAME . NAME ) == LIT , LIT"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "test_relationship_distance_parser",
      "lineno": 660,
      "end_lineno": 665,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "bc9ecd3eaf0bc2a874d7bc96fadf9a452fa98c8b",
      "simhash64": 8640714501104506403,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) assert NAME . NAME ( LIT ) == LIT assert NAME . NAME ( LIT ) == LIT assert NAME . NAME ( LIT ) is None"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "dna_gedcom_crossref_module_tests",
      "lineno": 668,
      "end_lineno": 715,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 48,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "a1cc529248ff91137449a1e25cd810350776721d",
      "simhash64": 5145886009646814251,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "dna_gedcom_crossref.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 718,
      "end_lineno": 720,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "summarize_extracted_data",
      "lineno": 15,
      "end_lineno": 46,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 32,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(extracted_data)",
      "fingerprint": "b7a5a18c1b28fbb4f47f780b27180822fcc2b263",
      "simhash64": 7487757811588699179,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT if not NAME ( NAME , NAME ) : NAME = { } def NAME ( NAME : NAME ) -> NAME : NAME = NAME . NAME ( NAME ) return NAME ( NAME ) if NAME ( NAME , NAME ) else LIT NAME = { LIT : NAME ( LIT ) , LIT : NAME ( LIT ) , LIT : NAME ( LIT ) , LIT : NAME ( LIT ) , LIT : NAME ( LIT ) , LIT : NAME ( LIT ) , LIT : NAME ( LIT ) , LIT : NAME ( LIT ) , } # Simple consistency flags NAME = { LIT : NAME ( NAME > LIT for NAME in NAME . NAME ( ) ) , LIT : ( NAME [ LIT ] > LIT and NAME [ LIT ] > LIT ) , } return { LIT : NAME , LIT : NAME }"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "_count_list",
      "lineno": 25,
      "end_lineno": 27,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(key)",
      "fingerprint": "99943055ffc89c2505aca01399313bb9f13c602d",
      "simhash64": 7488215207352116291,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : NAME = NAME . NAME ( NAME ) return NAME ( NAME ) if NAME ( NAME , NAME ) else LIT"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "compute_task_quality",
      "lineno": 59,
      "end_lineno": 117,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 18,
      "loc": 59,
      "tags": [
        "pure-ish",
        "regex",
        "size:medium"
      ],
      "signature": "(tasks)",
      "fingerprint": "9463f09654b19c97b918e190632a0e8481725493",
      "simhash64": 7488180024053765163,
      "normalized": "def NAME ( NAME : NAME [ NAME ] | None ) -> NAME : LIT if not NAME ( NAME , NAME ) or not NAME : return LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ] NAME = LIT NAME = LIT for NAME in NAME : if not NAME ( NAME , NAME ) : continue NAME = NAME . NAME ( ) if not NAME : continue NAME = LIT NAME = NAME . NAME ( ) NAME = NAME ( NAME . NAME ( LIT , NAME ) ) if NAME & NAME : NAME += LIT if NAME . NAME ( NAME ) : NAME += LIT if NAME . NAME ( NAME ) : NAME += LIT if LIT in NAME and LIT in NAME : NAME += LIT if LIT in NAME : NAME += LIT NAME = NAME ( NAME ) if LIT <= NAME <= LIT : NAME += LIT if NAME < LIT or NAME > LIT : NAME -= LIT if NAME ( NAME in NAME for NAME in NAME ) : NAME -= LIT # Soft clamp single task raw between -5 and 15 NAME = NAME ( - LIT , NAME ( LIT , NAME ) ) NAME += NAME NAME += LIT if NAME == LIT : return LIT NAME = NAME / NAME # -5 .. 15 typical # Map avg (-5..15) to 0..30 NAME = ( NAME + LIT ) / LIT # 0..1 NAME = NAME ( LIT , NAME ( LIT , NAME ) ) * LIT return NAME ( NAME )"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "compute_extraction_quality",
      "lineno": 120,
      "end_lineno": 232,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 34,
      "loc": 113,
      "tags": [
        "pure-ish",
        "size:large"
      ],
      "signature": "(extraction)",
      "fingerprint": "577fe9908ba62849aaf91456c1ea65a37bdcb27e",
      "simhash64": 7487617074167452715,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : LIT if not NAME ( NAME , NAME ) : return LIT NAME = NAME . NAME ( LIT ) NAME : NAME [ NAME , NAME ] = NAME if NAME ( NAME , NAME ) else { } NAME = NAME . NAME ( LIT ) NAME : NAME [ NAME ] = NAME if NAME ( NAME , NAME ) else [ ] def NAME ( NAME : NAME ) -> NAME : NAME = NAME . NAME ( NAME ) if NAME else None return NAME ( NAME ) if NAME ( NAME , NAME ) else LIT # Raw counts NAME = NAME ( LIT ) NAME = NAME ( LIT ) NAME = NAME ( LIT ) NAME = NAME ( LIT ) NAME = NAME ( LIT ) NAME = NAME ( LIT ) NAME = NAME ( LIT ) NAME = NAME ( LIT ) NAME = NAME ( NAME ) # Enhanced base entity richness score (max 70) NAME = LIT # Names scoring with quality bonuses NAME += NAME ( NAME * LIT , LIT ) if NAME > LIT : # Bonus for complete name structures NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME ( LIT for NAME in NAME if NAME ( NAME , NAME ) and NAME . NAME ( LIT ) and NAME ( NAME . NAME ( LIT , LIT ) . NAME ( ) ) > LIT ) if NAME > LIT : NAME += NAME ( NAME * LIT , LIT ) # Up to 5 bonus points # Vital records scoring with enhanced quality assessment NAME += NAME ( NAME * LIT , LIT ) if NAME > LIT : # Bonus for complete vital records with dates and places NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME ( LIT for NAME in NAME if NAME ( NAME , NAME ) and NAME . NAME ( LIT ) and NAME . NAME ( LIT ) and NAME . NAME ( LIT ) ) if NAME > LIT : NAME += NAME ( NAME * LIT , LIT ) # Up to 6 bonus points # Relationships scoring with connection quality NAME += NAME ( NAME * LIT , LIT ) if NAME > LIT : # Bonus for complete relationship structures NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME ( LIT for NAME in NAME if NAME ( NAME , NAME ) and NAME . NAME ( LIT ) and NAME . NAME ( LIT ) and NAME . NAME ( LIT ) ) if NAME > LIT : NAME += NAME ( NAME * LIT , LIT ) # Up to 4 bonus points # Enhanced DNA information scoring NAME += NAME ( NAME * LIT , LIT ) # Increased from 1 to 2, max from 5 to 8 if NAME > LIT : # Bonus for specific DNA information (cM values, chromosome data, etc.) NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME ( LIT for NAME in NAME if NAME ( NAME , NAME ) and NAME ( NAME in NAME . NAME ( ) for NAME in [ LIT , LIT , LIT , LIT ] ) ) if NAME > LIT : NAME += NAME ( NAME * LIT , LIT ) # Up to 4 bonus points # Standard scoring for other categories NAME += NAME ( NAME * LIT , LIT ) NAME += NAME ( NAME * LIT , LIT ) NAME += NAME ( NAME * LIT , LIT ) NAME += NAME ( NAME * LIT , LIT ) # Enhanced penalties and bonuses if NAME == LIT : NAME -= LIT # Bonus for genealogically rich extractions if NAME > LIT and NAME > LIT and ( NAME > LIT or NAME > LIT ) : NAME += LIT # Genealogical completeness bonus # Bonus for DNA + genealogical data combination if NAME > LIT and NAME > LIT and ( NAME > LIT or NAME > LIT ) : NAME += LIT # DNA-genealogy integration bonus # Task quality component (0-30) NAME = NAME ( NAME ) # Enhanced task quality bonuses if LIT <= NAME <= LIT and NAME >= LIT : NAME = NAME ( LIT , NAME + LIT ) # Bonus for genealogically-focused tasks if NAME > LIT : NAME = NAME ( LIT for NAME in NAME if NAME ( NAME , NAME ) and NAME ( NAME in NAME . NAME ( ) for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ] ) ) if NAME > LIT : NAME = NAME ( LIT , NAME + NAME ( NAME , LIT ) ) # Penalty if no tasks at all if NAME == LIT : NAME = NAME ( LIT , NAME - LIT ) NAME = NAME ( LIT , NAME ( LIT , NAME + NAME ) ) return NAME ( NAME )"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "count",
      "lineno": 136,
      "end_lineno": 138,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(key)",
      "fingerprint": "43d5fcd1b37eac954ce9fac672928434cbb1835b",
      "simhash64": 8641136716253930563,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : NAME = NAME . NAME ( NAME ) if NAME else None return NAME ( NAME ) if NAME ( NAME , NAME ) else LIT"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "compute_anomaly_summary",
      "lineno": 236,
      "end_lineno": 332,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 35,
      "loc": 97,
      "tags": [
        "pure-ish",
        "regex",
        "size:medium"
      ],
      "signature": "(extraction)",
      "fingerprint": "c0250eba3e414121c87641ee13d8275b932e92c4",
      "simhash64": 7488180022980031499,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : LIT try : if not NAME ( NAME , NAME ) : return LIT NAME = NAME . NAME ( LIT ) NAME : NAME [ NAME , NAME ] = NAME if NAME ( NAME , NAME ) else { } NAME = NAME . NAME ( LIT ) NAME : NAME [ NAME ] = NAME if NAME ( NAME , NAME ) else [ ] NAME : NAME [ NAME , NAME ] = { } # Vital record date anomalies NAME = LIT NAME = NAME . NAME ( LIT ) NAME : NAME [ NAME ] = NAME if NAME ( NAME , NAME ) else [ ] for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME ( NAME . NAME ( LIT , LIT ) ) . NAME ( ) if NAME : if NAME ( NAME ) == LIT and not NAME . NAME ( ) : NAME += LIT if NAME . NAME ( LIT , NAME ) : NAME += LIT if NAME : NAME [ LIT ] = NAME # Relationships missing one side NAME = LIT NAME = NAME . NAME ( LIT ) NAME : NAME [ NAME ] = NAME if NAME ( NAME , NAME ) else [ ] for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME ( NAME . NAME ( LIT , LIT ) ) . NAME ( ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) . NAME ( ) if ( NAME and not NAME ) or ( NAME and not NAME ) : NAME += LIT if NAME : NAME [ LIT ] = NAME # Incomplete locations NAME = LIT NAME = NAME . NAME ( LIT ) NAME : NAME [ NAME ] = NAME if NAME ( NAME , NAME ) else [ ] for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME ( NAME . NAME ( LIT , LIT ) ) . NAME ( ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) . NAME ( ) NAME = NAME ( NAME . NAME ( LIT , LIT ) ) . NAME ( ) if not NAME and ( NAME or NAME ) : NAME += LIT if NAME : NAME [ LIT ] = NAME # Duplicate names NAME = NAME . NAME ( LIT ) NAME : NAME [ NAME ] = NAME if NAME ( NAME , NAME ) else [ ] NAME : NAME [ NAME ] = NAME ( ) NAME : NAME [ NAME ] = NAME ( ) for NAME in NAME : NAME = LIT if NAME ( NAME , NAME ) : NAME = NAME ( NAME . NAME ( LIT , LIT ) ) . NAME ( ) elif NAME ( NAME , NAME ) : NAME = NAME . NAME ( ) if not NAME : continue NAME = NAME . NAME ( ) if NAME in NAME : NAME . NAME ( NAME ) else : NAME . NAME ( NAME ) if NAME : NAME [ LIT ] = NAME ( NAME ) # Empty task strings NAME = LIT for NAME in NAME : if NAME ( NAME , NAME ) and not NAME . NAME ( ) : NAME += LIT if NAME : NAME [ LIT ] = NAME if not NAME : return LIT return LIT . NAME ( f\" { NAME } = { NAME } \" for NAME , NAME in NAME ( NAME . NAME ( ) ) ) except NAME : return LIT"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "extraction_quality_module_tests",
      "lineno": 336,
      "end_lineno": 438,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 103,
      "tags": [
        "impure",
        "logging",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "940619bb39aa4b7b1d31181d90c3db5487af495b",
      "simhash64": 5145885971051877423,
      "normalized": "def NAME ( ) -> NAME : # pragma: no cover - invoked by master test harness LIT try : from NAME import NAME , NAME except NAME : # Fallback minimal harness NAME ( LIT ) return True with NAME ( ) : NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # === INIT === def NAME ( ) : assert NAME ( NAME ) assert NAME ( NAME ) assert NAME ( NAME ) assert NAME ( NAME ) # === CORE === def NAME ( ) : NAME = { LIT : [ { LIT : LIT } ] , LIT : [ { LIT : LIT } ] , LIT : [ ] , LIT : [ { LIT : LIT } ] , LIT : [ ] , LIT : [ LIT ] , LIT : [ ] , LIT : [ ] , } NAME = NAME ( NAME ) assert NAME [ LIT ] [ LIT ] == LIT assert NAME [ LIT ] [ LIT ] is True def NAME ( ) : NAME = [ LIT , LIT , LIT , ] NAME = NAME ( NAME ) assert LIT <= NAME <= LIT def NAME ( ) : NAME = { LIT : { LIT : [ { LIT : LIT } ] , LIT : [ { LIT : LIT } ] , LIT : [ { LIT : LIT , LIT : LIT } ] , LIT : [ { LIT : LIT } ] , } , LIT : [ LIT ] , } NAME = NAME ( NAME ) assert LIT <= NAME <= LIT # === EDGE / ANOMALY === def NAME ( ) : NAME = { LIT : { LIT : [ { LIT : LIT } ] , LIT : [ { LIT : LIT } ] , LIT : [ { LIT : LIT , LIT : LIT } ] , LIT : [ LIT , LIT ] , } , LIT : [ LIT , LIT ] , } NAME = NAME ( NAME ) # Expect at least one anomaly token present assert NAME != LIT assert NAME ( NAME . NAME ( LIT ) or NAME . NAME ( LIT ) for NAME in NAME . NAME ( LIT ) ) def NAME ( ) : NAME = { LIT : { LIT : [ { LIT : LIT } ] , LIT : [ { LIT : LIT , LIT : LIT } ] , LIT : [ { LIT : LIT } ] , LIT : [ LIT , LIT ] , } , LIT : [ LIT ] , } assert NAME ( NAME ) == LIT # === ERROR HANDLING === def NAME ( ) : assert NAME ( None ) == LIT # type: ignore assert NAME ( None ) == LIT # type: ignore assert NAME ( [ None , LIT ] ) == LIT # invalid entries ignored NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) return NAME . NAME ( )"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "test_module_symbols",
      "lineno": 353,
      "end_lineno": 357,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "c0f87a551f4d5f5420fd6d2ed692b2c995506bb1",
      "simhash64": 8638884878322410611,
      "normalized": "def NAME ( ) : assert NAME ( NAME ) assert NAME ( NAME ) assert NAME ( NAME ) assert NAME ( NAME )"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "test_basic_summary_counts",
      "lineno": 360,
      "end_lineno": 373,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3421e488e26463d03e9cafbf539e6fc7fc048133",
      "simhash64": 5147004165787390511,
      "normalized": "def NAME ( ) : NAME = { LIT : [ { LIT : LIT } ] , LIT : [ { LIT : LIT } ] , LIT : [ ] , LIT : [ { LIT : LIT } ] , LIT : [ ] , LIT : [ LIT ] , LIT : [ ] , LIT : [ ] , } NAME = NAME ( NAME ) assert NAME [ LIT ] [ LIT ] == LIT assert NAME [ LIT ] [ LIT ] is True"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "test_task_quality_scoring",
      "lineno": 375,
      "end_lineno": 382,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "412e7e1ccf95d312941602243c2025e8d1bfa047",
      "simhash64": 5146448946782442539,
      "normalized": "def NAME ( ) : NAME = [ LIT , LIT , LIT , ] NAME = NAME ( NAME ) assert LIT <= NAME <= LIT"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "test_extraction_quality_integration",
      "lineno": 384,
      "end_lineno": 395,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "0bd7f3530f145c0c2433b2f0425b3dcfffe6b03b",
      "simhash64": 5151507808364434991,
      "normalized": "def NAME ( ) : NAME = { LIT : { LIT : [ { LIT : LIT } ] , LIT : [ { LIT : LIT } ] , LIT : [ { LIT : LIT , LIT : LIT } ] , LIT : [ { LIT : LIT } ] , } , LIT : [ LIT ] , } NAME = NAME ( NAME ) assert LIT <= NAME <= LIT"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "test_anomaly_detection",
      "lineno": 398,
      "end_lineno": 411,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5ba40859a7de7275b64b9a885de25983cb183149",
      "simhash64": 7451730114141132335,
      "normalized": "def NAME ( ) : NAME = { LIT : { LIT : [ { LIT : LIT } ] , LIT : [ { LIT : LIT } ] , LIT : [ { LIT : LIT , LIT : LIT } ] , LIT : [ LIT , LIT ] , } , LIT : [ LIT , LIT ] , } NAME = NAME ( NAME ) # Expect at least one anomaly token present assert NAME != LIT assert NAME ( NAME . NAME ( LIT ) or NAME . NAME ( LIT ) for NAME in NAME . NAME ( LIT ) )"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "test_no_anomalies",
      "lineno": 413,
      "end_lineno": 423,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "946cf8ee350e9ce8f6f26546ddc16f8f1fe9fba0",
      "simhash64": 5151507774004695599,
      "normalized": "def NAME ( ) : NAME = { LIT : { LIT : [ { LIT : LIT } ] , LIT : [ { LIT : LIT , LIT : LIT } ] , LIT : [ { LIT : LIT } ] , LIT : [ LIT , LIT ] , } , LIT : [ LIT ] , } assert NAME ( NAME ) == LIT"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "test_defensive_inputs",
      "lineno": 426,
      "end_lineno": 429,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "8684c4fd98b5339c467fa6671cb3623694eb889f",
      "simhash64": 5145350642578920485,
      "normalized": "def NAME ( ) : assert NAME ( None ) == LIT # type: ignore assert NAME ( None ) == LIT # type: ignore assert NAME ( [ None , LIT ] ) == LIT # invalid entries ignored"
    },
    {
      "module_path": "extraction_quality.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 441,
      "end_lineno": 442,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "e4ef98fdf0dd24de5d09ba57fe31600880a8aee7",
      "simhash64": 7487784700828618851,
      "normalized": "def NAME ( ) -> NAME : # pragma: no cover return NAME ( )"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator.__init__",
      "lineno": 44,
      "end_lineno": 70,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 27,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "813d8ebb0c3a3e9691ed6c13fbac676c227e0cbb",
      "simhash64": 8642227431855789059,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = None NAME . NAME = None NAME . NAME = None if NAME : try : if NAME ( [ NAME is not None , NAME is not None , NAME is not None , ] ) : NAME . NAME = NAME ( ) # type: ignore[operator] NAME . NAME = NAME ( ) # type: ignore[operator] NAME . NAME = NAME ( ) # type: ignore[operator] else : raise NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Failed initializing GEDCOM AI components, falling back: { NAME } \" ) NAME . NAME = None NAME . NAME = None NAME . NAME = None NAME ( ) [ LIT ] = False NAME . NAME ( LIT ) else : NAME . NAME ( LIT )"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator.perform_comprehensive_analysis",
      "lineno": 72,
      "end_lineno": 142,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 7,
      "loc": 71,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, gedcom_data, dna_matches_data, tree_owner_info)",
      "fingerprint": "548d128335f9cc6bda55027ee7261d64deb2a1cf",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME [ NAME [ NAME , NAME ] ] ] = None , NAME : NAME [ NAME [ NAME , NAME ] ] = None ) -> NAME [ NAME , NAME ] : LIT try : if not NAME : return NAME . NAME ( ) NAME . NAME ( LIT ) # Step 1: GEDCOM Intelligence Analysis NAME . NAME ( LIT ) if NAME . NAME is None : return NAME . NAME ( ) NAME = NAME . NAME . NAME ( NAME ) # Step 2: DNA-GEDCOM Cross-Reference (if DNA data available) NAME = { } if NAME : NAME . NAME ( LIT ) if NAME . NAME is not None : NAME = NAME . NAME ( NAME ) NAME = NAME . NAME . NAME ( NAME , NAME , NAME ) # Step 3: Research Prioritization NAME . NAME ( LIT ) if NAME . NAME is None : return NAME . NAME ( ) NAME = NAME . NAME . NAME ( NAME , NAME ) # Combine all analyses NAME = { LIT : NAME . NAME ( ) . NAME ( ) , LIT : LIT , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME . NAME ( NAME , NAME , NAME ) , LIT : NAME . NAME ( NAME , NAME , NAME ) , LIT : NAME . NAME ( NAME , NAME , NAME ) } NAME . NAME ( LIT ) return NAME except NAME as NAME : NAME . NAME ( f\" Error during comprehensive GEDCOM AI analysis: { NAME } \" ) return NAME . NAME ( NAME ( NAME ) )"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator.generate_enhanced_research_tasks",
      "lineno": 144,
      "end_lineno": 202,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 8,
      "loc": 59,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, person_data, extracted_genealogical_data, gedcom_data)",
      "fingerprint": "4351dd50cb0f351cac59b1dc12216fb411362e94",
      "simhash64": 7451588276007646243,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME = None ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : if not NAME : return NAME . NAME ( NAME , NAME ) NAME = [ ] # If GEDCOM data is available, use AI analysis if NAME : NAME = NAME . NAME ( NAME ) # Extract relevant tasks for this person NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , [ ] ) # Filter tasks relevant to this person NAME = NAME . NAME ( LIT , LIT ) NAME = [ NAME for NAME in NAME if NAME in NAME . NAME ( LIT , [ ] ) or NAME ( NAME . NAME ( ) in NAME . NAME ( ) for NAME in NAME . NAME ( LIT , [ ] ) ) ] # Convert to enhanced task format for NAME in NAME [ : LIT ] : # Top 3 relevant tasks NAME = { LIT : f\" GEDCOM AI: { NAME . NAME ( LIT , LIT ) } \" , LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : LIT } NAME . NAME ( NAME ) # Add general AI-enhanced tasks based on extracted data NAME = NAME . NAME ( NAME ) NAME . NAME ( NAME ) return NAME [ : LIT ] # Limit to top 5 tasks except NAME as NAME : NAME . NAME ( f\" Error generating enhanced research tasks: { NAME } \" ) return NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator.get_gedcom_insights_for_person",
      "lineno": 204,
      "end_lineno": 241,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 5,
      "loc": 38,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self, person_identifier, gedcom_data)",
      "fingerprint": "d942d88fc5e35621384f20457f0fc26c1b0d675e",
      "simhash64": 7451588276007638059,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT try : if not NAME or not NAME : return { LIT : LIT } # Perform analysis if NAME . NAME is None : return { LIT : LIT } NAME = NAME . NAME . NAME ( NAME ) # Extract person-specific insights return { LIT : NAME , LIT : NAME . NAME ( NAME , NAME ) , LIT : NAME . NAME ( NAME , NAME ) , LIT : NAME . NAME ( NAME , NAME ) , LIT : NAME . NAME ( NAME , NAME ) , LIT : NAME . NAME ( NAME , NAME ) } except NAME as NAME : NAME . NAME ( f\" Error getting GEDCOM insights for person { NAME } : { NAME } \" ) return { LIT : f\" Failed to get insights: { NAME } \" }"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._convert_to_dna_matches",
      "lineno": 243,
      "end_lineno": 265,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, dna_matches_data)",
      "fingerprint": "2938cf4a245d47722d589d287aa96392fed298e2",
      "simhash64": 7488180022980031531,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME [ NAME ] : LIT NAME = [ ] for NAME in NAME : if NAME is None : continue try : NAME = NAME ( NAME = NAME . NAME ( LIT , LIT ) , NAME = NAME . NAME ( LIT , LIT ) , NAME = NAME . NAME ( LIT , LIT ) , NAME = NAME . NAME ( LIT ) , NAME = NAME . NAME ( LIT , LIT ) , NAME = NAME . NAME ( LIT , LIT ) , NAME = NAME . NAME ( LIT , [ ] ) ) NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error converting DNA match data: { NAME } \" ) continue return NAME"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._generate_integrated_insights",
      "lineno": 267,
      "end_lineno": 280,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gedcom_analysis, dna_analysis, prioritization_analysis)",
      "fingerprint": "4e7d9caca7a2b6c494aca04a79f0f17a012aaefa",
      "simhash64": 7487617073026610211,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME ( NAME ) }"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._generate_actionable_recommendations",
      "lineno": 283,
      "end_lineno": 308,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gedcom_analysis, dna_analysis, prioritization_analysis)",
      "fingerprint": "f7f05b4b19ebd008f4a82663a9d3f8738e441dda",
      "simhash64": 7452151225961067555,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT NAME = [ ] # From GEDCOM analysis NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , LIT ) if NAME > LIT : NAME . NAME ( f\" Address { NAME } high-priority GEDCOM issues first \" ) # From DNA analysis if NAME : NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) if NAME > LIT : NAME . NAME ( f\" Verify { NAME } high-confidence DNA-tree matches \" ) # From prioritization analysis NAME = NAME . NAME ( LIT , [ ] ) NAME . NAME ( NAME [ : LIT ] ) # Top 3 prioritization recommendations return NAME [ : LIT ] # Limit to top 5 recommendations"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._generate_comprehensive_summary",
      "lineno": 310,
      "end_lineno": 331,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gedcom_analysis, dna_analysis, prioritization_analysis)",
      "fingerprint": "33973e584ef168a93615e9efaa56334a27fdc50a",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : LIT if NAME else LIT } if NAME : NAME . NAME ( { LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) } ) return NAME"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._format_enhanced_task_description",
      "lineno": 333,
      "end_lineno": 354,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 22,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(self, task)",
      "fingerprint": "72f861ff17a825d0be79cdb0de31decf778f0284",
      "simhash64": 7452151227034801179,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = f\" { NAME } \\n\\n \" NAME += f\" Priority Score: { NAME : .1f } /100\\n \" NAME += f\" Success Probability: { NAME : .0% } \\n \" NAME += f\" Estimated Effort: { NAME . NAME ( LIT , LIT ) . NAME ( ) } \\n\\n \" NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME += LIT for NAME , NAME in NAME ( NAME [ : LIT ] , LIT ) : NAME += f\" { NAME } . { NAME } \\n \" NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME += f\" \\nExpected Outcomes: { LIT . NAME ( NAME ) } \" return NAME"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._generate_ai_enhanced_tasks_from_data",
      "lineno": 356,
      "end_lineno": 384,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 29,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "b1cf58879f145c089f9022d963ca37d07b8526d6",
      "simhash64": 7451729014570783787,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] # Enhanced tasks based on structured names NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME = { LIT : LIT , LIT : f\" Research { NAME ( NAME ) } individuals using AI-powered genealogical analysis \" , LIT : LIT , LIT : LIT , LIT : LIT } NAME . NAME ( NAME ) # Enhanced tasks based on locations NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME = { LIT : LIT , LIT : f\" Analyze { NAME ( NAME ) } locations using AI geographic and temporal analysis \" , LIT : LIT , LIT : LIT , LIT : LIT } NAME . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._fallback_research_tasks",
      "lineno": 386,
      "end_lineno": 396,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, person_data, extracted_data)",
      "fingerprint": "c9835d78a38204f2d5958cb89b21c2c2440e24fe",
      "simhash64": 5145886005356041259,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT return [ { LIT : f\" Research: { NAME . NAME ( LIT , LIT ) } \" , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ]"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._find_person_relevant_gaps",
      "lineno": 399,
      "end_lineno": 402,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, person_identifier, analysis)",
      "fingerprint": "b174ec79eb42a7999fde1b20072c9cd8cb444054",
      "simhash64": 7488180022980031523,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = NAME . NAME ( LIT , [ ] ) return [ NAME for NAME in NAME if NAME . NAME ( ) in NAME . NAME ( LIT , LIT ) . NAME ( ) ]"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._find_person_relevant_conflicts",
      "lineno": 404,
      "end_lineno": 407,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, person_identifier, analysis)",
      "fingerprint": "a96b9fc4e7f7724dd7b7d73448e093f1dce37236",
      "simhash64": 7488180022980031571,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = NAME . NAME ( LIT , [ ] ) return [ NAME for NAME in NAME if NAME in NAME . NAME ( LIT , [ ] ) ]"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._find_person_research_opportunities",
      "lineno": 409,
      "end_lineno": 412,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, person_identifier, analysis)",
      "fingerprint": "a96b9fc4e7f7724dd7b7d73448e093f1dce37236",
      "simhash64": 7488180022980031571,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = NAME . NAME ( LIT , [ ] ) return [ NAME for NAME in NAME if NAME in NAME . NAME ( LIT , [ ] ) ]"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._get_person_family_context",
      "lineno": 414,
      "end_lineno": 417,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self, person_identifier, gedcom_data)",
      "fingerprint": "d2cc78c1384742ef28e504b7b455d0a0f6b29f42",
      "simhash64": 7452291962375672891,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT # This would extract family relationships and context return { LIT : LIT }"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._get_person_ai_recommendations",
      "lineno": 419,
      "end_lineno": 425,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self, person_identifier, analysis)",
      "fingerprint": "1c8815b8df5cbb8678271733a243886032efe24c",
      "simhash64": 7452151225961059363,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT return [ f\" Focus on high-priority research for { NAME } \" , LIT , LIT ]"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._calculate_tree_health_score",
      "lineno": 428,
      "end_lineno": 439,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gedcom_analysis)",
      "fingerprint": "652a33ac5f9d64d5c9d2d613bbf01bd1568b8e44",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) # Simple health score calculation NAME = ( NAME + NAME ) / NAME ( LIT , NAME ) NAME = NAME ( LIT , LIT - ( NAME * LIT ) ) return NAME ( NAME , LIT )"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._identify_efficiency_opportunities",
      "lineno": 441,
      "end_lineno": 454,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, prioritization_analysis)",
      "fingerprint": "6687a4a0bea5063b1efcef41f1f29f1266380130",
      "simhash64": 7452151225961067531,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT NAME = NAME . NAME ( LIT , { } ) NAME = [ ] NAME = NAME . NAME ( LIT , LIT ) if NAME > LIT : NAME . NAME ( f\" Cluster research in { NAME } geographic areas \" ) NAME = NAME . NAME ( LIT , LIT ) if NAME > LIT : NAME . NAME ( f\" Focus on { NAME } low-effort, high-impact tasks \" ) return NAME"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._assess_dna_verification_potential",
      "lineno": 456,
      "end_lineno": 466,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, dna_analysis)",
      "fingerprint": "398cb2aa546f9f988c4b04c24f7d6f580e8a616e",
      "simhash64": 5181914802442114091,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT if not NAME : return LIT NAME = NAME ( NAME . NAME ( LIT , [ ] ) ) if NAME > LIT : return LIT if NAME > LIT : return LIT return LIT"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._identify_priority_research_areas",
      "lineno": 468,
      "end_lineno": 480,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, prioritization_analysis)",
      "fingerprint": "11c005058e3ff6e36f72742b8024c895e4c8562d",
      "simhash64": 7452151226028168211,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT NAME = NAME . NAME ( LIT , [ ] ) # Group by task type NAME = { } for NAME in NAME [ : LIT ] : # Top 10 tasks NAME = NAME . NAME ( LIT , LIT ) NAME [ NAME ] = NAME . NAME ( NAME , LIT ) + LIT # Return top task types NAME = NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ LIT ] , NAME = True ) return [ NAME for NAME , NAME in NAME [ : LIT ] ]"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._assess_data_quality",
      "lineno": 482,
      "end_lineno": 496,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gedcom_analysis)",
      "fingerprint": "66ee2e620528ae42dc0a1f9a9ae4c86eb0bc5a6b",
      "simhash64": 5181914802375005227,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME / NAME ( LIT , NAME ) if NAME < LIT : return LIT if NAME < LIT : return LIT if NAME < LIT : return LIT return LIT"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._unavailable_analysis_result",
      "lineno": 498,
      "end_lineno": 510,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "be3b7334503db81fa1026b4ea543752fd078678d",
      "simhash64": 7457359579311412783,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME ( ) . NAME ( ) , LIT : LIT , LIT : LIT , LIT : { } , LIT : { } , LIT : { } , LIT : { } , LIT : [ LIT ] , LIT : { LIT : LIT } }"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "GedcomAIIntegrator._error_analysis_result",
      "lineno": 512,
      "end_lineno": 524,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, error_message)",
      "fingerprint": "bbe396b545bdaa87d210d19b566abfe73757fe62",
      "simhash64": 7457358479736870447,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME ( ) . NAME ( ) , LIT : LIT , LIT : NAME , LIT : { } , LIT : { } , LIT : { } , LIT : { } , LIT : [ ] , LIT : { LIT : LIT } }"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "test_gedcom_ai_integration",
      "lineno": 528,
      "end_lineno": 555,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 28,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "0eeddd3e208948ccbc993839393721f694b5b5ed",
      "simhash64": 8606340467475256915,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Simple test that doesn't rely on complex imports NAME = NAME ( ) # Test basic instantiation assert NAME is not None , LIT # Test availability flag assert NAME ( NAME , NAME ) , LIT # Test basic functionality without complex operations if NAME : # Test that components are available assert NAME . NAME is not None , LIT assert NAME . NAME is not None , LIT assert NAME . NAME is not None , LIT else : # Test that components are None when not available assert NAME . NAME is None , LIT assert NAME . NAME is None , LIT assert NAME . NAME is None , LIT return True except NAME as NAME : NAME ( f\" GEDCOM AI integration test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "test_fallback_research_tasks",
      "lineno": 558,
      "end_lineno": 573,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9d5248292801b193a9683e154bb9914a6c067353",
      "simhash64": 5146448955369231915,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) # Force fallback by simulating unavailable components if not NAME : NAME = NAME . NAME ( { LIT : LIT } , { LIT : [ ] } , NAME = None ) assert NAME and NAME [ LIT ] [ LIT ] == LIT else : # Temporarily monkey patch availability to simulate fallback NAME = NAME ( ) . NAME ( LIT ) NAME ( ) [ LIT ] = False try : NAME = NAME . NAME ( { LIT : LIT } , { LIT : [ ] } , NAME = None ) assert NAME and NAME [ LIT ] [ LIT ] == LIT finally : NAME ( ) [ LIT ] = NAME"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "test_enhanced_task_description_formatting",
      "lineno": 576,
      "end_lineno": 589,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "43d8ccf03ca9c4e1d32b51617701b85d1b2b5ae3",
      "simhash64": 5145886005410567723,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : [ LIT , LIT , LIT ] , LIT : [ LIT ] } NAME = NAME . NAME ( NAME ) for NAME in [ LIT , LIT , LIT , LIT ] : assert NAME in NAME , f\" Description missing { NAME } \""
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "test_comprehensive_analysis_structure_with_stubs",
      "lineno": 592,
      "end_lineno": 610,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "44391572f2ce496bf3b0120932a137e421031812",
      "simhash64": 5145885970988963371,
      "normalized": "def NAME ( ) -> NAME : LIT if not NAME : # Skip if components not available; availability is already tested elsewhere return True NAME = NAME ( ) # Create minimal stub gedcom data object NAME = NAME ( LIT , ( ) , { LIT : { LIT : NAME ( LIT , ( ) , { LIT : [ LIT ] } ) ( ) } , LIT : { } , LIT : { } } ) ( ) NAME = NAME . NAME ( NAME , NAME = [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ] , NAME = { } ) for NAME in [ LIT , LIT , LIT , LIT , LIT ] : assert NAME in NAME , f\" Comprehensive analysis missing { NAME } \" assert NAME [ LIT ] . NAME ( LIT ) in [ LIT , LIT ] return None"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "test_person_specific_insights_fallback",
      "lineno": 613,
      "end_lineno": 628,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "482603cf2512b7577452724580ac7dc294991c60",
      "simhash64": 7451728980202657323,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) if not NAME : NAME = NAME . NAME ( LIT , None ) assert LIT in NAME or LIT in NAME return NAME = NAME ( LIT , ( ) , { LIT : { LIT : NAME ( LIT , ( ) , { LIT : [ LIT ] } ) ( ) } , LIT : { } , LIT : { } } ) ( ) NAME = NAME . NAME ( LIT , NAME ) for NAME in [ LIT , LIT , LIT , LIT , LIT ] : assert NAME in NAME return"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "gedcom_ai_integration_module_tests",
      "lineno": 631,
      "end_lineno": 678,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 48,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "a1cc529248ff91137449a1e25cd810350776721d",
      "simhash64": 5145886009646814251,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "gedcom_ai_integration.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 681,
      "end_lineno": 683,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "LazyGedcomData.__init__",
      "lineno": 72,
      "end_lineno": 74,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, gedcom_path)",
      "fingerprint": "2a4dafc447ff9f0c7e745bf68b4e0aad6f872516",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME ) : NAME . NAME = NAME NAME . NAME = None"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "LazyGedcomData.data",
      "lineno": 77,
      "end_lineno": 84,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5427ee137ba0e916e890cb4dab5280de8fdfefcf",
      "simhash64": 7488145388363752531,
      "normalized": "def NAME ( NAME ) : # Only load GEDCOM data when accessed try : from NAME . NAME import NAME NAME . NAME = NAME ( NAME . NAME ) except NAME : NAME . NAME = None return NAME . NAME"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "GedcomCacheModule.__init__",
      "lineno": 96,
      "end_lineno": 99,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "914a58363111568cb65b0c4a11173e19a64d1e8b",
      "simhash64": 8641066347509752851,
      "normalized": "def NAME ( NAME ) : NAME ( ) . NAME ( ) NAME . NAME = LIT NAME . NAME = NAME"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "GedcomCacheModule.get_module_name",
      "lineno": 101,
      "end_lineno": 102,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "c535505b83302f749df69716dfd6a90687463628",
      "simhash64": 7488145388363752531,
      "normalized": "def NAME ( NAME ) -> NAME : return NAME . NAME"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "GedcomCacheModule.get_stats",
      "lineno": 104,
      "end_lineno": 136,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 33,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "03f4716c309943adc848b6acd09e86a6b35be4cb",
      "simhash64": 7487617073026610219,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( ) . NAME ( ) # Add GEDCOM-specific statistics NAME = NAME ( NAME ) NAME = NAME ( LIT for NAME in NAME if NAME ( NAME ) ) NAME = { LIT : NAME . NAME , LIT : NAME , LIT : NAME , LIT : ( NAME / NAME * LIT if NAME > LIT else LIT ) , LIT : NAME , } # Add GEDCOM file information if available NAME = NAME . NAME . NAME if NAME and NAME ( NAME ) . NAME ( ) : NAME [ LIT ] = NAME ( NAME ) NAME [ LIT ] = NAME ( NAME ) . NAME ( ) . NAME / ( LIT * LIT ) NAME [ LIT ] = NAME ( NAME ) . NAME ( ) . NAME # Merge with base statistics return { ** NAME , ** NAME }"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "GedcomCacheModule.clear",
      "lineno": 138,
      "end_lineno": 157,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "0ca8fd58605d6f4322f8861c8998f0c4ace68214",
      "simhash64": 7488215207888991251,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : # Clear memory cache NAME = NAME ( NAME ) NAME . NAME ( ) # Clear disk-based caches with GEDCOM prefix NAME = NAME ( NAME = f\" { NAME . NAME } * \" , NAME = [ ] , ) NAME . NAME ( f\" GEDCOM cache cleared: { NAME } memory entries, { NAME ( NAME . NAME ( ) ) } disk entries \" ) return True except NAME as NAME : NAME . NAME ( f\" Error clearing GEDCOM cache: { NAME } \" ) return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "GedcomCacheModule.warm",
      "lineno": 159,
      "end_lineno": 188,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 30,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "ef26c4a8da4012b66dcc64a27284967ca18c8227",
      "simhash64": 7488180022980023299,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : # Check if GEDCOM file is available if not ( NAME and NAME ( NAME . NAME , LIT ) ) : NAME . NAME ( LIT ) return False NAME = NAME . NAME . NAME if not NAME or not NAME ( NAME ) . NAME ( ) : NAME . NAME ( f\" GEDCOM file not found: { NAME } \" ) return False # Warm cache with basic file metadata NAME = NAME ( LIT , LIT , NAME ) NAME = NAME ( NAME ) . NAME ( ) NAME = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME ( ) , } NAME ( NAME , NAME ) NAME . NAME ( f\" GEDCOM cache warmed with metadata for { NAME } \" ) return True except NAME as NAME : NAME . NAME ( f\" Error warming GEDCOM cache: { NAME } \" ) return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "GedcomCacheModule.get_health_status",
      "lineno": 190,
      "end_lineno": 250,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 12,
      "loc": 61,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "7c24fdea73ac805a96cbc415a13e155250c65f1f",
      "simhash64": 7452151227034801195,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( ) . NAME ( ) try : # Check memory cache health NAME = LIT NAME = [ ] if NAME ( NAME ) == LIT : NAME . NAME ( LIT ) # Check for stale entries NAME = NAME ( LIT for NAME in NAME if not NAME ( NAME ) ) if NAME > NAME ( NAME ) * LIT : NAME = LIT NAME . NAME ( f\" High number of stale entries: { NAME } \" ) # Check GEDCOM file accessibility NAME = LIT NAME = [ ] if NAME and NAME ( NAME . NAME , LIT ) : NAME = NAME . NAME . NAME if not NAME : NAME = LIT NAME . NAME ( LIT ) elif not NAME ( NAME ) . NAME ( ) : NAME = LIT NAME . NAME ( f\" GEDCOM file not found: { NAME } \" ) else : NAME = LIT NAME . NAME ( LIT ) # Overall health assessment NAME = LIT if NAME == LIT or NAME == LIT : NAME = LIT elif NAME == LIT : NAME = LIT NAME = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME ( NAME ) , LIT : NAME , } return { ** NAME , ** NAME } except NAME as NAME : NAME . NAME ( f\" Error getting GEDCOM cache health status: { NAME } \" ) return { ** NAME , LIT : NAME ( NAME ) , LIT : LIT , }"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "_get_memory_cache_key",
      "lineno": 260,
      "end_lineno": 266,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(file_path, operation)",
      "fingerprint": "8fea8ea9496d56030c7124970eec265cbf3700a7",
      "simhash64": 7488180024053769331,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT # Use the unified cache key generation for consistency from NAME import NAME return NAME ( LIT , NAME , NAME , NAME ( NAME ) . NAME ( ) . NAME )"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "_is_memory_cache_valid",
      "lineno": 269,
      "end_lineno": 275,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(cache_key)",
      "fingerprint": "864bbfe5957ac75d3dd5500b956aa608b95b6521",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if NAME not in NAME : return False NAME , NAME = NAME [ NAME ] return ( NAME . NAME ( ) - NAME ) < NAME"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "_get_from_memory_cache",
      "lineno": 278,
      "end_lineno": 287,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(cache_key)",
      "fingerprint": "484ad109ee5d46542e9ce68995afe7b3d50c6904",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT if NAME ( NAME ) : NAME , NAME = NAME [ NAME ] NAME . NAME ( f\" Memory cache HIT for key: { NAME } \" ) return NAME # Clean up expired entry NAME . NAME ( NAME , None ) NAME . NAME ( f\" Memory cache MISS for key: { NAME } \" ) return None"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "_store_in_memory_cache",
      "lineno": 290,
      "end_lineno": 293,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(cache_key, data)",
      "fingerprint": "5fdaf183d498ffe54c309d023cd7c5bd3826ebc7",
      "simhash64": 8641101528660612115,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT NAME [ NAME ] = ( NAME , NAME . NAME ( ) ) NAME . NAME ( f\" Stored in memory cache: { NAME } \" )"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "clear_memory_cache",
      "lineno": 296,
      "end_lineno": 301,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "fcc0170114a2b061736130a09717e38529d6f4b9",
      "simhash64": 7488215212720825427,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( NAME ) NAME . NAME ( ) NAME . NAME ( f\" Cleared { NAME } entries from memory cache \" ) return NAME"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "load_gedcom_with_aggressive_caching",
      "lineno": 307,
      "end_lineno": 398,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 11,
      "loc": 92,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(gedcom_path)",
      "fingerprint": "f5e4f145c4299d8951bda95d63aa2e45e41c119f",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT # Check memory cache first NAME = NAME ( NAME , LIT ) NAME = NAME ( NAME ) if NAME is not None : return NAME # Initialize disk_cache_key to None NAME = None # Check disk cache try : from NAME import NAME NAME = NAME ( NAME ) . NAME ( ) . NAME NAME = NAME . NAME ( NAME ( NAME ) . NAME ( ) ) . NAME ( ) [ : LIT ] NAME = f\" gedcom_load_mtime_ { NAME } \" if NAME is not None : from NAME . NAME import NAME NAME = NAME . NAME ( NAME , NAME = NAME , NAME = True ) if NAME is not NAME : NAME . NAME ( LIT ) # Store in memory cache for faster next access NAME ( NAME , NAME ) return NAME except NAME as NAME : NAME . NAME ( f\" Error checking disk cache: { NAME } \" ) NAME = None # Reset to None if there was an error NAME . NAME ( f\" Loading GEDCOM file with aggressive caching: { NAME } \" ) NAME = NAME . NAME ( ) try : # Import here to avoid circular imports from NAME import NAME # Load the GEDCOM file NAME = NAME ( NAME ) if NAME : NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" GEDCOM file loaded and cached in { NAME : .2f } s \" ) # Store in memory cache for fastest access NAME ( NAME , NAME ) # Store in disk cache for persistence - but don't cache the reader object # The GedcomReader contains BinaryFileCR objects that cannot be pickled try : if NAME is not None and NAME is not None : # Create a serializable version without the reader NAME = { LIT : NAME ( NAME . NAME ) , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , } NAME . NAME ( NAME , NAME , NAME = LIT , NAME = True ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error storing in disk cache: { NAME } \" ) # Log cache statistics NAME = NAME ( ) if NAME : NAME . NAME ( f\" Cache stats after GEDCOM load: { NAME } \" ) return NAME NAME . NAME ( LIT ) return None except NAME as NAME : NAME . NAME ( f\" Error loading GEDCOM file { NAME } : { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "cache_gedcom_processed_data",
      "lineno": 401,
      "end_lineno": 521,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 23,
      "loc": 121,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:large"
      ],
      "signature": "(gedcom_data, gedcom_path)",
      "fingerprint": "aac2639c3e65029d628d4cc0a5e8e3abefbc2351",
      "simhash64": 7488180022981071931,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT if not NAME or not NAME ( NAME , LIT ) : NAME . NAME ( LIT ) return False try : # Create cache key based on file path and modification time from NAME import NAME NAME = NAME ( NAME ) . NAME ( ) . NAME NAME = NAME . NAME ( NAME ( NAME ) . NAME ( ) ) . NAME ( ) [ : LIT ] NAME = NAME . NAME ( NAME ( NAME ) . NAME ( ) ) . NAME ( ) [ : LIT ] # Cache different components separately for efficiency NAME = { LIT : f\" gedcom_processed_ { NAME } _ { NAME } \" , LIT : f\" gedcom_indi_index_ { NAME } _ { NAME } \" , LIT : f\" gedcom_family_maps_ { NAME } _ { NAME } \" , } # Cache processed data - ensure it's serializable if NAME ( NAME , LIT ) : # Create a serializable version of processed_data_cache NAME = { } for NAME , NAME in NAME . NAME . NAME ( ) : if NAME ( NAME , NAME ) : NAME = { } for NAME , NAME in NAME . NAME ( ) : # Convert datetime objects to ISO strings for serialization if NAME ( NAME , LIT ) : # datetime objects NAME [ NAME ] = NAME . NAME ( ) elif NAME ( NAME , ( NAME , NAME , NAME , NAME , NAME , NAME , NAME ( None ) ) ) : NAME [ NAME ] = NAME else : # Skip non-serializable objects NAME . NAME ( f\" Skipping non-serializable object in processed_data_cache: { NAME } = { NAME ( NAME ) } \" ) NAME [ NAME ] = NAME elif NAME ( NAME , ( NAME , NAME , NAME , NAME , NAME , NAME , NAME ( None ) ) ) : NAME [ NAME ] = NAME NAME ( NAME [ LIT ] , NAME , NAME = LIT , ) # Cache individual index - filter out non-serializable objects if NAME ( NAME , LIT ) : # Create a serializable version of indi_index NAME = { } for NAME , NAME in NAME . NAME . NAME ( ) : # Only cache primitive data types and avoid GedcomReader references if NAME ( NAME , ( NAME , NAME , NAME , NAME , NAME , NAME , NAME , NAME ( None ) ) ) : NAME [ NAME ] = NAME else : # For complex objects, try to extract serializable data try : # Check if it's a simple object with serializable attributes if NAME ( NAME , LIT ) : NAME = { } for NAME , NAME in NAME . NAME . NAME ( ) : if NAME ( NAME , ( NAME , NAME , NAME , NAME , NAME , NAME , NAME , NAME ( None ) , ) , ) : NAME [ NAME ] = NAME if NAME : # Only store if we have serializable data NAME [ NAME ] = NAME except NAME : # Skip non-serializable objects pass if NAME : NAME ( NAME [ LIT ] , NAME , NAME = LIT ) # Cache family relationship maps NAME = { } if NAME ( NAME , LIT ) : NAME [ LIT ] = NAME . NAME if NAME ( NAME , LIT ) : NAME [ LIT ] = NAME . NAME if NAME : NAME ( NAME [ LIT ] , NAME , NAME = LIT ) NAME . NAME ( f\" Successfully cached GEDCOM processed data for { NAME ( NAME ) . NAME } \" ) return True except NAME as NAME : NAME . NAME ( f\" Error caching GEDCOM processed data: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "preload_gedcom_cache",
      "lineno": 524,
      "end_lineno": 558,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 7,
      "loc": 35,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "a97099062153f6edc0f39027dd0bb10a646a1da7",
      "simhash64": 7488215207352108035,
      "normalized": "def NAME ( ) -> NAME : LIT if not NAME or not NAME ( NAME . NAME , LIT ) : NAME . NAME ( LIT ) return False NAME = NAME . NAME . NAME if not NAME or not NAME ( NAME ) . NAME ( ) : NAME . NAME ( f\" GEDCOM file not found for preloading: { NAME } \" ) return False NAME . NAME ( LIT ) NAME = NAME . NAME ( ) try : NAME = NAME ( NAME ( NAME ) ) if NAME : # Also cache the processed data components NAME ( NAME , NAME ( NAME ) ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" GEDCOM cache preloaded successfully in { NAME : .2f } s \" ) return True NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" Error preloading GEDCOM cache: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "get_gedcom_cache_info",
      "lineno": 561,
      "end_lineno": 584,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 24,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "a013509699b611030d11dfa4375b57c733ae081c",
      "simhash64": 7487617074167460899,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : NAME ( NAME ) , LIT : NAME , LIT : NAME ( ) , } # Add GEDCOM-specific information if available if NAME and NAME ( NAME . NAME , LIT ) : NAME = NAME . NAME . NAME if NAME and NAME ( NAME ) . NAME ( ) : NAME [ LIT ] = NAME ( NAME ) NAME [ LIT ] = NAME ( NAME ) . NAME ( ) . NAME / ( LIT * LIT ) NAME [ LIT ] = NAME ( NAME ) . NAME ( ) . NAME return NAME"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "get_gedcom_cache_stats",
      "lineno": 590,
      "end_lineno": 592,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "cb45e5d238bf4d2167818b42bca357cb2ea31f9f",
      "simhash64": 7488180022980031523,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return NAME . NAME ( )"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "clear_gedcom_cache",
      "lineno": 595,
      "end_lineno": 597,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d47288f6127502799f806b1d647827a7f4d80a3e",
      "simhash64": 8645218654783181859,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME . NAME ( )"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "warm_gedcom_cache",
      "lineno": 600,
      "end_lineno": 602,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d47288f6127502799f806b1d647827a7f4d80a3e",
      "simhash64": 8645218654783181859,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME . NAME ( )"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "get_gedcom_cache_health",
      "lineno": 605,
      "end_lineno": 607,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "cb45e5d238bf4d2167818b42bca357cb2ea31f9f",
      "simhash64": 7488180022980031523,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return NAME . NAME ( )"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "demonstrate_gedcom_cache_usage",
      "lineno": 613,
      "end_lineno": 718,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 106,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "bab50a2b9c6ce8578a22b6552ac37562afaf0203",
      "simhash64": 7451729014637892651,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : [ ] , LIT : NAME . NAME ( ) , LIT : { } , } NAME . NAME ( LIT ) try : # Demo 1: Cache Statistics Display NAME = NAME ( ) NAME [ LIT ] . NAME ( { LIT : LIT , LIT : LIT , LIT : NAME , LIT : LIT , } ) # Demo 2: Health Status Check NAME = NAME ( ) NAME [ LIT ] . NAME ( { LIT : LIT , LIT : LIT , LIT : NAME , LIT : LIT , } ) # Demo 3: Memory Cache Operations if NAME and NAME ( NAME . NAME , LIT ) : NAME = NAME . NAME . NAME if NAME and NAME ( NAME ) . NAME ( ) : # Demonstrate file-based caching NAME = NAME ( NAME ( NAME ) , LIT ) NAME = { LIT : NAME , LIT : NAME . NAME ( ) , LIT : LIT , } NAME ( NAME , NAME ) NAME = NAME ( NAME ) NAME [ LIT ] . NAME ( { LIT : LIT , LIT : LIT , LIT : { LIT : NAME , LIT : NAME , LIT : NAME == NAME , } , LIT : LIT , } ) # Clean up demo data NAME . NAME ( NAME , None ) # Demo 4: Cache Coordination NAME = NAME ( LIT , LIT , LIT ) NAME [ LIT ] . NAME ( { LIT : LIT , LIT : LIT , LIT : { LIT : NAME , LIT : LIT } , LIT : LIT , } ) except NAME as NAME : NAME [ LIT ] . NAME ( { LIT : LIT , LIT : f\" Error occurred: { NAME ! NAME } \" , LIT : LIT , } ) NAME . NAME ( f\" Error in GEDCOM cache demonstration: { NAME } \" ) # Final summary NAME [ LIT ] = NAME . NAME ( ) NAME [ LIT ] = ( NAME [ LIT ] - NAME [ LIT ] ) NAME [ LIT ] = { LIT : NAME ( [ NAME for NAME in NAME [ LIT ] if NAME [ LIT ] == LIT ] ) , LIT : NAME ( NAME [ LIT ] ) , LIT : NAME ( ) , LIT : NAME ( ) , } NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "test_gedcom_cache_initialization",
      "lineno": 727,
      "end_lineno": 741,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3b39fe26d70d66909cd7bec9afbf44da6b8258bd",
      "simhash64": 7488355911554470955,
      "normalized": "def NAME ( ) : LIT try : # Test module instance NAME = NAME . NAME ( ) assert NAME == LIT # Test basic cache functionality if NAME ( LIT ) : NAME = NAME ( LIT ) if NAME : assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) return True except NAME : return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "test_memory_cache_operations",
      "lineno": 744,
      "end_lineno": 761,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 18,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "531769e784ecdf260795fbf680a3e0915b489fae",
      "simhash64": 7488321861121905723,
      "normalized": "def NAME ( ) : LIT try : NAME = LIT NAME = { LIT : LIT , LIT : NAME . NAME ( ) } # Store in memory cache NAME ( NAME , NAME ) # Retrieve from memory cache NAME = NAME ( NAME ) # Clean up NAME . NAME ( NAME , None ) return NAME == NAME except NAME : return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "test_gedcom_parsing_caching",
      "lineno": 764,
      "end_lineno": 778,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ff915699ce2ba824e783a0c97f1fa7406958473a",
      "simhash64": 7488320731537643051,
      "normalized": "def NAME ( ) : LIT try : if NAME ( LIT ) : NAME = NAME ( LIT ) # Test with mock data NAME = LIT NAME = { LIT : [ ] , LIT : [ ] } if NAME : NAME = NAME ( NAME , NAME ) return NAME ( NAME , NAME ) or NAME is None return True # Pass if function doesn't exist except NAME : return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "test_cached_data_retrieval",
      "lineno": 781,
      "end_lineno": 793,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "920f2b36bc591e43e6a833c69651e9c33f000258",
      "simhash64": 7488356498951017515,
      "normalized": "def NAME ( ) : LIT try : if NAME ( LIT ) : NAME = NAME ( LIT ) NAME = LIT if NAME : NAME = NAME ( NAME ) # May return None if no cache exists, which is valid return NAME is None or NAME ( NAME , NAME ) return True # Pass if function doesn't exist except NAME : return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "test_cache_key_generation",
      "lineno": 796,
      "end_lineno": 811,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 16,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "468c6f4e13572079b16976f06346751e2d8b1f98",
      "simhash64": 7487652261693658147,
      "normalized": "def NAME ( ) : LIT try : if not ( NAME and NAME ( NAME . NAME , LIT ) ) : return True # Skip if no GEDCOM configured NAME = NAME . NAME . NAME if not NAME or not NAME ( NAME ) . NAME ( ) : return True # Skip if file doesn't exist NAME = NAME ( NAME ( NAME ) , LIT ) NAME = NAME ( NAME ( NAME ) , LIT ) return NAME == NAME # Keys should be consistent except NAME : return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "test_memory_cache_expiration",
      "lineno": 814,
      "end_lineno": 831,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 18,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2f22c6fbdc16630f9553022b20fe78decb417d9b",
      "simhash64": 5182373297718727731,
      "normalized": "def NAME ( ) : LIT try : NAME = LIT NAME = LIT # Store with expired timestamp NAME [ NAME ] = ( NAME , NAME . NAME ( ) - NAME - LIT ) # Should be invalid due to age NAME = NAME ( NAME ) # Clean up NAME . NAME ( NAME , None ) return not NAME # Should be invalid (expired) except NAME : return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "test_cache_invalidation_file_modification",
      "lineno": 834,
      "end_lineno": 846,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3c3f976cf8f7b8036eb255a5db884fd23ec3d7ee",
      "simhash64": 7488355915909207595,
      "normalized": "def NAME ( ) : LIT try : if NAME ( LIT ) : NAME = NAME ( LIT ) # Test with mock file path NAME = LIT if NAME : NAME = NAME ( NAME ) return NAME ( NAME , NAME ) return True # Pass if function doesn't exist except NAME : return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "test_cache_statistics_collection",
      "lineno": 849,
      "end_lineno": 860,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7ab8f417be93de937904d7f5d0cc399ed26099ae",
      "simhash64": 7488320760535487531,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME . NAME ( ) NAME = [ LIT , LIT , LIT , ] return NAME ( NAME in NAME for NAME in NAME ) except NAME : return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "test_cache_health_status",
      "lineno": 863,
      "end_lineno": 874,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7ab8f417be93de937904d7f5d0cc399ed26099ae",
      "simhash64": 7488320760535487531,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME . NAME ( ) NAME = [ LIT , LIT , LIT , ] return NAME ( NAME in NAME for NAME in NAME ) except NAME : return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "test_cache_performance_metrics",
      "lineno": 877,
      "end_lineno": 885,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "5ee49f8c33b053d8f8bfc43bf0fe3cd24de59403",
      "simhash64": 7488180023038743611,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME . NAME ( ) # Check for performance-related metrics NAME = [ LIT , LIT ] return NAME ( NAME in NAME for NAME in NAME ) except NAME : return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "test_multifile_cache_management",
      "lineno": 888,
      "end_lineno": 906,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ccc57b75e2a8633f57891f2fb81c7611273a92be",
      "simhash64": 7488320761610277947,
      "normalized": "def NAME ( ) : LIT try : # Test cache can handle multiple file paths NAME = [ LIT , LIT ] NAME = { LIT : LIT } for NAME in NAME : NAME = NAME ( NAME , LIT ) NAME ( NAME , NAME ) # Clean up for NAME in NAME : NAME = NAME ( NAME , LIT ) NAME . NAME ( NAME , None ) return True except NAME : return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "test_memory_management_cleanup",
      "lineno": 909,
      "end_lineno": 917,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "33732ac706eecc53a85de1905f69e6e142b8bf7d",
      "simhash64": 7488355911076844547,
      "normalized": "def NAME ( ) : LIT try : # Test cache clearing NAME = NAME . NAME ( ) # Clear should either succeed or fail gracefully return NAME ( NAME , NAME ) except NAME : return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "test_cache_validation_integrity",
      "lineno": 920,
      "end_lineno": 927,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "3059d710ac009f9eadb8380f0c09e840e882411c",
      "simhash64": 7492683588314764323,
      "normalized": "def NAME ( ) : LIT try : # Test that health check detects cache state NAME = NAME . NAME ( ) return NAME ( NAME , NAME ) and LIT in NAME except NAME : return False"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "gedcom_cache_module_tests",
      "lineno": 930,
      "end_lineno": 1045,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 116,
      "tags": [
        "pure-ish",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "2c1cc6bdda95a94f44ecbd5f71e9ae8c92533365",
      "simhash64": 5127871611137332267,
      "normalized": "def NAME ( ) -> NAME : LIT with NAME ( ) : NAME = NAME ( LIT , NAME ) NAME . NAME ( ) # Run all tests using the suite NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "gedcom_cache.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 1048,
      "end_lineno": 1050,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer.__init__",
      "lineno": 68,
      "end_lineno": 72,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "0c61f1b1776ce5c48a6b931241dc5505d8e74db1",
      "simhash64": 7452151226028176469,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME : NAME [ NAME ] = [ ]"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer.analyze_gedcom_data",
      "lineno": 74,
      "end_lineno": 121,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 7,
      "loc": 48,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, gedcom_data)",
      "fingerprint": "9e80a28458689582aa5a59a5b1cf0c9b65629c4f",
      "simhash64": 7487617073026606099,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT try : if not NAME or not NAME ( NAME , LIT ) : NAME . NAME ( LIT ) return NAME . NAME ( ) NAME . NAME ( f\" Starting AI-enhanced GEDCOM analysis of { NAME ( NAME . NAME ) } individuals \" ) # Clear previous analysis NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) # Perform different types of analysis NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) # Generate AI-powered insights NAME = NAME . NAME ( NAME ) NAME = { LIT : NAME . NAME ( ) . NAME ( ) , LIT : NAME ( NAME . NAME ) , LIT : [ NAME . NAME ( NAME ) for NAME in NAME . NAME ] , LIT : [ NAME . NAME ( NAME ) for NAME in NAME . NAME ] , LIT : [ NAME . NAME ( NAME ) for NAME in NAME . NAME ] , LIT : NAME , LIT : NAME . NAME ( ) } NAME . NAME ( f\" GEDCOM analysis completed: { NAME ( NAME . NAME ) } gaps, { NAME ( NAME . NAME ) } conflicts, { NAME ( NAME . NAME ) } opportunities \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Error during GEDCOM analysis: { NAME } \" ) return NAME . NAME ( )"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._analyze_family_completeness",
      "lineno": 123,
      "end_lineno": 184,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 9,
      "loc": 62,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, gedcom_data)",
      "fingerprint": "b199432242c022a028aa1d9571208518aafc88f6",
      "simhash64": 7488109654235845659,
      "normalized": "def NAME ( NAME , NAME : NAME ) : LIT NAME . NAME ( LIT ) for NAME , NAME in NAME . NAME . NAME ( ) : try : NAME = NAME . NAME ( NAME ) # Check for missing parents if NAME not in NAME . NAME or not NAME . NAME [ NAME ] : # Only flag as gap if person was born after 1800 (more likely to have records) NAME = NAME . NAME ( NAME ) if NAME and NAME > LIT : NAME = NAME ( NAME = NAME , NAME = NAME , NAME = LIT , NAME = f\" No parents identified for { NAME } (b. { NAME } ) \" , NAME = LIT if NAME > LIT else LIT , NAME = [ f\" Search birth records for { NAME } around { NAME } \" , f\" Look for census records showing { NAME } with parents \" , LIT ] ) NAME . NAME . NAME ( NAME ) # Check for missing vital dates if not NAME . NAME ( NAME ) : NAME = NAME ( NAME = NAME , NAME = NAME , NAME = LIT , NAME = f\" Missing birth date for { NAME } \" , NAME = LIT , NAME = [ f\" Search vital records for { NAME } \" , LIT , LIT ] ) NAME . NAME . NAME ( NAME ) # Check for missing locations if not NAME . NAME ( NAME ) : NAME = NAME ( NAME = NAME , NAME = NAME , NAME = LIT , NAME = f\" Missing birth location for { NAME } \" , NAME = LIT , NAME = [ LIT , LIT , LIT ] ) NAME . NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error analyzing person { NAME } : { NAME } \" ) continue"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._analyze_date_consistency",
      "lineno": 186,
      "end_lineno": 231,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 46,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, gedcom_data)",
      "fingerprint": "64d4dd4875d9d6eed85333ffc20a950782272faf",
      "simhash64": 7452151227034801179,
      "normalized": "def NAME ( NAME , NAME : NAME ) : LIT NAME . NAME ( LIT ) for NAME , NAME in NAME . NAME . NAME ( ) : try : NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) # Check for impossible date ranges if NAME and NAME : NAME = NAME - NAME if NAME < LIT : NAME = NAME ( NAME = f\" date_conflict_ { NAME } \" , NAME = LIT , NAME = f\" { NAME } has death year ( { NAME } ) before birth year ( { NAME } ) \" , NAME = [ NAME ] , NAME = LIT , NAME = [ LIT , LIT , LIT ] ) NAME . NAME . NAME ( NAME ) elif NAME > LIT : NAME = NAME ( NAME = f\" age_conflict_ { NAME } \" , NAME = LIT , NAME = f\" { NAME } lived { NAME } years (unusually long lifespan) \" , NAME = [ NAME ] , NAME = LIT , NAME = [ LIT , LIT , LIT ] ) NAME . NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error analyzing dates for person { NAME } : { NAME } \" ) continue"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._analyze_location_patterns",
      "lineno": 233,
      "end_lineno": 271,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 39,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, gedcom_data)",
      "fingerprint": "32f7e181faac5e765e16eece01f8f8ac049c6b90",
      "simhash64": 7488109654235853851,
      "normalized": "def NAME ( NAME , NAME : NAME ) : LIT NAME . NAME ( LIT ) # This would analyze migration patterns, impossible location combinations, etc. # For now, implementing basic location consistency checks for NAME , NAME in NAME . NAME . NAME ( ) : try : NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) # Check for location consistency (basic implementation) if NAME and NAME : # Look for major geographic inconsistencies NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) if NAME and NAME and NAME != NAME : # This could be migration, but worth noting as research opportunity NAME = NAME ( NAME = f\" migration_ { NAME } \" , NAME = LIT , NAME = f\" Research migration of { NAME } from { NAME } to { NAME } \" , NAME = [ NAME ] , NAME = LIT , NAME = LIT , NAME = [ f\" Search immigration records for { NAME } \" , LIT , f\" Check naturalization records in { NAME } \" ] ) NAME . NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error analyzing locations for person { NAME } : { NAME } \" ) continue"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._analyze_relationship_conflicts",
      "lineno": 273,
      "end_lineno": 322,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 10,
      "loc": 50,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, gedcom_data)",
      "fingerprint": "f07dd7197da8438af8e0723f94b51a8fd53d31c2",
      "simhash64": 7452080857216889875,
      "normalized": "def NAME ( NAME , NAME : NAME ) : LIT NAME . NAME ( LIT ) # Check for relationship inconsistencies for NAME in NAME . NAME : try : # Check parent-child age gaps if NAME in NAME . NAME : NAME = NAME . NAME ( NAME . NAME [ NAME ] ) for NAME in NAME . NAME [ NAME ] : if NAME in NAME . NAME : NAME = NAME . NAME ( NAME . NAME [ NAME ] ) if NAME and NAME : NAME = NAME - NAME if NAME < LIT : # Parent too young NAME = NAME ( NAME = f\" age_gap_ { NAME } _ { NAME } \" , NAME = LIT , NAME = f\" Parent-child age gap too small: { NAME } years \" , NAME = [ NAME , NAME ] , NAME = LIT , NAME = [ LIT , LIT , LIT ] ) NAME . NAME . NAME ( NAME ) elif NAME > LIT : # Parent quite old NAME = NAME ( NAME = f\" late_parent_ { NAME } _ { NAME } \" , NAME = LIT , NAME = f\" Large parent-child age gap: { NAME } years \" , NAME = [ NAME , NAME ] , NAME = LIT , NAME = [ LIT , LIT , LIT ] ) NAME . NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error analyzing relationships for person { NAME } : { NAME } \" ) continue"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._identify_research_opportunities",
      "lineno": 324,
      "end_lineno": 347,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 24,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, gedcom_data)",
      "fingerprint": "b280b619a755f9bd4a3bf4f5fcfc1d1e8087be68",
      "simhash64": 7488180024053765179,
      "normalized": "def NAME ( NAME , NAME : NAME ) : LIT NAME . NAME ( LIT ) # Look for clusters of people in same location/time that could be researched together NAME = NAME . NAME ( NAME ) for NAME , NAME in NAME . NAME ( ) : if NAME ( NAME ) >= LIT : # Cluster research opportunity NAME = NAME ( NAME = f\" cluster_ { NAME . NAME ( LIT , LIT ) } \" , NAME = LIT , NAME = f\" Cluster research opportunity in { NAME } with { NAME ( NAME ) } family members \" , NAME = NAME , NAME = LIT , NAME = LIT , NAME = [ f\" Research local records for { NAME } \" , LIT , LIT , LIT ] ) NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._generate_ai_insights",
      "lineno": 349,
      "end_lineno": 376,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gedcom_data)",
      "fingerprint": "6a04195e5dfabb7124fb917d4ed4ae8e731fea99",
      "simhash64": 7488180022980031531,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT try : # This would integrate with the AI interface to generate insights # For now, providing structured analysis NAME = NAME ( NAME . NAME ) NAME = NAME ( [ NAME for NAME in NAME . NAME if NAME . NAME [ NAME ] ] ) NAME = NAME ( [ NAME for NAME in NAME . NAME if NAME . NAME [ NAME ] ] ) NAME = ( NAME / NAME ) * LIT if NAME > LIT else LIT return { LIT : { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME ( NAME , LIT ) } , LIT : NAME . NAME ( ) , LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME ( ) } except NAME as NAME : NAME . NAME ( f\" Error generating AI insights: { NAME } \" ) return { LIT : LIT }"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._generate_research_priorities",
      "lineno": 378,
      "end_lineno": 395,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "0cd470e42094730675271d7b9d5a050fceeff819",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME = [ ] NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] if NAME : NAME . NAME ( f\" Resolve { NAME ( NAME ) } critical data conflicts \" ) if NAME : NAME . NAME ( f\" Fill { NAME ( NAME ) } high-priority information gaps \" ) NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] if NAME : NAME . NAME ( f\" Pursue { NAME ( NAME ) } high-value research opportunities \" ) return NAME [ : LIT ] # Top 5 priorities"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._analyze_family_patterns",
      "lineno": 397,
      "end_lineno": 403,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, gedcom_data)",
      "fingerprint": "2d4d9620501f85622b550ce57f6c00e493a72eea",
      "simhash64": 7487617074100343843,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME ( NAME ) }"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._generate_ai_recommendations",
      "lineno": 405,
      "end_lineno": 420,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "82aeb731f6092439dfea3913450541aeafd766a1",
      "simhash64": 7487617073093719043,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME = [ ] if NAME ( NAME . NAME ) > NAME ( NAME . NAME ) : NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) if NAME ( NAME . NAME ) > LIT : NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._extract_person_name",
      "lineno": 423,
      "end_lineno": 430,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self, person_record)",
      "fingerprint": "012fe9a5e1a5200c3ce3201cc3d913f7f2869625",
      "simhash64": 7487757810582066211,
      "normalized": "def NAME ( NAME , NAME ) -> NAME : LIT try : if NAME ( NAME , LIT ) and NAME . NAME : return NAME ( NAME . NAME [ LIT ] ) return LIT except NAME : return LIT"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._extract_birth_year",
      "lineno": 432,
      "end_lineno": 439,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self, person_record)",
      "fingerprint": "1267d134378532a04bd423e585ff71ccc063239c",
      "simhash64": 5146440124387480611,
      "normalized": "def NAME ( NAME , NAME ) -> NAME [ NAME ] : LIT try : # This would need to be implemented based on the actual GEDCOM structure # For now, returning None as placeholder return None except NAME : return None"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._extract_death_year",
      "lineno": 441,
      "end_lineno": 447,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self, person_record)",
      "fingerprint": "8a34361f6567498b9a84dc8b5950b27f8a69278b",
      "simhash64": 5182468921137992739,
      "normalized": "def NAME ( NAME , NAME ) -> NAME [ NAME ] : LIT try : # This would need to be implemented based on the actual GEDCOM structure return None except NAME : return None"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._extract_birth_place",
      "lineno": 449,
      "end_lineno": 455,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self, person_record)",
      "fingerprint": "8a34361f6567498b9a84dc8b5950b27f8a69278b",
      "simhash64": 5182468921137992739,
      "normalized": "def NAME ( NAME , NAME ) -> NAME [ NAME ] : LIT try : # This would need to be implemented based on the actual GEDCOM structure return None except NAME : return None"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._extract_death_place",
      "lineno": 457,
      "end_lineno": 463,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self, person_record)",
      "fingerprint": "8a34361f6567498b9a84dc8b5950b27f8a69278b",
      "simhash64": 5182468921137992739,
      "normalized": "def NAME ( NAME , NAME ) -> NAME [ NAME ] : LIT try : # This would need to be implemented based on the actual GEDCOM structure return None except NAME : return None"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._has_birth_date",
      "lineno": 465,
      "end_lineno": 467,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self, person_record)",
      "fingerprint": "5f7c342162a16d3a645169a317a0488d973c84af",
      "simhash64": 7488180022980543491,
      "normalized": "def NAME ( NAME , NAME ) -> NAME : LIT return NAME . NAME ( NAME ) is not None"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._has_birth_place",
      "lineno": 469,
      "end_lineno": 471,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self, person_record)",
      "fingerprint": "5f7c342162a16d3a645169a317a0488d973c84af",
      "simhash64": 7488180022980543491,
      "normalized": "def NAME ( NAME , NAME ) -> NAME : LIT return NAME . NAME ( NAME ) is not None"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._extract_country_from_place",
      "lineno": 473,
      "end_lineno": 486,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, place)",
      "fingerprint": "045119672331650a4b665e0994adda7c28d51e0a",
      "simhash64": 5145886005423150123,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT if not NAME : return None # Simple implementation - look for common country names at end of place string NAME = NAME . NAME ( LIT ) if NAME : NAME = NAME [ - LIT ] . NAME ( ) . NAME ( ) NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : if NAME in NAME : return NAME . NAME ( ) return None"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._find_location_clusters",
      "lineno": 488,
      "end_lineno": 500,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gedcom_data)",
      "fingerprint": "308a5da0b62ca8d3e1c42d8a2df76764e85b8481",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME [ NAME ] ] : LIT NAME = { } for NAME , NAME in NAME . NAME . NAME ( ) : NAME = NAME . NAME ( NAME ) if NAME : if NAME not in NAME : NAME [ NAME ] = [ ] NAME [ NAME ] . NAME ( NAME ) # Only return clusters with multiple people return { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME ( NAME ) > LIT }"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._find_common_surnames",
      "lineno": 502,
      "end_lineno": 514,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gedcom_data)",
      "fingerprint": "49b5795b53281cd7e7c5e651ec3ad821cc632a0b",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT NAME = { } for NAME in NAME . NAME . NAME ( ) : NAME = NAME . NAME ( NAME ) if LIT in NAME : NAME = NAME . NAME ( ) [ - LIT ] NAME [ NAME ] = NAME . NAME ( NAME , LIT ) + LIT # Return top 5 surnames NAME = NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ LIT ] , NAME = True ) return [ NAME for NAME , NAME in NAME [ : LIT ] ]"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._find_geographic_patterns",
      "lineno": 516,
      "end_lineno": 519,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, gedcom_data)",
      "fingerprint": "9a631565c1293fd7bfe38ab583c8ee3ecffe857b",
      "simhash64": 5146440123850077287,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT # Placeholder implementation return [ LIT ]"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._analyze_time_coverage",
      "lineno": 521,
      "end_lineno": 524,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(self, gedcom_data)",
      "fingerprint": "42a52e716c98952192b03db02847ae0d70fb912b",
      "simhash64": 5150381874102047787,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT # Placeholder implementation return { LIT : LIT , LIT : LIT , LIT : LIT }"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._generate_analysis_summary",
      "lineno": 526,
      "end_lineno": 535,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "6021d5a67e55c7b437cf2019fd70607be332cd78",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , LIT : NAME ( [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] ) + NAME ( [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] ) + NAME ( [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] ) }"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._empty_analysis_result",
      "lineno": 537,
      "end_lineno": 548,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "2df19984e978e67a955984e03b3cbe88952230e1",
      "simhash64": 5151507774004696623,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME ( ) . NAME ( ) , LIT : LIT , LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : { } , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , LIT : LIT }"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._gap_to_dict",
      "lineno": 550,
      "end_lineno": 560,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gap)",
      "fingerprint": "2d703168796e53dbd3f22f56532f8ba9567e37e5",
      "simhash64": 7451729014569743395,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME }"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._conflict_to_dict",
      "lineno": 562,
      "end_lineno": 571,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, conflict)",
      "fingerprint": "6a55157276c2642ce7a7b9fecca870905fc0ba2e",
      "simhash64": 7451729014569743395,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME }"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "GedcomIntelligenceAnalyzer._opportunity_to_dict",
      "lineno": 573,
      "end_lineno": 583,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, opportunity)",
      "fingerprint": "2d703168796e53dbd3f22f56532f8ba9567e37e5",
      "simhash64": 7451729014569743395,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME }"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "test_gedcom_intelligence",
      "lineno": 587,
      "end_lineno": 608,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c6b9cff624b29404da569ac708a837284e126d72",
      "simhash64": 7451728980209997355,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) NAME = NAME ( ) # Test with mock data NAME = NAME ( LIT , ( ) , { LIT : { LIT : NAME ( LIT , ( ) , { LIT : [ LIT ] } ) ( ) } , LIT : { } , LIT : { } } ) ( ) NAME = NAME . NAME ( NAME ) assert LIT in NAME , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "test_gap_detection_with_mocked_birth_year",
      "lineno": 611,
      "end_lineno": 626,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7eb29f4fa40027ed778b223bed22decdc7dc73b1",
      "simhash64": 7451730114149520427,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) NAME = NAME ( LIT , ( ) , { LIT : { LIT : NAME ( LIT , ( ) , { LIT : [ LIT ] } ) ( ) } , LIT : { } , LIT : { } } ) ( ) # Monkey patch birth year extractor NAME . NAME = lambda NAME : LIT # type: ignore NAME . NAME = lambda NAME : None # ensure place gap  # type: ignore NAME . NAME = lambda NAME : LIT # type: ignore NAME = NAME . NAME ( NAME ) NAME = { NAME [ LIT ] for NAME in NAME [ LIT ] } assert LIT in NAME or LIT in LIT . NAME ( NAME ) , LIT assert NAME ( LIT in NAME [ LIT ] for NAME in NAME [ LIT ] ) , LIT"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "test_ai_insights_structure",
      "lineno": 629,
      "end_lineno": 639,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "cb69c06d79af308db686b5702f4d8ba9e71672ee",
      "simhash64": 7434840481600017963,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) NAME = NAME ( LIT , ( ) , { LIT : { LIT : NAME ( LIT , ( ) , { LIT : [ LIT ] } ) ( ) } , LIT : { LIT : [ ] } , LIT : { } } ) ( ) NAME = NAME . NAME ( NAME ) for NAME in [ LIT , LIT , LIT , LIT ] : assert NAME in NAME , f\" ai_insights missing { NAME } \""
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "test_recommendation_balance_logic",
      "lineno": 642,
      "end_lineno": 648,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "cb10776bafd247363caf71b75280fc82105c7f4e",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) NAME . NAME = [ ] NAME . NAME = [ ] NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) and NAME ( NAME ) >= LIT"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "gedcom_intelligence_module_tests",
      "lineno": 651,
      "end_lineno": 692,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 42,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "8043546c99fe1e243c3f1d7b7ac9464c4d6a2dc0",
      "simhash64": 5145886005351846955,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Add additional existing tests to ensure multi-test coverage is reported NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "gedcom_intelligence.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 695,
      "end_lineno": 697,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "set_cached_gedcom_data",
      "lineno": 74,
      "end_lineno": 101,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(gedcom_data)",
      "fingerprint": "a8fdc869a5d00e3d00cafbbd072c808c60e92849",
      "simhash64": 8641101527586874419,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT global NAME NAME = NAME NAME . NAME ( f\" Set cached GEDCOM data directly: { NAME is not None } \" ) # If we have a valid gedcom_data instance, cache its processed data if NAME and NAME ( NAME , LIT ) : try : from NAME import NAME NAME ( NAME , NAME ( NAME . NAME ) ) except NAME : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error caching processed GEDCOM data: { NAME } \" )"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "get_cached_gedcom_data",
      "lineno": 104,
      "end_lineno": 106,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "3140307c015cf6691ad5a38fc8fae0b0658afea9",
      "simhash64": 7492851299204895843,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "load_gedcom_data",
      "lineno": 109,
      "end_lineno": 153,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 45,
      "tags": [
        "impure",
        "filesystem",
        "regex",
        "size:medium"
      ],
      "signature": "(gedcom_path)",
      "fingerprint": "afa832b035f3f1e6abe4568e1c081ac26032a596",
      "simhash64": 7488215207352120371,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT try : # Log the path we're using NAME . NAME ( f\" Loading GEDCOM file from: { NAME } \" ) # Check if the file exists and is readable if not NAME . NAME ( ) : raise NAME ( f\" GEDCOM file does not exist: { NAME } \" ) # Create GedcomData instance NAME . NAME ( LIT ) NAME = NAME ( NAME ) # Check if the instance was created successfully if NAME : NAME . NAME ( LIT ) # Try to build caches if the method exists if NAME ( NAME , LIT ) : NAME . NAME ( LIT ) try : NAME . NAME ( ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error building caches: { NAME } \" , NAME = True ) # Continue without caches rather than failing completely else : NAME . NAME ( LIT ) return NAME NAME . NAME ( LIT ) return None except NAME as NAME : NAME . NAME ( f\" Error loading GEDCOM file: { NAME } \" , NAME = True ) # Use exception chaining for better error context raise NAME ( f\" Failed to load GEDCOM data from { NAME } \" ) from NAME"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "get_gedcom_data",
      "lineno": 156,
      "end_lineno": 233,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 9,
      "loc": 78,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "3a4101d6ecee45f9c9061d1dbf7629998efccc52",
      "simhash64": 7488215207352120339,
      "normalized": "def NAME ( ) -> NAME [ NAME ] : LIT global NAME # Return cached data if already loaded if NAME is not None : NAME . NAME ( LIT ) return NAME # Check if GEDCOM path is configured NAME = None try : NAME = ( NAME . NAME . NAME if NAME else None ) except NAME as NAME : NAME . NAME ( NAME ( NAME ) ) raise NAME . NAME ( f\" GEDCOM_FILE_PATH from config: { NAME } \" ) if not NAME : raise NAME ( LIT ) # Convert string to Path object NAME = NAME ( NAME ) # Make sure the path is absolute if not NAME . NAME ( ) : # If it's a relative path, make it absolute relative to the project root NAME = NAME NAME = NAME ( NAME ) . NAME . NAME ( ) / NAME NAME . NAME ( f\" Converted relative path ' { NAME } ' to absolute path: { NAME } \" ) # Check if the file exists if not NAME . NAME ( ) : raise NAME ( f\" GEDCOM file not found at { NAME } \" ) # Try to load with aggressive caching first try : from NAME import NAME NAME . NAME ( LIT ) NAME = NAME ( NAME ( NAME ) ) except NAME : NAME . NAME ( LIT ) NAME = NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error with aggressive caching, falling back to standard: { NAME } \" ) NAME = NAME ( NAME ) if NAME : NAME . NAME ( LIT ) # Log cache statistics if available try : from NAME import NAME NAME = NAME ( ) NAME . NAME ( f\" GEDCOM cache info: { NAME } \" ) except NAME : pass else : NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "matches_criterion",
      "lineno": 236,
      "end_lineno": 248,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(key, criteria, value)",
      "fingerprint": "36a0748d20a12d17e9b512a47f172ed7e294bec0",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME : LIT if NAME not in NAME or NAME [ NAME ] is None : return False NAME = NAME [ NAME ] # Handle string values (case-insensitive contains) if NAME ( NAME , NAME ) and NAME ( NAME , NAME ) : return NAME . NAME ( ) in NAME . NAME ( ) # Handle exact matches for non-string values return NAME == NAME"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "matches_year_criterion",
      "lineno": 251,
      "end_lineno": 265,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(key, criteria, value, year_range)",
      "fingerprint": "f9290ecad63c30838a80ccb08f504754f8114ad8",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME : NAME ) -> NAME : LIT if NAME not in NAME or NAME [ NAME ] is None or NAME is None : return False NAME = NAME [ NAME ] # Handle exact match if NAME == NAME : return True # Handle range match return NAME ( NAME - NAME ) <= NAME"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "search_gedcom_for_criteria",
      "lineno": 268,
      "end_lineno": 451,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 24,
      "loc": 184,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:large"
      ],
      "signature": "(search_criteria, max_results, gedcom_data, gedcom_path)",
      "fingerprint": "4572add624751cdc3b10c1614ac5b29f354a41e7",
      "simhash64": 7488180022980023339,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME = LIT , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME [ NAME , NAME ] ] : LIT # Step 1: Ensure we have GEDCOM data if not NAME : # Try to use the cached GEDCOM data first if NAME is not None : NAME . NAME ( LIT ) NAME = NAME else : if not NAME : # Try to get path from config NAME = ( NAME ( NAME . NAME . NAME ) if NAME else NAME ( NAME ( NAME ) . NAME / LIT / LIT ) ) if not NAME or not NAME ( NAME ) . NAME ( ) : raise NAME ( f\" GEDCOM file not found at { NAME } \" ) # Load GEDCOM data NAME = NAME ( NAME ( NAME ( NAME ) ) ) if not NAME or not NAME ( NAME , LIT , None ) : raise NAME ( LIT ) # Step 2: Prepare scoring and filter criteria NAME = { } NAME = { } # Copy provided criteria to scoring criteria for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] : if NAME in NAME and NAME [ NAME ] is not None : NAME [ NAME ] = NAME [ NAME ] # Create filter criteria (subset of scoring criteria) for NAME in [ LIT , LIT , LIT , LIT , LIT ] : if NAME in NAME : NAME [ NAME ] = NAME [ NAME ] # Step 3: Get configuration values    if config_schema: NAME = NAME ( NAME . NAME ) NAME = NAME [ LIT ] NAME = ( NAME . NAME if NAME else NAME [ LIT ] [ LIT ] ) # Convert to dict format expected by calculate_match_score if NAME ( NAME , ( NAME , NAME ) ) : NAME = { LIT : NAME ( NAME ) } elif NAME ( NAME , NAME ) : NAME = NAME else : NAME = { LIT : LIT } # Handle both old and new date_flex formats if NAME ( NAME , ( NAME , NAME ) ) : # New config format - date_flex is a float/int representing years NAME = NAME ( NAME ) elif NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) else : NAME = LIT # Step 4: Filter and score individuals NAME = [ ] NAME = { } # Cache for score calculations # Process each individual in the GEDCOM data for NAME , NAME in NAME . NAME . NAME ( ) : try : # Extract needed values for filtering NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = ( NAME . NAME ( LIT , LIT ) . NAME ( ) if NAME . NAME ( LIT ) else None ) NAME = NAME . NAME ( LIT ) # Evaluate OR Filter NAME = NAME ( LIT , NAME , NAME ) NAME = NAME ( LIT , NAME , NAME ) NAME = NAME ( NAME . NAME ( LIT ) and NAME and NAME [ LIT ] == NAME ) NAME = NAME ( LIT , NAME , NAME ) NAME = NAME ( LIT , NAME , NAME , NAME ) NAME = NAME is None NAME = ( NAME or NAME or NAME or NAME or NAME or NAME ) if NAME : # Calculate match score NAME = NAME ( NAME . NAME ( NAME , NAME = True ) ) NAME = NAME ( NAME . NAME ( NAME ( NAME ) , NAME = True ) ) NAME = ( NAME , NAME ) if NAME not in NAME : NAME , NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) NAME [ NAME ] = ( NAME , NAME , NAME ) else : NAME , NAME , NAME = NAME [ NAME ] # Only include if score is above threshold if NAME > LIT : # Create a match record NAME = { LIT : NAME , LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME , LIT : NAME , LIT : NAME , LIT : LIT , } NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error processing individual { NAME } : { NAME } \" ) continue # Sort matches by score (highest first) NAME . NAME ( NAME = lambda NAME : NAME . NAME ( LIT , LIT ) , NAME = True ) # Return top matches (limited by max_results) return NAME [ : NAME ] if NAME else [ ]"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "get_gedcom_family_details",
      "lineno": 454,
      "end_lineno": 686,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 42,
      "loc": 233,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "purpose:getter",
        "size:large"
      ],
      "signature": "(individual_id, gedcom_data, gedcom_path)",
      "fingerprint": "48d678ea2b469c1f38d8b2f3a6daadfa2d8f505e",
      "simhash64": 7487617074167452715,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME , NAME ] : LIT # Step 1: Ensure we have GEDCOM data if not NAME : # Try to use the cached GEDCOM data first if NAME is not None : NAME . NAME ( LIT ) NAME = NAME else : if not NAME : # Try to get path from config NAME = ( NAME ( NAME . NAME . NAME ) if NAME else NAME ( NAME ( NAME ) . NAME / LIT / LIT ) ) if not NAME or not NAME ( NAME ) . NAME ( ) : raise NAME ( f\" GEDCOM file not found at { NAME } \" ) # Load GEDCOM data NAME = NAME ( NAME ( NAME ( NAME ) ) ) if not NAME : raise NAME ( LIT ) # Step 2: Get individual data from cache if not NAME ( NAME , LIT ) : raise NAME ( LIT ) # Normalize the individual ID NAME = NAME ( NAME ) if NAME is None : raise NAME ( f\" Invalid individual ID: { NAME } \" ) # Get individual data from cache NAME = NAME . NAME . NAME ( NAME , { } ) if not NAME : raise NAME ( f\" Individual { NAME } not found in GEDCOM data \" ) # Step 3: Extract basic information NAME = { LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : [ ] , } # Step 4: Get family relationships try : # Get parents NAME = ( NAME . NAME . NAME ( NAME , [ ] ) if NAME ( NAME , LIT ) else [ ] ) for NAME in NAME : if NAME is None : continue NAME = NAME . NAME . NAME ( NAME , { } ) if NAME : NAME = NAME . NAME ( LIT , LIT ) NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) NAME = { LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME , } NAME [ LIT ] . NAME ( NAME ) # Get siblings (share at least one parent) NAME = NAME ( ) for NAME in NAME : NAME = NAME . NAME . NAME ( NAME , [ ] ) for NAME in NAME : if NAME != NAME : NAME . NAME ( NAME ) for NAME in NAME : NAME = NAME . NAME . NAME ( NAME ) if NAME : NAME = { LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , } NAME [ LIT ] . NAME ( NAME ) # Get spouses and children # This requires looking at family records in the GEDCOM data if ( NAME ( NAME , LIT ) and NAME . NAME and NAME ( NAME , LIT ) and NAME . NAME ) : # Get the individual record NAME = NAME . NAME . NAME ( NAME ) if NAME : # Get family records where this individual is a spouse for NAME in NAME . NAME ( LIT ) : NAME = NAME . NAME NAME = None # Try to get family record using various methods (with error handling) try : if NAME ( NAME . NAME , LIT ) : NAME = NAME ( NAME . NAME , LIT , None ) if NAME : NAME = NAME . NAME ( NAME ) if not NAME and NAME ( NAME . NAME , LIT ) : NAME = NAME ( NAME . NAME , LIT , None ) if NAME : NAME = NAME ( NAME ) except NAME : NAME = None if NAME : # Get spouse NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = None if NAME and NAME . NAME != NAME : NAME = NAME ( NAME . NAME ) elif NAME and NAME . NAME != NAME : NAME = NAME ( NAME . NAME ) if NAME : NAME = NAME . NAME . NAME ( NAME ) if NAME : # Get marriage information NAME = LIT NAME = LIT NAME = NAME . NAME ( LIT ) if NAME : NAME = NAME . NAME ( LIT ) if NAME : NAME = NAME . NAME NAME = NAME . NAME ( LIT ) if NAME : NAME = NAME . NAME NAME = { LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME , LIT : NAME , } NAME [ LIT ] . NAME ( NAME ) # Get children for NAME in NAME . NAME ( LIT ) : NAME = NAME ( NAME . NAME ) if NAME is None : continue NAME = NAME . NAME . NAME ( NAME , { } ) if NAME : NAME = { LIT : NAME , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , } NAME [ LIT ] . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error getting family details for { NAME } : { NAME } \" , NAME = True ) return NAME"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "get_gedcom_relationship_path",
      "lineno": 689,
      "end_lineno": 781,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 15,
      "loc": 93,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(individual_id, reference_id, reference_name, gedcom_data, gedcom_path)",
      "fingerprint": "23bc9199ff2bd92a88a9960937484cabed5b9403",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = LIT , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , ) -> NAME : LIT # Step 1: Ensure we have GEDCOM data if not NAME : # Try to use the cached GEDCOM data first if NAME is not None : NAME . NAME ( LIT ) NAME = NAME else : if not NAME : # Try to get path from config NAME = ( NAME ( NAME . NAME . NAME ) if NAME else NAME ( NAME ( NAME ) . NAME / LIT / LIT ) ) if NAME and not NAME ( NAME ) . NAME ( ) : return f\" (GEDCOM file not found at { NAME } ) \" # Load GEDCOM data NAME = ( NAME ( NAME ( NAME ( NAME ) ) ) if NAME else None ) if not NAME : return LIT # Step 2: Normalize individual ID NAME = NAME ( NAME ) # Step 3: Get reference ID if not provided if not NAME : NAME = NAME . NAME if NAME else None if not NAME : return LIT NAME = NAME ( NAME ) # Step 4: Get individual name NAME = LIT if NAME and NAME in NAME . NAME : NAME = NAME . NAME [ NAME ] NAME = NAME . NAME ( LIT , LIT ) # Step 5: Get relationship path using fast_bidirectional_bfs if NAME and NAME : # Find the relationship path using the consolidated function NAME = NAME ( NAME , NAME , NAME . NAME , NAME . NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) else : NAME = [ ] if not NAME : return f\" (No relationship path found between { NAME } and { NAME } ) \" # Convert the GEDCOM path to the unified format NAME = NAME ( NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , ) # Format the relationship path return NAME ( NAME , NAME , NAME or LIT , None )"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "gedcom_search_module_tests",
      "lineno": 785,
      "end_lineno": 899,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 115,
      "tags": [
        "impure",
        "logging",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "f7ef4ffbcbd2a599f7602c7bd3c2ff4a531ecd11",
      "simhash64": 5127871611137332267,
      "normalized": "def NAME ( ) -> NAME : LIT with NAME ( ) : NAME = NAME ( LIT , LIT ) # Run all tests NAME ( LIT ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Generate summary report return NAME . NAME ( )"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 902,
      "end_lineno": 904,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "test_function_availability",
      "lineno": 908,
      "end_lineno": 916,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "eda28b47b29bf9e59416dc2dac6f3be9071055c5",
      "simhash64": 5143634171178423339,
      "normalized": "def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] from NAME import NAME NAME ( NAME , NAME ( ) , LIT )"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "test_criterion_matching",
      "lineno": 919,
      "end_lineno": 926,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "111a2da0aff6c4d8874249053492d76f055be3f4",
      "simhash64": 5145885970997351979,
      "normalized": "def NAME ( ) : LIT # Test basic criterion matching NAME = NAME ( LIT , { LIT : LIT } , LIT ) assert NAME ( NAME , NAME ) , LIT NAME = NAME ( LIT , { LIT : LIT } , LIT ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "test_year_criterion",
      "lineno": 929,
      "end_lineno": 936,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "913be3b75c95984325f8c0408be74e5ddbb96bc9",
      "simhash64": 5145885970993157675,
      "normalized": "def NAME ( ) : LIT # Test year range matching with required year_range parameter NAME = NAME ( LIT , { LIT : LIT } , LIT , LIT ) assert NAME ( NAME , NAME ) , LIT NAME = NAME ( LIT , { LIT : LIT } , LIT , LIT ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "test_gedcom_operations",
      "lineno": 939,
      "end_lineno": 946,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "ebd1faed912a8afd85a2fa467394f01292da2f8f",
      "simhash64": 8606374519042381371,
      "normalized": "def NAME ( ) : LIT # Test GEDCOM data caching NAME = { LIT : { } , LIT : { } } NAME ( NAME ) NAME = NAME ( ) assert NAME is not None , LIT"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "test_search_criteria",
      "lineno": 949,
      "end_lineno": 962,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "8d1824b1805111604494e911acebb59d26857c36",
      "simhash64": 8604685673485472811,
      "normalized": "def NAME ( ) : LIT # Test search criteria with multiple filters NAME = { LIT : LIT , LIT : LIT } # Test that search criteria can be processed if LIT in NAME ( ) : try : NAME = NAME ( NAME ) assert NAME ( NAME , ( NAME , NAME , NAME ( None ) ) ) , LIT except NAME : pass # Function may require specific data setup"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "test_family_details",
      "lineno": 965,
      "end_lineno": 975,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "0e6d2e1db16dcfbc25e0050b8627f4f9ab1d4242",
      "simhash64": 8641277420523918379,
      "normalized": "def NAME ( ) : LIT if LIT in NAME ( ) : try : # Test with a mock individual ID NAME = NAME ( LIT ) assert NAME is None or NAME ( NAME , ( NAME , NAME ) ) , LIT except NAME : pass # Function may require specific GEDCOM data"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "test_relationship_paths",
      "lineno": 978,
      "end_lineno": 988,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "347c75f960b154e319c315b991558405655fb1f4",
      "simhash64": 7487792965964699179,
      "normalized": "def NAME ( ) : LIT if LIT in NAME ( ) : try : # Test relationship path calculation NAME = NAME ( LIT , LIT ) assert NAME is None or NAME ( NAME , ( NAME , NAME ) ) , LIT except NAME : pass # Function may require specific GEDCOM data setup"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "test_invalid_data_handling",
      "lineno": 991,
      "end_lineno": 1005,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "629f2b674548681e032f9905fa6a8a1de49f1bd8",
      "simhash64": 7453417834366801455,
      "normalized": "def NAME ( ) : LIT # Test with invalid criterion data try : NAME = NAME ( LIT , { } , LIT ) assert NAME ( NAME , NAME ) , LIT except NAME : pass # Exception handling is acceptable # Test with invalid year data try : NAME = NAME ( LIT , { } , LIT , LIT ) assert NAME ( NAME , NAME ) , LIT except NAME : pass # Exception handling is acceptable"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "test_edge_cases",
      "lineno": 1008,
      "end_lineno": 1016,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "4487e85fa96a3fd3ec14588ebe6d5452341ec5f6",
      "simhash64": 7433714585997055019,
      "normalized": "def NAME ( ) : LIT # Test empty criterion NAME = NAME ( LIT , { } , LIT ) assert NAME ( NAME , NAME ) , LIT # Test empty criteria dict NAME = NAME ( LIT , { } , LIT ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "test_performance",
      "lineno": 1019,
      "end_lineno": 1029,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6e980a441eae397c2317543af885edb8170212dd",
      "simhash64": 7451729014570783807,
      "normalized": "def NAME ( ) : LIT import NAME # Test criterion matching performance NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( LIT , { LIT : LIT } , LIT ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Criterion matching should be fast, took { NAME : .3f } s \""
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "test_memory_efficiency",
      "lineno": 1032,
      "end_lineno": 1039,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "2a6ad5f333ce1b11df7635b7dbd2499c105fb7fe",
      "simhash64": 7455986323564173115,
      "normalized": "def NAME ( ) : LIT # Test that repeated operations don't accumulate excessive memory for NAME in NAME ( LIT ) : NAME ( LIT , { LIT : f\" value_ { NAME } \" } , f\" test_value_ { NAME } \" ) # If we get here without memory issues, test passes assert True , LIT"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "test_error_recovery",
      "lineno": 1042,
      "end_lineno": 1055,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6ce963f80697347be7d5feb72bbb15aea701ddb3",
      "simhash64": 9187338853860415023,
      "normalized": "def NAME ( ) : LIT # Test that functions handle errors gracefully try : # Attempt operations that might fail NAME ( LIT , { LIT : LIT } , LIT ) if LIT in NAME ( ) : NAME ( { LIT : LIT } ) except NAME : pass # Error handling is acceptable # Test should pass if no unhandled exceptions occur assert True , LIT"
    },
    {
      "module_path": "gedcom_search_utils.py",
      "qualname": "search_frances_milne_demo",
      "lineno": 1058,
      "end_lineno": 1136,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 14,
      "loc": 79,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "25e27083539de73a2c55cb6d24938f1d7f3b5d9b",
      "simhash64": 7451764198942872619,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) try : # Search for Frances Milne born 1947 NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } NAME ( f\" Searching for: { NAME } \" ) NAME ( LIT * LIT ) NAME = NAME ( NAME , NAME = LIT ) if NAME : NAME ( f\" Found { NAME ( NAME ) } potential matches:\\n \" ) for NAME , NAME in NAME ( NAME , LIT ) : NAME ( f\" { NAME } . ID: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" Name: { NAME . NAME ( LIT , LIT ) } { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" Birth Year: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" Birth Place: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" Gender: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" Death Year: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" Match Score: { NAME . NAME ( LIT , LIT ) } \" ) # Show detailed scoring for top match if NAME == LIT and NAME . NAME ( LIT ) : NAME ( f\" Field Scores: { NAME . NAME ( LIT , { } ) } \" ) NAME ( f\" Reasons: { NAME . NAME ( LIT , [ ] ) } \" ) NAME ( ) # Get family details for top matches if NAME <= LIT : NAME = NAME ( NAME [ LIT ] ) if NAME : NAME ( LIT ) if NAME . NAME ( LIT ) : NAME ( f\" - Parents: { NAME ( NAME [ LIT ] ) } \" ) if NAME . NAME ( LIT ) : NAME ( f\" - Spouses: { NAME ( NAME [ LIT ] ) } \" ) if NAME . NAME ( LIT ) : NAME ( f\" - Children: { NAME ( NAME [ LIT ] ) } \" ) if NAME . NAME ( LIT ) : NAME ( f\" - Siblings: { NAME ( NAME [ LIT ] ) } \" ) NAME ( ) else : NAME ( LIT ) NAME ( LIT ) # Try just name without birth year NAME = { LIT : LIT , LIT : LIT } NAME = NAME ( NAME , NAME = LIT ) if NAME : NAME ( f\" Found { NAME ( NAME ) } matches for just 'Frances Milne': \" ) for NAME , NAME in NAME ( NAME , LIT ) : NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" { NAME } . Frances Milne (b. { NAME } ) - Score: { NAME . NAME ( LIT , LIT ) } \" ) else : NAME ( LIT ) except NAME as NAME : NAME ( f\" Error during Frances Milne search: { NAME ! NAME } \" ) NAME . NAME ( f\" Frances Milne search error: { NAME } \" , NAME = True )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_is_individual",
      "lineno": 116,
      "end_lineno": 131,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(obj)",
      "fingerprint": "23346819aac12146f73d0c47d166421ab751c1d8",
      "simhash64": 5181914800229094443,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if NAME is None : return False # We can't use isinstance with Any, so we need to check for specific attributes # This is a heuristic approach to identify Individual objects return ( NAME ( NAME , LIT ) and NAME ( NAME , LIT ) and NAME ( NAME , LIT , LIT ) == NAME )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_is_record",
      "lineno": 134,
      "end_lineno": 145,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(obj)",
      "fingerprint": "df9619fcd94b08bd6d85dc140a6b748456c302ce",
      "simhash64": 5181914800228045867,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if NAME is None : return False # We can't use isinstance with Any, so we need to check for specific attributes # This is a heuristic approach to identify Record objects return NAME ( NAME , LIT ) and NAME ( NAME , LIT ) and NAME ( NAME , LIT )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_is_name_rec",
      "lineno": 148,
      "end_lineno": 163,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(obj)",
      "fingerprint": "57e0d22d2a8badd2f55e7a2e63c051714e4b9f3e",
      "simhash64": 5181914802376578091,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if NAME is None : return False # We can't use isinstance with Any, so we need to check for specific attributes # This is a heuristic approach to identify NameRec objects return ( NAME ( NAME , LIT ) and NAME ( NAME , LIT ) and NAME ( NAME , LIT , LIT ) == NAME )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_normalize_id",
      "lineno": 166,
      "end_lineno": 188,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 6,
      "loc": 23,
      "tags": [
        "pure-ish",
        "regex",
        "size:small"
      ],
      "signature": "(xref_id)",
      "fingerprint": "6f61b8e186a0d6ae8b9157beb8ca6df8f94e273a",
      "simhash64": 8622559367791023139,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME [ NAME ] : if not NAME or not NAME ( NAME , NAME ) : return None # Try to match standard GEDCOM ID format NAME = NAME . NAME ( LIT , NAME . NAME ( ) . NAME ( ) ) if NAME : return NAME . NAME ( LIT ) # Try fallback regex for partial GEDCOM IDs NAME = NAME . NAME ( LIT , NAME . NAME ( ) . NAME ( ) ) if NAME : NAME . NAME ( f\" Normalized ID ' { NAME . NAME ( LIT ) } ' using fallback regex from ' { NAME } '. \" ) return NAME . NAME ( LIT ) # For pure numeric strings, return as-is (handle raw numeric IDs) if NAME . NAME ( LIT , NAME . NAME ( ) ) : return NAME . NAME ( ) NAME . NAME ( f\" Could not normalize potential ID: ' { NAME } ' \" ) return None"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "extract_and_fix_id",
      "lineno": 191,
      "end_lineno": 206,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 7,
      "loc": 16,
      "tags": [
        "impure",
        "size:small"
      ],
      "signature": "(raw_id)",
      "fingerprint": "9c0e168f4490aca6b7543e401016c8bfab9fa10c",
      "simhash64": 7488180024055337987,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : if not NAME : return None NAME : NAME [ NAME ] = None if NAME ( NAME , NAME ) : NAME = NAME elif NAME ( NAME , NAME ) : NAME = NAME ( NAME ) elif NAME ( NAME , LIT ) and ( NAME ( NAME ) or NAME ( NAME ) ) : NAME = NAME ( NAME , LIT , None ) else : NAME . NAME ( f\" extract_and_fix_id: Invalid input type ' { NAME ( NAME ) . NAME } '. \" ) return None return NAME ( NAME )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_get_full_name",
      "lineno": 209,
      "end_lineno": 323,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 29,
      "loc": 115,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:large"
      ],
      "signature": "(indi)",
      "fingerprint": "631dd7c79941aee4913b96b1b73c233cdf828d58",
      "simhash64": 7488144839682724923,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if not NAME ( NAME ) : if NAME ( NAME , LIT ) and NAME ( NAME ( NAME , LIT , None ) ) : # Type ignore is needed because the type checker doesn't understand the dynamic nature # of this code. We've already checked that indi.value is a valid GedcomIndividualType NAME = NAME . NAME # type: ignore else : NAME . NAME ( f\" _get_full_name called with non-Individual type: { NAME ( NAME ) } \" ) return LIT # At this point, indi should be a valid GedcomIndividualType # But we'll still add null checks to be safe if NAME is None : return LIT NAME = NAME ( NAME ) or LIT NAME = None NAME = LIT try : # --- Attempt 1: Use indi.name if it has .format --- if NAME ( NAME , LIT ) : NAME = NAME . NAME if NAME and NAME ( NAME , LIT ) and NAME ( NAME . NAME ) : try : NAME = NAME . NAME ( ) NAME = LIT NAME . NAME ( f\" Name for { NAME } from { NAME } : ' { NAME } ' \" ) except NAME as NAME : NAME . NAME ( f\" Error calling indi.name.format() for { NAME } : { NAME } \" ) NAME = None # Reset on error # --- Attempt 2: Use indi.sub_tag(TAG_NAME) if Attempt 1 failed and it has .format --- if NAME is None and NAME ( NAME , LIT ) : NAME = NAME . NAME ( NAME ) if ( NAME and NAME ( NAME , LIT ) and NAME ( NAME ( NAME , LIT , None ) ) ) : try : # Type ignore is needed because the type checker doesn't know about format NAME = NAME . NAME ( ) # type: ignore NAME = LIT NAME . NAME ( f\" Name for { NAME } from { NAME } : ' { NAME } ' \" ) except NAME as NAME : NAME . NAME ( f\" Error calling indi.sub_tag(TAG_NAME).format() for { NAME } : { NAME } \" ) NAME = None # --- Attempt 3: Manually combine GIVN and SURN if formatting failed --- if NAME is None and NAME ( NAME , LIT ) : NAME = NAME . NAME ( NAME ) # Get tag again or reuse from above if needed if NAME : # Check if NAME tag exists NAME = ( NAME . NAME ( NAME ) if NAME ( NAME , LIT ) else None ) NAME = ( NAME . NAME ( NAME ) if NAME ( NAME , LIT ) else None ) # Combine, prioritizing surname placement if NAME and NAME : NAME = f\" { NAME } { NAME } \" elif NAME : NAME = NAME elif NAME : NAME = NAME # Or potentially format as /SURN/? NAME = LIT NAME . NAME ( f\" Name for { NAME } from { NAME } : ' { NAME } ' \" ) # --- Attempt 4: Use indi.sub_tag_value(TAG_NAME) as last resort --- if NAME is None and NAME ( NAME , LIT ) : NAME = NAME . NAME ( NAME ) if NAME ( NAME , NAME ) and NAME . NAME ( ) and NAME != LIT : NAME = NAME NAME = LIT NAME . NAME ( f\" Name for { NAME } from { NAME } : ' { NAME } ' \" ) # --- Final Cleaning and Return --- if NAME : # Apply utils.format_name for styling NAME = NAME ( NAME ) return ( NAME if NAME and NAME != LIT else f\" Unknown ( { NAME } Error) \" ) return LIT except NAME as NAME : NAME . NAME ( f\" Unexpected error in _get_full_name for @ { NAME } @: { NAME } \" , NAME = True , ) return LIT"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_parse_date",
      "lineno": 326,
      "end_lineno": 463,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 10,
      "yield_count": 0,
      "complexity": 28,
      "loc": 138,
      "tags": [
        "pure-ish",
        "time",
        "regex",
        "size:large"
      ],
      "signature": "(date_str)",
      "fingerprint": "4578233b6366b977f01133a0f4b451ff43539190",
      "simhash64": 7487617074100343827,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME [ NAME ] : LIT if not NAME or not NAME ( NAME , NAME ) : return None NAME = NAME NAME . NAME ( f\" Attempting to parse date: ' { NAME } ' \" ) if NAME . NAME ( LIT ) and NAME . NAME ( LIT ) : NAME = NAME [ LIT : - LIT ] . NAME ( ) if not NAME : NAME . NAME ( LIT ) return None NAME = NAME . NAME ( ) . NAME ( ) if NAME . NAME ( LIT , NAME ) : NAME . NAME ( f\" Identified non-parseable string: ' { NAME } ' -> ' { NAME } ' \" ) return None if NAME . NAME ( LIT , NAME ) or NAME . NAME ( LIT , NAME ) : NAME . NAME ( f\" Ignoring date string without year: ' { NAME } ' -> ' { NAME } ' \" ) return None NAME = LIT NAME = NAME NAME = - LIT while NAME ( NAME ) != NAME : NAME = NAME ( NAME ) NAME = NAME . NAME ( NAME , LIT , NAME , NAME = NAME . NAME ) . NAME ( ) NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) NAME = NAME . NAME ( LIT , NAME , NAME = LIT ) [ LIT ] . NAME ( ) # CORRECTED SPLIT NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME = NAME . NAME ( LIT ) NAME . NAME ( f\" Treated as year range, using first year: ' { NAME } ' \" ) NAME = LIT NAME = NAME . NAME ( NAME , LIT , NAME , NAME = LIT ) . NAME ( ) NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) if NAME . NAME ( LIT , NAME ) : NAME . NAME ( f\" Treating year 0000 pattern as invalid: ' { NAME } ' -> ' { NAME } ' \" ) return None NAME = NAME . NAME ( LIT , LIT , NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) if not NAME : NAME . NAME ( f\" Date string empty after cleaning: ' { NAME } ' \" ) return None NAME . NAME ( f\" Cleaned date string for parsing: ' { NAME } ' \" ) NAME = None if NAME : try : # Use settings that dateparser accepts # The type checker doesn't understand that dateparser.parse accepts a dict NAME = { LIT : LIT , LIT : [ LIT ] } NAME = NAME . NAME ( NAME , NAME = NAME ) # type: ignore if NAME : NAME . NAME ( f\" dateparser succeeded for ' { NAME } ' \" ) else : NAME . NAME ( f\" dateparser returned None for ' { NAME } ', trying strptime... \" ) except NAME as NAME : NAME . NAME ( f\" Error using dateparser for ' { NAME } ' (cleaned: ' { NAME } '): { NAME } \" , NAME = False , ) if not NAME : NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : try : if NAME == LIT and not NAME . NAME ( LIT , NAME ) : continue NAME = NAME . NAME ( NAME , NAME ) NAME . NAME ( f\" Parsed ' { NAME } ' using strptime format ' { NAME } ' \" ) NAME = NAME break except NAME : continue except NAME as NAME : NAME . NAME ( f\" Strptime error for format ' { NAME } ': { NAME } \" ) continue if not NAME : NAME . NAME ( f\" Full parsing failed for ' { NAME } ', attempting year extraction. \" ) NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME = NAME . NAME ( LIT ) try : # <<< START OF TRY BLOCK FOR YEAR EXTRACTION >>> NAME = NAME ( NAME ) if LIT <= NAME <= NAME . NAME ( ) . NAME + LIT : NAME . NAME ( f\" Extracted year { NAME } as fallback. \" ) NAME = NAME ( NAME , LIT , LIT ) else : NAME . NAME ( f\" Extracted year { NAME } out of plausible range. \" ) except NAME : # <<< CORRECTED except BLOCK >>> NAME . NAME ( f\" Could not convert extracted year ' { NAME } ' to int. \" ) # <<< END except BLOCK >>> if NAME ( NAME , NAME ) : if NAME . NAME == LIT : NAME . NAME ( f\" Parsed date resulted in year 0, treating as invalid: ' { NAME } ' -> { NAME } \" ) return None if NAME . NAME is None : return NAME . NAME ( NAME = NAME . NAME ) return NAME . NAME ( NAME . NAME ) NAME . NAME ( f\" All parsing attempts failed for: ' { NAME } ' -> cleaned: ' { NAME } ' \" ) return None"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_clean_display_date",
      "lineno": 466,
      "end_lineno": 483,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 18,
      "tags": [
        "pure-ish",
        "regex",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(raw_date_str)",
      "fingerprint": "aaae24c4f2222dd7e4a95bbc75bcabec0b088c2c",
      "simhash64": 7488180022980023299,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME : # ... implementation ... if not NAME or not NAME ( NAME , NAME ) or NAME == LIT : return LIT NAME = NAME . NAME ( ) if NAME . NAME ( LIT ) and NAME . NAME ( LIT ) : NAME = NAME [ LIT : - LIT ] . NAME ( ) NAME = NAME if NAME else LIT NAME = NAME . NAME ( LIT , LIT , NAME , NAME = NAME . NAME ) NAME = NAME . NAME ( LIT , LIT , NAME , NAME = NAME . NAME ) NAME = NAME . NAME ( LIT , LIT , NAME , NAME = NAME . NAME ) NAME = NAME . NAME ( LIT , LIT , NAME , NAME = NAME . NAME ) NAME = NAME . NAME ( LIT , LIT , NAME , NAME = NAME . NAME ) NAME = NAME . NAME ( LIT , LIT , NAME , NAME = NAME . NAME ) NAME = NAME . NAME ( LIT , LIT , NAME , NAME = NAME . NAME ) . NAME ( ) NAME = NAME . NAME ( LIT , LIT , NAME , NAME = NAME . NAME ) . NAME ( ) NAME = NAME . NAME ( LIT , LIT , NAME , NAME = NAME . NAME ) NAME = NAME . NAME ( LIT , LIT , NAME , NAME = NAME . NAME ) . NAME ( ) return NAME if NAME else LIT"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_get_event_info",
      "lineno": 486,
      "end_lineno": 547,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 16,
      "loc": 62,
      "tags": [
        "impure",
        "time",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(individual, event_tag)",
      "fingerprint": "4dcf9471c2047664ee689808f2c67e8e05be719f",
      "simhash64": 7488109654236894235,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME ] , NAME , NAME ] : # ... implementation ... NAME : NAME [ NAME ] = None NAME : NAME = LIT NAME : NAME = LIT if not NAME ( NAME ) : if NAME ( NAME , LIT ) and NAME ( NAME ( NAME , LIT , None ) ) : # Type ignore is needed because the type checker doesn't understand the dynamic nature # of this code. We've already checked that individual.value is a valid GedcomIndividualType NAME = NAME . NAME # type: ignore else : NAME . NAME ( f\" _get_event_info invalid input type: { NAME ( NAME ) } \" ) return NAME , NAME , NAME # At this point, individual should be a valid GedcomIndividualType # But we'll still add null checks to be safe if NAME is None : return NAME , NAME , NAME NAME = NAME ( NAME ) or LIT try : # Add null check before calling sub_tag if not NAME ( NAME , LIT ) : NAME . NAME ( f\" Individual { NAME } has no sub_tag method \" ) return NAME , NAME , NAME NAME = NAME . NAME ( NAME . NAME ( ) ) if not NAME : return NAME , NAME , NAME # Add null check before calling sub_tag on event_record if not NAME ( NAME , LIT ) : NAME . NAME ( f\" Event record for { NAME } has no sub_tag method \" ) return NAME , NAME , NAME NAME = NAME . NAME ( NAME ) NAME = NAME ( NAME , LIT , None ) if NAME else None if NAME ( NAME , NAME ) and NAME . NAME ( ) : NAME = NAME . NAME ( ) NAME = NAME ( NAME ) elif NAME is not None : NAME = NAME ( NAME ) NAME = NAME ( NAME ) NAME = NAME . NAME ( NAME ) NAME = NAME ( NAME , LIT , None ) if NAME else None if NAME ( NAME , NAME ) and NAME . NAME ( ) : NAME = NAME . NAME ( ) elif NAME is not None : NAME = NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Attribute error getting event ' { NAME } ' for { NAME } : { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Error accessing event { NAME } for @ { NAME } @: { NAME } \" , NAME = True ) return NAME , NAME , NAME"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "format_life_dates",
      "lineno": 550,
      "end_lineno": 563,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(indi)",
      "fingerprint": "7d4d42cbafba0ec6e9f78aecbb6afbaa73222d34",
      "simhash64": 7488109654235845659,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : # ... implementation ... if not NAME ( NAME ) : NAME . NAME ( f\" format_life_dates called with non-Individual type: { NAME ( NAME ) } \" ) return LIT NAME , NAME , NAME = NAME ( NAME , NAME ) NAME , NAME , NAME = NAME ( NAME , NAME ) NAME = NAME ( NAME ) NAME = NAME ( NAME ) NAME = f\" b. { NAME } \" if NAME != LIT else LIT NAME = f\" d. { NAME } \" if NAME != LIT else LIT NAME = [ NAME for NAME in [ NAME , NAME ] if NAME ] return f\" ( { LIT . NAME ( NAME ) } ) \" if NAME else LIT"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "format_full_life_details",
      "lineno": 566,
      "end_lineno": 584,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(indi)",
      "fingerprint": "4d0bb952069c250d46cd39404f9423edc1b1a3c4",
      "simhash64": 7488250391724200987,
      "normalized": "def NAME ( NAME : NAME , ) -> NAME [ NAME , NAME ] : # ... implementation ... if not NAME ( NAME ) : NAME . NAME ( f\" format_full_life_details called with non-Individual type: { NAME ( NAME ) } \" ) return LIT , LIT NAME , NAME , NAME = NAME ( NAME , NAME ) NAME = NAME ( NAME ) NAME = NAME if NAME != LIT else LIT NAME = f\" Born: { NAME if NAME != LIT else LIT } in { NAME } \" NAME , NAME , NAME = NAME ( NAME , NAME ) NAME = NAME ( NAME ) NAME = NAME if NAME != LIT else LIT NAME = LIT if NAME != LIT or NAME != LIT : NAME = f\" Died: { NAME if NAME != LIT else LIT } in { NAME } \" return NAME , NAME"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "format_relative_info",
      "lineno": 587,
      "end_lineno": 604,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 7,
      "loc": 18,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(relative)",
      "fingerprint": "d33c3b23663b0f9287974ed79581fe0262e3fb66",
      "simhash64": 7488215208426902555,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : # ... implementation ... NAME : NAME [ NAME ] = None if NAME ( NAME ) : NAME = NAME elif NAME ( NAME , LIT ) and NAME ( NAME ( NAME , LIT , None ) ) : NAME = NAME . NAME elif NAME ( NAME , LIT ) and NAME ( NAME ( NAME , LIT , None ) , NAME ) : NAME = NAME ( NAME ) return f\" - (Relative Data: ID= { NAME or LIT } , Type= { NAME ( NAME ) . NAME } ) \" else : return f\" - (Invalid Relative Data: Type= { NAME ( NAME ) . NAME } ) \" NAME = NAME ( NAME ) NAME = NAME ( NAME ) return f\" - { NAME } { NAME } \""
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_reconstruct_path",
      "lineno": 607,
      "end_lineno": 695,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 14,
      "loc": 89,
      "tags": [
        "impure",
        "filesystem",
        "size:medium"
      ],
      "signature": "(start_id, end_id, meeting_id, visited_fwd, visited_bwd)",
      "fingerprint": "b588777d1adabc717c6f0606a30049d8be022e6d",
      "simhash64": 7452080857216889939,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] , # {node: predecessor_from_start} NAME : NAME [ NAME , NAME [ NAME ] ] , # {node: predecessor_from_end} ) -> NAME [ NAME ] : LIT # Standard path reconstruction NAME : NAME [ NAME ] = [ ] # Trace back from meeting point to start_id NAME = NAME while NAME is not None : NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) NAME . NAME ( ) # Now path is start_id -> ... -> meeting_id # Trace back from meeting point to end_id (but skip meeting_id itself) NAME = NAME . NAME ( NAME ) # Start from predecessor of meeting_id in backward search NAME : NAME [ NAME ] = [ ] while NAME is not None : NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) # path_end is now [predecessor_of_meeting, ..., end_id] - needs reversing NAME . NAME ( ) # Combine the two parts NAME = NAME + NAME # Basic validation if not NAME : NAME . NAME ( f\" Path reconstruction failed - empty path! Start: { NAME } , End: { NAME } , Meet: { NAME } \" ) return [ ] # Check if start_id is in the path if NAME [ LIT ] != NAME : NAME . NAME ( f\" Path reconstruction issue - start ID not at beginning. Start: { NAME } , First in path: { NAME [ LIT ] } \" ) # Try to fix by ensuring start_id is at the beginning if NAME in NAME : # Remove everything before start_id NAME = NAME . NAME ( NAME ) NAME = NAME [ NAME : ] else : # Prepend start_id if not in path NAME = [ NAME , * NAME ] # Check if end_id is in the path if NAME [ - LIT ] != NAME : NAME . NAME ( f\" Path reconstruction issue - end ID not at end. End: { NAME } , Last in path: { NAME [ - LIT ] } \" ) # Try to fix by ensuring end_id is at the end if NAME in NAME : # Remove everything after end_id NAME = NAME . NAME ( NAME ) NAME = NAME [ : NAME + LIT ] else : # Append end_id if not in path NAME . NAME ( NAME ) # Final validation if NAME [ LIT ] != NAME or NAME [ - LIT ] != NAME : NAME . NAME ( f\" Path reconstruction failed after correction attempts! Start: { NAME } , End: { NAME } , Meet: { NAME } , Result: { NAME } \" ) # Attempt manual reconstruction if possible (simple cases) if NAME == NAME and NAME and NAME [ LIT ] == NAME : return NAME # FWD search found END directly if NAME == NAME and NAME and NAME [ - LIT ] == NAME : return [ NAME , * NAME ] # BWD search found START directly # Last resort: create a direct path if all else fails NAME . NAME ( f\" Creating direct path from { NAME } to { NAME } as last resort \" ) return [ NAME , NAME ] NAME . NAME ( f\" _reconstruct_path: Final reconstructed path IDs: { NAME } \" ) return NAME"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_validate_bfs_inputs",
      "lineno": 698,
      "end_lineno": 708,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(start_id, end_id, id_to_parents, id_to_children)",
      "fingerprint": "06dfc86bc4829edbaf52b08b6efd700c6a4a3695",
      "simhash64": 7488171226887001091,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT if NAME == NAME : return True if NAME is None or NAME is None : NAME . NAME ( LIT ) return False if not NAME or not NAME : NAME . NAME ( LIT ) return False return True"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_initialize_bfs_queues",
      "lineno": 711,
      "end_lineno": 723,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(start_id, end_id)",
      "fingerprint": "586fe70dda01f838541bd47d5fcc9c2a73d669c9",
      "simhash64": 5146308183462941735,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT # Initialize BFS queues and visited sets # Forward queue from start_id NAME = NAME ( [ ( NAME , LIT , [ NAME ] ) ] ) # (id, depth, path) # Backward queue from end_id NAME = NAME ( [ ( NAME , LIT , [ NAME ] ) ] ) # (id, depth, path) # Track visited nodes and their paths NAME = { NAME : ( LIT , [ NAME ] ) } # {id: (depth, path)} NAME = { NAME : ( LIT , [ NAME ] ) } # {id: (depth, path)} return NAME , NAME , NAME , NAME"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_expand_forward_node",
      "lineno": 726,
      "end_lineno": 755,
      "is_method": false,
      "is_async": false,
      "args_count": 8,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 10,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(current_id, depth, path, visited_fwd, queue_fwd, id_to_parents, id_to_children, max_depth)",
      "fingerprint": "5060f9056dc9e50a07e0a0145495c6e6e3790f32",
      "simhash64": 7488180022980023347,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) : LIT # Stop expanding if we've reached max depth if NAME >= NAME : return # Expand to parents (direct relationship) for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME not in NAME : NAME = [ * NAME , NAME ] NAME [ NAME ] = ( NAME + LIT , NAME ) NAME . NAME ( ( NAME , NAME + LIT , NAME ) ) # Expand to children (direct relationship) for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME not in NAME : NAME = [ * NAME , NAME ] NAME [ NAME ] = ( NAME + LIT , NAME ) NAME . NAME ( ( NAME , NAME + LIT , NAME ) ) # Expand to siblings (through parent) for NAME in NAME . NAME ( NAME , NAME ( ) ) : for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME != NAME and NAME not in NAME : # Include parent in path for proper relationship context NAME = [ * NAME , NAME , NAME ] NAME [ NAME ] = ( NAME + LIT , NAME ) NAME . NAME ( ( NAME , NAME + LIT , NAME ) )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_expand_backward_node",
      "lineno": 758,
      "end_lineno": 787,
      "is_method": false,
      "is_async": false,
      "args_count": 8,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 10,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(current_id, depth, path, visited_bwd, queue_bwd, id_to_parents, id_to_children, max_depth)",
      "fingerprint": "53a4e8a71d16c9e583520735b0dbc54d3586f44e",
      "simhash64": 7488180022980023347,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) : LIT # Stop expanding if we've reached max depth if NAME >= NAME : return # Expand to parents (direct relationship) for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME not in NAME : NAME = [ NAME , * NAME ] NAME [ NAME ] = ( NAME + LIT , NAME ) NAME . NAME ( ( NAME , NAME + LIT , NAME ) ) # Expand to children (direct relationship) for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME not in NAME : NAME = [ NAME , * NAME ] NAME [ NAME ] = ( NAME + LIT , NAME ) NAME . NAME ( ( NAME , NAME + LIT , NAME ) ) # Expand to siblings (through parent) for NAME in NAME . NAME ( NAME , NAME ( ) ) : for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME != NAME and NAME not in NAME : # Include parent in path for proper relationship context NAME = [ NAME , NAME , * NAME ] NAME [ NAME ] = ( NAME + LIT , NAME ) NAME . NAME ( ( NAME , NAME + LIT , NAME ) )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "fast_bidirectional_bfs",
      "lineno": 790,
      "end_lineno": 888,
      "is_method": false,
      "is_async": false,
      "args_count": 8,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 12,
      "loc": 99,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(start_id, end_id, id_to_parents, id_to_children, max_depth, node_limit, timeout_sec, log_progress)",
      "fingerprint": "65dd269f840603fddc35fef8292d563b84a6aafd",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = False , ) -> NAME [ NAME ] : LIT NAME = NAME . NAME ( ) # Validate inputs if not NAME ( NAME , NAME , NAME , NAME ) : return [ ] if NAME == NAME : return [ NAME ] # First try to find a direct relationship (parent, child, sibling) # This is a quick check before running the full BFS NAME = NAME ( NAME , NAME , NAME , NAME ) if NAME : NAME . NAME ( f\" [FastBiBFS] Found direct relationship: { NAME } \" ) return NAME # Initialize BFS data structures NAME , NAME , NAME , NAME = NAME ( NAME , NAME ) # Track all complete paths found NAME = [ ] NAME = LIT NAME . NAME ( f\" [FastBiBFS] Starting BFS: { NAME } <-> { NAME } \" ) # Main search loop - continue until we find paths or exhaust the search while NAME and NAME and NAME ( NAME ) < LIT : # Check timeout and node limit if NAME . NAME ( ) - NAME > NAME : NAME . NAME ( f\" [FastBiBFS] Timeout after { NAME : .1f } seconds. \" ) break if NAME > NAME : NAME . NAME ( f\" [FastBiBFS] Node limit ( { NAME } ) reached. \" ) break # Process forward queue (from start) if NAME : NAME , NAME , NAME = NAME . NAME ( ) NAME += LIT # Check if we've reached a node visited by backward search if NAME in NAME : # Found a meeting point - reconstruct the path NAME , NAME = NAME [ NAME ] # Combine paths (remove duplicate meeting point) NAME = NAME + NAME [ LIT : ] NAME . NAME ( NAME ) NAME . NAME ( f\" [FastBiBFS] Path found via { NAME } : { NAME ( NAME ) } nodes \" ) continue # Expand this node in forward direction NAME ( NAME , NAME , NAME , NAME , NAME , NAME , NAME , NAME ) # Process backward queue (from end) if NAME : NAME , NAME , NAME = NAME . NAME ( ) NAME += LIT # Check if we've reached a node visited by forward search if NAME in NAME : # Found a meeting point - reconstruct the path NAME , NAME = NAME [ NAME ] # Combine paths (remove duplicate meeting point) NAME = NAME + NAME [ LIT : ] NAME . NAME ( NAME ) NAME . NAME ( f\" [FastBiBFS] Path found via { NAME } : { NAME ( NAME ) } nodes \" ) continue # Expand this node in backward direction NAME ( NAME , NAME , NAME , NAME , NAME , NAME , NAME , NAME ) # Select the best path from found paths return NAME ( NAME , NAME , NAME , NAME , NAME )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_select_best_path",
      "lineno": 891,
      "end_lineno": 930,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 40,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(all_paths, start_id, end_id, id_to_parents, id_to_children)",
      "fingerprint": "8660d4af5885c84a301fb1b5b1dcf88970b429a0",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME ] ] , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME ] : LIT # If we found paths, select the best one if NAME : # Score paths based on directness of relationships NAME = [ ] for NAME in NAME : # Check if each adjacent pair has a direct relationship NAME = LIT for NAME in NAME ( NAME ( NAME ) - LIT ) : if NAME ( NAME [ NAME ] , NAME [ NAME + LIT ] , NAME , NAME ) : NAME += LIT # Calculate score: prefer paths with more direct relationships and shorter length NAME = ( NAME / ( NAME ( NAME ) - LIT ) if NAME ( NAME ) > LIT else LIT ) NAME = NAME ( NAME ) / LIT # Slight penalty for longer paths NAME = NAME - NAME NAME . NAME ( ( NAME , NAME ) ) # Sort by score (highest first) NAME . NAME ( NAME = lambda NAME : NAME [ LIT ] , NAME = True ) # Return the path with the highest score NAME = NAME [ LIT ] [ LIT ] NAME . NAME ( f\" [FastBiBFS] Selected best path: { NAME ( NAME ) } nodes with score { NAME [ LIT ] [ LIT ] : .2f } \" ) return NAME # If we didn't find any paths, try a more aggressive search NAME . NAME ( f\" [FastBiBFS] No paths found between { NAME } and { NAME } . \" ) # Fallback: Try a direct path if possible return [ NAME , NAME ]"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_has_direct_relationship",
      "lineno": 933,
      "end_lineno": 970,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 8,
      "loc": 38,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(id1, id2, id_to_parents, id_to_children)",
      "fingerprint": "46e5a8af5d4f65d390a071ebc8a580a88a5b91d7",
      "simhash64": 7488180022980019251,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME [ NAME ] ] , ) -> NAME : LIT # Parent-child relationship if NAME in NAME . NAME ( NAME , NAME ( ) ) or NAME in NAME . NAME ( NAME , NAME ( ) ) : return True # Sibling relationship (share at least one parent) NAME = NAME . NAME ( NAME , NAME ( ) ) NAME = NAME . NAME ( NAME , NAME ( ) ) if NAME and NAME and not NAME . NAME ( NAME ) : return True # Check for grandparent relationship for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME in NAME . NAME ( NAME , NAME ( ) ) : return True # Check for grandchild relationship return NAME ( NAME in NAME . NAME ( NAME , NAME ( ) ) for NAME in NAME . NAME ( NAME , NAME ( ) ) )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_find_direct_relationship",
      "lineno": 973,
      "end_lineno": 1009,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 37,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(id1, id2, id_to_parents, id_to_children)",
      "fingerprint": "8d7d979f1b84d7acf20735bc6a1860b77c133d6e",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME [ NAME ] ] , ) -> NAME [ NAME ] : LIT # Check if id2 is a parent of id1 if NAME in NAME . NAME ( NAME , NAME ( ) ) : return [ NAME , NAME ] # Check if id2 is a child of id1 if NAME in NAME . NAME ( NAME , NAME ( ) ) : return [ NAME , NAME ] # Check if id1 and id2 are siblings (share at least one parent) NAME = NAME . NAME ( NAME , NAME ( ) ) NAME = NAME . NAME ( NAME , NAME ( ) ) NAME = NAME . NAME ( NAME ) if NAME : # Use the first common parent NAME = NAME ( NAME ( NAME ) ) return [ NAME , NAME , NAME ] # No direct relationship found return [ ]"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_are_directly_related",
      "lineno": 1012,
      "end_lineno": 1037,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(id1, id2, id_to_parents, id_to_children)",
      "fingerprint": "2dce84bff68715e2fe69351d6c3db7e96e09a112",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME [ NAME ] ] , ) -> NAME : LIT # Parent-child relationship if NAME in NAME . NAME ( NAME , NAME ( ) ) or NAME in NAME . NAME ( NAME , NAME ( ) ) : return True # Sibling relationship (share at least one parent) NAME = NAME . NAME ( NAME , NAME ( ) ) NAME = NAME . NAME ( NAME , NAME ( ) ) return NAME ( NAME and NAME and not NAME . NAME ( NAME ) )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "explain_relationship_path",
      "lineno": 1040,
      "end_lineno": 1241,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 26,
      "loc": 202,
      "tags": [
        "pure-ish",
        "size:large"
      ],
      "signature": "(path_ids, reader, id_to_parents, id_to_children, indi_index)",
      "fingerprint": "6fbda0c9116a7a481b48908eabe98fddc0c664fd",
      "simhash64": 7488180022981072411,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME ] , ) -> NAME : LIT if not NAME or NAME ( NAME ) < LIT : return LIT if NAME is None or NAME is None or NAME is None : return LIT NAME : NAME [ NAME ] = [ ] NAME = NAME . NAME ( NAME [ LIT ] ) # Get birth year for the first person NAME = LIT if NAME : NAME , NAME , NAME = NAME ( NAME , NAME ) if NAME : NAME = f\" (b. { NAME . NAME } ) \" NAME = ( NAME ( NAME ) if NAME else f\" Unknown ( { NAME [ LIT ] } ) \" ) # Start with the first person's name with birth year NAME = f\" { NAME } { NAME } \" # Process each pair of individuals in the path for NAME in NAME ( NAME ( NAME ) - LIT ) : NAME , NAME = NAME [ NAME ] , NAME [ NAME + LIT ] NAME = NAME . NAME ( NAME ) # Person A object (previous step) NAME = NAME . NAME ( NAME ) # Person B object (current step in explanation) # Skip if either individual is missing if not NAME or not NAME : if not NAME : NAME . NAME ( f\" -> connected to Unknown Person ( { NAME } ) \" ) else : NAME = NAME ( NAME ) NAME = LIT NAME , NAME , NAME = NAME ( NAME , NAME ) if NAME : NAME = f\" (b. { NAME . NAME } ) \" NAME . NAME ( f\" -> connected to { NAME } { NAME } \" ) continue # Get name and birth year for person B NAME = NAME ( NAME ) NAME = LIT NAME , NAME , NAME = NAME ( NAME , NAME ) if NAME : NAME = f\" (b. { NAME . NAME } ) \" # Determine gender of person B for labels like son/daughter etc. NAME = NAME ( NAME , NAME . NAME ( ) , None ) NAME = ( NAME ( NAME ) . NAME ( ) [ LIT ] if NAME and NAME ( NAME , NAME ) and NAME ( NAME ) . NAME ( ) in ( LIT , LIT ) else None ) # Determine the relationship between A and B NAME = None # Check 1: Is B a PARENT of A? if NAME in NAME . NAME ( NAME , NAME ( ) ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) NAME = f\" whose { NAME } is { NAME } { NAME } \" # Check 2: Is B a CHILD of A? elif NAME in NAME . NAME ( NAME , NAME ( ) ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) NAME = f\" whose { NAME } is { NAME } { NAME } \" # Check 3: Is B a SIBLING of A? (Share at least one parent) elif NAME ( NAME , NAME , NAME ) : # Get the sibling label based on gender NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) NAME = f\" whose { NAME } is { NAME } { NAME } \" # Check 4: Is B a SPOUSE of A? elif NAME ( NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) NAME = f\" whose { NAME } is { NAME } { NAME } \" # Check 5: Is B an AUNT/UNCLE of A? (Sibling of parent) elif NAME ( NAME , NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) NAME = ( f\" whose { NAME } is { NAME } { NAME } \" ) # Check 6: Is B a NIECE/NEPHEW of A? (Child of sibling) elif NAME ( NAME , NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) NAME = ( f\" whose { NAME } is { NAME } { NAME } \" ) # Check 7: Is B a COUSIN of A? (Child of aunt/uncle) elif NAME ( NAME , NAME , NAME , NAME ) : NAME = f\" whose cousin is { NAME } { NAME } \" # Check 8: Is B a GRANDPARENT of A? elif NAME ( NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) NAME = ( f\" whose { NAME } is { NAME } { NAME } \" ) # Check 9: Is B a GRANDCHILD of A? elif NAME ( NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) NAME = ( f\" whose { NAME } is { NAME } { NAME } \" ) # Fallback for unknown relationships - try to determine a more specific relationship if NAME is None : # Check for great-grandparent relationship if NAME ( NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else ( LIT if NAME == LIT else LIT ) ) NAME = ( f\" whose { NAME } is { NAME } { NAME } \" ) # Check for great-grandchild relationship elif NAME ( NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else ( LIT if NAME == LIT else LIT ) ) NAME = ( f\" whose { NAME } is { NAME } { NAME } \" ) # If still no relationship found, use a generic description based on position in path else : # For adjacent nodes, use \"related to\" instead of \"connected to\" NAME = f\" related to { NAME } { NAME } \" NAME . NAME ( f\" -> { NAME } \" ) # Join the start name and all the steps return NAME + LIT + LIT . NAME ( NAME )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_are_siblings",
      "lineno": 1244,
      "end_lineno": 1248,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(id1, id2, id_to_parents)",
      "fingerprint": "d35a742210a266aff0a97e4799d0b95ee24f6fa6",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] ) -> NAME : LIT NAME = NAME . NAME ( NAME , NAME ( ) ) NAME = NAME . NAME ( NAME , NAME ( ) ) return NAME ( NAME and NAME and not NAME . NAME ( NAME ) )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_are_spouses",
      "lineno": 1251,
      "end_lineno": 1284,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 11,
      "loc": 34,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(id1, id2, reader)",
      "fingerprint": "2b1ebf3816c6250f559958458d22723b3022443f",
      "simhash64": 7488180022980019203,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT if not NAME : return False try : for NAME in NAME . NAME ( LIT ) : if not NAME ( NAME ) : continue # Get husband and wife IDs NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME ) NAME = ( NAME ( NAME . NAME ) if NAME and NAME ( NAME , LIT ) else None ) NAME = ( NAME ( NAME . NAME ) if NAME and NAME ( NAME , LIT ) else None ) # Check if id1 and id2 are husband and wife in this family if ( NAME == NAME and NAME == NAME ) or ( NAME == NAME and NAME == NAME ) : return True except NAME as NAME : NAME . NAME ( f\" Error checking spouse relationship: { NAME } \" , NAME = False ) return False"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_is_aunt_or_uncle",
      "lineno": 1287,
      "end_lineno": 1310,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(id1, id2, id_to_parents, id_to_children)",
      "fingerprint": "e09ba56dd37a6fec0ded2997435b9a10094a81e3",
      "simhash64": 7488180022980019251,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME [ NAME ] ] , ) -> NAME : LIT # Get parents of id1 NAME = NAME . NAME ( NAME , NAME ( ) ) # For each parent, check if id2 is their sibling for NAME in NAME : # Get grandparents (parents of parent) NAME = NAME . NAME ( NAME , NAME ( ) ) # For each grandparent, get their children for NAME in NAME : NAME = NAME . NAME ( NAME , NAME ( ) ) # If id2 is a child of a grandparent and not a parent, it's an aunt/uncle if NAME in NAME and NAME != NAME : return True return False"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_is_niece_or_nephew",
      "lineno": 1313,
      "end_lineno": 1321,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(id1, id2, id_to_parents, id_to_children)",
      "fingerprint": "127eda5c93889447e725693d3214ba4fd9f346ce",
      "simhash64": 7488180022980031607,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME [ NAME ] ] , ) -> NAME : LIT # This is the reverse of aunt/uncle relationship return NAME ( NAME , NAME , NAME , NAME )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_are_cousins",
      "lineno": 1324,
      "end_lineno": 1354,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 31,
      "tags": [
        "pure-ish",
        "regex",
        "size:medium"
      ],
      "signature": "(id1, id2, id_to_parents, id_to_children)",
      "fingerprint": "0bdfccb7961e5642ccc954f32f1720a547564e82",
      "simhash64": 7488180022980031523,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME [ NAME ] ] , ) -> NAME : LIT # Get parents of id1 and id2 NAME = NAME . NAME ( NAME , NAME ( ) ) NAME = NAME . NAME ( NAME , NAME ( ) ) # For each parent of id1, check if they have a sibling who is a parent of id2 for NAME in NAME : # Get grandparents of id1 NAME = NAME . NAME ( NAME , NAME ( ) ) for NAME in NAME : # Get grandparents of id2 NAME = NAME . NAME ( NAME , NAME ( ) ) # If they share a grandparent but have different parents, they're cousins if ( NAME and NAME and not NAME . NAME ( NAME ) ) and ( NAME != NAME ) : # Make sure they don't have the same parent (which would make them siblings) return True return False"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_is_grandparent",
      "lineno": 1357,
      "end_lineno": 1368,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(id1, id2, id_to_parents)",
      "fingerprint": "f6748f197c11014a95f63049550780a436c03314",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] ) -> NAME : LIT # Get parents of id1 NAME = NAME . NAME ( NAME , NAME ( ) ) # For each parent, check if id2 is their parent for NAME in NAME : NAME = NAME . NAME ( NAME , NAME ( ) ) if NAME in NAME : return True return False"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_is_grandchild",
      "lineno": 1371,
      "end_lineno": 1382,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(id1, id2, id_to_children)",
      "fingerprint": "4c69cad1fe9bfbb58fe3440cd67323f6e4517e54",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] ) -> NAME : LIT # Get children of id1 NAME = NAME . NAME ( NAME , NAME ( ) ) # For each child, check if id2 is their child for NAME in NAME : NAME = NAME . NAME ( NAME , NAME ( ) ) if NAME in NAME : return True return False"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_is_great_grandparent",
      "lineno": 1385,
      "end_lineno": 1400,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(id1, id2, id_to_parents)",
      "fingerprint": "8f26ce97c3d962eae5c5162295139f333563fedf",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] ) -> NAME : LIT # Get parents of id1 NAME = NAME . NAME ( NAME , NAME ( ) ) # For each parent, check if id2 is their grandparent for NAME in NAME : NAME = NAME . NAME ( NAME , NAME ( ) ) for NAME in NAME : NAME = NAME . NAME ( NAME , NAME ( ) ) if NAME in NAME : return True return False"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "_is_great_grandchild",
      "lineno": 1403,
      "end_lineno": 1418,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(id1, id2, id_to_children)",
      "fingerprint": "43fe615474e82d79e23dda747628cfdba49bc75c",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] ) -> NAME : LIT # Get children of id1 NAME = NAME . NAME ( NAME , NAME ( ) ) # For each child, check if id2 is their grandchild for NAME in NAME : NAME = NAME . NAME ( NAME , NAME ( ) ) for NAME in NAME : NAME = NAME . NAME ( NAME , NAME ( ) ) if NAME in NAME : return True return False"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "calculate_match_score",
      "lineno": 1424,
      "end_lineno": 1732,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 63,
      "loc": 309,
      "tags": [
        "pure-ish",
        "time",
        "size:large"
      ],
      "signature": "(search_criteria, candidate_processed_data, scoring_weights, name_flexibility, date_flexibility)",
      "fingerprint": "b5304c8fd4bc05d85f2edb7e9e47418cfed6036e",
      "simhash64": 7488180024053765147,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME ] , # Expects pre-processed data NAME : NAME [ NAME [ NAME , NAME [ NAME , NAME ] ] ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME , NAME [ NAME , NAME ] , NAME [ NAME ] ] : LIT NAME : NAME [ NAME ] = [ ] NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , # Birth bonus LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , # Death bonus LIT : LIT , # Name bonus } NAME = ( NAME if NAME is not None else NAME . NAME ) NAME = ( NAME if NAME is not None else { LIT : NAME . NAME } ) NAME = NAME . NAME ( LIT , LIT ) # Prepare Target Data NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( ) if NAME ( NAME , NAME ) else LIT NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( ) if NAME ( NAME , NAME ) else LIT NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( ) if NAME ( NAME , NAME ) else LIT NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( ) if NAME ( NAME , NAME ) else LIT NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) # Get Candidate Data from Pre-processed dict NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( ) if NAME ( NAME , NAME ) else LIT NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( ) if NAME ( NAME , NAME ) else LIT NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( ) if NAME ( NAME , NAME ) else LIT NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( ) if NAME ( NAME , NAME ) else LIT NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) # Name Scoring NAME = False NAME = False if NAME and NAME and NAME in NAME : NAME = NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME . NAME ( f\" Contains First Name ( { NAME } pts) \" ) NAME = True NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Matched contains_first_name. Set field_scores['givn'] = { NAME } \" ) if NAME and NAME and NAME in NAME : NAME = NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME . NAME ( f\" Contains Surname ( { NAME } pts) \" ) NAME = True NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Matched contains_surname. Set field_scores['surn'] = { NAME } \" ) if NAME and NAME and NAME and NAME : NAME = NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME . NAME ( f\" Bonus Both Names ( { NAME } pts) \" ) NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Applied bonus_both_names_contain. Set field_scores['bonus'] = { NAME } \" ) # Date Flag Calculation (Restored except clauses) NAME = NAME ( NAME and NAME and NAME ( NAME , NAME ) and NAME ( NAME , NAME ) and NAME . NAME ( ) == NAME . NAME ( ) ) NAME = NAME ( NAME and NAME and NAME ( NAME , NAME ) and NAME ( NAME , NAME ) and NAME . NAME ( ) == NAME . NAME ( ) ) NAME = False NAME = False if NAME is not None and NAME is not None : try : NAME = NAME ( NAME ) NAME = NAME ( NAME ) NAME = NAME == NAME if not NAME : NAME = ( NAME ( NAME - NAME ) <= NAME ) except NAME : pass # Keep flags False if error occurs NAME = False NAME = False if NAME is not None and NAME is not None : try : NAME = NAME ( NAME ) NAME = NAME ( NAME ) NAME = NAME == NAME if not NAME : NAME = ( NAME ( NAME - NAME ) <= NAME ) except NAME : pass # Keep flags False NAME = NAME ( NAME is None and NAME is None and NAME is None and NAME is None ) # Date Scoring NAME = False if NAME : NAME = NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME . NAME ( f\" Exact Birth Date ( { NAME } pts) \" ) NAME = True NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Matched exact_birth_date. Set field_scores['bdate'] = { NAME } \" ) if not NAME and NAME : NAME = NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME . NAME ( f\" Exact Birth Year ( { NAME } ) ( { NAME } pts) \" ) NAME = True NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Matched year_birth. Set field_scores['byear'] = { NAME } \" ) if not NAME and NAME : # Try both old and new weight keys for compatibility NAME = NAME . NAME ( LIT , LIT ) or NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME . NAME ( f\" Approx Birth Year ( { NAME } vs { NAME } ) ( { NAME } pts) \" ) NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Matched birth_year_close. Set field_scores['byear'] = { NAME } \" ) NAME = False if NAME : NAME = NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME . NAME ( f\" Exact Death Date ( { NAME } pts) \" ) NAME = True NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Matched exact_death_date. Set field_scores['ddate'] = { NAME } \" ) elif NAME : NAME = NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME . NAME ( f\" Exact Death Year ( { NAME } ) ( { NAME } pts) \" ) NAME = True NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Matched year_death. Set field_scores['dyear'] = { NAME } \" ) elif NAME : NAME = NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME . NAME ( f\" Approx Death Year ( { NAME } vs { NAME } ) ( { NAME } pts) \" ) NAME = True NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Matched approx_year_death. Set field_scores['dyear'] = { NAME } \" ) elif NAME and not NAME : NAME = NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME . NAME ( f\" Death Dates Absent ( { NAME } pts) \" ) NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Matched death_dates_both_absent. Set field_scores['ddate'] = { NAME } \" ) # Place Scoring if NAME and NAME and NAME in NAME : # Try both old and new weight keys for compatibility NAME = NAME . NAME ( LIT , LIT ) or NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME . NAME ( f\" Birth Place Contains ( { NAME } pts) \" ) NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Matched birth_place_match. Set field_scores['bplace'] = { NAME } \" ) NAME = NAME ( NAME and NAME and NAME in NAME ) NAME = not NAME ( NAME ) NAME = not NAME ( NAME ) NAME = NAME ( NAME and NAME ) if NAME or NAME : # Try both old and new weight keys for compatibility NAME = NAME . NAME ( LIT , LIT ) or NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME = ( f\" Death Place Contains ( { NAME } pts) \" if NAME else f\" Death Places Both Absent ( { NAME } pts) \" ) NAME . NAME ( NAME ) NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Matched Death Place condition ( { LIT if NAME else LIT } ). Set field_scores['dplace'] = { NAME } \" ) # Gender Scoring if NAME and NAME and NAME == NAME : NAME = NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME . NAME ( f\" Gender Match ( { NAME . NAME ( ) } ) ( { NAME } pts) \" ) NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Matched gender_match. Set field_scores['gender'] = { NAME } \" ) # Birth Bonus Scoring (if both birth year and birth place matched) if NAME [ LIT ] > LIT and NAME [ LIT ] > LIT : # Try both old and new weight keys for compatibility NAME = NAME . NAME ( LIT , LIT ) or NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME . NAME ( f\" Bonus Birth Info ( { NAME } pts) \" ) NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Applied bonus_birth_date_and_place. Set field_scores['bbonus'] = { NAME } \" ) # Death Bonus Scoring - Apply when BOTH death info matched OR BOTH are absent (living person) NAME = ( NAME [ LIT ] > LIT or NAME [ LIT ] > LIT ) and NAME [ LIT ] > LIT NAME = NAME and NAME [ LIT ] == LIT # No death date AND no death place if NAME or NAME : # Try both old and new weight keys for compatibility NAME = NAME . NAME ( LIT , LIT ) or NAME . NAME ( LIT , LIT ) if NAME != LIT : NAME [ LIT ] = NAME ( NAME ) NAME = f\" Bonus Death Info ( { NAME } pts) \" if NAME else f\" Bonus Death Absent ( { NAME } pts) \" NAME . NAME ( NAME ) NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Applied death bonus ( { LIT if NAME else LIT } ). Set field_scores['dbonus'] = { NAME } \" ) # Calculate Final Total Score NAME = NAME ( NAME . NAME ( ) ) NAME = NAME ( LIT , NAME ( NAME ) ) NAME = NAME ( NAME ( NAME ) ) # Final Debug Logs NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Final Field Scores Dict before return: { NAME } \" ) NAME . NAME ( f\" SCORE DEBUG ( { NAME } ): Calculated Total Score from dict: { NAME } \" ) # Return a COPY of the dictionary return NAME , NAME . NAME ( ) , NAME"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "GedcomData.__init__",
      "lineno": 1742,
      "end_lineno": 1783,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 42,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "purpose:initialization",
        "size:medium"
      ],
      "signature": "(self, gedcom_path)",
      "fingerprint": "93cb6d4c114f4d4e2f335dfbae046cf86253bdcc",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) : NAME . NAME = NAME ( NAME ) . NAME ( ) NAME . NAME : NAME [ NAME ] = None NAME . NAME : NAME [ NAME , NAME ] = { } # Index of INDI records NAME . NAME : NAME [ NAME , NAME [ NAME , NAME ] ] = ( { } ) # NEW: Cache for processed data NAME . NAME : NAME [ NAME , NAME [ NAME ] ] = { } NAME . NAME : NAME [ NAME , NAME [ NAME ] ] = { } NAME . NAME : NAME = LIT NAME . NAME : NAME = LIT NAME . NAME : NAME = LIT # NEW: Time for pre-processing if not NAME . NAME . NAME ( ) : NAME . NAME ( f\" GEDCOM file not found: { NAME . NAME } \" ) raise NAME ( f\" GEDCOM file not found: { NAME . NAME } \" ) try : NAME . NAME ( f\" Loading GEDCOM file: { NAME . NAME } \" ) NAME = NAME . NAME ( ) # Initialize GedcomReader with the file path as a string # The constructor takes a file parameter (file name or file object) # There seems to be a discrepancy between the documentation and the actual implementation # We'll try to create it with a positional argument, ignoring the type checker warning # @type: ignore is used to suppress the type checker warning NAME . NAME = NAME ( NAME ( NAME . NAME ) ) # type: ignore NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" GEDCOM file loaded in { NAME : .2f } s. \" ) except NAME as NAME : NAME = ( NAME . NAME . NAME ( ) . NAME / ( LIT * LIT ) if NAME . NAME . NAME ( ) else LIT ) NAME = ( f\" Failed to load/parse GEDCOM file { NAME . NAME } (size: { NAME : .2f } MB). \" f\" Error type: { NAME ( NAME ) . NAME } . This may indicate file corruption, \" f\" unsupported GEDCOM format, or encoding issues. \" ) NAME . NAME ( NAME , NAME = True ) # Use exception chaining to preserve the original error context raise NAME ( NAME ) from NAME NAME . NAME ( ) # Build caches upon initialization"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "GedcomData.build_caches",
      "lineno": 1785,
      "end_lineno": 1798,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "05a2bd2c56621fa8b7a0a7cc5b8738e379118187",
      "simhash64": 7487652257465803811,
      "normalized": "def NAME ( NAME ) : LIT if not NAME . NAME : NAME . NAME ( LIT ) return NAME . NAME ( ) # Only build maps and process data if index was successful if NAME . NAME : NAME . NAME ( ) NAME . NAME ( ) # NEW: Call pre-processing else : NAME . NAME ( LIT )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "GedcomData._build_indi_index",
      "lineno": 1802,
      "end_lineno": 1871,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 12,
      "loc": 70,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "ad5180bf4ee52d127e107c598ca1bc2a7842cf52",
      "simhash64": 7488215207352112147,
      "normalized": "def NAME ( NAME ) : LIT if not NAME . NAME : NAME . NAME ( LIT ) return NAME = NAME . NAME ( ) NAME . NAME ( LIT ) NAME . NAME = { } NAME = LIT NAME = LIT NAME = LIT try : for NAME in NAME . NAME . NAME ( NAME ) : # Track current record ID for error reporting NAME = ( NAME ( NAME , LIT , LIT ) if NAME else LIT ) if ( NAME ( NAME ) and NAME ( NAME , LIT ) and NAME . NAME ) : NAME = NAME ( NAME . NAME ) if NAME : if NAME in NAME . NAME : NAME . NAME ( f\" Duplicate normalized INDI ID found: { NAME } . Overwriting. \" ) # Cast the record to the expected type to satisfy the type checker NAME . NAME [ NAME ] = NAME # type: ignore NAME += LIT elif NAME . NAME ( NAME . NAME ) : NAME += LIT NAME . NAME ( f\" Skipping INDI with unnormalizable xref_id: { NAME . NAME } \" ) elif NAME . NAME ( NAME . NAME ) : NAME += LIT if NAME ( NAME , LIT ) : NAME . NAME ( f\" Skipping non-Individual record: Type= { NAME ( NAME ) . NAME } , Xref= { NAME . NAME } \" ) else : NAME . NAME ( f\" Skipping record with no xref_id: Type= { NAME ( NAME ) . NAME } \" ) except NAME : NAME . NAME ( LIT ) except NAME as NAME : # Enhanced error reporting with record context NAME = f\" while processing record ID: { NAME } \" NAME . NAME ( f\" [Cache Build] Error during INDI index build { NAME } : { NAME } . \" f\" Error type: { NAME ( NAME ) . NAME } . Index may be incomplete. \" f\" Records processed so far: { NAME } , skipped: { NAME } . \" , NAME = True , ) NAME = NAME . NAME ( ) - NAME NAME . NAME = NAME if NAME > LIT : NAME . NAME ( f\" [Cache] INDI index built with { NAME } individuals ( { NAME } skipped) in { NAME : .2f } s. \" ) else : NAME . NAME ( f\" [Cache Build] INDI index is EMPTY after build attempt ( { NAME } skipped) in { NAME : .2f } s. \" )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "GedcomData._build_family_maps",
      "lineno": 1873,
      "end_lineno": 1950,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 22,
      "loc": 78,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "bd617f09d91d90a4e5b51025dab0e73d92246f18",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME ) : LIT if not NAME . NAME : NAME . NAME ( LIT ) return NAME = NAME . NAME ( ) NAME . NAME ( LIT ) NAME . NAME = { } NAME . NAME = { } NAME = LIT NAME = LIT NAME = LIT try : for NAME in NAME . NAME . NAME ( LIT ) : NAME += LIT if not NAME ( NAME ) : NAME . NAME ( f\" Skipping non-record FAM entry: { NAME ( NAME ) } \" ) continue NAME = NAME ( NAME , LIT , LIT ) NAME : NAME [ NAME ] = NAME ( ) for NAME in [ NAME , NAME ] : NAME = NAME . NAME ( NAME ) if NAME and NAME ( NAME , LIT ) : NAME = NAME ( NAME . NAME ) if NAME : NAME . NAME ( NAME ) elif NAME . NAME ( NAME . NAME ) : NAME . NAME ( f\" Skipping parent with invalid/unnormalizable ID { NAME ( NAME , LIT , LIT ) } in FAM { NAME } \" ) NAME = NAME . NAME ( NAME ) for NAME in NAME : if NAME and NAME ( NAME , LIT ) : NAME = NAME ( NAME . NAME ) if NAME : for NAME in NAME : NAME . NAME . NAME ( NAME , NAME ( ) ) . NAME ( NAME ) if NAME : NAME . NAME . NAME ( NAME , NAME ( ) ) . NAME ( NAME ) NAME += LIT elif NAME . NAME ( NAME . NAME ) : NAME . NAME ( f\" Child { NAME } found in FAM { NAME } but no valid parents identified in this specific record. \" ) elif NAME . NAME ( NAME . NAME ) : NAME += LIT NAME . NAME ( f\" Skipping child with invalid/unnormalizable ID { NAME ( NAME , LIT , LIT ) } in FAM { NAME } \" ) elif NAME is not None and NAME . NAME ( NAME . NAME ) : NAME += LIT NAME . NAME ( f\" Skipping CHIL record in FAM { NAME } with invalid format: Type= { NAME ( NAME ) . NAME } \" ) except NAME : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" [Cache Build] Unexpected error during family map build: { NAME } . Maps may be incomplete. \" , NAME = True , ) NAME = NAME . NAME ( ) - NAME NAME . NAME = NAME NAME = NAME ( NAME . NAME ) NAME = NAME ( NAME . NAME ) NAME . NAME ( f\" [Cache] Family maps built: { NAME } FAMs processed. Added { NAME } child-parent relationships ( { NAME } skipped invalid links/IDs). Map sizes: { NAME } child->parents entries, { NAME } parent->children entries in { NAME : .2f } s. \" ) if NAME == LIT and NAME == LIT and NAME > LIT : NAME . NAME ( LIT )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "GedcomData._pre_process_individual_data",
      "lineno": 1952,
      "end_lineno": 2042,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 91,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "dba02feda5c156d0aa9504fb8fb07fac6c5e9d79",
      "simhash64": 7488320760468378635,
      "normalized": "def NAME ( NAME ) : LIT if not NAME . NAME : NAME . NAME ( LIT ) return NAME = NAME . NAME ( ) NAME . NAME ( LIT ) NAME . NAME = { } NAME = LIT NAME = LIT for NAME , NAME in NAME . NAME . NAME ( ) : try : # Get full name first using the utility NAME = NAME ( NAME ) # Use the robust getter # Derive scoring name parts from the full name (simple split) NAME = ( NAME . NAME ( ) if NAME != LIT else [ ] ) NAME = NAME [ LIT ] if NAME else LIT NAME = NAME [ - LIT ] if NAME ( NAME ) > LIT else LIT # Extract raw names from tags if needed for specific logic elsewhere # Add null check for indi before calling sub_tag NAME = NAME . NAME ( NAME ) if NAME is not None else None NAME = NAME . NAME ( NAME ) if NAME else None NAME = NAME . NAME ( NAME ) if NAME else None # Extract gender # Add null check for indi before calling sub_tag_value NAME = NAME . NAME ( NAME ) if NAME is not None else None NAME = NAME ( NAME ) . NAME ( ) if NAME else None NAME = NAME if NAME in [ LIT , LIT ] else None # Extract birth info NAME , NAME , NAME = NAME ( NAME , NAME ) NAME = NAME . NAME if NAME else None NAME = NAME ( NAME ) NAME = NAME if NAME != LIT else None # Extract death info NAME , NAME , NAME = NAME ( NAME , NAME ) NAME = NAME . NAME if NAME else None NAME = NAME ( NAME ) NAME = NAME if NAME != LIT else None NAME . NAME [ NAME ] = { LIT : NAME , LIT : NAME ( NAME , LIT , NAME ) , LIT : NAME , # Keep raw tag value if needed LIT : NAME , # Keep raw tag value if needed LIT : NAME , # For scoring LIT : NAME , # For scoring LIT : NAME , # For display LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , } NAME += LIT except NAME as NAME : # Enhanced error reporting with more context NAME = NAME ( NAME ) . NAME NAME . NAME ( f\" Error pre-processing individual { NAME } : { NAME } : { NAME } . \" f\" This may affect search results and relationship paths for this individual. \" , NAME = True , ) NAME += LIT NAME = NAME . NAME ( ) - NAME NAME . NAME = NAME NAME . NAME ( f\" [Pre-Process] Processed data for { NAME } individuals ( { NAME } errors) in { NAME : .2f } s. \" ) if not NAME . NAME : NAME . NAME ( LIT )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "GedcomData.get_processed_indi_data",
      "lineno": 2044,
      "end_lineno": 2051,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self, norm_id)",
      "fingerprint": "10ff7f36e0d095c5e73bb32d5e251c21dac0a3d4",
      "simhash64": 7488180022980027395,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME . NAME : NAME . NAME ( LIT ) NAME . NAME ( ) return NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "GedcomData.find_individual_by_id",
      "lineno": 2053,
      "end_lineno": 2071,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 7,
      "loc": 19,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "(self, norm_id)",
      "fingerprint": "2069cbba27ae70a84b9034720d9df908a06b6158",
      "simhash64": 7488180022980027395,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] ) -> NAME [ NAME ] : LIT if not NAME or not NAME ( NAME , NAME ) : NAME . NAME ( LIT ) return None if not NAME . NAME : NAME . NAME ( LIT ) NAME . NAME ( ) if not NAME . NAME : NAME . NAME ( LIT ) return None NAME = NAME . NAME . NAME ( NAME ) if not NAME and NAME . NAME ( NAME . NAME ) : NAME . NAME ( f\" Individual with normalized ID { NAME } not found in INDI_INDEX. \" ) return NAME"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "GedcomData.get_related_individuals",
      "lineno": 2073,
      "end_lineno": 2152,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 24,
      "loc": 80,
      "tags": [
        "impure",
        "logging",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self, individual, relationship_type)",
      "fingerprint": "b9f02fa3ed81f59a28e135c14423a790de62d841",
      "simhash64": 7488180022980019219,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME ] : LIT NAME : NAME [ NAME ] = [ ] if not NAME ( NAME ) or not NAME ( NAME , LIT ) : NAME . NAME ( f\" get_related_individuals: Invalid input individual object: { NAME ( NAME ) } \" ) return NAME # Add null check before accessing xref_id NAME = NAME ( NAME . NAME if NAME is not None else None ) if not NAME : return NAME if not NAME . NAME and not NAME . NAME : NAME . NAME ( LIT ) NAME . NAME ( ) if not NAME . NAME and not NAME . NAME : NAME . NAME ( LIT ) return NAME try : NAME : NAME [ NAME ] = NAME ( ) if NAME == LIT : NAME = NAME . NAME . NAME ( NAME , NAME ( ) ) elif NAME == LIT : NAME = NAME . NAME . NAME ( NAME , NAME ( ) ) elif NAME == LIT : NAME = NAME . NAME . NAME ( NAME , NAME ( ) ) if NAME : NAME = NAME ( ) . NAME ( * ( NAME . NAME . NAME ( NAME , NAME ( ) ) for NAME in NAME ) ) NAME = NAME - { NAME } else : NAME = NAME ( ) elif NAME == LIT : NAME = NAME . NAME ( NAME ) for NAME , NAME , NAME in NAME : NAME = NAME if NAME else NAME # Add null check before calling sub_tag NAME = ( NAME . NAME ( NAME ) if NAME is not None else None ) if NAME and NAME ( NAME , LIT ) : NAME = NAME ( NAME . NAME ) if NAME : NAME . NAME ( NAME ) else : NAME . NAME ( f\" Unknown relationship type requested: ' { NAME } ' \" ) return [ ] for NAME in NAME : if NAME != NAME : NAME = NAME . NAME ( NAME ) if NAME : NAME . NAME ( NAME ) elif NAME . NAME ( NAME . NAME ) : NAME . NAME ( f\" Could not find Individual object for related ID: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Error getting { NAME } for { NAME } : { NAME } \" , NAME = True ) return [ ] NAME . NAME ( NAME = lambda NAME : ( NAME ( NAME ( NAME , LIT , None ) ) or LIT ) ) return NAME"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "GedcomData._find_family_records",
      "lineno": 2154,
      "end_lineno": 2180,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 8,
      "loc": 27,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, target_id, role_tag)",
      "fingerprint": "535761f51a2c09121ea16ac0993496fa6be793ea",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME ] : LIT NAME : NAME [ NAME ] = [ ] if not NAME . NAME or not NAME or not NAME : return NAME try : NAME . NAME ( f\" Scanning FAM records for { NAME } in role { NAME } (less efficient). \" ) for NAME in NAME . NAME . NAME ( LIT ) : if not NAME ( NAME ) : continue NAME = NAME . NAME ( NAME ) if ( NAME and NAME ( NAME , LIT ) and NAME ( NAME . NAME ) == NAME ) : NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error finding FAMs via scan for ID { NAME } , role { NAME } : { NAME } \" , NAME = True , ) return NAME"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "GedcomData._find_family_records_where_individual_is_parent",
      "lineno": 2182,
      "end_lineno": 2200,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, target_id)",
      "fingerprint": "cdd61d3b83aa7a045607a931b67b8f6c813166a3",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME , NAME ] ] : LIT NAME : NAME [ NAME [ NAME , NAME , NAME ] ] = [ ] NAME = NAME . NAME ( NAME , NAME ) NAME = NAME . NAME ( NAME , NAME ) NAME = NAME ( ) for NAME in NAME : NAME = NAME ( NAME , LIT , None ) if NAME and NAME not in NAME : NAME . NAME ( ( NAME , True , False ) ) NAME . NAME ( NAME ) for NAME in NAME : NAME = NAME ( NAME , LIT , None ) if NAME and NAME not in NAME : NAME . NAME ( ( NAME , False , True ) ) NAME . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "GedcomData.get_relationship_path",
      "lineno": 2202,
      "end_lineno": 2278,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 13,
      "loc": 77,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self, id1, id2)",
      "fingerprint": "d14c0e3daed566f0de15b6231a193d9c9bef217f",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT NAME = NAME ( NAME ) NAME = NAME ( NAME ) if not NAME . NAME : return LIT if not NAME or not NAME : return LIT if NAME == NAME : return LIT if not NAME . NAME and not NAME . NAME : NAME . NAME ( LIT ) NAME . NAME ( ) if not NAME . NAME and not NAME . NAME : return LIT if not NAME . NAME : NAME . NAME ( LIT ) NAME . NAME ( ) if not NAME . NAME : return LIT # Use the enhanced bidirectional BFS algorithm to find the path NAME = LIT NAME = LIT NAME = LIT NAME . NAME ( f\" Calculating relationship path (FastBiBFS): { NAME } <-> { NAME } \" ) NAME = NAME . NAME ( ) NAME = NAME ( NAME , NAME , NAME . NAME , NAME . NAME , NAME , NAME , NAME , ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" [PROFILE] BFS search completed in { NAME : .2f } s. \" ) if not NAME : NAME = f\" [PROFILE] Search: { NAME : .2f } s, MapsBuild: { NAME . NAME : .2f } s, IndexBuild: { NAME . NAME : .2f } s, PreProcess: { NAME . NAME : .2f } s \" return f\" No relationship path found (FastBiBFS could not connect).\\n { NAME } \" # Generate the explanation NAME = NAME . NAME ( ) try : NAME = NAME ( NAME , NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , ) except NAME as NAME : NAME . NAME ( f\" Error generating path explanation: { NAME } \" , NAME = True ) NAME = LIT NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" [PROFILE] Path explanation built in { NAME : .2f } s. \" ) NAME = NAME NAME = f\" [PROFILE] Total Time: { NAME : .2f } s (BFS: 0.00s, Explain: { NAME : .2f } s) [Build Times: Maps= { NAME . NAME : .2f } s, Index= { NAME . NAME : .2f } s, PreProcess= { NAME . NAME : .2f } s] \" NAME . NAME ( NAME ) return f\" { NAME } \\n { NAME } \""
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "GedcomData._find_direct_relationship",
      "lineno": 2280,
      "end_lineno": 2312,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 33,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, id1, id2)",
      "fingerprint": "e2ec9e28ce5ce9fd69a131ee74fe9a545b962e44",
      "simhash64": 7488180022980027395,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME ] : LIT # Check if id2 is a parent of id1 if NAME in NAME . NAME . NAME ( NAME , NAME ( ) ) : return [ NAME , NAME ] # Check if id2 is a child of id1 if NAME in NAME . NAME . NAME ( NAME , NAME ( ) ) : return [ NAME , NAME ] # Check if id1 and id2 are siblings (share at least one parent) NAME = NAME . NAME . NAME ( NAME , NAME ( ) ) NAME = NAME . NAME . NAME ( NAME , NAME ( ) ) NAME = NAME . NAME ( NAME ) if NAME : # Use the first common parent NAME = NAME ( NAME ( NAME ) ) return [ NAME , NAME , NAME ] # No direct relationship found return [ ]"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "gedcom_module_tests",
      "lineno": 2318,
      "end_lineno": 2456,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 139,
      "tags": [
        "impure",
        "logging",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "c4d56e7d633e1560cd0747ed4d78e81655d3e2d9",
      "simhash64": 5127871611137332267,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import ( NAME , NAME , ) with NAME ( ) : NAME = NAME ( LIT , LIT ) # Run all tests NAME ( LIT ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Generate summary report return NAME . NAME ( )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 2459,
      "end_lineno": 2461,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_function_availability",
      "lineno": 2465,
      "end_lineno": 2489,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 25,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "416939a37a1f3c6da07932f7a935cc7370fc4570",
      "simhash64": 5145885970992108587,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ] from NAME import NAME NAME = NAME ( NAME , NAME ( ) , LIT ) return NAME ( NAME )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_id_normalization",
      "lineno": 2492,
      "end_lineno": 2529,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 38,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "37ffea1a63bf2150ecd71e1806429f1325489a87",
      "simhash64": 7488180024054813739,
      "normalized": "def NAME ( ) : LIT if LIT not in NAME ( ) : NAME ( LIT ) return NAME = [ ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( None , LIT ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME in NAME : try : NAME = NAME ( NAME ) NAME = NAME ( NAME , NAME ) or NAME is None NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" Input: { NAME ! NAME } \u2192 Output: { NAME ! NAME } \" ) NAME . NAME ( NAME ) assert ( NAME ) , f\" _normalize_id should return string or None for { NAME } \" except NAME as NAME : NAME ( f\" \u26a0\ufe0f { NAME } \" ) NAME ( f\" Input: { NAME ! NAME } \u2192 Error: { NAME } (may be acceptable) \" ) NAME . NAME ( True ) # Some formats may be invalid, which is acceptable NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } ID normalization tests passed \" )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_individual_detection",
      "lineno": 2532,
      "end_lineno": 2541,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "a177c5b69abdd1d3b37aef0838d57ccea0befefb",
      "simhash64": 8641277420457858091,
      "normalized": "def NAME ( ) : LIT if LIT in NAME ( ) : # Test with None NAME = NAME ( None ) assert NAME ( NAME , NAME ) # Test with empty dict NAME = NAME ( { } ) assert NAME ( NAME , NAME )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_name_extraction",
      "lineno": 2544,
      "end_lineno": 2549,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "7934a94a6136f4e62e97acb3bbd0c2d782c553a6",
      "simhash64": 8641277420524967467,
      "normalized": "def NAME ( ) : LIT if LIT in NAME ( ) : # Test with None NAME = NAME ( None ) assert NAME == LIT or NAME ( NAME , NAME )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_date_parsing",
      "lineno": 2552,
      "end_lineno": 2562,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "24114edcd18641d0bd5089b408f1335711ca4525",
      "simhash64": 7488320725094143535,
      "normalized": "def NAME ( ) : LIT if LIT in NAME ( ) : # Test with various date formats NAME = [ LIT , LIT , LIT , LIT ] for NAME in NAME : try : NAME = NAME ( NAME ) assert NAME is None or NAME ( NAME , NAME ) except NAME : pass # Some formats may be invalid"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_event_extraction",
      "lineno": 2565,
      "end_lineno": 2570,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "229ba5a96870ac0450a3795e80b472af7a17e971",
      "simhash64": 7487757781525500971,
      "normalized": "def NAME ( ) : LIT if LIT in NAME ( ) : # Test with None NAME = NAME ( None , LIT ) assert NAME ( NAME , NAME ) and NAME ( NAME ) == LIT"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_life_dates_formatting",
      "lineno": 2573,
      "end_lineno": 2578,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "68ebf601762a73f33e819fa6b7aa2a09502db3e0",
      "simhash64": 8641277420516578347,
      "normalized": "def NAME ( ) : LIT if LIT in NAME ( ) : # Test with None values NAME = NAME ( None ) assert NAME ( NAME , NAME )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_relationship_explanation",
      "lineno": 2581,
      "end_lineno": 2589,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "7b6ce4daf20278081ef3c4f357f68663618bbe23",
      "simhash64": 7452291932304086591,
      "normalized": "def NAME ( ) : LIT if LIT in NAME ( ) : # Test with minimal valid parameters try : NAME = NAME ( [ ] , None , { } , { } , { } ) assert NAME ( NAME , NAME ) except NAME : pass # May fail with invalid parameters, which is acceptable"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_bfs_pathfinding",
      "lineno": 2592,
      "end_lineno": 2600,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "60dbf6154fcb9f24e15f03fbdf230ee60917f92e",
      "simhash64": 7488320731470534191,
      "normalized": "def NAME ( ) : LIT if LIT in NAME ( ) : # Test with empty graph try : NAME = NAME ( LIT , LIT , { } , { } ) assert NAME ( NAME , NAME ) except NAME : pass # May fail with missing IDs, which is acceptable"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_sibling_detection",
      "lineno": 2603,
      "end_lineno": 2611,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "6c5e2c677b1396bd8d041d939f17b00e2951cf7a",
      "simhash64": 7488355915842623039,
      "normalized": "def NAME ( ) : LIT if LIT in NAME ( ) : # Test with valid string IDs try : NAME = NAME ( LIT , LIT , { } ) assert NAME ( NAME , NAME ) except NAME : pass # May fail with missing data, which is acceptable"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_invalid_data_handling",
      "lineno": 2614,
      "end_lineno": 2626,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "aa439be1ba50c8978b40a24f0a899bcee865aad3",
      "simhash64": 8641277416230000171,
      "normalized": "def NAME ( ) : LIT # Test functions with invalid inputs if LIT in NAME ( ) : try : NAME = NAME ( None ) assert NAME is None or NAME ( NAME , NAME ) except NAME : pass # Exception handling is acceptable if LIT in NAME ( ) : NAME = NAME ( LIT ) assert NAME ( NAME , NAME )"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_large_dataset_performance",
      "lineno": 2629,
      "end_lineno": 2637,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "e1a6e31472e433d3afdda91b3dc906bd33c6769c",
      "simhash64": 8641136713100334139,
      "normalized": "def NAME ( ) : LIT # Test ID normalization performance if LIT in NAME ( ) : NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( f\" @I { NAME } @ \" ) NAME = NAME . NAME ( ) assert ( NAME - NAME ) < LIT # Should complete in under 1 second"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_memory_optimization",
      "lineno": 2640,
      "end_lineno": 2648,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "96858ce8ab2bbde121879f6b57e03fde8a1a8955",
      "simhash64": 9222242300694795819,
      "normalized": "def NAME ( ) : LIT # Test that functions don't create excessive memory overhead if LIT in NAME ( ) : for NAME in NAME ( LIT ) : try : NAME ( None ) # Should not accumulate memory except NAME : pass"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_external_integration",
      "lineno": 2651,
      "end_lineno": 2662,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3ed823a2d5e0029b33d78b78ed54dd6719dec538",
      "simhash64": 7452291934527067183,
      "normalized": "def NAME ( ) : LIT # Test that functions can handle various data structures NAME = [ None , { } , [ ] , LIT , LIT , False ] if LIT in NAME ( ) : for NAME in NAME : try : NAME = NAME ( NAME ) assert NAME ( NAME , NAME ) except NAME : pass # Some types may not be supported"
    },
    {
      "module_path": "gedcom_utils.py",
      "qualname": "test_error_recovery",
      "lineno": 2665,
      "end_lineno": 2679,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "297da0d178dc44be5af0d17d6d6873d12339783c",
      "simhash64": 8641277965977425455,
      "normalized": "def NAME ( ) : LIT # Test that functions handle errors gracefully if LIT in NAME ( ) : try : NAME ( LIT ) # Invalid format except NAME : pass # Exception is acceptable if LIT in NAME ( ) : try : NAME = NAME ( None ) assert NAME == LIT or NAME ( NAME , NAME ) except NAME : pass # Exception is acceptable"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "_dedupe_list_str",
      "lineno": 43,
      "end_lineno": 58,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(items)",
      "fingerprint": "9c123aaa9c9a9a89ea7b6f5cd6b744a440f785e6",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : if not NAME ( NAME , NAME ) : return [ ] NAME : NAME [ NAME ] = [ ] NAME = NAME ( ) for NAME in NAME : if NAME is None : continue NAME = NAME ( NAME ) . NAME ( ) if not NAME : continue if NAME . NAME ( ) in NAME : continue NAME . NAME ( NAME . NAME ( ) ) NAME . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "_validate_and_normalize_date",
      "lineno": 61,
      "end_lineno": 135,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 24,
      "loc": 75,
      "tags": [
        "pure-ish",
        "regex",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(date_str)",
      "fingerprint": "b1b51a8d08fc4a89340e8d09c445c59bfd394d9b",
      "simhash64": 7451729014636844587,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if not NAME or not NAME ( NAME , NAME ) : return LIT NAME = NAME . NAME ( ) if not NAME : return LIT # Preserve approximate indicators NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ] NAME = NAME ( NAME in NAME . NAME ( ) for NAME in NAME ) # Extract year patterns (genealogically relevant range: 1400-2100) NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME = NAME . NAME ( LIT ) # Check for month patterns NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } NAME = None for NAME , NAME in NAME . NAME ( ) : if NAME . NAME ( NAME , NAME . NAME ( ) ) : NAME = NAME break # Check for day patterns NAME = NAME . NAME ( LIT , NAME ) NAME = None if NAME and NAME : NAME = NAME ( NAME . NAME ( LIT ) ) if LIT <= NAME <= LIT : NAME = f\" { NAME : 02d } \" # Construct normalized date if NAME and NAME : NAME = f\" { NAME } - { NAME } - { NAME } \" elif NAME : NAME = f\" { NAME } - { NAME } \" else : NAME = NAME # Add back approximation indicators if NAME : if LIT in NAME . NAME ( ) or LIT in NAME . NAME ( ) : NAME = f\" circa { NAME } \" elif LIT in NAME : NAME = f\" ~ { NAME } \" elif LIT in NAME . NAME ( ) or LIT in NAME . NAME ( ) : NAME = f\" about { NAME } \" elif LIT in NAME . NAME ( ) or LIT in NAME . NAME ( ) : NAME = f\" before { NAME } \" elif LIT in NAME . NAME ( ) or LIT in NAME . NAME ( ) : NAME = f\" after { NAME } \" return NAME # Return original if no recognizable date pattern return NAME"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "_validate_relationship",
      "lineno": 138,
      "end_lineno": 178,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 41,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(relationship)",
      "fingerprint": "0f6b933ca8f23f5504a9664d09f98140df0ec7a9",
      "simhash64": 5726842626401277483,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if not NAME or not NAME ( NAME , NAME ) : return LIT NAME = NAME . NAME ( ) . NAME ( ) # Standard relationship mappings NAME = { # Direct relationships LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , # Extended relationships LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , # In-law relationships LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , # Step relationships LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } return NAME . NAME ( NAME , NAME . NAME ( ) )"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "_validate_location",
      "lineno": 181,
      "end_lineno": 228,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 8,
      "loc": 48,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(location)",
      "fingerprint": "1e97a57610c9d3b84e31db26de1122e83616485e",
      "simhash64": 5726842660759967275,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if not NAME or not NAME ( NAME , NAME ) : return LIT NAME = NAME . NAME ( ) # Common state/country abbreviations NAME = { # US States LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , # Countries LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } # Check for exact matches (case insensitive) NAME = NAME . NAME ( ) if NAME in NAME : return NAME [ NAME ] # Handle comma-separated locations (City, State, Country) if LIT in NAME : NAME = [ NAME . NAME ( ) for NAME in NAME . NAME ( LIT ) ] NAME = [ ] for NAME in NAME : NAME = NAME . NAME ( ) if NAME in NAME : NAME . NAME ( NAME [ NAME ] ) else : NAME . NAME ( NAME ) return LIT . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "_ensure_extracted_data_container",
      "lineno": 231,
      "end_lineno": 245,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(resp)",
      "fingerprint": "0af0a57510b084f28798bbf3a51e640416058888",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : if not NAME ( NAME , NAME ) : NAME = { } NAME = NAME . NAME ( LIT ) if not NAME ( NAME , NAME ) : NAME = { } # Ensure structured keys exist for NAME in NAME : if NAME not in NAME or NAME [ NAME ] is None : NAME [ NAME ] = [ ] NAME [ LIT ] = NAME # Ensure suggested_tasks exists as list[str] NAME = NAME . NAME ( LIT , [ ] ) NAME [ LIT ] = NAME ( NAME ) return NAME"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "_promote_legacy_fields",
      "lineno": 248,
      "end_lineno": 278,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 9,
      "loc": 31,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(extracted)",
      "fingerprint": "5e251c7b470a2c73ad550a5b962c5baa5dfaa463",
      "simhash64": 7451729014570783787,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> None : LIT for NAME , ( NAME , NAME ) in NAME . NAME ( ) : NAME = NAME . NAME ( NAME ) if not NAME : continue if not NAME ( NAME , NAME ) : continue # Prepare the structured container list NAME = NAME . NAME ( NAME ) if not NAME ( NAME , NAME ) : NAME = [ ] for NAME in NAME ( NAME ) : if NAME == LIT : NAME . NAME ( { LIT : NAME , LIT : [ ] } ) elif NAME == LIT : NAME . NAME ( { LIT : NAME , LIT : LIT , LIT : LIT } ) elif NAME == LIT : NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : NAME , LIT : LIT , LIT : LIT , } ) NAME [ NAME ] = NAME"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "normalize_extracted_data",
      "lineno": 281,
      "end_lineno": 369,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 33,
      "loc": 89,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(extracted)",
      "fingerprint": "4f36bf5b9a494a32d71f4591499822ffe351cda9",
      "simhash64": 7488180023047140387,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT if not NAME ( NAME , NAME ) : NAME = { } # Ensure all structured keys exist for NAME in NAME : if NAME not in NAME or NAME [ NAME ] is None : NAME [ NAME ] = [ ] # Promote legacy flat fields conservatively NAME ( NAME ) # Enhanced Phase 12.1: Apply genealogical validation and normalization # Validate and normalize vital records NAME = NAME . NAME ( LIT , [ ] ) if NAME ( NAME , NAME ) : for NAME in NAME : if NAME ( NAME , NAME ) : # Normalize dates if NAME . NAME ( LIT ) : NAME [ LIT ] = NAME ( NAME ( NAME [ LIT ] ) ) # Normalize locations if NAME . NAME ( LIT ) : NAME [ LIT ] = NAME ( NAME ( NAME [ LIT ] ) ) # Validate event types if NAME . NAME ( LIT ) : NAME = NAME ( NAME [ LIT ] ) . NAME ( ) . NAME ( ) NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT ] if NAME in NAME : NAME [ LIT ] = NAME # Validate and normalize relationships NAME = NAME . NAME ( LIT , [ ] ) if NAME ( NAME , NAME ) : for NAME in NAME : if NAME ( NAME , NAME ) : # Normalize relationship type if NAME . NAME ( LIT ) : NAME [ LIT ] = NAME ( NAME ( NAME [ LIT ] ) ) # Ensure person names are properly formatted for NAME in [ LIT , LIT ] : if NAME . NAME ( NAME ) : NAME = NAME ( NAME [ NAME ] ) . NAME ( ) # Basic name validation - ensure it's not just whitespace or numbers if NAME and not NAME . NAME ( ) and NAME ( NAME ) > LIT : NAME [ NAME ] = NAME else : NAME [ NAME ] = LIT # Validate and normalize locations NAME = NAME . NAME ( LIT , [ ] ) if NAME ( NAME , NAME ) : for NAME in NAME : if NAME ( NAME , NAME ) : # Normalize place names if NAME . NAME ( LIT ) : NAME [ LIT ] = NAME ( NAME ( NAME [ LIT ] ) ) # Normalize time periods if NAME . NAME ( LIT ) : NAME [ LIT ] = NAME ( NAME ( NAME [ LIT ] ) ) # Validate and normalize structured names NAME = NAME . NAME ( LIT , [ ] ) if NAME ( NAME , NAME ) : for NAME in NAME : if NAME ( NAME , NAME ) : # Ensure full_name is properly formatted if NAME . NAME ( LIT ) : NAME = NAME ( NAME [ LIT ] ) . NAME ( ) # Basic name validation if NAME and not NAME . NAME ( ) and NAME ( NAME ) > LIT : NAME [ LIT ] = NAME else : NAME [ LIT ] = LIT # Ensure nicknames is a list if LIT not in NAME or not NAME ( NAME [ LIT ] , NAME ) : NAME [ LIT ] = [ ] return NAME"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "normalize_ai_response",
      "lineno": 372,
      "end_lineno": 382,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(ai_resp)",
      "fingerprint": "d1d66e7511d1b0240b9c46267ccc44b38eb4fcf5",
      "simhash64": 7488109655310636083,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME , NAME ] : LIT if not NAME ( NAME , NAME ) : NAME = { } NAME = NAME ( NAME ) NAME [ LIT ] = NAME ( NAME . NAME ( LIT , { } ) ) # suggested_tasks already deduped in container ensure step return NAME"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 389,
      "end_lineno": 582,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 194,
      "tags": [
        "impure",
        "logging",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "0e746450c3d27742f6e7fbe9e063a27b799617d3",
      "simhash64": 5146448955309462571,
      "normalized": "def NAME ( ) -> NAME : LIT try : from NAME import NAME except NAME : NAME ( LIT ) return NAME ( ) NAME = NAME ( LIT , LIT ) def NAME ( ) : LIT # Test with empty input NAME = NAME ( { } ) assert LIT in NAME assert LIT in NAME assert NAME ( NAME [ LIT ] , NAME ) assert NAME ( NAME [ LIT ] , NAME ) # Test with None input NAME = NAME ( None ) assert LIT in NAME assert LIT in NAME # Test with valid data NAME = { LIT : { LIT : LIT } , LIT : [ LIT , LIT ] } NAME = NAME ( NAME ) assert NAME ( NAME [ LIT ] ) == LIT def NAME ( ) : LIT # Test empty dict NAME = NAME ( { } ) for NAME in NAME : assert NAME in NAME assert NAME ( NAME [ NAME ] , NAME ) # Test with existing data NAME = { LIT : [ { LIT : LIT } ] } NAME = NAME ( NAME ) assert NAME [ LIT ] [ LIT ] [ LIT ] == LIT assert LIT in NAME def NAME ( ) : LIT NAME = { LIT : [ LIT , LIT ] , LIT : [ LIT , LIT ] } NAME = NAME ( NAME ) # Check names were promoted assert LIT in NAME assert NAME ( NAME [ LIT ] ) == LIT assert NAME [ LIT ] [ LIT ] [ LIT ] == LIT # Check locations were promoted assert LIT in NAME assert NAME ( NAME [ LIT ] ) == LIT assert NAME [ LIT ] [ LIT ] [ LIT ] == LIT def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT , None , LIT ] NAME = NAME ( NAME ) assert NAME ( NAME ) == LIT assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT not in NAME # Test with non-list input assert NAME ( LIT ) == [ ] assert NAME ( None ) == [ ] def NAME ( ) : LIT # Test with malformed data NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) # Test with nested None values NAME = { LIT : None } NAME = NAME ( NAME ) assert NAME ( NAME [ LIT ] , NAME ) # Test with mixed data types NAME = { LIT : [ LIT , LIT , LIT , None , LIT ] } NAME = NAME ( NAME ) NAME = NAME [ LIT ] assert NAME ( NAME ) == LIT # 1, 2, John assert NAME [ LIT ] [ LIT ] == LIT def NAME ( ) : LIT # Test container creation NAME = NAME ( { } ) assert LIT in NAME assert LIT in NAME # Test task deduplication NAME = { LIT : [ LIT , LIT , LIT , LIT ] } NAME = NAME ( NAME ) assert NAME ( NAME [ LIT ] ) == LIT assert LIT in NAME [ LIT ] def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME ( ) , f\" Function { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] ) , f\" Function { NAME } should be callable \" # Run all tests NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) return NAME . NAME ( )"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "test_ai_response_normalization",
      "lineno": 407,
      "end_lineno": 427,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 21,
      "tags": [
        "impure",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d1d06dae6c8df07be16a086377e09e93af581ede",
      "simhash64": 7452291930155030075,
      "normalized": "def NAME ( ) : LIT # Test with empty input NAME = NAME ( { } ) assert LIT in NAME assert LIT in NAME assert NAME ( NAME [ LIT ] , NAME ) assert NAME ( NAME [ LIT ] , NAME ) # Test with None input NAME = NAME ( None ) assert LIT in NAME assert LIT in NAME # Test with valid data NAME = { LIT : { LIT : LIT } , LIT : [ LIT , LIT ] } NAME = NAME ( NAME ) assert NAME ( NAME [ LIT ] ) == LIT"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "test_extracted_data_normalization",
      "lineno": 429,
      "end_lineno": 441,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "eed41a6b81fdda989b84d8298b506cb6b7942343",
      "simhash64": 7452291929156785715,
      "normalized": "def NAME ( ) : LIT # Test empty dict NAME = NAME ( { } ) for NAME in NAME : assert NAME in NAME assert NAME ( NAME [ NAME ] , NAME ) # Test with existing data NAME = { LIT : [ { LIT : LIT } ] } NAME = NAME ( NAME ) assert NAME [ LIT ] [ LIT ] [ LIT ] == LIT assert LIT in NAME"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "test_legacy_field_promotion",
      "lineno": 443,
      "end_lineno": 459,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d2c2601c860882d143782d078472eb64341d2dab",
      "simhash64": 5144057507909908031,
      "normalized": "def NAME ( ) : LIT NAME = { LIT : [ LIT , LIT ] , LIT : [ LIT , LIT ] } NAME = NAME ( NAME ) # Check names were promoted assert LIT in NAME assert NAME ( NAME [ LIT ] ) == LIT assert NAME [ LIT ] [ LIT ] [ LIT ] == LIT # Check locations were promoted assert LIT in NAME assert NAME ( NAME [ LIT ] ) == LIT assert NAME [ LIT ] [ LIT ] [ LIT ] == LIT"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "test_list_deduplication",
      "lineno": 461,
      "end_lineno": 474,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "impure",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "a56da6c58acf88ddea88990d135ae15728ef8539",
      "simhash64": 5146448945712895539,
      "normalized": "def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT , None , LIT ] NAME = NAME ( NAME ) assert NAME ( NAME ) == LIT assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT not in NAME # Test with non-list input assert NAME ( LIT ) == [ ] assert NAME ( None ) == [ ]"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "test_edge_cases",
      "lineno": 476,
      "end_lineno": 494,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c92d71cc7762264784e6e3dccb5a203ddae5919a",
      "simhash64": 5146448912351925291,
      "normalized": "def NAME ( ) : LIT # Test with malformed data NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) # Test with nested None values NAME = { LIT : None } NAME = NAME ( NAME ) assert NAME ( NAME [ LIT ] , NAME ) # Test with mixed data types NAME = { LIT : [ LIT , LIT , LIT , None , LIT ] } NAME = NAME ( NAME ) NAME = NAME [ LIT ] assert NAME ( NAME ) == LIT # 1, 2, John assert NAME [ LIT ] [ LIT ] == LIT"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "test_container_structure",
      "lineno": 496,
      "end_lineno": 509,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d1bcc2e4d5c52b00d427e9cf9a415b12800d88f7",
      "simhash64": 5146448955368183355,
      "normalized": "def NAME ( ) : LIT # Test container creation NAME = NAME ( { } ) assert LIT in NAME assert LIT in NAME # Test task deduplication NAME = { LIT : [ LIT , LIT , LIT , LIT ] } NAME = NAME ( NAME ) assert NAME ( NAME [ LIT ] ) == LIT assert LIT in NAME [ LIT ]"
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "test_function_availability",
      "lineno": 511,
      "end_lineno": 523,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "194055438266a432a851f5fc73644c113deeedfa",
      "simhash64": 7452291964518962235,
      "normalized": "def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME ( ) , f\" Function { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] ) , f\" Function { NAME } should be callable \""
    },
    {
      "module_path": "genealogical_normalization.py",
      "qualname": "_run_basic_tests",
      "lineno": 585,
      "end_lineno": 600,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7279b6967cfa5623ef5c4c664dbacfc405e22413",
      "simhash64": 8641171863045052027,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Test basic functionality NAME = NAME ( { } ) assert LIT in NAME NAME = NAME ( { } ) for NAME in NAME : assert NAME in NAME NAME ( LIT ) return True except NAME as NAME : NAME ( f\" \u274c Basic tests failed: { NAME } \" ) return False"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator.__init__",
      "lineno": 32,
      "end_lineno": 46,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "959f877706a22308968a305423de5fd297f95856",
      "simhash64": 7488144842902905875,
      "normalized": "def NAME ( NAME ) : LIT NAME . NAME = NAME . NAME ( ) NAME . NAME = NAME . NAME ( ) # === PHASE 12: GEDCOM AI INTEGRATION === try : from NAME import NAME NAME . NAME = NAME ( ) NAME . NAME = True NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" GEDCOM AI integration not available in task generator: { NAME } \" ) NAME . NAME = None NAME . NAME = False"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._load_task_templates",
      "lineno": 48,
      "end_lineno": 99,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 52,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "c3c84674eb8084779bc0c7a461d9dd844ad4440e",
      "simhash64": 1116282542240470571,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME [ NAME , NAME ] ] : LIT return { LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } }"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._get_location_specific_strategy",
      "lineno": 101,
      "end_lineno": 132,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 8,
      "yield_count": 0,
      "complexity": 15,
      "loc": 32,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self, location)",
      "fingerprint": "78cd7bb609be22d241f3298b69b06dc5ef933904",
      "simhash64": 5145886005418955819,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT NAME = NAME . NAME ( ) # Scotland-specific strategies if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT ] ) : return LIT # Ireland-specific strategies if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT ] ) : return LIT # England-specific strategies if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT ] ) : return LIT # Wales-specific strategies if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT ] ) : return LIT # US state-specific strategies if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT ] ) : return LIT if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT ] ) : return LIT if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT ] ) : return LIT # Generic strategies for other locations return LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._generate_name_variations",
      "lineno": 134,
      "end_lineno": 163,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 11,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, name)",
      "fingerprint": "3c46ecbdea17367abc5b623f6f43c4bb9f888f3e",
      "simhash64": 5127730869425312811,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT if not NAME : return LIT NAME = [ ] NAME = NAME . NAME ( ) for NAME in NAME : # Common letter substitutions if LIT in NAME . NAME ( ) : NAME . NAME ( NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) ) if LIT in NAME . NAME ( ) : NAME . NAME ( NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) ) if LIT in NAME . NAME ( ) : NAME . NAME ( NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) ) # Add common prefixes/suffixes if NAME : NAME = NAME [ LIT ] if NAME . NAME ( ) in [ LIT , LIT , LIT ] : NAME . NAME ( [ LIT , LIT , LIT , LIT , LIT ] ) elif NAME . NAME ( ) in [ LIT , LIT , LIT ] : NAME . NAME ( [ LIT , LIT , LIT , LIT , LIT ] ) elif NAME . NAME ( ) in [ LIT , LIT , LIT ] : NAME . NAME ( [ LIT , LIT , LIT , LIT ] ) if NAME : return f\" Try variations: { LIT . NAME ( NAME ( NAME [ : LIT ] ) ) } \" return LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._load_task_configuration",
      "lineno": 165,
      "end_lineno": 184,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "e8e76107163392186e8e286d96c616bc7f337677",
      "simhash64": 5727968560667858475,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : LIT , LIT : { LIT : LIT , LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } }"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator.generate_research_tasks",
      "lineno": 186,
      "end_lineno": 250,
      "is_method": true,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 14,
      "loc": 65,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, person_data, extracted_data, suggested_tasks, gedcom_data)",
      "fingerprint": "5e09d7721bb9f37cd724293903ae0c074764c7cb",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] , NAME : NAME = None ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : # Input validation and safe defaults if NAME is None or not NAME ( NAME , NAME ) : NAME = { } if NAME is None or not NAME ( NAME , NAME ) : NAME = { } if NAME is None or not NAME ( NAME , NAME ) : NAME = [ ] NAME = [ ] # === PHASE 12: GEDCOM AI ENHANCED TASK GENERATION === if NAME . NAME and NAME . NAME is not None and NAME : try : NAME . NAME ( LIT ) NAME = NAME . NAME . NAME ( NAME , NAME , NAME ) NAME . NAME ( NAME ) NAME . NAME ( f\" Generated { NAME ( NAME ) } GEDCOM AI-enhanced tasks \" ) except NAME as NAME : NAME . NAME ( f\" GEDCOM AI task generation failed: { NAME } , falling back to standard generation \" ) # Generate tasks based on extracted data types (standard approach) NAME . NAME ( NAME . NAME ( NAME ) ) NAME . NAME ( NAME . NAME ( NAME ) ) NAME . NAME ( NAME . NAME ( NAME ) ) NAME . NAME ( NAME . NAME ( NAME ) ) NAME . NAME ( NAME . NAME ( NAME ) ) NAME . NAME ( NAME . NAME ( NAME ) ) NAME . NAME ( NAME . NAME ( NAME ) ) NAME . NAME ( NAME . NAME ( NAME ) ) # Add fallback tasks from AI suggestions if no specific tasks generated if not NAME and NAME : NAME . NAME ( NAME . NAME ( NAME , NAME ) ) # Prioritize and limit tasks NAME = NAME . NAME ( NAME ) NAME . NAME ( f\" Generated { NAME ( NAME ) } enhanced research tasks (GEDCOM AI: { LIT if NAME . NAME and NAME else LIT } ) \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Error generating research tasks: { NAME } \" ) return NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._generate_vital_records_tasks",
      "lineno": 252,
      "end_lineno": 281,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "67e60255fc731b94b6c19dfe88b754148c3ff7b1",
      "simhash64": 7451588277081379883,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME [ : LIT ] : # Limit to 2 most important if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) # Generate enhanced task data with location-specific strategies NAME = { LIT : NAME , LIT : f\" { NAME } record \" , LIT : f\" ( { NAME } { NAME } ) \" if NAME != LIT else LIT , LIT : NAME , LIT : NAME , LIT : LIT , LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME ( NAME ) , LIT : f\" Official { NAME } documentation with parents, dates, and locations \" } NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._generate_dna_analysis_tasks",
      "lineno": 283,
      "end_lineno": 303,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "fa0578d5f6222bcb2eee9daf7dfc9866ed1556c3",
      "simhash64": 7451588277148488747,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME [ : LIT ] : # Limit to 1 DNA task if NAME ( NAME , NAME ) and ( LIT in NAME . NAME ( ) or LIT in NAME . NAME ( ) ) : NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME . NAME ( NAME ) break return NAME"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._generate_verification_tasks",
      "lineno": 305,
      "end_lineno": 329,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 25,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "dec0ca8b5da3e09c25840b4017eb4ac6d7ddd7ab",
      "simhash64": 7451588277148488747,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME [ : LIT ] : # Limit to 2 verification tasks if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._generate_immigration_tasks",
      "lineno": 331,
      "end_lineno": 363,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 33,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "c7e05632c6cc27820ff29e3faa7eeeecc595871c",
      "simhash64": 5145886005423150123,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] NAME = NAME . NAME ( LIT , [ ] ) # Look for potential immigration scenarios NAME = [ ] for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT ] ) : NAME . NAME ( NAME ) if NAME : NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = { LIT : LIT , LIT : NAME , LIT : LIT , LIT : NAME , LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._generate_census_tasks",
      "lineno": 365,
      "end_lineno": 391,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 27,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "14607d0e844655c447a962d6edf7bacef9030393",
      "simhash64": 7452151227034801195,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME . NAME ( LIT , [ ] ) if NAME and NAME : NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME = NAME . NAME ( LIT , LIT ) if NAME ( NAME , NAME ) else NAME ( NAME ) NAME = NAME . NAME ( LIT , LIT ) if NAME ( NAME , NAME ) else NAME ( NAME ) NAME = { LIT : NAME , LIT : NAME , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._generate_military_tasks",
      "lineno": 393,
      "end_lineno": 415,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "5f07e0ca9fa1762e97858e9b5ced30408b3f66b9",
      "simhash64": 7451729014636844075,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] # Look for military-related information in research questions or documents NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : if NAME ( NAME , NAME ) and NAME ( NAME in NAME . NAME ( ) for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT ] ) : NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME . NAME ( NAME ) break return NAME"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._generate_occupation_tasks",
      "lineno": 417,
      "end_lineno": 442,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "accde39df9c1f3876be7418764ca4a86c68aa1d2",
      "simhash64": 7451588277148488747,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME [ : LIT ] : # Limit to 1 occupation task if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : LIT , LIT : f\" Understand { NAME } 's career and work history \" } NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._generate_location_tasks",
      "lineno": 444,
      "end_lineno": 468,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 25,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "44ffb0ec59ee4cb44f09e9cd3704d6438f0737a9",
      "simhash64": 7452151227101910059,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME [ : LIT ] : # Limit to 1 location task if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = { LIT : LIT , LIT : NAME , LIT : NAME , LIT : NAME , LIT : LIT , LIT : f\" Family's time in { NAME } and local connections \" } NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._create_task_from_template",
      "lineno": 470,
      "end_lineno": 494,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 3,
      "loc": 25,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, template_key, task_data)",
      "fingerprint": "abad21acca37cc2a9e76459ccb31dccb5988b9d5",
      "simhash64": 7452151225961067571,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : NAME = NAME . NAME . NAME ( NAME ) if not NAME : return None # Format title and description NAME = NAME [ LIT ] . NAME ( ** NAME ) NAME = NAME [ LIT ] . NAME ( ** NAME ) return { LIT : NAME , LIT : NAME , LIT : NAME [ LIT ] , LIT : NAME [ LIT ] , LIT : NAME } except NAME as NAME : NAME . NAME ( f\" Missing template data key { NAME } for template { NAME } \" ) return None except NAME as NAME : NAME . NAME ( f\" Error creating task from template { NAME } : { NAME } \" ) return None"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._create_fallback_tasks",
      "lineno": 496,
      "end_lineno": 510,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, person_data, suggested_tasks)",
      "fingerprint": "a44f152ccf0d2ad8f65debb8cd65c328818ca743",
      "simhash64": 7451729014570783803,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] NAME = NAME . NAME ( LIT , LIT ) for NAME , NAME in NAME ( NAME [ : LIT ] ) : # Limit to 3 fallback tasks NAME . NAME ( { LIT : f\" Genealogy Research: { NAME } (Task { NAME + LIT } ) \" , LIT : f\" Research Task: { NAME } \\n\\nMatch: { NAME } \\nPriority: Medium\\n\\nThis is a general research task. Consider breaking it down into more specific actions. \" , LIT : LIT , LIT : LIT , LIT : LIT } ) return NAME"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "GenealogicalTaskGenerator._prioritize_and_limit_tasks",
      "lineno": 512,
      "end_lineno": 527,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, tasks)",
      "fingerprint": "45821f07dd9df0311ab1afd14ab92d7ba099ccb0",
      "simhash64": 7452151226028176419,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME : return [ ] # Sort by priority (high > medium > low) NAME = { LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME ( NAME , NAME = lambda NAME : NAME . NAME ( NAME . NAME ( LIT , LIT ) , LIT ) , NAME = True ) # Limit to maximum tasks per person NAME = NAME . NAME [ LIT ] return NAME [ : NAME ]"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "genealogical_task_templates_module_tests",
      "lineno": 534,
      "end_lineno": 1019,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 23,
      "loc": 486,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "json",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "ba0e57e26b2af6d624ccdc249c79f03f883f27ad",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( ) -> NAME : LIT import NAME from NAME import NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # === INITIALIZATION TESTS === def NAME ( ) : LIT # Test core infrastructure imports assert LIT in NAME ( ) , LIT assert LIT in NAME ( ) , LIT # Test class availability assert LIT in NAME ( ) , LIT # Test standard imports NAME = [ LIT , LIT , LIT ] for NAME in NAME : # Check if import is available either directly or through standard_imports NAME = ( NAME in NAME ( ) or NAME ( NAME ( LIT ) , NAME ) or NAME in NAME ( NAME ( NAME ) ) ) assert NAME , f\" Import { NAME } should be available \" def NAME ( ) : LIT NAME = NAME ( ) # Test basic initialization assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME . NAME , NAME ) , LIT assert NAME ( NAME . NAME , NAME ) , LIT # Test GEDCOM AI integration setup assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT def NAME ( ) : LIT NAME = NAME ( ) NAME = NAME . NAME # Test template keys exist NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME , f\" Template { NAME } should be available \" assert NAME ( NAME [ NAME ] , NAME ) , f\" Template { NAME } should be a dictionary \" assert LIT in NAME [ NAME ] , f\" Template { NAME } should have title \" # === CORE FUNCTIONALITY TESTS === def NAME ( ) : LIT NAME = NAME ( ) # Test data NAME = { LIT : [ { LIT : LIT , LIT : [ ] , LIT : None } ] , LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ] , LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT } ] , LIT : [ LIT ] } NAME = { LIT : LIT } NAME = [ LIT ] # Test task generation NAME = NAME . NAME ( NAME , NAME , NAME ) assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME ) > LIT , LIT # Test task structure for NAME in NAME : assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT def NAME ( ) : LIT NAME = NAME ( ) NAME = { LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ] } NAME = NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT if NAME ( NAME ) > LIT : # Only test if tasks were generated NAME = NAME [ LIT ] assert LIT in NAME , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT def NAME ( ) : LIT NAME = NAME ( ) NAME = { LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT } ] } NAME = NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT if NAME ( NAME ) > LIT : # Only test if tasks were generated for NAME in NAME : assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT def NAME ( ) : LIT NAME = NAME ( ) NAME = { LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ] } NAME = NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT if NAME ( NAME ) > LIT : # Only test if tasks were generated for NAME in NAME : assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT # === EDGE CASE TESTS === def NAME ( ) : LIT NAME = NAME ( ) # Test with completely empty data NAME = NAME . NAME ( { } , { } , [ ] ) assert NAME ( NAME , NAME ) , LIT # Test with minimal data NAME = { LIT : LIT } NAME = { LIT : [ ] } NAME = [ ] NAME = NAME . NAME ( NAME , NAME , NAME ) assert NAME ( NAME , NAME ) , LIT def NAME ( ) : LIT NAME = NAME ( ) # Test with invalid template key NAME = NAME . NAME ( LIT , { LIT : LIT } ) assert NAME is None , LIT # Test with empty task data NAME = NAME ( NAME ( NAME . NAME . NAME ( ) ) ) NAME = NAME . NAME ( NAME , { } ) # Should handle empty data gracefully (may return task or None) assert NAME is None or NAME ( NAME , NAME ) , LIT def NAME ( ) : LIT NAME = NAME ( ) NAME = { LIT : LIT } NAME = [ LIT , LIT ] NAME = NAME . NAME ( NAME , NAME ) assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME ) > LIT , LIT for NAME in NAME : assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT # === INTEGRATION TESTS === def NAME ( ) : LIT NAME = NAME ( ) # Test AI availability tracking assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME . NAME , NAME ) , LIT # Test integrator attribute existence assert NAME ( NAME , LIT ) , LIT # integrator may be None if not available, which is fine def NAME ( ) : LIT NAME = NAME ( ) # Create test tasks with different priorities NAME = [ { LIT : LIT , LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT } ] NAME = NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME ) <= NAME ( NAME ) , LIT # Check that high priority tasks come first if any prioritization occurred if NAME ( NAME ) > LIT : NAME = NAME [ LIT ] assert LIT in NAME , LIT def NAME ( ) : LIT NAME = NAME ( ) NAME = NAME . NAME # Test configuration structure assert NAME ( NAME , NAME ) , LIT # Test for expected configuration keys NAME = [ LIT , LIT , LIT ] for NAME in NAME : if NAME in NAME : # Optional keys may not exist assert NAME [ NAME ] is not None , f\" Config key { NAME } should not be None \" # === PERFORMANCE TESTS === def NAME ( ) : LIT NAME = NAME ( ) # Test data NAME = { LIT : [ { LIT : f\" Person { NAME } \" , LIT : [ ] , LIT : None } for NAME in NAME ( LIT ) ] , LIT : [ { LIT : f\" Person { NAME } \" , LIT : LIT , LIT : f\" { LIT + NAME } \" , LIT : LIT } for NAME in NAME ( LIT ) ] , LIT : [ { LIT : f\" Location { NAME } \" , LIT : LIT , LIT : f\" { LIT + NAME } \" } for NAME in NAME ( LIT ) ] } NAME = NAME . NAME ( ) # Run task generation multiple times for NAME in NAME ( LIT ) : NAME = NAME . NAME ( { LIT : LIT } , NAME , [ LIT ] ) assert NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Performance test should complete quickly, took { NAME : .3f } s \" def NAME ( ) : LIT NAME = NAME ( ) NAME = NAME . NAME ( ) # Process multiple template types NAME = NAME ( NAME . NAME . NAME ( ) ) [ : LIT ] # Test first 5 templates for NAME in NAME : for NAME in NAME ( LIT ) : NAME = { LIT : f\" Test Person { NAME } \" , LIT : LIT } NAME = NAME . NAME ( NAME , NAME ) # Task may be None or dict, both are acceptable assert NAME is None or NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Bulk template processing should be fast, took { NAME : .3f } s \" # === ERROR HANDLING TESTS === def NAME ( ) : LIT NAME = NAME ( ) # Test with None inputs (using type ignore for intentional testing) NAME = NAME . NAME ( None , None , None ) # type: ignore assert NAME ( NAME , NAME ) , LIT # Test with invalid data types (using type ignore for intentional testing) NAME = NAME . NAME ( LIT , LIT , LIT ) # type: ignore assert NAME ( NAME , NAME ) , LIT # Test private methods with invalid data NAME = NAME . NAME ( { } ) assert NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( { LIT : LIT } ) assert NAME ( NAME , NAME ) , LIT def NAME ( ) : LIT NAME = NAME ( ) # Test with malformed extracted data NAME = { LIT : LIT , LIT : [ { LIT : LIT } ] , LIT : [ None , { LIT : True } ] } NAME = NAME . NAME ( { LIT : LIT } , NAME , [ LIT ] ) assert NAME ( NAME , NAME ) , LIT # Tasks list may be empty or contain fallback tasks, both are acceptable # Run all tests with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) return NAME . NAME ( )"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_module_imports",
      "lineno": 547,
      "end_lineno": 563,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "json",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "78347061662a85b7c35cdcebf7e84e07acf23396",
      "simhash64": 7488355945914734139,
      "normalized": "def NAME ( ) : LIT # Test core infrastructure imports assert LIT in NAME ( ) , LIT assert LIT in NAME ( ) , LIT # Test class availability assert LIT in NAME ( ) , LIT # Test standard imports NAME = [ LIT , LIT , LIT ] for NAME in NAME : # Check if import is available either directly or through standard_imports NAME = ( NAME in NAME ( ) or NAME ( NAME ( LIT ) , NAME ) or NAME in NAME ( NAME ( NAME ) ) ) assert NAME , f\" Import { NAME } should be available \""
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_task_generator_initialization",
      "lineno": 565,
      "end_lineno": 577,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "07bb08c5971d1143443f8fd1f018cf5bfb6a5958",
      "simhash64": 7451728980209996843,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test basic initialization assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME . NAME , NAME ) , LIT assert NAME ( NAME . NAME , NAME ) , LIT # Test GEDCOM AI integration setup assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_task_templates_structure",
      "lineno": 579,
      "end_lineno": 592,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "effc3318b01aa601fa379c3b11fb7e074b2d2083",
      "simhash64": 7452291963449414715,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) NAME = NAME . NAME # Test template keys exist NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME , f\" Template { NAME } should be available \" assert NAME ( NAME [ NAME ] , NAME ) , f\" Template { NAME } should be a dictionary \" assert LIT in NAME [ NAME ] , f\" Template { NAME } should have title \""
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_basic_task_generation",
      "lineno": 595,
      "end_lineno": 630,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 36,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "d8d8185c6412783a89b2e54794d35e3e21123d89",
      "simhash64": 5145887070563505711,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test data NAME = { LIT : [ { LIT : LIT , LIT : [ ] , LIT : None } ] , LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ] , LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT } ] , LIT : [ LIT ] } NAME = { LIT : LIT } NAME = [ LIT ] # Test task generation NAME = NAME . NAME ( NAME , NAME , NAME ) assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME ) > LIT , LIT # Test task structure for NAME in NAME : assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_vital_records_task_generation",
      "lineno": 632,
      "end_lineno": 650,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "671558673858d3a016b43ab38a2cbcdedeefb183",
      "simhash64": 5145887104926389803,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) NAME = { LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ] } NAME = NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT if NAME ( NAME ) > LIT : # Only test if tasks were generated NAME = NAME [ LIT ] assert LIT in NAME , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_location_task_generation",
      "lineno": 652,
      "end_lineno": 669,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "e5f2573f8745fd4253246118a0ab732143bb96a2",
      "simhash64": 7451729014636844587,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) NAME = { LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT } ] } NAME = NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT if NAME ( NAME ) > LIT : # Only test if tasks were generated for NAME in NAME : assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_occupation_task_generation",
      "lineno": 671,
      "end_lineno": 688,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "30be5e2c55ada0f838559ee60fda991f3cc5e3c9",
      "simhash64": 7451730114140083755,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) NAME = { LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ] } NAME = NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT if NAME ( NAME ) > LIT : # Only test if tasks were generated for NAME in NAME : assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_empty_data_handling",
      "lineno": 691,
      "end_lineno": 705,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d1c40dc30a1ac6bac6b23d846f651fbce075ff67",
      "simhash64": 7452291934459958331,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test with completely empty data NAME = NAME . NAME ( { } , { } , [ ] ) assert NAME ( NAME , NAME ) , LIT # Test with minimal data NAME = { LIT : LIT } NAME = { LIT : [ ] } NAME = [ ] NAME = NAME . NAME ( NAME , NAME , NAME ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_invalid_template_handling",
      "lineno": 707,
      "end_lineno": 719,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7368f89e0d111a048d338a39a2ea57b5876ecc95",
      "simhash64": 7488179993989518371,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test with invalid template key NAME = NAME . NAME ( LIT , { LIT : LIT } ) assert NAME is None , LIT # Test with empty task data NAME = NAME ( NAME ( NAME . NAME . NAME ( ) ) ) NAME = NAME . NAME ( NAME , { } ) # Should handle empty data gracefully (may return task or None) assert NAME is None or NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_fallback_task_creation",
      "lineno": 721,
      "end_lineno": 736,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "19526a953f0462120ec8c3c0fe144a0b3aef27f4",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) NAME = { LIT : LIT } NAME = [ LIT , LIT ] NAME = NAME . NAME ( NAME , NAME ) assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME ) > LIT , LIT for NAME in NAME : assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_gedcom_ai_integration",
      "lineno": 739,
      "end_lineno": 748,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "de2f7af25f663e75eaf9c15d9a3ff570f6d81b68",
      "simhash64": 7451728980480005167,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test AI availability tracking assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME . NAME , NAME ) , LIT # Test integrator attribute existence assert NAME ( NAME , LIT ) , LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_task_prioritization",
      "lineno": 751,
      "end_lineno": 771,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6c8e94ad424e59bd598f05ac954fe209c5d6311b",
      "simhash64": 5145887104923244075,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Create test tasks with different priorities NAME = [ { LIT : LIT , LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT , LIT : LIT } ] NAME = NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME ) <= NAME ( NAME ) , LIT # Check that high priority tasks come first if any prioritization occurred if NAME ( NAME ) > LIT : NAME = NAME [ LIT ] assert LIT in NAME , LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_template_configuration_loading",
      "lineno": 773,
      "end_lineno": 785,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f388d2c681d0bec23f57013d8114516893570025",
      "simhash64": 7452291963517572147,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) NAME = NAME . NAME # Test configuration structure assert NAME ( NAME , NAME ) , LIT # Test for expected configuration keys NAME = [ LIT , LIT , LIT ] for NAME in NAME : if NAME in NAME : # Optional keys may not exist assert NAME [ NAME ] is not None , f\" Config key { NAME } should not be None \""
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_performance",
      "lineno": 788,
      "end_lineno": 820,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 33,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "d5e47b9cc39ea0120dd7358570e3b130cc3486cf",
      "simhash64": 7451729014562395707,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test data NAME = { LIT : [ { LIT : f\" Person { NAME } \" , LIT : [ ] , LIT : None } for NAME in NAME ( LIT ) ] , LIT : [ { LIT : f\" Person { NAME } \" , LIT : LIT , LIT : f\" { LIT + NAME } \" , LIT : LIT } for NAME in NAME ( LIT ) ] , LIT : [ { LIT : f\" Location { NAME } \" , LIT : LIT , LIT : f\" { LIT + NAME } \" } for NAME in NAME ( LIT ) ] } NAME = NAME . NAME ( ) # Run task generation multiple times for NAME in NAME ( LIT ) : NAME = NAME . NAME ( { LIT : LIT } , NAME , [ LIT ] ) assert NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Performance test should complete quickly, took { NAME : .3f } s \""
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_bulk_template_processing",
      "lineno": 822,
      "end_lineno": 839,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 18,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "55f9a301e3ba726923d73cd89080d9a9fcb6e139",
      "simhash64": 7452151227102958643,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) NAME = NAME . NAME ( ) # Process multiple template types NAME = NAME ( NAME . NAME . NAME ( ) ) [ : LIT ] # Test first 5 templates for NAME in NAME : for NAME in NAME ( LIT ) : NAME = { LIT : f\" Test Person { NAME } \" , LIT : LIT } NAME = NAME . NAME ( NAME , NAME ) # Task may be None or dict, both are acceptable assert NAME is None or NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Bulk template processing should be fast, took { NAME : .3f } s \""
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_error_handling",
      "lineno": 842,
      "end_lineno": 859,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6a33d44a212dfa98e51214d5c434b18ab00b994a",
      "simhash64": 7487792965897065519,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test with None inputs (using type ignore for intentional testing) NAME = NAME . NAME ( None , None , None ) # type: ignore assert NAME ( NAME , NAME ) , LIT # Test with invalid data types (using type ignore for intentional testing) NAME = NAME . NAME ( LIT , LIT , LIT ) # type: ignore assert NAME ( NAME , NAME ) , LIT # Test private methods with invalid data NAME = NAME . NAME ( { } ) assert NAME ( NAME , NAME ) , LIT NAME = NAME . NAME ( { LIT : LIT } ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "test_malformed_data_handling",
      "lineno": 861,
      "end_lineno": 878,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d5c3dfd707545cef75ccc309b45af4a60f38e829",
      "simhash64": 7452854880176608815,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test with malformed extracted data NAME = { LIT : LIT , LIT : [ { LIT : LIT } ] , LIT : [ None , { LIT : True } ] } NAME = NAME . NAME ( { LIT : LIT } , NAME , [ LIT ] ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "genealogical_task_templates.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 1022,
      "end_lineno": 1024,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "HealthMetric.status",
      "lineno": 64,
      "end_lineno": 74,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "6ee57a44ac15c6b28f85e256501ae58f4ef8cd91",
      "simhash64": 7488109654235853891,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if NAME . NAME >= NAME . NAME : return NAME . NAME if NAME . NAME >= NAME . NAME : return NAME . NAME if NAME . NAME >= NAME . NAME * LIT : return NAME . NAME if NAME . NAME >= NAME . NAME * LIT : return NAME . NAME return NAME . NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.__init__",
      "lineno": 95,
      "end_lineno": 148,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 54,
      "tags": [
        "pure-ish",
        "time",
        "regex",
        "purpose:initialization",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "35f0ace5585866130bdf215630b49d3f72581143",
      "simhash64": 7452080857283998807,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME : NAME = NAME ( NAME = LIT ) NAME . NAME = NAME . NAME ( ) NAME . NAME = NAME . NAME ( ) NAME . NAME = False NAME . NAME = NAME . NAME ( ) # Performance tracking NAME . NAME : NAME = NAME ( NAME = LIT ) NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME : NAME = NAME ( NAME = LIT ) NAME . NAME : NAME = NAME ( NAME = LIT ) # Enhanced error rate monitoring - PERFORMANCE OPTIMIZED NAME . NAME : NAME = NAME ( NAME = LIT ) # Increased for 20+ hour sessions NAME . NAME : NAME [ NAME , NAME ] = { } # Track when warnings were sent NAME . NAME : NAME = NAME . NAME ( ) # Metric alert de-duplication (prevents alert spam on repeated updates) NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME : NAME = LIT # Only re-log after 60s unless level escalates # Performance optimization for long sessions NAME . NAME : NAME = LIT # Base monitoring interval NAME . NAME : NAME = True # Enable adaptive monitoring NAME . NAME : NAME = NAME . NAME ( ) NAME . NAME : NAME = LIT # Clean up every 5 minutes # Automatic intervention flags NAME . NAME : NAME = False NAME . NAME : NAME = LIT NAME . NAME : NAME = LIT NAME . NAME : NAME = False NAME . NAME : NAME = LIT NAME . NAME : NAME = LIT NAME . NAME : NAME = False NAME . NAME : NAME = LIT NAME . NAME : NAME = LIT # Predictive analytics NAME . NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] NAME . NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] # Safety test mode flag to standardize alert prefixes NAME . NAME : NAME = False # Initialize metrics NAME . NAME ( ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor._initialize_metrics",
      "lineno": 150,
      "end_lineno": 171,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "fdd3469afb4b8b4ff8ef1012b330f3e31eb7e010",
      "simhash64": 5150381874097853999,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME = { LIT : { LIT : LIT , LIT : LIT , LIT : LIT } , # OPTIMIZATION: Less pessimistic thresholds (was 5.0/10.0) LIT : { LIT : LIT , LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT , LIT : LIT } , # WORKLOAD-APPROPRIATE: Errors per hour for 724-page workload LIT : { LIT : LIT , LIT : LIT , LIT : LIT } , # WORKLOAD-APPROPRIATE: 10-20 hours for 724 pages LIT : { LIT : LIT , LIT : LIT , LIT : LIT } , # WORKLOAD-APPROPRIATE: 2-3 hours browser lifetime LIT : { LIT : LIT , LIT : LIT , LIT : LIT } , # WORKLOAD-APPROPRIATE: More pages before refresh LIT : { LIT : LIT , LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT , LIT : LIT } , } for NAME , NAME in NAME . NAME ( ) : NAME . NAME [ NAME ] = NAME ( NAME = NAME , NAME = LIT , NAME = NAME [ LIT ] , NAME = NAME [ LIT ] , NAME = NAME [ LIT ] ) NAME . NAME [ NAME ] = NAME ( NAME = LIT )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.begin_safety_test",
      "lineno": 173,
      "end_lineno": 175,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "6abb2046431aebfbeac14f960fa191a8ad3c8c8c",
      "simhash64": 8642403870186050563,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = True"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.end_safety_test",
      "lineno": 177,
      "end_lineno": 179,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "352b6dd22ebc6ca88e2eaf29d4f40f12c7d2e053",
      "simhash64": 8605249203325015139,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = False"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor._safety_prefix",
      "lineno": 181,
      "end_lineno": 183,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "0b49f86c20d85ab2f0c5332dc5d2dbef3cd9fd7d",
      "simhash64": 5186972554856141859,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return LIT if NAME . NAME else LIT"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.update_metric",
      "lineno": 185,
      "end_lineno": 196,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, name, value)",
      "fingerprint": "5b84bcaf6edfca579546dd8e2d8ee88cedd126a8",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) : LIT with NAME . NAME : if NAME in NAME . NAME : NAME . NAME [ NAME ] . NAME = NAME NAME . NAME [ NAME ] . NAME = NAME . NAME ( ) NAME . NAME [ NAME ] . NAME ( ( NAME . NAME ( ) , NAME ) ) # Check for alerts NAME . NAME ( NAME ) else : NAME . NAME ( f\" Unknown health metric: { NAME } \" )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor._check_metric_alerts",
      "lineno": 198,
      "end_lineno": 237,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 40,
      "tags": [
        "pure-ish",
        "time",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, metric_name)",
      "fingerprint": "ec6a348837f072e150c2af33f0a3eb617d0c736a",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT NAME = NAME . NAME [ NAME ] NAME : NAME [ NAME ] = None NAME : NAME = LIT NAME : NAME = LIT if NAME . NAME >= NAME . NAME : NAME = NAME . NAME NAME = f\" { NAME } is critical: { NAME . NAME : .2f } >= { NAME . NAME } \" NAME = NAME . NAME elif NAME . NAME >= NAME . NAME : NAME = NAME . NAME NAME = f\" { NAME } is elevated: { NAME . NAME : .2f } >= { NAME . NAME } \" NAME = NAME . NAME if NAME is None : # Reset last level so future crossings log again NAME . NAME . NAME ( NAME , None ) return # Gate logs: only log when escalating level or after cooldown NAME = NAME . NAME . NAME ( NAME ) NAME = NAME . NAME . NAME ( NAME , LIT ) NAME = NAME . NAME ( ) NAME = False if NAME is None : NAME = True elif NAME . NAME != NAME . NAME : # Escalation from WARNING->CRITICAL (or vice versa) should log NAME = True elif ( NAME - NAME ) >= NAME . NAME : NAME = True if NAME : NAME . NAME ( NAME , LIT , NAME , NAME , NAME . NAME , NAME ) NAME . NAME [ NAME ] = NAME NAME . NAME [ NAME ] = NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor._create_alert",
      "lineno": 239,
      "end_lineno": 261,
      "is_method": true,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 23,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, level, component, message, metric_name, metric_value, threshold)",
      "fingerprint": "46f90d45b2d9bc1766ed83116653c57e80424ed4",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) : LIT NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) NAME . NAME . NAME ( NAME ) # Log alert with standardized safety test prefix when in test mode NAME = NAME . NAME ( ) if NAME == NAME . NAME : NAME . NAME ( f\" { NAME } \ud83d\udea8 CRITICAL ALERT: { NAME } \" ) elif NAME == NAME . NAME : NAME . NAME ( f\" { NAME } \u26a0\ufe0f WARNING: { NAME } \" ) else : NAME . NAME ( f\" { NAME } INFO: { NAME } \" )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.calculate_health_score",
      "lineno": 263,
      "end_lineno": 297,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 35,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "f7256805b057e4d58eb5a79d7522f329fd4ad8ed",
      "simhash64": 7452080857283998739,
      "normalized": "def NAME ( NAME ) -> NAME : LIT with NAME . NAME : NAME = LIT NAME = LIT for NAME in NAME . NAME . NAME ( ) : # Calculate metric score (0-100) if NAME . NAME <= NAME . NAME * LIT : NAME = LIT # Excellent elif NAME . NAME <= NAME . NAME * LIT : NAME = LIT # Good elif NAME . NAME <= NAME . NAME : NAME = LIT # Fair elif NAME . NAME <= NAME . NAME : NAME = LIT # Poor else : NAME = LIT # Critical # Apply weighted average NAME += NAME * NAME . NAME NAME += NAME . NAME # Calculate final weighted score NAME = NAME / NAME if NAME > LIT else LIT # Store in history NAME . NAME . NAME ( ( NAME . NAME ( ) , NAME ) ) return NAME ( LIT , NAME ( LIT , NAME ) )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.get_health_status",
      "lineno": 299,
      "end_lineno": 311,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 13,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "acf9b8dec6c9b06f8acce9f03041bc4ba3765799",
      "simhash64": 7488180023047140355,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) if NAME >= LIT : return NAME . NAME if NAME >= LIT : return NAME . NAME if NAME >= LIT : return NAME . NAME if NAME >= LIT : return NAME . NAME return NAME . NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.predict_session_death_risk",
      "lineno": 313,
      "end_lineno": 361,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 14,
      "loc": 49,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "75bdf70284ee90d498c038ae8a1ae51c24edf8bc",
      "simhash64": 7452081956795626531,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = LIT # Base risk from current health score (more aggressive) NAME = NAME . NAME ( ) NAME = ( LIT - NAME ) / LIT * LIT # Increased from 0.4 NAME += NAME # Risk from API response time trend (more sensitive) if NAME ( NAME . NAME ) >= LIT : # Reduced from 5 NAME = NAME ( NAME ( NAME . NAME ) [ - LIT : ] ) / LIT if NAME > LIT : NAME += LIT # Increased from 0.3 elif NAME > LIT : NAME += LIT # New threshold elif NAME > LIT : NAME += LIT # Increased from 0.15 # Risk from error rate (more aggressive) NAME = NAME ( NAME . NAME . NAME ( ) ) if NAME > LIT : NAME += LIT # Increased from 0.2 elif NAME > LIT : NAME += LIT # Increased from 0.2 elif NAME > LIT : NAME += LIT # Increased from 0.1 # Risk from memory usage trend if NAME ( NAME . NAME ) >= LIT : NAME = NAME ( NAME . NAME ) [ - LIT ] - NAME ( NAME . NAME ) [ - LIT ] if NAME > LIT : # Memory increasing very rapidly NAME += LIT # Increased from 0.1 elif NAME > LIT : # Memory increasing rapidly NAME += LIT # Additional risk factors for critical metrics for NAME , NAME in NAME . NAME . NAME ( ) : if NAME . NAME >= NAME . NAME : NAME += LIT # Each critical metric adds significant risk elif NAME . NAME >= NAME . NAME : NAME += LIT # Each warning metric adds some risk return NAME ( LIT , NAME )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.get_recommended_actions",
      "lineno": 363,
      "end_lineno": 387,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 25,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "910a31c85be22d9edceefb2c943575e0183e8d95",
      "simhash64": 7487617074167460899,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME = [ ] NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) if NAME > LIT : NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) elif NAME > LIT : NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) elif NAME > LIT : NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) elif NAME < LIT : NAME . NAME ( LIT ) NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.record_api_response_time",
      "lineno": 389,
      "end_lineno": 396,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(self, response_time)",
      "fingerprint": "612c508f38791270abd0025340fcacb5797a91d3",
      "simhash64": 7488215207419229187,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT NAME . NAME . NAME ( NAME ) # Update metric if NAME ( NAME . NAME ) >= LIT : NAME = NAME ( NAME ( NAME . NAME ) [ - LIT : ] ) / LIT NAME . NAME ( LIT , NAME )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.record_error",
      "lineno": 398,
      "end_lineno": 416,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 19,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, error_type)",
      "fingerprint": "3bd035aef231999eed9d5d35e149523575016568",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT NAME = NAME . NAME ( ) if NAME not in NAME . NAME : NAME . NAME [ NAME ] = LIT NAME . NAME [ NAME ] += LIT # Track error timestamp for rate analysis NAME . NAME . NAME ( NAME ) # Update error rate metric NAME = NAME ( NAME . NAME . NAME ( ) ) NAME = ( NAME - NAME . NAME ) / LIT NAME = NAME / NAME ( NAME , LIT ) # Errors per hour NAME . NAME ( LIT , NAME ) # Check for early warning conditions NAME . NAME ( NAME )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor._check_error_rate_early_warning",
      "lineno": 418,
      "end_lineno": 480,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 12,
      "loc": 63,
      "tags": [
        "pure-ish",
        "time",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, current_time)",
      "fingerprint": "e82615984f3bb4d2d89017a3ee64592c9fe8f37e",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT # Adaptive monitoring interval based on current error rate NAME = NAME . NAME ( NAME ) # Only check at adaptive intervals to reduce overhead if NAME - NAME . NAME < NAME : return NAME . NAME = NAME # PERFORMANCE: Efficient cleanup with batched operations NAME . NAME ( NAME ) # Check different time windows for early warning - WORKLOAD-APPROPRIATE for 724 pages NAME = [ ( LIT , LIT , LIT ) , # 500 errors in 30 minutes (cascade failure) ( LIT , LIT , LIT ) , # 200 errors in 15 minutes (severe issues) ( LIT , LIT , LIT ) , # 75 errors in 5 minutes (moderate issues) ( LIT , LIT , LIT ) , # 15 errors in 1 minute (immediate issues) ] for NAME , NAME , NAME in NAME : NAME = NAME - NAME NAME = NAME ( LIT for NAME in NAME . NAME if NAME >= NAME ) if NAME >= NAME : NAME = f\" { NAME } _ { NAME } \" # Only send warning once per hour for each threshold NAME = NAME . NAME . NAME ( NAME , LIT ) if NAME - NAME > LIT : # 1 hour NAME . NAME [ NAME ] = NAME # Create critical alert NAME = NAME ( NAME = NAME . NAME , NAME = LIT , NAME = f\" \ud83d\udea8 HIGH ERROR RATE: { NAME } errors in { NAME } (threshold: { NAME } ) \" , NAME = LIT , NAME = NAME , NAME = NAME , NAME = NAME ) NAME . NAME . NAME ( NAME ) NAME = NAME . NAME ( ) NAME . NAME ( f\" { NAME } \ud83d\udea8 CRITICAL ALERT: { NAME . NAME } \" ) # WORKLOAD-APPROPRIATE: Cascade failure detection with automatic intervention if NAME == LIT and NAME >= LIT : NAME . NAME ( f\" { NAME } \ud83d\udea8 CASCADE FAILURE DETECTED - EMERGENCY INTERVENTION REQUIRED \" ) NAME . NAME ( LIT , NAME , NAME ) elif NAME == LIT and NAME >= LIT : NAME . NAME ( f\" { NAME } \ud83d\udea8 SEVERE ERROR PATTERN DETECTED - Triggering immediate intervention \" ) NAME . NAME ( LIT , NAME , NAME ) elif NAME == LIT and NAME >= LIT : NAME . NAME ( f\" { NAME } \u26a0\ufe0f ELEVATED ERROR RATE - Triggering enhanced monitoring \" ) NAME . NAME ( LIT , NAME , NAME )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.get_error_rate_statistics",
      "lineno": 482,
      "end_lineno": 541,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 60,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "4773023e117cc042c22db85866d574f38e510851",
      "simhash64": 5145886005423150123,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME ( ) # Calculate error rates for different time windows NAME = [ ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) ] NAME = { } for NAME , NAME in NAME : NAME = NAME - NAME NAME = NAME ( LIT for NAME in NAME . NAME if NAME >= NAME ) NAME [ NAME ] = { LIT : NAME , LIT : NAME / ( NAME / LIT ) , LIT : NAME } # Determine risk level - WORKLOAD-APPROPRIATE for 724-page processing NAME = NAME [ LIT ] [ LIT ] NAME = NAME [ LIT ] [ LIT ] NAME = NAME [ LIT ] [ LIT ] if NAME >= LIT : NAME = LIT NAME = LIT elif NAME >= LIT : NAME = LIT NAME = LIT elif NAME >= LIT : NAME = LIT NAME = LIT elif NAME >= LIT : NAME = LIT NAME = LIT else : NAME = LIT NAME = LIT return { LIT : NAME , LIT : NAME , LIT : NAME ( NAME . NAME . NAME ( ) ) , LIT : ( NAME - NAME . NAME ) / LIT , LIT : NAME , LIT : NAME , LIT : NAME ( NAME . NAME ) , LIT : [ NAME for NAME in NAME . NAME if NAME - NAME . NAME < LIT ] }"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor._trigger_emergency_intervention",
      "lineno": 543,
      "end_lineno": 571,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 29,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, pattern_type, error_count, window)",
      "fingerprint": "af9064f308c657e29a713ee82dc27a6e3fbb3d1d",
      "simhash64": 7452116041588970515,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME ) -> None : LIT try : NAME = NAME . NAME ( ) NAME . NAME ( f\" { NAME } \ud83d\udea8 EMERGENCY INTERVENTION TRIGGERED: { NAME } \" ) NAME . NAME ( f\" { NAME } Pattern: { NAME } errors in { NAME } \" ) NAME . NAME ( f\" { NAME } Action: Setting emergency halt flag \" ) # Set emergency halt flag that can be checked by main processing loops NAME . NAME = True NAME . NAME = f\" { NAME } : { NAME } errors in { NAME } \" NAME . NAME = NAME . NAME ( ) # Create critical alert NAME = NAME ( NAME = NAME . NAME , NAME = LIT , NAME = f\" \ud83d\udea8 EMERGENCY HALT: { NAME } - { NAME } errors in { NAME } \" , NAME = LIT , NAME = NAME , NAME = LIT if NAME == LIT else LIT , NAME = NAME . NAME ( ) ) NAME . NAME . NAME ( NAME ) NAME . NAME ( f\" { NAME . NAME ( ) } \ud83d\udea8 EMERGENCY INTERVENTION COMPLETE - Processing should halt immediately \" ) except NAME as NAME : NAME . NAME ( f\" Failed to trigger emergency intervention: { NAME } \" )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor._trigger_immediate_intervention",
      "lineno": 573,
      "end_lineno": 601,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 29,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, pattern_type, error_count, window)",
      "fingerprint": "da45ce0ca6c803f0e7e53bae728c6181b192f09f",
      "simhash64": 7452116041588970523,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME ) -> None : LIT try : NAME = NAME . NAME ( ) NAME . NAME ( f\" { NAME } \u26a0\ufe0f IMMEDIATE INTERVENTION TRIGGERED: { NAME } \" ) NAME . NAME ( f\" { NAME } Pattern: { NAME } errors in { NAME } \" ) NAME . NAME ( f\" { NAME } Action: Setting immediate halt flag and triggering recovery \" ) # Set immediate intervention flag NAME . NAME = True NAME . NAME = f\" { NAME } : { NAME } errors in { NAME } \" NAME . NAME = NAME . NAME ( ) # Create critical alert NAME = NAME ( NAME = NAME . NAME , NAME = LIT , NAME = f\" \u26a0\ufe0f IMMEDIATE INTERVENTION: { NAME } - { NAME } errors in { NAME } \" , NAME = LIT , NAME = NAME , NAME = LIT if NAME == LIT else LIT , NAME = NAME . NAME ( ) ) NAME . NAME . NAME ( NAME ) NAME . NAME ( f\" { NAME . NAME ( ) } \u26a0\ufe0f IMMEDIATE INTERVENTION COMPLETE - Consider halting or recovery \" ) except NAME as NAME : NAME . NAME ( f\" Failed to trigger immediate intervention: { NAME } \" )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor._trigger_enhanced_monitoring",
      "lineno": 603,
      "end_lineno": 634,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 32,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, pattern_type, error_count, window)",
      "fingerprint": "5022d937c7854e681c9d277106f0610b398238c6",
      "simhash64": 7452116041588970523,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME ) -> None : LIT try : NAME = NAME . NAME ( ) NAME . NAME ( f\" { NAME } \ud83d\udcca ENHANCED MONITORING TRIGGERED: { NAME } \" ) NAME . NAME ( f\" { NAME } Pattern: { NAME } errors in { NAME } \" ) NAME . NAME ( f\" { NAME } Action: Increasing monitoring frequency \" ) # Set enhanced monitoring flag NAME . NAME = True NAME . NAME = f\" { NAME } : { NAME } errors in { NAME } \" NAME . NAME = NAME . NAME ( ) # Reduce monitoring interval for enhanced monitoring NAME . NAME = NAME . NAME ( ) - LIT # Check again in 5 seconds instead of 30 # Create warning alert NAME = NAME ( NAME = NAME . NAME , NAME = LIT , NAME = f\" \ud83d\udcca ENHANCED MONITORING: { NAME } - { NAME } errors in { NAME } \" , NAME = LIT , NAME = NAME , NAME = LIT , NAME = NAME . NAME ( ) ) NAME . NAME . NAME ( NAME ) NAME . NAME ( f\" { NAME . NAME ( ) } \ud83d\udcca ENHANCED MONITORING ACTIVE - Increased error rate surveillance \" ) except NAME as NAME : NAME . NAME ( f\" Failed to trigger enhanced monitoring: { NAME } \" )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.should_emergency_halt",
      "lineno": 636,
      "end_lineno": 638,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "7cf791c4ea854fe6df646a3cb215382778b2a514",
      "simhash64": 7488109654235849795,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.should_immediate_intervention",
      "lineno": 640,
      "end_lineno": 642,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "7cf791c4ea854fe6df646a3cb215382778b2a514",
      "simhash64": 7488109654235849795,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.is_enhanced_monitoring_active",
      "lineno": 644,
      "end_lineno": 646,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "7cf791c4ea854fe6df646a3cb215382778b2a514",
      "simhash64": 7488109654235849795,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.get_intervention_status",
      "lineno": 648,
      "end_lineno": 666,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "ac1cf8990d94fc9e48ae2582c51a44dbc2bbae1f",
      "simhash64": 7457359613615576107,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME } , LIT : { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME } , LIT : { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME } }"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.reset_intervention_flags",
      "lineno": 668,
      "end_lineno": 679,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "977cb1eb7b1a5fca8fa66c3d920e97728143023e",
      "simhash64": 16675453993650402323,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME ( LIT ) NAME . NAME = False NAME . NAME = LIT NAME . NAME = LIT NAME . NAME = False NAME . NAME = LIT NAME . NAME = LIT NAME . NAME = False NAME . NAME = LIT NAME . NAME = LIT"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor._get_adaptive_monitoring_interval",
      "lineno": 681,
      "end_lineno": 707,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 7,
      "loc": 27,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, current_time)",
      "fingerprint": "0302c1b84fad809ad52848eb64f4f002cbe24ae2",
      "simhash64": 5146450053814465591,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT try : # Base interval NAME = NAME . NAME # If enhanced monitoring is active, check more frequently if NAME . NAME : NAME = LIT # Check every 5 seconds during enhanced monitoring else : # Adaptive interval based on recent error rate NAME = NAME ( LIT for NAME in NAME . NAME if NAME - NAME < LIT ) # Last 5 minutes if NAME >= LIT : NAME = LIT # High error rate - check every 10 seconds elif NAME >= LIT : NAME = LIT # Moderate error rate - check every 20 seconds elif NAME >= LIT : NAME = LIT # Low error rate - normal interval else : NAME = LIT # Very low error rate - check every minute return NAME except NAME as NAME : NAME . NAME ( f\" Error calculating adaptive interval: { NAME } \" ) return NAME . NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor._perform_efficient_cleanup",
      "lineno": 709,
      "end_lineno": 746,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 10,
      "loc": 38,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, current_time)",
      "fingerprint": "33d8bba3d95112c9470ea3399c24889b2cb44033",
      "simhash64": 7488109654302962771,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT try : # Only perform cleanup every 5 minutes to reduce overhead if NAME - NAME . NAME < NAME . NAME : return NAME . NAME = NAME # Clean old error timestamps (older than 2 hours for long sessions) NAME = NAME - LIT # 2 hours # PERFORMANCE: Batch cleanup instead of one-by-one NAME = LIT while NAME . NAME and NAME . NAME [ LIT ] < NAME : NAME . NAME . NAME ( ) NAME += LIT # Prevent excessive cleanup in one operation if NAME > LIT : break # Clean old warning timestamps NAME = NAME - LIT # 1 hour NAME = [ NAME for NAME , NAME in NAME . NAME . NAME ( ) if NAME < NAME ] for NAME in NAME : del NAME . NAME [ NAME ] # Clean old alerts (keep only last 4 hours) NAME = NAME - LIT # 4 hours NAME . NAME = [ NAME for NAME in NAME . NAME if NAME . NAME >= NAME ] if NAME > LIT : NAME . NAME ( f\" Cleaned up { NAME } old error timestamps and { NAME ( NAME ) } old warnings \" ) except NAME as NAME : NAME . NAME ( f\" Error during efficient cleanup: { NAME } \" )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.optimize_for_long_session",
      "lineno": 748,
      "end_lineno": 773,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "6490eabc6286e96841033130b49decb500dc996b",
      "simhash64": 7488109654302962707,
      "normalized": "def NAME ( NAME ) -> None : LIT try : NAME . NAME ( LIT ) # Increase monitoring intervals to reduce overhead NAME . NAME = LIT # Check every minute instead of 30 seconds NAME . NAME = LIT # Clean up every 10 minutes instead of 5 # Increase deque sizes for longer data retention if NAME . NAME . NAME is None or NAME . NAME . NAME < LIT : # Create new deque with larger size and copy existing data NAME = NAME ( NAME . NAME ) NAME . NAME = NAME ( NAME , NAME = LIT ) # Optimize metrics history for longer sessions for NAME in NAME . NAME : NAME = NAME . NAME [ NAME ] . NAME if NAME is None or NAME < LIT : NAME = NAME ( NAME . NAME [ NAME ] ) NAME . NAME [ NAME ] = NAME ( NAME , NAME = LIT ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Failed to optimize for long session: { NAME } \" )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.get_performance_stats",
      "lineno": 775,
      "end_lineno": 800,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 26,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "d58cffd945788fd3fc3bd66090773f74f0ad7407",
      "simhash64": 7451588277081379883,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT try : NAME = NAME . NAME ( ) NAME = ( NAME - NAME . NAME ) / LIT # Hours return { LIT : NAME , LIT : NAME ( NAME . NAME ) , LIT : NAME . NAME . NAME , LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , LIT : NAME . NAME , LIT : NAME . NAME , LIT : ( NAME - NAME . NAME ) / LIT , LIT : { LIT : f\" { NAME ( NAME . NAME ) } / { NAME . NAME . NAME } \" , LIT : NAME ( NAME ( NAME ) for NAME in NAME . NAME . NAME ( ) ) , LIT : LIT , LIT : LIT } } except NAME as NAME : NAME . NAME ( f\" Error getting performance stats: { NAME } \" ) return { LIT : NAME ( NAME ) }"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.record_page_processing_time",
      "lineno": 802,
      "end_lineno": 804,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(self, processing_time)",
      "fingerprint": "c2664991185302329ef95477bb2bd28562c3caf0",
      "simhash64": 7488180024053769219,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.update_system_metrics",
      "lineno": 806,
      "end_lineno": 824,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "90589d387aef8600a677c01835f3f2fb3f8fd53f",
      "simhash64": 7487652257398699027,
      "normalized": "def NAME ( NAME ) -> None : LIT try : # Memory usage NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) . NAME / LIT / LIT NAME . NAME . NAME ( NAME ) NAME . NAME ( LIT , NAME ) # CPU usage NAME = NAME . NAME ( NAME = LIT ) NAME . NAME ( LIT , NAME ) # Disk usage NAME = NAME . NAME ( LIT ) . NAME NAME . NAME ( LIT , NAME ) except NAME as NAME : NAME . NAME ( f\" Error updating system metrics: { NAME } \" )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.update_session_metrics",
      "lineno": 826,
      "end_lineno": 867,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 14,
      "loc": 42,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, session_manager)",
      "fingerprint": "14f9bd404c7f4141f8141cb1a56c2f245667389c",
      "simhash64": 8640573762005537835,
      "normalized": "def NAME ( NAME , NAME : NAME = None ) -> None : LIT try : # Session age NAME = ( NAME . NAME ( ) - NAME . NAME ) / LIT NAME . NAME ( LIT , NAME ) if NAME : # Handle browser health monitor if NAME ( NAME , LIT ) : try : NAME = NAME . NAME # Check if monitor is a dict-like object if NAME ( NAME , LIT ) or NAME ( NAME , NAME ) : # Browser age NAME = NAME . NAME ( LIT ) if NAME ( NAME , LIT ) else NAME . NAME ( LIT , NAME . NAME ( ) ) if NAME : NAME = ( NAME . NAME ( ) - NAME ) / LIT NAME . NAME ( LIT , NAME ) # Pages since refresh NAME = NAME . NAME ( LIT ) if NAME ( NAME , LIT ) else NAME . NAME ( LIT , LIT ) if NAME is not None : NAME . NAME ( LIT , NAME ) except NAME as NAME : NAME . NAME ( f\" Browser health monitor update failed: { NAME } \" ) # Handle session health monitor if NAME ( NAME , LIT ) : try : NAME = NAME . NAME if NAME ( NAME , LIT ) or NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT ) if NAME ( NAME , LIT ) else NAME . NAME ( LIT , NAME . NAME ( ) ) if NAME : NAME = ( NAME . NAME ( ) - NAME ) / LIT NAME . NAME ( LIT , NAME ) except NAME as NAME : NAME . NAME ( f\" Session health monitor update failed: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Error updating session metrics: { NAME } \" )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.get_health_dashboard",
      "lineno": 869,
      "end_lineno": 902,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 34,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "5e6b6b4931679a2ca4a76c930b899a4824047f18",
      "simhash64": 7451588276074746883,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) return { LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME . NAME , LIT : NAME , LIT : NAME . NAME ( NAME ) , LIT : { NAME : { LIT : NAME . NAME , LIT : NAME . NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME } for NAME , NAME in NAME . NAME . NAME ( ) } , LIT : [ { LIT : NAME . NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME } for NAME in NAME . NAME [ - LIT : ] # Last 5 alerts ] , LIT : NAME . NAME ( ) , LIT : { LIT : NAME ( NAME . NAME ) / NAME ( NAME . NAME ) if NAME . NAME else LIT , LIT : NAME ( NAME . NAME . NAME ( ) ) , LIT : NAME ( NAME . NAME ) / NAME ( NAME . NAME ) if NAME . NAME else LIT , LIT : NAME . NAME [ - LIT ] if NAME . NAME else LIT } }"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor._get_risk_level",
      "lineno": 904,
      "end_lineno": 914,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, risk_score)",
      "fingerprint": "dcb316ae2a1637b1277046dfe1fe51e654e9561f",
      "simhash64": 5762870349681563179,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT if NAME > LIT : return LIT if NAME > LIT : return LIT if NAME > LIT : return LIT if NAME > LIT : return LIT return LIT"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.log_health_summary",
      "lineno": 916,
      "end_lineno": 928,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "8787fc6d65707251cfe4b48675d3480ffead0394",
      "simhash64": 7434136827518693427,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME = NAME . NAME ( ) NAME . NAME ( LIT ) NAME . NAME ( f\" Score: { NAME [ LIT ] : .1f } /100 ( { NAME [ LIT ] . NAME ( ) } ) \" ) NAME . NAME ( f\" Risk: { NAME [ LIT ] : .2f } ( { NAME [ LIT ] } ) \" ) NAME . NAME ( f\" API: { NAME [ LIT ] [ LIT ] : .1f } s avg \" ) NAME . NAME ( f\" Memory: { NAME [ LIT ] [ LIT ] : .1f } MB \" ) NAME . NAME ( f\" Errors: { NAME [ LIT ] [ LIT ] } \" ) if NAME [ LIT ] : NAME . NAME ( f\" Actions: { NAME [ LIT ] [ LIT ] } \" )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.create_session_checkpoint",
      "lineno": 932,
      "end_lineno": 993,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 62,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "purpose:validation",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self, checkpoint_name)",
      "fingerprint": "354a2edb9d6e2a9162583d3b34ac0a0e6f19844c",
      "simhash64": 7451588276007638027,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT try : if NAME is None : NAME = f\" checkpoint_ { NAME ( NAME . NAME ( ) ) } \" # Create checkpoint directory NAME = NAME ( LIT ) NAME . NAME ( NAME = True , NAME = True ) # Prepare session state data NAME = { LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME . NAME , LIT : NAME ( NAME . NAME ) , LIT : { NAME : { LIT : NAME . NAME , LIT : NAME . NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME } for NAME , NAME in NAME . NAME . NAME ( ) } , LIT : [ { LIT : NAME . NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME } for NAME in NAME . NAME ] , LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , LIT : { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME } , LIT : NAME . NAME ( ) } # Save checkpoint to file NAME = NAME / f\" { NAME } .json \" with NAME . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME , NAME = LIT , NAME = NAME ) NAME . NAME ( f\" \ud83d\udcc1 Session checkpoint created: { NAME } \" ) return NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Failed to create session checkpoint: { NAME } \" ) return LIT"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.restore_from_checkpoint",
      "lineno": 995,
      "end_lineno": 1073,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 15,
      "loc": 79,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, checkpoint_path)",
      "fingerprint": "3655235af016126016893937a796a6c2e070bee7",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT try : NAME = NAME ( NAME ) if not NAME . NAME ( ) : NAME . NAME ( f\" Checkpoint file not found: { NAME } \" ) return False # Load checkpoint data with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( NAME ) # Restore session state NAME . NAME = NAME . NAME ( LIT , NAME . NAME ( ) ) # Restore health score history if LIT in NAME : NAME . NAME = NAME ( NAME [ LIT ] , NAME = LIT ) # Restore current metrics if LIT in NAME : for NAME , NAME in NAME [ LIT ] . NAME ( ) : NAME = NAME ( NAME = NAME , NAME = NAME [ LIT ] , NAME = NAME [ LIT ] , NAME = NAME [ LIT ] , NAME = NAME . NAME ( LIT , NAME . NAME ( ) ) ) NAME . NAME [ NAME ] = NAME # Restore alerts if LIT in NAME : NAME . NAME = [ ] for NAME in NAME [ LIT ] : NAME = NAME ( NAME [ LIT ] ) NAME = NAME ( NAME = NAME , NAME = NAME [ LIT ] , NAME = NAME [ LIT ] , NAME = NAME [ LIT ] , NAME = NAME [ LIT ] , NAME = NAME [ LIT ] , NAME = NAME [ LIT ] ) NAME . NAME . NAME ( NAME ) # Restore error data if LIT in NAME : NAME . NAME = NAME ( NAME [ LIT ] , NAME = NAME . NAME . NAME ) if LIT in NAME : NAME . NAME . NAME ( NAME [ LIT ] ) # Restore performance data if LIT in NAME : NAME . NAME = NAME ( NAME [ LIT ] , NAME = NAME . NAME . NAME ) if LIT in NAME : NAME . NAME = NAME ( NAME [ LIT ] , NAME = NAME . NAME . NAME ) if LIT in NAME : NAME . NAME = NAME ( NAME [ LIT ] , NAME = NAME . NAME . NAME ) # Restore intervention state if LIT in NAME : NAME = NAME [ LIT ] NAME . NAME = NAME . NAME ( LIT , False ) NAME . NAME = NAME . NAME ( LIT , False ) NAME . NAME = NAME . NAME ( LIT , False ) NAME . NAME = NAME . NAME ( LIT , LIT ) NAME . NAME = NAME . NAME ( LIT , NAME . NAME ( ) ) NAME . NAME ( f\" \ud83d\udd04 Session state restored from checkpoint: { NAME . NAME } \" ) return True except NAME as NAME : NAME . NAME ( f\" Failed to restore from checkpoint: { NAME } \" ) return False"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.auto_checkpoint",
      "lineno": 1075,
      "end_lineno": 1092,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 18,
      "tags": [
        "pure-ish",
        "time",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self, interval_minutes)",
      "fingerprint": "282663998a2c9df57b6014283db6362fb585ea94",
      "simhash64": 8641136711958963219,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) -> None : LIT try : NAME = NAME . NAME ( ) if not NAME ( NAME , LIT ) : NAME . NAME = NAME # Check if it's time for a checkpoint if NAME - NAME . NAME >= ( NAME * LIT ) : NAME = f\" auto_checkpoint_ { NAME ( NAME ) } \" NAME . NAME ( NAME ) NAME . NAME = NAME # Clean up old auto checkpoints (keep only last 5) NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" Auto checkpoint failed: { NAME } \" )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor._cleanup_old_checkpoints",
      "lineno": 1094,
      "end_lineno": 1116,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 23,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self, keep_count)",
      "fingerprint": "531d7ddc25b73029eea0a927af9cab662c9281c4",
      "simhash64": 8641066343214789651,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) -> None : LIT try : NAME = NAME ( LIT ) if not NAME . NAME ( ) : return # Get all auto checkpoint files NAME = NAME ( NAME . NAME ( LIT ) ) # Sort by modification time (newest first) NAME . NAME ( NAME = lambda NAME : NAME . NAME ( ) . NAME , NAME = True ) # Remove old checkpoints for NAME in NAME [ NAME : ] : try : NAME . NAME ( ) NAME . NAME ( f\" Removed old checkpoint: { NAME . NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Failed to remove checkpoint { NAME . NAME } : { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Checkpoint cleanup failed: { NAME } \" )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.list_available_checkpoints",
      "lineno": 1118,
      "end_lineno": 1154,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 37,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "72bf6b50087f65423ea00cd54b0945ba5d513611",
      "simhash64": 7487617073026601995,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : NAME = NAME ( LIT ) if not NAME . NAME ( ) : return [ ] NAME = [ ] for NAME in NAME . NAME ( LIT ) : try : # Get file metadata NAME = NAME . NAME ( ) # Try to read checkpoint metadata with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( NAME ) NAME . NAME ( { LIT : NAME . NAME , LIT : NAME ( NAME ) , LIT : NAME . NAME ( LIT , NAME . NAME ) , LIT : NAME . NAME / LIT , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) } ) except NAME as NAME : NAME . NAME ( f\" Failed to read checkpoint metadata for { NAME . NAME } : { NAME } \" ) # Sort by creation time (newest first) NAME . NAME ( NAME = lambda NAME : NAME [ LIT ] , NAME = True ) return NAME except NAME as NAME : NAME . NAME ( f\" Failed to list checkpoints: { NAME } \" ) return [ ]"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.persist_session_state_to_disk",
      "lineno": 1156,
      "end_lineno": 1194,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 39,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "size:medium"
      ],
      "signature": "(self, session_data)",
      "fingerprint": "aed44e7f332fbd91e117efbe9e28bdd91f67b42a",
      "simhash64": 7487617073026602043,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None ) -> NAME : LIT try : # Create persistent state directory NAME = NAME ( LIT ) NAME . NAME ( NAME = True , NAME = True ) # Prepare session state data if NAME is None : NAME = { } # Add health monitoring state NAME . NAME ( { LIT : { LIT : NAME . NAME , LIT : { NAME : NAME . NAME for NAME , NAME in NAME . NAME . NAME ( ) } , LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , LIT : NAME . NAME ( ) , LIT : { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME } } , LIT : NAME . NAME ( ) } ) # Save to persistent state file NAME = NAME / LIT with NAME . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME , NAME = LIT , NAME = NAME ) NAME . NAME ( f\" Session state persisted to disk: { NAME } \" ) return NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Failed to persist session state: { NAME } \" ) return LIT"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "SessionHealthMonitor.recover_session_state_from_disk",
      "lineno": 1196,
      "end_lineno": 1234,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 8,
      "loc": 39,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "24d0c0768e2e10eb48cf9de653b4785a01a1766f",
      "simhash64": 7488180023047140355,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : NAME = NAME ( LIT ) if not NAME . NAME ( ) : NAME . NAME ( LIT ) return None # Load session state with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( NAME ) # Check if state is recent (within last 24 hours) NAME = NAME . NAME ( ) - NAME . NAME ( LIT , LIT ) if NAME > LIT : # 24 hours NAME . NAME ( LIT ) return None # Restore health monitoring state if available if LIT in NAME : NAME = NAME [ LIT ] # Restore basic state if LIT in NAME : NAME . NAME = NAME [ LIT ] # Restore intervention state if LIT in NAME : NAME = NAME [ LIT ] NAME . NAME = NAME . NAME ( LIT , False ) NAME . NAME = NAME . NAME ( LIT , False ) NAME . NAME = NAME . NAME ( LIT , False ) NAME . NAME ( f\" \ud83d\udd04 Session state recovered from disk (age: { NAME / LIT : .1f } minutes) \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Failed to recover session state: { NAME } \" ) return None"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "get_health_monitor",
      "lineno": 1241,
      "end_lineno": 1246,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "3a573710230332b0c1d977db240b0730319b901e",
      "simhash64": 8641278000278443091,
      "normalized": "def NAME ( ) -> NAME : LIT global NAME if NAME is None : NAME = NAME ( ) return NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "initialize_health_monitoring",
      "lineno": 1249,
      "end_lineno": 1253,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "5925b92f1efd4f455756efa56e466ecddcebef8d",
      "simhash64": 7487652258472428579,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( ) NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "integrate_with_session_manager",
      "lineno": 1258,
      "end_lineno": 1272,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "4b643066cf1887dbadb5a0ee73679720d18f77ae",
      "simhash64": 7487617073026610211,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT NAME = NAME ( ) # Add health monitoring hooks to session manager if NAME ( NAME , LIT ) : # Update session metrics NAME . NAME ( NAME ) # Log health summary every 25 pages NAME = NAME . NAME . NAME ( LIT , LIT ) if NAME > LIT and NAME % LIT == LIT : NAME . NAME ( ) return NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "integrate_with_action6",
      "lineno": 1275,
      "end_lineno": 1278,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(action6_module)",
      "fingerprint": "62cf8ca5c8f35f61472833faeb7f7880391424ee",
      "simhash64": 7488250908262704187,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT NAME = NAME # Unused parameter for future integration return NAME ( )"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "get_performance_recommendations",
      "lineno": 1297,
      "end_lineno": 1344,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 48,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(health_score, risk_score)",
      "fingerprint": "c81a79249bab5fe1bc1d0de1017f65a7acf23a17",
      "simhash64": 5726842660759967275,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } if NAME > LIT : # Emergency settings NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ) elif NAME > LIT : # Critical settings NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ) elif NAME > LIT : # Warning settings NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ) elif NAME > LIT : # Excellent health - can optimize NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ) return NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "enable_session_state_persistence",
      "lineno": 1349,
      "end_lineno": 1377,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 7,
      "loc": 29,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(session_manager, auto_checkpoint_interval)",
      "fingerprint": "4c59abfc24f95d273e43053cc394aaa46df57a4a",
      "simhash64": 7488180022980031537,
      "normalized": "def NAME ( NAME = None , NAME : NAME = LIT ) : LIT NAME = NAME ( ) try : # Try to recover previous session state NAME = NAME . NAME ( ) if NAME : NAME . NAME ( LIT ) # If session manager provided, restore its state too if NAME and LIT in NAME : try : NAME = NAME [ LIT ] # Restore session manager specific state if available if NAME ( NAME , LIT ) : NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Failed to restore session manager state: { NAME } \" ) # Enable auto checkpointing NAME . NAME ( NAME ) NAME . NAME ( f\" \ud83d\udcc1 Session state persistence enabled (auto-checkpoint every { NAME } minutes) \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Failed to enable session state persistence: { NAME } \" ) return NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "create_recovery_checkpoint",
      "lineno": 1380,
      "end_lineno": 1423,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 7,
      "loc": 44,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(session_manager, checkpoint_name)",
      "fingerprint": "5ca046a1eb1dda8e984b3f9c408aa7db25bde5f8",
      "simhash64": 7451729018865751083,
      "normalized": "def NAME ( NAME = None , NAME : NAME = LIT ) : LIT NAME = NAME ( ) try : # Gather session manager state if available NAME = { } if NAME : try : # Capture session manager state NAME [ LIT ] = { LIT : NAME ( NAME , LIT , False ) , LIT : NAME ( NAME , LIT ) and NAME ( NAME . NAME , LIT , None ) is not None , LIT : NAME ( NAME , LIT ) , LIT : NAME ( NAME , LIT ) , LIT : NAME ( NAME , LIT , None ) , LIT : NAME ( NAME , LIT , LIT ) , LIT : NAME ( NAME , LIT , LIT ) } # Add browser health state if available if NAME ( NAME , LIT ) : NAME [ LIT ] = NAME . NAME # Add session health state if available if NAME ( NAME , LIT ) : NAME [ LIT ] = NAME . NAME except NAME as NAME : NAME . NAME ( f\" Failed to capture session manager state: { NAME } \" ) # Create checkpoint with session data NAME = NAME . NAME ( NAME ) # Also persist to disk for crash recovery NAME . NAME ( NAME ) NAME . NAME ( f\" \ud83d\udee1\ufe0f Recovery checkpoint created: { NAME } \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Failed to create recovery checkpoint: { NAME } \" ) return LIT"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "get_session_recovery_status",
      "lineno": 1426,
      "end_lineno": 1453,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 28,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6d1ffd218bb8366c3529567fb49bb045fbd1c996",
      "simhash64": 7488180024120874027,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( ) try : NAME = NAME . NAME ( ) # Check for crash recovery state NAME = False try : NAME = NAME ( LIT ) if NAME . NAME ( ) : NAME = NAME . NAME ( ) - NAME . NAME ( ) . NAME NAME = NAME < LIT # Less than 24 hours old except NAME : pass return { LIT : NAME ( NAME ) , LIT : NAME [ LIT ] if NAME else None , LIT : NAME , LIT : NAME [ : LIT ] , # Last 5 checkpoints LIT : NAME ( NAME , NAME ) } except NAME as NAME : NAME . NAME ( f\" Failed to get recovery status: { NAME } \" ) return { LIT : NAME ( NAME ) }"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "_get_recovery_recommendations",
      "lineno": 1456,
      "end_lineno": 1473,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 18,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(checkpoints, crash_recovery)",
      "fingerprint": "0d972c94623ba5623dbcdbd4d2fab81bd9aff756",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME ) -> NAME [ NAME ] : LIT NAME = [ ] if NAME : NAME . NAME ( LIT ) if NAME : NAME = NAME [ LIT ] NAME = ( NAME . NAME ( ) - NAME [ LIT ] ) / LIT if NAME < LIT : NAME . NAME ( f\" Recent checkpoint available ( { NAME : .1f } h old) \" ) elif NAME < LIT : NAME . NAME ( f\" Checkpoint available from { NAME : .1f } hours ago \" ) else : NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "health_monitor_tests",
      "lineno": 1478,
      "end_lineno": 1832,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 10,
      "yield_count": 0,
      "complexity": 12,
      "loc": 355,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "cf94e7f9cec4794f39b33bb26618536c5952ad14",
      "simhash64": 7488180022980023347,
      "normalized": "def NAME ( ) -> NAME : LIT def NAME ( ) : LIT NAME = NAME ( ) assert NAME is not None assert NAME ( NAME . NAME ) > LIT assert NAME . NAME > LIT return True def NAME ( ) : LIT NAME = NAME ( ) # Test updating a metric NAME . NAME ( LIT , LIT ) assert NAME . NAME [ LIT ] . NAME == LIT # Test metric history assert NAME ( NAME . NAME [ LIT ] ) == LIT return True def NAME ( ) : LIT NAME = NAME ( ) # Set all metrics to excellent values for NAME in NAME . NAME : NAME . NAME ( NAME , LIT ) NAME = NAME . NAME ( ) assert NAME >= LIT , f\" Expected high score for excellent metrics, got { NAME } \" # Set all metrics to critical values for NAME , NAME in NAME . NAME . NAME ( ) : NAME . NAME ( NAME , NAME . NAME + LIT ) NAME = NAME . NAME ( ) assert NAME <= LIT , f\" Expected low score for critical metrics, got { NAME } \" return True def NAME ( ) : LIT NAME = NAME ( ) # Test with good conditions NAME = NAME . NAME ( ) assert LIT <= NAME <= LIT , f\" Risk score should be 0-1, got { NAME } \" # Test with bad conditions NAME . NAME . NAME ( [ LIT , LIT , LIT , LIT , LIT ] ) NAME . NAME [ LIT ] = LIT NAME . NAME . NAME ( [ LIT , LIT , LIT ] ) # Increasing memory NAME = NAME . NAME ( ) assert NAME > LIT , f\" Expected elevated risk with bad conditions, got { NAME } \" return True def NAME ( ) : LIT NAME = NAME ( ) # Trigger a warning alert (warning threshold is 15.0) NAME . NAME ( LIT , LIT ) # Above warning threshold # Check that alert was created NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == NAME . NAME ] assert NAME ( NAME ) > LIT , LIT # Trigger a critical alert (critical threshold is 25.0) NAME . NAME ( LIT , LIT ) # Above critical threshold NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == NAME . NAME ] assert NAME ( NAME ) > LIT , LIT return True def NAME ( ) : LIT NAME = NAME ( ) # Test API response time tracking NAME . NAME ( LIT ) assert NAME ( NAME . NAME ) == LIT # Test error tracking NAME . NAME ( LIT ) assert NAME . NAME [ LIT ] == LIT # Test page processing time tracking NAME . NAME ( LIT ) assert NAME ( NAME . NAME ) == LIT return True def NAME ( ) : LIT NAME = NAME ( ) NAME = NAME . NAME ( ) # Check required fields NAME = [ LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME , f\" Dashboard missing required field: { NAME } \" # Check data types assert NAME ( NAME [ LIT ] , ( NAME , NAME ) ) assert NAME ( NAME [ LIT ] , ( NAME ) ) assert NAME ( NAME [ LIT ] , NAME ) assert NAME ( NAME [ LIT ] , NAME ) return True def NAME ( ) : LIT # Test performance recommendations NAME = NAME ( LIT , LIT ) assert LIT in NAME assert LIT in NAME # Test emergency recommendations NAME = NAME ( LIT , LIT ) assert NAME [ LIT ] == LIT assert NAME [ LIT ] == LIT return True def NAME ( ) : LIT NAME = NAME ( ) NAME = NAME ( ) # Should return the same instance assert NAME is NAME , LIT return True # Run all tests NAME = NAME ( LIT , LIT ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) # === PHASE 4: MEMORY & RESOURCE TESTING === def NAME ( ) : LIT NAME = NAME ( ) # Test memory optimization for long sessions NAME . NAME ( ) # Verify optimization settings assert NAME . NAME == LIT , LIT assert NAME . NAME . NAME == LIT , LIT # Test performance stats under memory pressure NAME = NAME . NAME ( ) assert LIT in NAME , LIT assert LIT in NAME [ LIT ] , LIT # Test basic memory management functionality import NAME NAME = NAME . NAME ( ) # Add some error timestamps for NAME in NAME ( LIT ) : NAME . NAME . NAME ( NAME - NAME ) # Verify timestamps were added assert NAME ( NAME . NAME ) == LIT , LIT # Test that memory optimization settings are working assert NAME . NAME . NAME == LIT , LIT def NAME ( ) : LIT NAME = NAME ( ) # Test adaptive monitoring under resource constraints NAME = NAME . NAME ( ) # Simulate high error rate (resource constraint indicator) for NAME in NAME ( LIT ) : NAME . NAME . NAME ( NAME - NAME ) # Should adapt to shorter intervals under high error rate NAME = NAME . NAME ( NAME ) assert NAME <= LIT , f\" Should use short interval under high error rate, got { NAME } \" # Test enhanced monitoring activation NAME . NAME ( LIT , LIT , LIT ) assert NAME . NAME ( ) , LIT # Enhanced monitoring should use very short intervals NAME = NAME . NAME ( NAME ) assert NAME == LIT , f\" Enhanced monitoring should use 5s interval, got { NAME } \" def NAME ( ) : LIT import NAME NAME = NAME ( ) # Simulate 20-hour session NAME = NAME . NAME ( ) - ( LIT * LIT ) NAME . NAME = NAME # Optimize for long session NAME . NAME ( ) # Add realistic data for 20-hour session NAME = NAME . NAME ( ) # Add 200 errors distributed over 20 hours for NAME in NAME ( LIT ) : NAME = NAME + ( NAME * ( LIT * LIT ) / LIT ) NAME . NAME . NAME ( NAME ) # Add 100 alerts distributed over time for NAME in NAME ( LIT ) : NAME = NAME + ( NAME * ( LIT * LIT ) / LIT ) NAME = NAME ( NAME = NAME . NAME , NAME = LIT , NAME = f\" Test alert { NAME } \" , NAME = LIT , NAME = NAME , NAME = LIT , NAME = NAME ) NAME . NAME . NAME ( NAME ) # Test performance stats for long session NAME = NAME . NAME ( ) assert NAME [ LIT ] >= LIT , LIT assert NAME [ LIT ] == LIT , LIT assert NAME [ LIT ] == LIT , LIT # Test cleanup efficiency for long session NAME = NAME ( NAME . NAME ) NAME = NAME ( NAME . NAME ) # Force cleanup NAME . NAME = NAME - LIT NAME . NAME ( NAME ) # Should clean up old data but keep recent data NAME = NAME ( NAME . NAME ) NAME = NAME ( NAME . NAME ) assert NAME <= NAME , LIT assert NAME <= NAME , LIT assert NAME > LIT , LIT assert NAME > LIT , LIT NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) # === SESSION STATE PERSISTENCE TESTS === def NAME ( ) : LIT NAME = NAME ( ) # Add some test data using existing metrics NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT ) # Create checkpoint NAME = NAME . NAME ( LIT ) assert NAME != LIT , LIT assert NAME ( NAME ) . NAME ( ) , LIT # Test checkpoint restoration NAME = NAME ( ) NAME = NAME . NAME ( NAME ) assert NAME , LIT # Verify restored data assert LIT in NAME . NAME , LIT # Check that the metric was restored (value might be recalculated) assert NAME . NAME [ LIT ] . NAME >= LIT , LIT assert NAME ( NAME . NAME ) > LIT , LIT def NAME ( ) : LIT NAME = NAME ( ) # Add some test data using existing metrics NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT ) # Test session data persistence NAME = { LIT : LIT , LIT : LIT } NAME = NAME . NAME ( NAME ) assert NAME != LIT , LIT # Test session state recovery NAME = NAME . NAME ( ) assert NAME is not None , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT def NAME ( ) : LIT NAME = NAME ( ) # Create multiple checkpoints NAME . NAME ( LIT ) NAME . NAME ( LIT ) # List checkpoints NAME = NAME . NAME ( ) assert NAME ( NAME ) >= LIT , LIT # Verify checkpoint metadata for NAME in NAME : assert LIT in NAME , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT def NAME ( ) : LIT NAME = NAME ( ) # Test auto checkpoint (with very short interval for testing) NAME . NAME ( NAME = LIT ) # 1 minute for testing # Manually trigger checkpoint by setting old timestamp NAME . NAME = NAME . NAME ( ) - LIT # 2 minutes ago NAME . NAME ( NAME = LIT ) # Should have created at least one auto checkpoint NAME = NAME . NAME ( ) NAME = [ NAME for NAME in NAME if NAME [ LIT ] . NAME ( LIT ) ] assert NAME ( NAME ) >= LIT , LIT NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT , NAME ) return NAME . NAME == LIT"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_health_monitor_initialization",
      "lineno": 1486,
      "end_lineno": 1492,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "28f8071d32c5289b4954eb75fee9392d88b7787f",
      "simhash64": 7487617073026597891,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) assert NAME is not None assert NAME ( NAME . NAME ) > LIT assert NAME . NAME > LIT return True"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_metric_updates",
      "lineno": 1494,
      "end_lineno": 1504,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "4a55b9df17b92a068da3a469bf2a298d0792ae63",
      "simhash64": 7451588280638157831,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test updating a metric NAME . NAME ( LIT , LIT ) assert NAME . NAME [ LIT ] . NAME == LIT # Test metric history assert NAME ( NAME . NAME [ LIT ] ) == LIT return True"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_health_score_calculation",
      "lineno": 1506,
      "end_lineno": 1523,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "aaedb9931878bf575a9cf4d4452ed63b29d6439e",
      "simhash64": 7451588276007638043,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Set all metrics to excellent values for NAME in NAME . NAME : NAME . NAME ( NAME , LIT ) NAME = NAME . NAME ( ) assert NAME >= LIT , f\" Expected high score for excellent metrics, got { NAME } \" # Set all metrics to critical values for NAME , NAME in NAME . NAME . NAME ( ) : NAME . NAME ( NAME , NAME . NAME + LIT ) NAME = NAME . NAME ( ) assert NAME <= LIT , f\" Expected low score for critical metrics, got { NAME } \" return True"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_risk_prediction",
      "lineno": 1525,
      "end_lineno": 1540,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7b4e77a03720c5285a6eab769582fb607415de8d",
      "simhash64": 7452291964590265387,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test with good conditions NAME = NAME . NAME ( ) assert LIT <= NAME <= LIT , f\" Risk score should be 0-1, got { NAME } \" # Test with bad conditions NAME . NAME . NAME ( [ LIT , LIT , LIT , LIT , LIT ] ) NAME . NAME [ LIT ] = LIT NAME . NAME . NAME ( [ LIT , LIT , LIT ] ) # Increasing memory NAME = NAME . NAME ( ) assert NAME > LIT , f\" Expected elevated risk with bad conditions, got { NAME } \" return True"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_alert_system",
      "lineno": 1542,
      "end_lineno": 1558,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3b079ab85c575c9de9f58483d45c80d75778eef5",
      "simhash64": 7488109654235849779,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Trigger a warning alert (warning threshold is 15.0) NAME . NAME ( LIT , LIT ) # Above warning threshold # Check that alert was created NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == NAME . NAME ] assert NAME ( NAME ) > LIT , LIT # Trigger a critical alert (critical threshold is 25.0) NAME . NAME ( LIT , LIT ) # Above critical threshold NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == NAME . NAME ] assert NAME ( NAME ) > LIT , LIT return True"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_performance_tracking",
      "lineno": 1560,
      "end_lineno": 1575,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 16,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c2ecc617036047d042517e8a6bd26ac4fd759525",
      "simhash64": 7451623460446843911,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test API response time tracking NAME . NAME ( LIT ) assert NAME ( NAME . NAME ) == LIT # Test error tracking NAME . NAME ( LIT ) assert NAME . NAME [ LIT ] == LIT # Test page processing time tracking NAME . NAME ( LIT ) assert NAME ( NAME . NAME ) == LIT return True"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_dashboard_generation",
      "lineno": 1577,
      "end_lineno": 1593,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c4e3664b357123c39d7e757d009041f63310e321",
      "simhash64": 7488179989695075387,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) NAME = NAME . NAME ( ) # Check required fields NAME = [ LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME , f\" Dashboard missing required field: { NAME } \" # Check data types assert NAME ( NAME [ LIT ] , ( NAME , NAME ) ) assert NAME ( NAME [ LIT ] , ( NAME ) ) assert NAME ( NAME [ LIT ] , NAME ) assert NAME ( NAME [ LIT ] , NAME ) return True"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_integration_helpers",
      "lineno": 1595,
      "end_lineno": 1606,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "1a1f141072fc1840ed2c1e04e206c7c1dcd319d4",
      "simhash64": 5146450183737218611,
      "normalized": "def NAME ( ) : LIT # Test performance recommendations NAME = NAME ( LIT , LIT ) assert LIT in NAME assert LIT in NAME # Test emergency recommendations NAME = NAME ( LIT , LIT ) assert NAME [ LIT ] == LIT assert NAME [ LIT ] == LIT return True"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_global_instance",
      "lineno": 1608,
      "end_lineno": 1615,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "7dffa0ad4798cb1cbe828afb95bd9487dec3eb6b",
      "simhash64": 8641277450522629163,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) NAME = NAME ( ) # Should return the same instance assert NAME is NAME , LIT return True"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_memory_pressure_monitoring",
      "lineno": 1631,
      "end_lineno": 1660,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 30,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "7c79ce75c2f8c7e2341aa3a1697ece719006bf51",
      "simhash64": 7452151226028176499,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test memory optimization for long sessions NAME . NAME ( ) # Verify optimization settings assert NAME . NAME == LIT , LIT assert NAME . NAME . NAME == LIT , LIT # Test performance stats under memory pressure NAME = NAME . NAME ( ) assert LIT in NAME , LIT assert LIT in NAME [ LIT ] , LIT # Test basic memory management functionality import NAME NAME = NAME . NAME ( ) # Add some error timestamps for NAME in NAME ( LIT ) : NAME . NAME . NAME ( NAME - NAME ) # Verify timestamps were added assert NAME ( NAME . NAME ) == LIT , LIT # Test that memory optimization settings are working assert NAME . NAME . NAME == LIT , LIT"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_resource_constraint_handling",
      "lineno": 1662,
      "end_lineno": 1684,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 23,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f754f35241435b5965da33daa02622bb44b8deb5",
      "simhash64": 7452186411406898203,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test adaptive monitoring under resource constraints NAME = NAME . NAME ( ) # Simulate high error rate (resource constraint indicator) for NAME in NAME ( LIT ) : NAME . NAME . NAME ( NAME - NAME ) # Should adapt to shorter intervals under high error rate NAME = NAME . NAME ( NAME ) assert NAME <= LIT , f\" Should use short interval under high error rate, got { NAME } \" # Test enhanced monitoring activation NAME . NAME ( LIT , LIT , LIT ) assert NAME . NAME ( ) , LIT # Enhanced monitoring should use very short intervals NAME = NAME . NAME ( NAME ) assert NAME == LIT , f\" Enhanced monitoring should use 5s interval, got { NAME } \""
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_long_session_resource_management",
      "lineno": 1686,
      "end_lineno": 1742,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 57,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "5064a82a07b7d29b1443ecc616d07423dae5430e",
      "simhash64": 7488180023047140411,
      "normalized": "def NAME ( ) : LIT import NAME NAME = NAME ( ) # Simulate 20-hour session NAME = NAME . NAME ( ) - ( LIT * LIT ) NAME . NAME = NAME # Optimize for long session NAME . NAME ( ) # Add realistic data for 20-hour session NAME = NAME . NAME ( ) # Add 200 errors distributed over 20 hours for NAME in NAME ( LIT ) : NAME = NAME + ( NAME * ( LIT * LIT ) / LIT ) NAME . NAME . NAME ( NAME ) # Add 100 alerts distributed over time for NAME in NAME ( LIT ) : NAME = NAME + ( NAME * ( LIT * LIT ) / LIT ) NAME = NAME ( NAME = NAME . NAME , NAME = LIT , NAME = f\" Test alert { NAME } \" , NAME = LIT , NAME = NAME , NAME = LIT , NAME = NAME ) NAME . NAME . NAME ( NAME ) # Test performance stats for long session NAME = NAME . NAME ( ) assert NAME [ LIT ] >= LIT , LIT assert NAME [ LIT ] == LIT , LIT assert NAME [ LIT ] == LIT , LIT # Test cleanup efficiency for long session NAME = NAME ( NAME . NAME ) NAME = NAME ( NAME . NAME ) # Force cleanup NAME . NAME = NAME - LIT NAME . NAME ( NAME ) # Should clean up old data but keep recent data NAME = NAME ( NAME . NAME ) NAME = NAME ( NAME . NAME ) assert NAME <= NAME , LIT assert NAME <= NAME , LIT assert NAME > LIT , LIT assert NAME > LIT , LIT"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_session_checkpoint_creation",
      "lineno": 1749,
      "end_lineno": 1772,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 24,
      "tags": [
        "impure",
        "filesystem",
        "purpose:validation",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "99eb089e658ad37ddb0ca249869ccdecec6a9be4",
      "simhash64": 7487617073026602019,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Add some test data using existing metrics NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT ) # Create checkpoint NAME = NAME . NAME ( LIT ) assert NAME != LIT , LIT assert NAME ( NAME ) . NAME ( ) , LIT # Test checkpoint restoration NAME = NAME ( ) NAME = NAME . NAME ( NAME ) assert NAME , LIT # Verify restored data assert LIT in NAME . NAME , LIT # Check that the metric was restored (value might be recalculated) assert NAME . NAME [ LIT ] . NAME >= LIT , LIT assert NAME ( NAME . NAME ) > LIT , LIT"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_session_state_persistence",
      "lineno": 1774,
      "end_lineno": 1791,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "48c863d7a4fde685ec5d1fd0440d7f916dc2d223",
      "simhash64": 7451730114081362987,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Add some test data using existing metrics NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT ) # Test session data persistence NAME = { LIT : LIT , LIT : LIT } NAME = NAME . NAME ( NAME ) assert NAME != LIT , LIT # Test session state recovery NAME = NAME . NAME ( ) assert NAME is not None , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_checkpoint_management",
      "lineno": 1793,
      "end_lineno": 1809,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "time",
        "purpose:validation",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "96d58b548bc9e3af8d02ae3070dedf1001dfc87b",
      "simhash64": 7487617073093710907,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Create multiple checkpoints NAME . NAME ( LIT ) NAME . NAME ( LIT ) # List checkpoints NAME = NAME . NAME ( ) assert NAME ( NAME ) >= LIT , LIT # Verify checkpoint metadata for NAME in NAME : assert LIT in NAME , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "test_auto_checkpoint_functionality",
      "lineno": 1811,
      "end_lineno": 1825,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "time",
        "purpose:validation",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7817784a0ff87c401894018179915ff0f24b8f7c",
      "simhash64": 8641101527653979159,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test auto checkpoint (with very short interval for testing) NAME . NAME ( NAME = LIT ) # 1 minute for testing # Manually trigger checkpoint by setting old timestamp NAME . NAME = NAME . NAME ( ) - LIT # 2 minutes ago NAME . NAME ( NAME = LIT ) # Should have created at least one auto checkpoint NAME = NAME . NAME ( ) NAME = [ NAME for NAME in NAME if NAME [ LIT ] . NAME ( LIT ) ] assert NAME ( NAME ) >= LIT , LIT"
    },
    {
      "module_path": "health_monitor.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 1844,
      "end_lineno": 1849,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "7c4fadec6098d2bc967458cf1106709bfc0ad5a3",
      "simhash64": 9219418776879928363,
      "normalized": "def NAME ( ) : LIT return NAME ( )"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "NameFilter.__init__",
      "lineno": 100,
      "end_lineno": 102,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, excluded_names)",
      "fingerprint": "3b3c06ea6fd617bc9af3ca1866cd4434501df7fd",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] ) : NAME ( ) . NAME ( ) NAME . NAME = NAME"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "NameFilter.filter",
      "lineno": 106,
      "end_lineno": 110,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "(self, record)",
      "fingerprint": "d68781d22a4ed53e0c267e31c46476e7ffde5120",
      "simhash64": 7488145388363753043,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME ) -> NAME : LIT # Step 1: Check if the record's logger name starts with any excluded name # Step 2: Return False (filter out) if match found, True (keep) otherwise return not NAME ( NAME . NAME . NAME ( NAME ) for NAME in NAME . NAME )"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "RemoteConnectionFilter.filter",
      "lineno": 121,
      "end_lineno": 128,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:tiny"
      ],
      "signature": "(self, record)",
      "fingerprint": "2eb399158b85bd4972dbbe381a443255d3c5a04e",
      "simhash64": 7488140440628536339,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME ) -> NAME : LIT # Step 1: Check if log level is DEBUG NAME = NAME . NAME == NAME . NAME # Step 2: Check if the source pathname includes remote_connection.py NAME = NAME . NAME and LIT in NAME ( NAME . NAME ) . NAME # Step 3: Return False (filter out) only if both conditions are True return not ( NAME and NAME )"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "AlignedMessageFormatter.format",
      "lineno": 143,
      "end_lineno": 210,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 11,
      "loc": 68,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "(self, record)",
      "fingerprint": "e98e39c9919d0863bd8bc9da29d35ca4521b94ab",
      "simhash64": 7416087244637123635,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME ) -> NAME : LIT # Step 1: Get the original message content NAME = NAME . NAME ( ) # Step 1.5: Apply automatic color based on log level if NAME . NAME >= NAME . NAME : # Critical messages in red if LIT not in NAME : # Check if already has ANSI codes NAME = NAME . NAME ( NAME ) elif NAME . NAME >= NAME . NAME : # Error messages in red if LIT not in NAME : # Check if already has ANSI codes NAME = NAME . NAME ( NAME ) elif NAME . NAME >= NAME . NAME : # Warning messages in yellow if LIT not in NAME : # Check if already has ANSI codes NAME = NAME . NAME ( NAME ) # Step 2: Create a copy to safely calculate prefix length NAME = NAME . NAME ( NAME ) NAME = LIT # Placeholder character for calculation NAME . NAME = NAME NAME . NAME = ( ) # Clear args for prefix calculation NAME . NAME = ( NAME . NAME ( ) ) # Ensure message attribute is generated # Step 3: Format the record with the placeholder to find message start position NAME = NAME ( ) . NAME ( NAME ) # Use base class format try : # Find the position of the placeholder (start of the actual message) NAME = NAME . NAME ( NAME ) except NAME : # Fallback if placeholder isn't found (shouldn't happen with standard format) NAME . NAME ( LIT , NAME = False , ) # Heuristic: find end of metadata bracket ']' and add 2 spaces NAME = NAME . NAME ( LIT ) NAME = ( NAME + LIT if NAME != - LIT else LIT ) # Default indent # Step 4: Extract the prefix string and calculate indent string NAME = NAME [ : NAME ] NAME = LIT * NAME # Step 5: Split the original message into lines NAME = NAME . NAME ( LIT ) NAME = [ ] # Step 6: Format the first line (prefix + left-stripped content) if NAME : NAME = NAME [ LIT ] . NAME ( ) # Remove leading whitespace NAME . NAME ( f\" { NAME } { NAME } \" ) elif NAME : # Handle case where message is empty but prefix exists return NAME . NAME ( ) # Return only prefix # Step 7: Format subsequent lines (indent + left-stripped content) for NAME in NAME ( LIT , NAME ( NAME ) ) : NAME = NAME [ NAME ] . NAME ( ) # Remove leading whitespace NAME . NAME ( f\" { NAME } { NAME } \" ) # Step 8: Join the formatted lines back together return LIT . NAME ( NAME )"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "setup_logging",
      "lineno": 223,
      "end_lineno": 310,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 88,
      "tags": [
        "impure",
        "network",
        "filesystem",
        "logging",
        "regex",
        "size:medium"
      ],
      "signature": "(log_file, log_level)",
      "fingerprint": "3d923fb4b852c72d41b30558261a5e9d21da58da",
      "simhash64": 7488215211647083523,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME = LIT ) -> NAME . NAME : LIT global NAME # Validate log level NAME = NAME . NAME ( ) NAME = NAME ( NAME , NAME , NAME . NAME ) # If already initialized, just update handler levels if NAME : for NAME in NAME . NAME : NAME . NAME ( NAME ) return NAME # Ensure log directory exists NAME = NAME . NAME ( ) NAME . NAME ( NAME = True , NAME = True ) # Construct full log file path NAME = NAME / NAME ( NAME ( NAME ) ) . NAME NAME = NAME ( NAME ) # Clear any existing handlers for NAME in NAME . NAME [ : ] : NAME . NAME ( NAME ) # Create formatter NAME = NAME ( NAME = NAME , NAME = NAME ) # Configure File Handler NAME ( NAME ) . NAME . NAME ( NAME = True , NAME = True ) NAME = NAME . NAME ( NAME , NAME = LIT , NAME = LIT ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) # Configure Console Handler NAME = NAME . NAME ( NAME . NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) # Add filters to console handler NAME . NAME ( NAME ( ) ) NAME . NAME ( NAME ( [ LIT , LIT , LIT , LIT , LIT , LIT , ] ) ) NAME . NAME ( NAME ) # Configure logging levels for external libraries NAME . NAME ( LIT ) . NAME ( NAME . NAME ) NAME . NAME ( LIT ) . NAME ( NAME . NAME ) NAME . NAME ( LIT ) . NAME ( NAME . NAME ) NAME . NAME ( LIT ) . NAME ( NAME . NAME ) NAME . NAME ( LIT ) . NAME ( NAME . NAME ) NAME . NAME ( LIT ) . NAME ( NAME . NAME ) NAME . NAME ( LIT ) . NAME ( NAME . NAME ) # Disable propagation NAME . NAME ( LIT ) . NAME = False NAME . NAME ( LIT ) . NAME = False # Mark logging as initialized NAME = True return NAME"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "logging_config_module_tests",
      "lineno": 316,
      "end_lineno": 466,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 151,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "13b327f20e688e20818d7bfb0e1370fe33a95e81",
      "simhash64": 5127871611137332267,
      "normalized": "def NAME ( ) -> NAME : LIT with NAME ( ) : NAME = NAME ( LIT , LIT ) # Run all tests NAME ( LIT ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Generate summary report return NAME . NAME ( )"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 469,
      "end_lineno": 471,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_logger_creation",
      "lineno": 475,
      "end_lineno": 498,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 24,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "fc54e90b2322acc35ee11f9a8e5f3d83967de7c3",
      "simhash64": 7434136828526367803,
      "normalized": "def NAME ( ) : LIT NAME = [ ( LIT , NAME . NAME , LIT , LIT ) , ( LIT , NAME . NAME , NAME . NAME , LIT ) , ( LIT , NAME . NAME , False , LIT ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME , NAME , NAME in NAME : NAME = NAME == NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" { NAME } : { NAME } (Expected: { NAME } ) \" ) NAME . NAME ( NAME ) assert NAME == NAME , f\" { NAME } should be { NAME } , got { NAME } \" NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } logger configuration tests passed \" )"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_default_configuration",
      "lineno": 501,
      "end_lineno": 505,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "344b3840db8c6186a78ea13532131e2eaa904d9a",
      "simhash64": 8641277415087584887,
      "normalized": "def NAME ( ) : LIT assert NAME assert NAME assert NAME"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_directory_creation",
      "lineno": 508,
      "end_lineno": 531,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 24,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3d803b62cfc695986b36e454393f35daca9693e6",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( ) : LIT import NAME with NAME . NAME ( ) as NAME : global NAME , NAME NAME = NAME NAME = NAME NAME = False # Reset to allow fresh setup NAME = NAME ( NAME ) / LIT NAME ( LIT , LIT ) # Check that directory was created NAME = NAME . NAME ( ) # Close all handlers to release file locks before temp dir cleanup for NAME in NAME . NAME [ : ] : NAME . NAME ( ) NAME . NAME ( NAME ) NAME = NAME NAME = NAME assert NAME"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_setup_logging",
      "lineno": 534,
      "end_lineno": 538,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "dcb7850930b847031f3f695dcb8e1a70c96a1ad9",
      "simhash64": 7451729014569735731,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( LIT , LIT ) assert NAME is not None assert NAME . NAME == LIT"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_log_level_setting",
      "lineno": 541,
      "end_lineno": 546,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "6fbf6819f160c1e8bcd4a27d58bdec87b3174a5a",
      "simhash64": 7488180022980027451,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( LIT , LIT ) # Check that handlers have the correct level for NAME in NAME . NAME : assert NAME . NAME == NAME . NAME"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_handler_configuration",
      "lineno": 549,
      "end_lineno": 561,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7cd82e8e2d71561e13755fb62371502f7d27ec17",
      "simhash64": 7488180022980031603,
      "normalized": "def NAME ( ) : LIT global NAME NAME = NAME NAME = False # Reset to allow fresh setup NAME = NAME ( LIT , LIT ) assert NAME ( NAME . NAME ) >= LIT # Should have file handler and possibly console handler NAME = [ NAME ( NAME ) . NAME for NAME in NAME . NAME ] assert NAME ( LIT in NAME for NAME in NAME ) NAME = NAME"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_formatter_application",
      "lineno": 564,
      "end_lineno": 577,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "11ac6ade5385e6ba9c92005aadda059251ffecb9",
      "simhash64": 7488250397092910107,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( NAME = NAME , NAME = NAME ) NAME = NAME . NAME ( NAME = LIT , NAME = NAME . NAME , NAME = LIT , NAME = LIT , NAME = LIT , NAME = ( ) , NAME = None , ) NAME = NAME . NAME ( NAME ) assert LIT in NAME"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_invalid_log_level",
      "lineno": 580,
      "end_lineno": 584,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "568124cd542727da39dbec8181f570f9efed2e7b",
      "simhash64": 6334827476597773859,
      "normalized": "def NAME ( ) : LIT # Should default to INFO for invalid levels NAME = NAME ( LIT , LIT ) assert NAME is not None"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_missing_directory",
      "lineno": 587,
      "end_lineno": 610,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 24,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c9890893bcd1f6047a83add655bb5a7e73bc5ae5",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( ) : LIT import NAME with NAME . NAME ( ) as NAME : global NAME , NAME NAME = NAME NAME = NAME NAME = False # Reset to allow fresh setup NAME = NAME ( NAME ) / LIT / LIT / LIT NAME ( LIT , LIT ) # Check that directory was created NAME = NAME . NAME ( ) # Close all handlers to release file locks before temp dir cleanup for NAME in NAME . NAME [ : ] : NAME . NAME ( ) NAME . NAME ( NAME ) NAME = NAME NAME = NAME assert NAME"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_reinitialize_logging",
      "lineno": 613,
      "end_lineno": 626,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "93404efb1f70d6bc787b95ba5c976c9953c26927",
      "simhash64": 7488109619876103251,
      "normalized": "def NAME ( ) : LIT global NAME NAME = NAME NAME = True # Get initial handler count NAME = NAME ( NAME . NAME ) # Reinitialize - should not add new handlers NAME ( LIT , LIT ) assert NAME ( NAME . NAME ) == NAME NAME = NAME"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_multiple_handlers",
      "lineno": 629,
      "end_lineno": 639,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "aa74ba90ec0433a507e0122b662eb6b2f51e2e0a",
      "simhash64": 7452186410333148283,
      "normalized": "def NAME ( ) : LIT global NAME NAME = NAME NAME = False # Reset to allow fresh setup NAME = NAME ( LIT , LIT ) # Should have at least one handler assert NAME ( NAME . NAME ) >= LIT NAME = NAME"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_filter_integration",
      "lineno": 642,
      "end_lineno": 668,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 27,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "003ec72d113b77c0ea09fd0a12b839e918996785",
      "simhash64": 5146378556502086687,
      "normalized": "def NAME ( ) : LIT # Test the NameFilter NAME = NAME ( [ LIT ] ) # Create test records NAME = NAME . NAME ( NAME = LIT , NAME = NAME . NAME , NAME = LIT , NAME = LIT , NAME = LIT , NAME = ( ) , NAME = None , ) NAME = NAME . NAME ( NAME = LIT , NAME = NAME . NAME , NAME = LIT , NAME = LIT , NAME = LIT , NAME = ( ) , NAME = None , ) assert NAME . NAME ( NAME ) assert not NAME . NAME ( NAME )"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_external_library_logging",
      "lineno": 671,
      "end_lineno": 675,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "impure",
        "network",
        "logging",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "748d1d976b0274d3db064952d7bc31f925bf0783",
      "simhash64": 7487723725654504467,
      "normalized": "def NAME ( ) : LIT # This would test the urllib3, selenium, etc. logger configurations NAME = NAME . NAME ( LIT ) assert NAME . NAME == NAME . NAME"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_logging_speed",
      "lineno": 678,
      "end_lineno": 690,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "fcdf7a18af8baedd39d46e942e01378d0eb2cb06",
      "simhash64": 8640573763079279739,
      "normalized": "def NAME ( ) : LIT import NAME NAME = NAME ( LIT , LIT ) NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME . NAME ( f\" Test message { NAME } \" ) NAME = NAME . NAME ( ) # Should complete 100 log messages in reasonable time (< 1 second) assert ( NAME - NAME ) < LIT"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_handler_performance",
      "lineno": 693,
      "end_lineno": 703,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d740e5c538ca5c0d34b042af15e499d1751d86fe",
      "simhash64": 7452116008302982267,
      "normalized": "def NAME ( ) : LIT global NAME NAME = NAME NAME = False # Reset to allow fresh setup NAME = NAME ( LIT , LIT ) # Performance should be reasonable even with multiple handlers assert NAME ( NAME . NAME ) > LIT NAME = NAME"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_invalid_file_path",
      "lineno": 706,
      "end_lineno": 711,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "51b06e732467851bc5dad71684ac3d958db738be",
      "simhash64": 8643388478815376427,
      "normalized": "def NAME ( ) : LIT from NAME import NAME with NAME ( NAME ) : # Try with an invalid path - should handle gracefully NAME ( LIT , LIT )"
    },
    {
      "module_path": "logging_config.py",
      "qualname": "test_permission_errors",
      "lineno": 715,
      "end_lineno": 721,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "f77d1074d73a7f53e2e0600711f902747a4556fe",
      "simhash64": 7492648403833620011,
      "normalized": "def NAME ( ) : LIT # This test is platform-specific and may not always be testable # Just verify the function doesn't crash with edge cases from NAME import NAME with NAME ( NAME ) : NAME ( LIT , LIT )"
    },
    {
      "module_path": "main.py",
      "qualname": "validate_action_config",
      "lineno": 68,
      "end_lineno": 113,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 7,
      "loc": 46,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "04d9c6c88bfc6b635043f9c23d3cc7f803596536",
      "simhash64": 7452186410333156379,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Import and validate configuration try : from NAME import NAME if NAME is None : NAME . NAME ( LIT ) return False NAME = NAME # Assign the loaded configuration instance NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Could not import config_schema from config package: { NAME } \" ) return False except NAME as NAME : NAME . NAME ( f\" Unexpected error loading configuration: { NAME } \" ) return False # Check essential processing limits (only warn about critical issues) NAME = [ ] if NAME . NAME <= LIT : NAME . NAME ( LIT ) if NAME . NAME <= LIT : NAME . NAME ( LIT ) # Remove RPS warning since 0.25 is actually conservative if NAME : NAME . NAME ( f\" Configuration notes: { LIT . NAME ( NAME ) } \" ) # Log current configuration for transparency NAME . NAME ( LIT ) NAME . NAME ( f\" MAX_PAGES: { NAME . NAME . NAME } \" ) NAME . NAME ( f\" BATCH_SIZE: { NAME . NAME } \" ) NAME . NAME ( f\" MAX_PRODUCTIVE_TO_PROCESS: { NAME . NAME } \" ) NAME . NAME ( f\" MAX_INBOX: { NAME . NAME } \" ) NAME . NAME ( f\" Rate Limiting - RPS: { NAME . NAME . NAME } , Delay: { NAME . NAME . NAME } s \" ) NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" Configuration validation failed: { NAME } \" ) return False"
    },
    {
      "module_path": "main.py",
      "qualname": "_get_current_log_level",
      "lineno": 151,
      "end_lineno": 171,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 21,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:factory",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3827b5fed84a835a14c55a50ec26c569f394105d",
      "simhash64": 7488180022980027395,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = LIT # Default if NAME and NAME . NAME : NAME = None for NAME in NAME . NAME : if ( NAME ( NAME , NAME . NAME ) and NAME . NAME == NAME . NAME ) : NAME = NAME break if NAME : NAME = NAME . NAME ( NAME . NAME ) else : NAME = NAME . NAME ( NAME . NAME ( ) ) elif NAME ( NAME , LIT ) and NAME ( NAME . NAME , LIT ) : NAME = NAME . NAME . NAME . NAME ( ) return NAME"
    },
    {
      "module_path": "main.py",
      "qualname": "_display_main_menu_options",
      "lineno": 174,
      "end_lineno": 187,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "impure",
        "logging",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7bd40c92e17d5a13e8cee3e36dc4658f6177d4b3",
      "simhash64": 6915827017690551851,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT )"
    },
    {
      "module_path": "main.py",
      "qualname": "_display_phase12_menu_options",
      "lineno": 190,
      "end_lineno": 197,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "impure",
        "logging",
        "purpose:formatting",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "6564cc5160957c6905e50f54c1bf0ebe265699b4",
      "simhash64": 6915827017690551851,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT )"
    },
    {
      "module_path": "main.py",
      "qualname": "_display_utility_menu_options",
      "lineno": 200,
      "end_lineno": 211,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "impure",
        "logging",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c2fcf5d88ec2402e6c24f5424ef1078d29740210",
      "simhash64": 6915827017690551851,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT )"
    },
    {
      "module_path": "main.py",
      "qualname": "menu",
      "lineno": 214,
      "end_lineno": 226,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "18f7a6253d0086bd693ad1ebf8e28e41a90f4e93",
      "simhash64": 8622559335043466283,
      "normalized": "def NAME ( ) -> NAME : LIT NAME ( LIT ) NAME ( LIT * LIT ) NAME = NAME ( ) NAME ( f\" (Log Level: { NAME } )\\n \" ) NAME ( ) NAME ( ) NAME ( ) return NAME ( LIT ) . NAME ( ) . NAME ( )"
    },
    {
      "module_path": "main.py",
      "qualname": "clear_log_file",
      "lineno": 232,
      "end_lineno": 264,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 33,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "28c8e1821f9616b21c99bc66937ac461d8062405",
      "simhash64": 7452256779078382615,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME [ NAME ] ] : LIT NAME = False NAME : NAME [ NAME . NAME ] = None NAME : NAME [ NAME ] = None try : # Step 1: Find the FileHandler in the logger's handlers for NAME in NAME . NAME : if NAME ( NAME , NAME . NAME ) : NAME = NAME NAME = NAME . NAME # type: ignore[union-attr] break if NAME and NAME : # Step 2: Flush the handler (ensuring all previous writes are persisted to disk) NAME . NAME ( ) # type: ignore[union-attr] # Step 3: Close the handler (releases resources) NAME . NAME ( ) # type: ignore[union-attr] # Step 4: Clear the log file contents from NAME import NAME NAME ( NAME ) . NAME ( LIT , NAME = LIT ) . NAME ( ) NAME = True except NAME as NAME : # Handle permission errors when attempting to open the log file NAME . NAME ( f\" Permission denied clearing log ' { NAME } ': { NAME } \" ) except NAME as NAME : # Handle I/O errors when attempting to open the log file NAME . NAME ( f\" IOError clearing log ' { NAME } ': { NAME } \" ) except NAME as NAME : # Handle any other exceptions during the log clearing process NAME . NAME ( f\" Error clearing log ' { NAME } ': { NAME } \" , NAME = True ) return NAME , NAME"
    },
    {
      "module_path": "main.py",
      "qualname": "_show_platform_specific_instructions",
      "lineno": 270,
      "end_lineno": 281,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b70fa40636fb72422503709f40c3ed7b1026cf31",
      "simhash64": 6334730719565616683,
      "normalized": "def NAME ( ) -> None : LIT import NAME # Use platform.system() instead of os.name to avoid static analysis warning NAME = NAME . NAME ( ) if NAME in ( LIT , LIT ) : # Linux or macOS NAME ( LIT ) NAME ( LIT ) NAME ( LIT )"
    },
    {
      "module_path": "main.py",
      "qualname": "initialize_aggressive_caching",
      "lineno": 288,
      "end_lineno": 298,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d1ed928e4121bf64c00fbc949af345007ea1341c",
      "simhash64": 7492718806979482651,
      "normalized": "def NAME ( ) -> NAME : LIT try : from NAME import NAME return NAME ( ) except NAME : NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" Failed to initialize aggressive caching: { NAME } \" ) return False"
    },
    {
      "module_path": "main.py",
      "qualname": "ensure_caching_initialized",
      "lineno": 301,
      "end_lineno": 317,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c855a985c7159fdcf0fd52dc41965c7918c29afb",
      "simhash64": 8640573762005537795,
      "normalized": "def NAME ( ) -> NAME : LIT global NAME if not NAME : NAME . NAME ( LIT ) NAME = NAME ( ) if NAME : NAME . NAME ( LIT ) NAME = True else : NAME . NAME ( LIT ) return NAME NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "main.py",
      "qualname": "_check_cached_gedcom_data",
      "lineno": 323,
      "end_lineno": 331,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "fc3996b4ae8e9f30a9a96dda0ffd8a7892c55ea6",
      "simhash64": 7488144838607930411,
      "normalized": "def NAME ( ) -> NAME : LIT if NAME : from NAME import NAME NAME = NAME ( ) if NAME : NAME . NAME ( LIT ) return True return False"
    },
    {
      "module_path": "main.py",
      "qualname": "_get_gedcom_file_path",
      "lineno": 334,
      "end_lineno": 351,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "impure",
        "logging",
        "purpose:factory",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ba1625e111c61c7c539adbf6e167614974454112",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( ) -> NAME [ NAME ] : LIT try : from NAME . NAME import NAME NAME = NAME ( ) NAME = NAME . NAME ( ) NAME = NAME ( NAME . NAME , LIT , None ) if not NAME : NAME ( LIT ) NAME ( LIT ) return None return NAME except NAME as NAME : NAME . NAME ( f\" Error getting GEDCOM path from config: { NAME } \" ) return None"
    },
    {
      "module_path": "main.py",
      "qualname": "_validate_gedcom_file_exists",
      "lineno": 354,
      "end_lineno": 365,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(gedcom_path)",
      "fingerprint": "c0e9d650659139d7c22625ca894b2b10d2dc4ed9",
      "simhash64": 7492648438235300883,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT from NAME import NAME NAME = NAME ( NAME ) if not NAME . NAME ( ) : NAME ( f\" \u274c GEDCOM file not found: { NAME } \" ) NAME ( LIT ) return False NAME ( f\" \ud83d\udcc2 Loading GEDCOM file: { NAME . NAME } \" ) return True"
    },
    {
      "module_path": "main.py",
      "qualname": "_load_and_cache_gedcom_data",
      "lineno": 368,
      "end_lineno": 389,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 22,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:small"
      ],
      "signature": "(gedcom_path)",
      "fingerprint": "7b8756427ebe199e7508b42bcf8fa8f7b649eb23",
      "simhash64": 7488109654235841595,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if not NAME : NAME ( LIT ) return False from NAME import NAME from NAME import NAME , NAME NAME = NAME ( NAME ) NAME = NAME ( NAME ) if NAME : # Cache the loaded data NAME ( NAME ) NAME ( LIT ) NAME ( f\" \ud83d\udcca Individuals: { NAME ( NAME ( NAME , LIT , { } ) ) } \" ) return True NAME ( LIT ) return False"
    },
    {
      "module_path": "main.py",
      "qualname": "ensure_gedcom_loaded_and_cached",
      "lineno": 392,
      "end_lineno": 424,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 33,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "00baf458d8ecd68b620dedc49934a924fefe277d",
      "simhash64": 8064667129807279651,
      "normalized": "def NAME ( ) -> NAME : LIT try : # First ensure caching is initialized NAME ( ) # Check if GEDCOM data is already cached if NAME ( ) : return True # Try to load GEDCOM data NAME ( LIT ) # Get GEDCOM file path from configuration NAME = NAME ( ) if not NAME : return False # Validate file exists if not NAME ( NAME ) : return False # Load and cache the GEDCOM data return NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error ensuring GEDCOM loaded and cached: { NAME } \" ) return False"
    },
    {
      "module_path": "main.py",
      "qualname": "exec_actn",
      "lineno": 430,
      "end_lineno": 640,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": true,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 36,
      "loc": 211,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "(action_func, session_manager, choice, close_sess_after, *args)",
      "fingerprint": "fb4348fea72bb3c986066ec5bd2e66568f8d0736",
      "simhash64": 7488109654302954523,
      "normalized": "def NAME ( NAME : NAME [ ... , NAME ] , NAME : NAME , NAME : NAME , NAME : NAME = False , * NAME , ) -> NAME : LIT NAME = NAME . NAME ( ) NAME = NAME . NAME # --- Performance Logging Setup --- NAME = NAME . NAME ( NAME . NAME ( ) ) NAME = NAME . NAME ( ) . NAME / ( LIT * LIT ) NAME . NAME ( LIT ) NAME . NAME ( f\" Action { NAME } : Starting { NAME } ... \" ) NAME . NAME ( LIT ) NAME = None NAME = None # Store exception if one occurs # Determine if the action requires a browser NAME = [ LIT , LIT , LIT , LIT , LIT , # GEDCOM Report (Local File) # \"run_action11_wrapper\",  # API Report (Ancestry Online) - Removed: needs browser session ] # Set browser_needed flag based on action NAME = NAME not in NAME NAME . NAME = NAME # Determine the required session state for the action NAME = LIT # Default for actions that don't need any special state if NAME : # Special case for check_login_actn: only needs driver, not full session NAME = LIT if NAME == LIT else LIT else : NAME = LIT # Database-only session # --- Preflight: prevent duplicate Action 6 run if lock is held --- if NAME in ( LIT , LIT ) : try : from NAME import NAME NAME = NAME ( LIT ) / LIT if NAME . NAME ( ) : try : NAME = NAME . NAME ( NAME = LIT , NAME = LIT ) . NAME ( ) NAME = NAME . NAME ( LIT ) NAME = NAME ( NAME [ LIT ] ) if NAME and NAME [ LIT ] . NAME ( ) else None NAME = NAME [ LIT ] if NAME ( NAME ) > LIT else LIT except NAME : NAME = None NAME = LIT # Check if holder is alive NAME = False if NAME : try : NAME = NAME . NAME ( NAME ) except NAME : NAME = False if NAME : NAME . NAME ( f\" Action 6 already running (PID= { NAME } , RUN= { NAME } ). Skipping duplicate start. \" ) return True # Graceful no-op, do not close session except NAME as NAME : NAME . NAME ( f\" Action 6 lock preflight check error: { NAME } \" ) try : # --- Ensure Required State --- NAME = True if NAME == LIT : NAME = NAME . NAME ( ) elif NAME == LIT : # For check_login_actn: only ensure browser is started, no login attempts NAME = NAME . NAME . NAME ( f\" { NAME } - Browser Start \" ) elif NAME == LIT : # Skip CSRF token validation for Action 11 (only uses Tree Ladder API) NAME = ( NAME == LIT ) NAME = NAME . NAME ( NAME = f\" { NAME } - Setup \" , NAME = NAME ) if not NAME : # Log specific state failure before raising generic exception NAME . NAME ( f\" Failed to achieve required state ' { NAME } ' for action ' { NAME } '. \" ) raise NAME ( f\" Setup failed: Could not achieve state ' { NAME } '. \" ) # --- Execute Action --- # Prepare arguments for action function call NAME = NAME . NAME ( NAME ) NAME = LIT in NAME . NAME NAME = [ ] if NAME : NAME . NAME ( NAME ) NAME . NAME ( NAME ) # Handle keyword args specifically for coord function if NAME in [ LIT , LIT ] and LIT in NAME . NAME : NAME = LIT NAME = [ NAME for NAME in NAME if NAME ( NAME , NAME ) ] if NAME : NAME = NAME [ - LIT ] NAME = { LIT : NAME } # Prepare coord specific positional args NAME = [ ] if NAME : NAME . NAME ( NAME ) # coord_action also needs config_schema if NAME == LIT and LIT in NAME . NAME : NAME . NAME ( NAME ) # Pass the global config # Call with prepared positional args and keyword args NAME = NAME ( * NAME , ** NAME ) else : # General case - call with the assembled final_args list NAME = NAME ( * NAME ) except NAME as NAME : # Log exception details and mark action as failure NAME . NAME ( f\" Exception during action { NAME } : { NAME } \" , NAME = True ) NAME = False NAME = NAME finally : # --- Session Closing Logic (Simplified) --- NAME = False if NAME is False or NAME is not None : # Close session if action failed or raised exception NAME . NAME ( f\" Action ' { NAME } ' failed or raised exception. Closing session. \" ) NAME = True elif NAME : # Close session if explicitly requested NAME . NAME ( f\" Closing session after ' { NAME } ' as requested by caller (close_sess_after=True). \" ) NAME = True # --- Performance Logging --- NAME = NAME . NAME ( ) - NAME NAME , NAME = NAME ( NAME , LIT ) NAME , NAME = NAME ( NAME , LIT ) NAME = f\" { NAME ( NAME ) } hr { NAME ( NAME ) } min { NAME : .2f } sec \" # Recalculate memory usage safely try : NAME = NAME . NAME ( ) . NAME / ( LIT * LIT ) NAME = NAME - NAME NAME = f\" Memory used: { NAME : .1f } MB \" except NAME as NAME : NAME = f\" Memory usage unavailable: { NAME } \" NAME ( LIT ) # Spacer # Restore old footer style if NAME is False : NAME . NAME ( f\" Action { NAME } ( { NAME } ) reported failure. \" ) elif NAME is not None : NAME . NAME ( f\" Action { NAME } ( { NAME } ) failed due to exception: { NAME ( NAME ) . NAME } . \" ) # --- Return Action Result --- # Return True only if action completed without exception AND didn't return False explicitly NAME = NAME is not False and NAME is None NAME . NAME ( LIT ) NAME . NAME ( f\" Action { NAME } ( { NAME } ) finished. \" ) NAME . NAME ( f\" Duration: { NAME } \" ) NAME . NAME ( NAME ) NAME . NAME ( LIT ) # Perform cleanup AFTER footer to prevent logs bleeding after completion if NAME and NAME ( NAME , NAME ) : if NAME . NAME and NAME . NAME : NAME . NAME ( LIT ) # Close browser but keep DB connections for most actions NAME . NAME ( ) NAME . NAME ( LIT ) elif NAME and NAME in [ LIT ] : # For specific actions, close everything including DB NAME . NAME ( LIT ) NAME . NAME ( NAME = False ) NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "main.py",
      "qualname": "all_but_first_actn",
      "lineno": 649,
      "end_lineno": 790,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 10,
      "loc": 142,
      "tags": [
        "pure-ish",
        "size:large"
      ],
      "signature": "(session_manager, *args)",
      "fingerprint": "26808c433511c6c1531026e3f842326fe0626d2b",
      "simhash64": 7488180022980023323,
      "normalized": "def NAME ( NAME : NAME , * NAME ) -> NAME : LIT # Define the specific profile ID to keep from config (ensure it's uppercase for comparison) NAME = NAME . NAME . NAME if not NAME : NAME . NAME ( LIT ) return False NAME = NAME . NAME ( ) NAME = None # Initialize NAME = None NAME = False try : # --- Close main pool FIRST --- if NAME : NAME . NAME ( f\" Closing main DB connections before deleting data (except { NAME } )... \" ) NAME . NAME ( NAME = False ) NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) # --- End closing main pool --- NAME . NAME ( f\" Deleting data for all people except Profile ID: { NAME } ... \" ) # Create a temporary SessionManager for this specific operation NAME = NAME ( ) NAME = NAME . NAME ( ) if NAME is None : raise NAME ( LIT ) with NAME ( NAME ) as NAME : # 1. Find the ID of the person to keep NAME = ( NAME . NAME ( NAME . NAME , NAME . NAME ) . NAME ( NAME . NAME == NAME , NAME . NAME is None ) . NAME ( ) ) if not NAME : NAME . NAME ( f\" Person with Profile ID { NAME } not found. No records will be deleted. \" ) return True # Exit gracefully if the keeper doesn't exist NAME = NAME . NAME NAME . NAME ( f\" Keeping Person ID: { NAME } (ProfileID: { NAME } , User: { NAME . NAME } ) \" ) # --- Perform Deletions --- NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } # 2. Delete from conversation_log NAME . NAME ( f\" Deleting from conversation_log where people_id != { NAME } ... \" ) NAME = ( NAME . NAME ( NAME ) . NAME ( NAME . NAME != NAME ) . NAME ( NAME = False ) ) NAME [ LIT ] = ( NAME if NAME is not None else LIT ) NAME . NAME ( f\" Deleted { NAME [ LIT ] } conversation_log records. \" ) # 3. Delete from dna_match NAME . NAME ( f\" Deleting from dna_match where people_id != { NAME } ... \" ) NAME = ( NAME . NAME ( NAME ) . NAME ( NAME . NAME != NAME ) . NAME ( NAME = False ) ) NAME [ LIT ] = NAME if NAME is not None else LIT NAME . NAME ( f\" Deleted { NAME [ LIT ] } dna_match records. \" ) # 4. Delete from family_tree NAME . NAME ( f\" Deleting from family_tree where people_id != { NAME } ... \" ) NAME = ( NAME . NAME ( NAME ) . NAME ( NAME . NAME != NAME ) . NAME ( NAME = False ) ) NAME [ LIT ] = NAME if NAME is not None else LIT NAME . NAME ( f\" Deleted { NAME [ LIT ] } family_tree records. \" ) # 5. Delete from people NAME . NAME ( f\" Deleting from people where id != { NAME } ... \" ) NAME = ( NAME . NAME ( NAME ) . NAME ( NAME . NAME != NAME ) . NAME ( NAME = False ) ) NAME [ LIT ] = NAME if NAME is not None else LIT NAME . NAME ( f\" Deleted { NAME [ LIT ] } people records. \" ) NAME = NAME ( NAME . NAME ( ) ) if NAME == LIT : NAME . NAME ( f\" No records found to delete besides Person ID { NAME } . \" ) NAME = True # Mark success if transaction completes except NAME as NAME : NAME . NAME ( f\" Error during deletion (except { NAME } ): { NAME } \" , NAME = True ) NAME = False # Explicitly mark failure finally : # Clean up the temporary session manager and its resources if NAME : if NAME : NAME . NAME ( NAME ) NAME . NAME ( NAME = False ) # Close the temp pool NAME . NAME ( f\" Delete action (except { NAME } ) finished. \" ) return NAME"
    },
    {
      "module_path": "main.py",
      "qualname": "run_core_workflow_action",
      "lineno": 797,
      "end_lineno": 959,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": false,
      "returns_count": 13,
      "yield_count": 0,
      "complexity": 16,
      "loc": 163,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "(session_manager, *args)",
      "fingerprint": "f8f2f8f80a855bfc6806eb9a075d7ff965e0fa7c",
      "simhash64": 7487617073026601995,
      "normalized": "def NAME ( NAME : NAME , * NAME ) -> NAME : LIT # Guard clause now checks session_ready if not NAME or not NAME . NAME : NAME . NAME ( LIT ) return False try : # --- Action 6 (Optional) --- # Check if Action 6 should be included in the workflow NAME = NAME . NAME if NAME : NAME . NAME ( LIT ) NAME = NAME ( NAME , NAME , NAME = LIT ) if NAME is False : NAME . NAME ( LIT ) # Match gathering failure logged above return False NAME . NAME ( LIT ) # --- Action 7 --- NAME . NAME ( LIT ) NAME = NAME ( NAME . NAME . NAME , LIT ) NAME . NAME ( f\" Navigating to Inbox ( { NAME } ) for Action 7... \" ) # Use a more reliable selector that exists on the messaging page # First try to navigate to the inbox page try : if not NAME ( NAME . NAME , NAME , LIT , # More general selector for the messaging container NAME , ) : NAME . NAME ( LIT ) # Navigation error logged above return False NAME . NAME ( LIT ) # Add a short delay to ensure page is fully loaded NAME . NAME ( LIT ) # Now run the inbox processor NAME . NAME ( LIT ) NAME = NAME ( NAME = NAME ) NAME = NAME . NAME ( ) if NAME is False : NAME . NAME ( LIT ) # Inbox search failure logged above return False NAME . NAME ( LIT ) # Inbox search completed successfully except NAME as NAME : NAME . NAME ( f\" Action 7 FAILED with exception: { NAME } \" , NAME = True ) # Error during inbox search logged above return False # --- Action 9 --- NAME . NAME ( LIT ) NAME . NAME ( LIT ) try : if not NAME ( NAME . NAME , NAME . NAME . NAME , NAME , # Use a general page load selector NAME , ) : NAME . NAME ( LIT ) # Navigation error logged above return False NAME . NAME ( LIT ) # Add a short delay to ensure page is fully loaded NAME . NAME ( LIT ) # Process productive messages NAME = NAME ( NAME ) if NAME is False : NAME . NAME ( LIT ) NAME ( LIT ) return False NAME . NAME ( LIT ) # Productive message processing completed successfully except NAME as NAME : NAME . NAME ( f\" Action 9 FAILED with exception: { NAME } \" , NAME = True ) NAME ( f\" ERROR during productive message processing: { NAME } \" ) return False # --- Action 8 --- NAME . NAME ( LIT ) NAME . NAME ( LIT ) try : if not NAME ( NAME . NAME , NAME . NAME . NAME , NAME , # Use a general page load selector NAME , ) : NAME . NAME ( LIT ) NAME ( LIT ) return False NAME . NAME ( LIT ) # Add a short delay to ensure page is fully loaded NAME . NAME ( LIT ) # send_messages_to_matches expects session_manager NAME = NAME ( NAME ) if NAME is False : NAME . NAME ( LIT ) # Message sending failure logged above return False NAME . NAME ( LIT ) # Message sending completed successfully except NAME as NAME : NAME . NAME ( f\" Action 8 FAILED with exception: { NAME } \" , NAME = True ) NAME ( f\" ERROR during message sending: { NAME } \" ) return False # Determine which actions were run for the success message NAME = [ ] if NAME : NAME . NAME ( LIT ) NAME . NAME ( [ LIT , LIT , LIT ] ) NAME = LIT . NAME ( NAME ) NAME . NAME ( f\" Core Workflow (Actions { NAME } ) finished successfully. \" ) NAME ( f\" \\n\u2713 Core Workflow (Actions { NAME } ) completed successfully. \" ) return True except NAME as NAME : NAME . NAME ( f\" Critical error during core workflow: { NAME } \" , NAME = True ) # Critical error during core workflow logged above return False"
    },
    {
      "module_path": "main.py",
      "qualname": "_create_message_template",
      "lineno": 965,
      "end_lineno": 1006,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 10,
      "loc": 42,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(template_key, template_content)",
      "fingerprint": "f34ca9c549151aebae18d4e08d689887fb51d52a",
      "simhash64": 7452221595846087723,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT # Extract subject line from content NAME = None if NAME . NAME ( LIT ) : NAME = NAME . NAME ( LIT , LIT ) if NAME ( NAME ) >= LIT : NAME = NAME [ LIT ] . NAME ( LIT , LIT ) . NAME ( ) # Determine template category and tree status NAME = LIT NAME = LIT if LIT in NAME : NAME = LIT elif LIT in NAME : NAME = LIT elif LIT in NAME : NAME = LIT elif LIT in NAME : NAME = LIT elif LIT in NAME : NAME = LIT if NAME . NAME ( LIT ) : NAME = LIT elif NAME . NAME ( LIT ) : NAME = LIT # Create human-readable name NAME = NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) return NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = True , NAME = LIT )"
    },
    {
      "module_path": "main.py",
      "qualname": "reset_db_actn",
      "lineno": 1010,
      "end_lineno": 1137,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 19,
      "loc": 128,
      "tags": [
        "impure",
        "db",
        "time",
        "size:large"
      ],
      "signature": "(session_manager, *args)",
      "fingerprint": "5e145c64d5b2a1631bdc1b84223a806abb958e5b",
      "simhash64": 8641136712026076163,
      "normalized": "def NAME ( NAME : NAME , * NAME ) -> NAME : LIT NAME = NAME . NAME . NAME NAME = False NAME = None # For recreation/seeding NAME = None # Session for seeding try : # --- 1. Close main pool FIRST --- if NAME : NAME . NAME ( LIT ) NAME . NAME ( NAME = False ) # Ensure pool is closed NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) # Force garbage collection to release any file handles NAME . NAME ( LIT ) NAME . NAME ( ) NAME . NAME ( LIT ) NAME . NAME ( ) # --- 2. Reset Database Content --- if NAME is None : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) try : # Create temporary SessionManager for database reset NAME . NAME ( LIT ) NAME = NAME ( ) # Step 1: Safely truncate all tables that exist NAME . NAME ( LIT ) NAME = NAME . NAME ( ) if NAME : with NAME ( NAME ) as NAME : # Check which tables exist and delete in safe order from NAME import NAME NAME = NAME ( NAME . NAME ( ) ) NAME = NAME . NAME ( ) NAME . NAME ( f\" Found existing tables: { NAME } \" ) # Delete in reverse dependency order, but only if tables exist if LIT in NAME : NAME . NAME ( NAME ) . NAME ( NAME = False ) NAME . NAME ( LIT ) if LIT in NAME : NAME . NAME ( NAME ) . NAME ( NAME = False ) NAME . NAME ( LIT ) if LIT in NAME : NAME . NAME ( NAME ) . NAME ( NAME = False ) NAME . NAME ( LIT ) if LIT in NAME : NAME . NAME ( NAME ) . NAME ( NAME = False ) NAME . NAME ( LIT ) # Clear message_types too for complete reset if LIT in NAME : NAME . NAME ( NAME ) . NAME ( NAME = False ) NAME . NAME ( LIT ) NAME . NAME ( NAME ) NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) return False # Step 2: Ensure all tables exist with proper schema NAME . NAME ( LIT ) NAME . NAME . NAME ( ) if not NAME . NAME . NAME or not NAME . NAME . NAME : raise NAME ( LIT ) # Create any missing tables NAME . NAME . NAME ( NAME . NAME . NAME ) NAME . NAME ( LIT ) # --- Seed MessageTemplate Table (handled by database.py) --- # Note: MessageTemplate seeding is now handled by database.py during create_all() # The following code is kept for reference but should not be needed NAME = NAME . NAME ( ) if not NAME : raise NAME ( LIT ) # MessageTemplate verification (templates managed in database) with NAME ( NAME ) as NAME : NAME = NAME . NAME ( NAME . NAME ( NAME . NAME ) ) . NAME ( ) or LIT NAME . NAME ( f\" MessageTemplate verification: { NAME } templates found in database \" ) # --- End Seeding --- NAME = True NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error during DB recreation/seeding: { NAME } \" , NAME = True ) NAME = False finally : # Clean up the temporary manager and its session/engine NAME . NAME ( LIT ) if NAME : if NAME : NAME . NAME ( NAME ) NAME . NAME ( NAME = False ) # Dispose temp engine NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Outer error during DB reset action: { NAME } \" , NAME = True ) NAME = False # Ensure failure is marked finally : NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "main.py",
      "qualname": "backup_db_actn",
      "lineno": 1144,
      "end_lineno": 1160,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(session_manager, *args)",
      "fingerprint": "cc165c1175914e55af39b0661cf01e304bffbea2",
      "simhash64": 7488180023047132171,
      "normalized": "def NAME ( NAME : NAME [ NAME ] = None , * NAME ) : # Added session_manager parameter for exec_actn compatibility NAME = NAME # Mark as intentionally unused LIT try : NAME . NAME ( LIT ) # session_manager isn't used but needed for exec_actn compatibility NAME = NAME ( ) if NAME : NAME . NAME ( LIT ) return True NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" Error during DB backup: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "main.py",
      "qualname": "restore_db_actn",
      "lineno": 1167,
      "end_lineno": 1220,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 54,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(session_manager, *args)",
      "fingerprint": "e45e15fc5b9aae9bc583dc78e99e52a1e71d68e2",
      "simhash64": 7488215207352120323,
      "normalized": "def NAME ( NAME : NAME , * NAME ) -> NAME : # Added session_manager back LIT NAME = NAME . NAME . NAME NAME = NAME . NAME . NAME NAME = False # Validate paths if NAME is None : NAME . NAME ( LIT ) return False if NAME is None : NAME . NAME ( LIT ) return False NAME = NAME / LIT try : # --- Close main pool FIRST --- if NAME : NAME . NAME ( LIT ) NAME . NAME ( NAME = False ) NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) # --- End closing main pool --- NAME . NAME ( f\" Restoring DB from: { NAME } \" ) if not NAME . NAME ( ) : NAME . NAME ( f\" Backup not found: { NAME } . \" ) return False NAME . NAME ( LIT ) NAME . NAME ( ) NAME . NAME ( LIT ) NAME . NAME ( ) NAME . NAME ( NAME , NAME ) NAME . NAME ( LIT ) NAME = True except NAME : NAME . NAME ( f\" Backup not found during copy: { NAME } \" ) except ( NAME , NAME . NAME ) as NAME : NAME . NAME ( f\" Error restoring DB: { NAME } \" , NAME = True ) except NAME as NAME : NAME . NAME ( f\" Unexpected restore error: { NAME } \" , NAME = True ) finally : NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "main.py",
      "qualname": "check_login_actn",
      "lineno": 1227,
      "end_lineno": 1307,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": false,
      "returns_count": 9,
      "yield_count": 0,
      "complexity": 13,
      "loc": 81,
      "tags": [
        "impure",
        "logging",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(session_manager, *args)",
      "fingerprint": "79d36f7954f8b82e45d1984d5977108d94ec5361",
      "simhash64": 7487652257398690859,
      "normalized": "def NAME ( NAME : NAME , * NAME ) -> NAME : LIT if not NAME : NAME . NAME ( LIT ) NAME ( LIT ) return False # Phase 1 (Driver Start) is handled by exec_actn if needed. # We only need to check if driver is live before proceeding. if not NAME . NAME : NAME . NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) return False NAME ( LIT ) # Call login_status directly to check initial status try : NAME = NAME ( NAME , NAME = False ) # Use UI fallback for reliability if NAME is True : NAME ( LIT ) # Display additional session info if available if NAME . NAME : NAME ( f\" Profile ID: { NAME . NAME } \" ) if NAME . NAME : NAME ( f\" Account: { NAME . NAME } \" ) return True if NAME is False : NAME ( LIT ) NAME ( LIT ) # Attempt login using the session manager's login functionality try : NAME = NAME ( NAME ) if NAME : NAME ( LIT ) # Check status again after login NAME = NAME ( NAME , NAME = False ) if NAME is True : NAME ( LIT ) # Display session info if available if NAME . NAME : NAME ( f\" Profile ID: { NAME . NAME } \" ) if NAME . NAME : NAME ( f\" Account: { NAME . NAME } \" ) return True NAME ( LIT ) return False NAME ( LIT ) NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" Exception during login attempt: { NAME } \" , NAME = True ) NAME ( f\" \u2717 Login failed with error: { NAME } \" ) NAME ( LIT ) return False else : # Status is None NAME ( LIT ) NAME ( LIT ) NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" Exception during login status check: { NAME } \" , NAME = True ) NAME ( f\" \\n! Error checking login status: { NAME } \" ) NAME ( LIT ) return False"
    },
    {
      "module_path": "main.py",
      "qualname": "coord_action",
      "lineno": 1314,
      "end_lineno": 1344,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 31,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(session_manager, config_schema, start)",
      "fingerprint": "86698ac4902c8fa1508ec94be2a367905ff804d2",
      "simhash64": 7488144838607934483,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] = None , NAME : NAME = LIT ) -> NAME : LIT # Use global config if config_schema not provided if NAME is None : NAME = NAME # Guard clause now checks session_ready if not NAME or not NAME . NAME : NAME . NAME ( LIT ) NAME ( LIT ) return False NAME . NAME ( f\" Gathering DNA Matches from page { NAME } ... \" ) try : # Call the imported function from action6 NAME = NAME ( NAME , NAME , NAME = NAME ) if NAME is False : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" Error during coord_action: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "main.py",
      "qualname": "srch_inbox_actn",
      "lineno": 1351,
      "end_lineno": 1388,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 7,
      "loc": 38,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(session_manager, *args)",
      "fingerprint": "98de11aa9fcc8f36d2c188819b20f377e5f82a2e",
      "simhash64": 7488215207419220995,
      "normalized": "def NAME ( NAME : NAME , * NAME ) -> NAME : LIT # Guard clause now checks session_manager exists if not NAME : NAME . NAME ( LIT ) return False # Check session_ready attribute safely NAME = NAME ( NAME , LIT , None ) if NAME is None : # If session_ready is not set, initialize it based on driver_live NAME = NAME ( NAME , LIT , False ) if NAME : NAME . NAME ( LIT ) NAME . NAME = True NAME = True else : NAME . NAME ( LIT ) NAME . NAME = False NAME = False # Now check if session is ready if not NAME : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) try : NAME = NAME ( NAME = NAME ) NAME = NAME . NAME ( ) if NAME is False : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) return True # Use INFO except NAME as NAME : NAME . NAME ( f\" Error during inbox search: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "main.py",
      "qualname": "send_messages_action",
      "lineno": 1395,
      "end_lineno": 1444,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 8,
      "loc": 50,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(session_manager, *args)",
      "fingerprint": "39f8c3d3592211edac525d3892f30b5cb2eb968c",
      "simhash64": 7487652257398690819,
      "normalized": "def NAME ( NAME : NAME , * NAME ) -> NAME : LIT # Guard clause now checks session_manager exists if not NAME : NAME . NAME ( LIT ) return False # Check session_ready attribute safely NAME = NAME ( NAME , LIT , None ) if NAME is None : # If session_ready is not set, initialize it based on driver_live NAME = NAME ( NAME , LIT , False ) if NAME : NAME . NAME ( LIT ) NAME . NAME = True NAME = True else : NAME . NAME ( LIT ) NAME . NAME = False NAME = False # Now check if session is ready if not NAME : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) try : # Navigate to Base URL first (good practice before starting message loops) NAME . NAME ( LIT ) if not NAME ( NAME . NAME , NAME . NAME . NAME , NAME , NAME , ) : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) # Call the actual sending function NAME = NAME ( NAME ) if NAME is False : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) return True # Use INFO except NAME as NAME : NAME . NAME ( f\" Error during message sending: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "main.py",
      "qualname": "process_productive_messages_action",
      "lineno": 1451,
      "end_lineno": 1488,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 7,
      "loc": 38,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(session_manager, *args)",
      "fingerprint": "44e4c1992328d3d0ab3dadbf862bb0482a32d5cf",
      "simhash64": 7488215207419220995,
      "normalized": "def NAME ( NAME : NAME , * NAME ) -> NAME : LIT # Guard clause now checks session_manager exists if not NAME : NAME . NAME ( LIT ) return False # Check session_ready attribute safely NAME = NAME ( NAME , LIT , None ) if NAME is None : # If session_ready is not set, initialize it based on driver_live NAME = NAME ( NAME , LIT , False ) if NAME : NAME . NAME ( LIT ) NAME . NAME = True NAME = True else : NAME . NAME ( LIT ) NAME . NAME = False NAME = False # Now check if session is ready if not NAME : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) try : # Call the actual processing function NAME = NAME ( NAME ) if NAME is False : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" Error during productive message processing: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "main.py",
      "qualname": "run_action11_wrapper",
      "lineno": 1495,
      "end_lineno": 1508,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "(session_manager, *args)",
      "fingerprint": "0bb8e6477a27afe9b4caf02ded206048405e3730",
      "simhash64": 7488215207352108043,
      "normalized": "def NAME ( NAME : NAME , * NAME ) -> NAME : LIT NAME . NAME ( LIT ) try : # Call the actual API Report function, passing the session_manager for API calls NAME = NAME ( NAME ) if NAME is False : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" Error during API Report: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "main.py",
      "qualname": "main",
      "lineno": 1514,
      "end_lineno": 1945,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 77,
      "loc": 432,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "0060ff61791e77999ba3f9ad8523d5994a12249b",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( ) -> None : global NAME , NAME NAME = None # Initialize session_manager # Ensure terminal window has focus (Windows & VS Code) try : if NAME . NAME == LIT : # Windows import NAME import NAME # Get console window handle NAME = NAME . NAME . NAME NAME = NAME . NAME . NAME # Method 1: Try to focus console window (for regular terminals) NAME = NAME . NAME ( ) if NAME : # Bring console window to foreground NAME . NAME ( NAME ) NAME . NAME ( NAME , LIT ) # SW_RESTORE # Method 2: For VS Code integrated terminal, try to focus current window # Get the currently active window NAME = NAME . NAME ( ) if NAME and NAME != NAME : # This might be VS Code - try to ensure it stays focused NAME . NAME ( NAME ) NAME . NAME ( NAME ) # Also try to send a focus message to ensure terminal panel is active # This is a gentle nudge that shouldn't disrupt the user NAME . NAME ( NAME ) # Small delay to ensure focus operations complete NAME . NAME ( LIT ) except NAME as NAME : # Silently ignore focus errors but log for debugging if logger is available try : # Check if logger exists and is available (logging is already imported at top) if LIT in NAME ( ) and NAME and NAME ( NAME , LIT ) : NAME . NAME ( f\" Terminal focus attempt failed (non-critical): { NAME } \" ) except NAME : pass # Even logging failed, continue silently try : NAME ( LIT ) # --- Logging Setup --- NAME = NAME ( ) # --- Configuration Validation --- # Validate action configuration to prevent Action 6-style failures NAME ( ) if NAME is None : NAME . NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME . NAME ( LIT ) # --- Instantiate SessionManager --- NAME = NAME ( ) # No browser started by default # --- Main menu loop --- while True : NAME = NAME ( ) NAME ( LIT ) # --- Confirmation dictionary --- NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } # --- Confirmation Check --- if NAME in NAME : NAME = NAME [ NAME ] NAME = ( NAME ( f\" Are you sure you want to { NAME } ? \u26a0\ufe0f  This cannot be undone. (yes/no): \" ) . NAME ( ) . NAME ( ) ) if NAME not in [ LIT , LIT ] : NAME ( LIT ) continue NAME ( LIT ) # Newline after confirmation # --- Action Dispatching --- # Note: Removed most close_sess_after=False as the default is now to keep open. # Added close_sess_after=True only where explicit closure after action is desired. # --- Database-only actions (no browser needed) --- if NAME in [ LIT , LIT , LIT , LIT ] : # For database-only actions, we can use the main session_manager # The exec_actn function will set browser_needed=False based on the action if NAME == LIT : # Confirmation handled above NAME ( NAME , NAME , NAME ) elif NAME == LIT : # Confirmation handled above NAME ( NAME , NAME , NAME ) elif NAME == LIT : NAME ( NAME , NAME , NAME ) # Run through exec_actn for consistent logging elif NAME == LIT : # Confirmation handled above NAME ( NAME , NAME , NAME ) # --- Browser-required actions --- elif NAME == LIT : # Initialize caching for GEDCOM operations (needed for action 9 in workflow) NAME ( ) # exec_actn will set browser_needed=True based on the action NAME ( NAME , NAME , NAME , NAME = True , ) # Close after full sequence elif NAME == LIT : NAME ( NAME , NAME , NAME ) # API-only check elif NAME . NAME ( LIT ) : NAME = NAME . NAME ( ) NAME = LIT if NAME ( NAME ) > LIT : try : NAME = NAME ( NAME [ LIT ] ) NAME = NAME if NAME > LIT else LIT except NAME : NAME . NAME ( f\" Invalid start page ' { NAME [ LIT ] } '. Using 1. \" ) NAME ( f\" Invalid start page ' { NAME [ LIT ] } '. Using page 1 instead. \" ) # Call exec_actn with the correct parameters NAME ( NAME , NAME , LIT , False , # don't close session after NAME , NAME , ) # Keep open elif NAME == LIT : NAME ( NAME , NAME , NAME ) # Keep open elif NAME == LIT : NAME ( NAME , NAME , NAME ) # Keep open elif NAME == LIT : # Initialize caching for GEDCOM operations NAME ( ) NAME ( NAME , NAME , NAME ) # Keep open elif NAME == LIT : # Initialize caching for GEDCOM operations and load GEDCOM data NAME ( ) NAME ( NAME , NAME , NAME ) # After running action 10, try to cache the GEDCOM data for future use try : NAME ( LIT ) if NAME ( ) : NAME ( LIT ) else : NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error caching GEDCOM data after action 10: { NAME } \" ) NAME ( LIT ) elif NAME == LIT : # Initialize caching for GEDCOM operations NAME ( ) # Use the wrapper function to run Action 11 through exec_actn NAME ( NAME , NAME , NAME ) # === PHASE 12: GEDCOM AI INTELLIGENCE === elif NAME == LIT : if NAME ( ) : NAME ( ) else : NAME ( LIT ) elif NAME == LIT : if NAME ( ) : NAME ( ) else : NAME ( LIT ) elif NAME == LIT : if NAME ( ) : NAME ( ) else : NAME ( LIT ) elif NAME == LIT : if NAME ( ) : NAME ( ) else : NAME ( LIT ) # --- Test Options --- elif NAME == LIT : # Show Main.py Status NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) elif NAME == LIT : # Run All Module Tests try : import NAME NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME = NAME . NAME ( [ NAME . NAME , LIT ] , NAME = False , NAME = False , NAME = True , ) if NAME . NAME == LIT : NAME ( LIT ) else : NAME ( f\" \\n\u26a0\ufe0f Some tests failed (exit code: { NAME . NAME } ) \" ) except NAME : NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error running all tests: { NAME } \" ) NAME ( f\" Error running all tests: { NAME } \" ) NAME ( LIT ) NAME ( LIT ) # --- Meta Options --- elif NAME == LIT : # Setup Security (Encrypt Credentials) try : from NAME import NAME NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME = NAME ( ) NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" Error importing credentials manager: { NAME } \" ) NAME ( LIT ) if LIT in NAME ( NAME ) or LIT in NAME ( NAME ) : NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) # Platform-specific installation instructions NAME ( ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) else : NAME ( LIT ) NAME ( f\" Details: { NAME } \" ) NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error running credential manager: { NAME } \" ) NAME ( f\" Error running credential manager: { NAME } \" ) NAME ( LIT ) NAME ( LIT ) elif NAME == LIT : # Review/Edit .env Settings try : NAME = NAME ( NAME ) . NAME / LIT if not NAME . NAME ( ) : NAME ( LIT ) NAME ( LIT ) continue # Read .env file with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( ) # Filter out comments and blank lines # Build a list of (line_index, setting_line) for settings only NAME = [ ( NAME , NAME . NAME ( ) ) for NAME , NAME in NAME ( NAME ) if NAME . NAME ( ) and not NAME . NAME ( ) . NAME ( LIT ) ] NAME ( LIT ) for NAME , ( NAME , NAME ) in NAME ( NAME , LIT ) : NAME ( f\" { NAME } . { NAME } \" ) NAME ( LIT ) NAME = NAME ( LIT ) . NAME ( ) . NAME ( ) if NAME == LIT : continue try : NAME = NAME ( NAME ) - LIT if NAME < LIT or NAME >= NAME ( NAME ) : NAME ( LIT ) NAME ( LIT ) continue except NAME : NAME ( LIT ) NAME ( LIT ) continue NAME , NAME = NAME [ NAME ] NAME , NAME , NAME = NAME . NAME ( LIT ) if not NAME : NAME ( LIT ) NAME ( LIT ) continue NAME ( f\" Current value for { NAME } : { NAME } \" ) NAME = NAME ( f\" Enter new value for { NAME } (or leave blank to cancel): \" ) . NAME ( ) if not NAME : NAME ( LIT ) NAME ( LIT ) continue # Update the line in the original lines list NAME [ NAME ] = f\" { NAME } = { NAME } \\n \" # Write back to .env with NAME . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME ) NAME ( f\" Updated { NAME } in .env. \" ) except NAME as NAME : NAME ( f\" Error editing .env: { NAME } \" ) NAME ( LIT ) NAME ( LIT ) elif NAME == LIT : # Show cache statistics try : NAME . NAME ( LIT ) NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error displaying cache statistics: { NAME } \" ) NAME ( LIT ) elif NAME == LIT : NAME . NAME ( LIT if NAME . NAME == LIT else LIT ) if NAME and NAME . NAME : NAME = None for NAME in NAME . NAME : if ( NAME ( NAME , NAME . NAME ) and NAME . NAME == NAME . NAME ) : NAME = NAME break if NAME : NAME = NAME . NAME # Cycle through DEBUG \u2192 INFO \u2192 WARNING if NAME == NAME . NAME : NAME = LIT elif NAME == NAME . NAME : NAME = LIT else : # WARNING or other NAME = LIT # Re-call setup_logging to potentially update filters etc. too NAME = NAME ( NAME = NAME ) NAME . NAME ( f\" Console log level toggled to: { NAME } \" ) NAME ( f\" Log level changed to: { NAME } \" ) else : NAME . NAME ( LIT ) else : NAME ( LIT , NAME = NAME . NAME ) elif NAME == LIT : NAME . NAME ( LIT if NAME . NAME == LIT else LIT ) elif NAME == LIT : NAME . NAME ( LIT if NAME . NAME == LIT else LIT ) NAME ( LIT ) break # Handle invalid choices elif NAME not in NAME : # Avoid double 'invalid' message NAME ( LIT ) # No need to track if driver became live anymore except NAME : NAME . NAME ( LIT if NAME . NAME == LIT else LIT ) NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Critical error in main: { NAME } \" , NAME = True ) finally : # Final cleanup: Always close the session manager if it exists NAME . NAME ( LIT ) if NAME is not None : try : NAME . NAME ( NAME = False ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error during final Session Manager cleanup: { NAME } \" ) # Log program finish NAME . NAME ( LIT )"
    },
    {
      "module_path": "main.py",
      "qualname": "run_gedcom_intelligence_analysis",
      "lineno": 1954,
      "end_lineno": 2019,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 66,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "da6120aa47f8177f6992d239b5013ec7c96d9ad3",
      "simhash64": 7451588277082428459,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) if not NAME : NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) return try : # Get cached GEDCOM data (already loaded by menu handler) from NAME import NAME NAME = NAME ( ) # Initialize analyzer NAME ( LIT ) from NAME import NAME NAME = NAME ( ) # Perform analysis NAME ( LIT ) NAME = NAME . NAME ( NAME ) # Display results NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME = NAME . NAME ( LIT , { } ) NAME ( f\" \ud83d\udc65 Individuals Analyzed: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" \ud83d\udd0d Gaps Identified: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" \u26a0\ufe0f  Conflicts Found: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" \ud83c\udfaf Research Opportunities: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" \ud83d\udd25 High Priority Items: { NAME . NAME ( LIT , LIT ) } \" ) # Show top gaps NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME ( LIT ) for NAME , NAME in NAME ( NAME [ : LIT ] , LIT ) : NAME ( f\" { NAME } . { NAME . NAME ( LIT , LIT ) } (Priority: { NAME . NAME ( LIT , LIT ) } ) \" ) # Show top conflicts NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME ( LIT ) for NAME , NAME in NAME ( NAME [ : LIT ] , LIT ) : NAME ( f\" { NAME } . { NAME . NAME ( LIT , LIT ) } (Severity: { NAME . NAME ( LIT , LIT ) } ) \" ) # Show AI insights NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) if NAME : NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" \\n\ud83c\udf33 Tree Completeness: { NAME : .1f } % \" ) NAME ( LIT ) except NAME as NAME : NAME ( f\" \u274c Error during GEDCOM intelligence analysis: { NAME } \" ) NAME . NAME ( f\" GEDCOM intelligence analysis error: { NAME } \" ) NAME ( LIT )"
    },
    {
      "module_path": "main.py",
      "qualname": "run_dna_gedcom_crossref",
      "lineno": 2022,
      "end_lineno": 2122,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 13,
      "loc": 101,
      "tags": [
        "impure",
        "logging",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "5725d9901d0e3316961cd76cf67f302badd16b20",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) if not NAME : NAME ( LIT ) NAME ( LIT ) return try : # Load GEDCOM data NAME ( LIT ) if NAME is None : NAME ( LIT ) return NAME = NAME ( ) if not NAME : NAME ( LIT ) NAME ( LIT ) return # Get DNA matches from database NAME ( LIT ) NAME = NAME ( ) NAME = NAME . NAME ( ) try : if not NAME : NAME ( LIT ) NAME ( LIT ) NAME = [ ] else : NAME = NAME . NAME ( NAME ) . NAME ( LIT ) . NAME ( ) # Convert to Phase 12 format NAME = [ ] for NAME in NAME : from NAME import NAME NAME = NAME ( NAME = NAME ( NAME . NAME ) , NAME = NAME . NAME or LIT , NAME = LIT , NAME = None , NAME = LIT ) NAME . NAME ( NAME ) NAME ( f\" \ud83d\udcca Found { NAME ( NAME ) } DNA matches to analyze \" ) finally : if NAME : NAME . NAME ( NAME ) if not NAME : NAME ( LIT ) NAME ( LIT ) return # Initialize cross-referencer NAME ( LIT ) from NAME import NAME NAME = NAME ( ) # Perform analysis NAME ( LIT ) NAME = NAME . NAME ( NAME , NAME ) # Display results NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME = NAME . NAME ( LIT , { } ) NAME ( f\" \ud83e\uddec DNA Matches Analyzed: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" \ud83d\udc65 GEDCOM People Analyzed: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" \ud83d\udd17 Cross-References Found: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" \u2b50 High Confidence Matches: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" \u26a0\ufe0f  Conflicts Identified: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" \u2705 Verification Opportunities: { NAME . NAME ( LIT , LIT ) } \" ) # Show top matches NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME ( LIT ) for NAME , NAME in NAME ( NAME [ : LIT ] , LIT ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" { NAME } . { NAME } - { NAME } (Confidence: { NAME : .1% } ) \" ) NAME ( LIT ) except NAME as NAME : NAME ( f\" \u274c Error during DNA-GEDCOM cross-reference: { NAME } \" ) NAME . NAME ( f\" DNA-GEDCOM cross-reference error: { NAME } \" ) NAME ( LIT )"
    },
    {
      "module_path": "main.py",
      "qualname": "run_research_prioritization",
      "lineno": 2125,
      "end_lineno": 2217,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 14,
      "loc": 93,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "f5f8e2a69105cc2e291d17343abfd93720892cec",
      "simhash64": 7451588277082428459,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) if not NAME : NAME ( LIT ) NAME ( LIT ) return try : # First run GEDCOM intelligence analysis NAME ( LIT ) from NAME import NAME NAME = NAME ( ) if not NAME : NAME ( LIT ) NAME ( LIT ) return from NAME import NAME NAME = NAME ( ) NAME = NAME . NAME ( NAME ) # Initialize prioritizer NAME ( LIT ) from NAME import NAME NAME = NAME ( ) # Perform prioritization NAME ( LIT ) NAME = NAME . NAME ( NAME , { } ) # Display results NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME ( f\" \ud83c\udfaf Total Priorities Identified: { NAME . NAME ( LIT , LIT ) } \" ) # Show family line analysis NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME ( LIT ) for NAME in NAME [ : LIT ] : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" \u2022 { NAME } Line: { NAME : .1f } % complete, { NAME } generations back \" ) # Show location clusters NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME ( LIT ) for NAME in NAME [ : LIT ] : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" \u2022 { NAME } : { NAME } people (Efficiency: { NAME : .1% } ) \" ) # Show top priority tasks NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME ( LIT ) for NAME , NAME in NAME ( NAME [ : LIT ] , LIT ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" { NAME } . { NAME [ : LIT ] } ... (Score: { NAME : .1f } , Urgency: { NAME } ) \" ) # Show recommendations NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME ( LIT ) for NAME , NAME in NAME ( NAME [ : LIT ] , LIT ) : NAME ( f\" { NAME } . { NAME } \" ) # Show next steps NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME ( LIT ) for NAME , NAME in NAME ( NAME [ : LIT ] , LIT ) : NAME ( f\" { NAME } . { NAME } \" ) NAME ( LIT ) except NAME as NAME : NAME ( f\" \u274c Error during research prioritization: { NAME } \" ) NAME . NAME ( f\" Research prioritization error: { NAME } \" ) NAME ( LIT )"
    },
    {
      "module_path": "main.py",
      "qualname": "run_comprehensive_gedcom_ai",
      "lineno": 2220,
      "end_lineno": 2319,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 13,
      "loc": 100,
      "tags": [
        "impure",
        "logging",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "3a0adc497b1fe1efdecf5b14cc638c10b32e9bb3",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( ) -> None : LIT NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) if not NAME : NAME ( LIT ) NAME ( LIT ) return try : # Load GEDCOM data NAME ( LIT ) from NAME import NAME NAME = NAME ( ) if not NAME : NAME ( LIT ) NAME ( LIT ) return # Get DNA matches NAME ( LIT ) NAME = NAME ( ) NAME = NAME . NAME ( ) NAME = [ ] try : if not NAME : NAME ( LIT ) NAME ( LIT ) else : NAME = NAME . NAME ( NAME ) . NAME ( LIT ) . NAME ( ) for NAME in NAME : NAME . NAME ( { LIT : NAME ( NAME . NAME ) , LIT : NAME . NAME or LIT , LIT : LIT , LIT : None , LIT : LIT } ) finally : if NAME : NAME . NAME ( NAME ) # Initialize comprehensive integrator NAME ( LIT ) from NAME import NAME NAME = NAME ( ) # Perform comprehensive analysis NAME ( LIT ) NAME = NAME . NAME ( NAME , NAME ) # Display results NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME = NAME . NAME ( LIT , { } ) NAME ( f\" \ud83d\udc65 Individuals Analyzed: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" \ud83d\udd0d Gaps Identified: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" \u26a0\ufe0f  Conflicts Found: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" \ud83c\udfaf Research Priorities: { NAME . NAME ( LIT , LIT ) } \" ) if NAME : NAME ( f\" \ud83e\uddec DNA Matches Analyzed: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" \ud83d\udd17 DNA Cross-References: { NAME . NAME ( LIT , LIT ) } \" ) # Show integrated insights NAME = NAME . NAME ( LIT , { } ) if NAME : NAME ( LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" \ud83c\udf33 Tree Health Score: { NAME } /100 \" ) NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" \ud83e\uddec DNA Verification Potential: { NAME } \" ) NAME = NAME . NAME ( LIT , LIT ) NAME ( f\" \ud83d\udcca Data Quality Assessment: { NAME } \" ) # Show actionable recommendations NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME ( LIT ) for NAME , NAME in NAME ( NAME [ : LIT ] , LIT ) : NAME ( f\" { NAME } . { NAME } \" ) NAME ( LIT ) NAME ( LIT ) except NAME as NAME : NAME ( f\" \u274c Error during comprehensive GEDCOM AI analysis: { NAME } \" ) NAME . NAME ( f\" Comprehensive GEDCOM AI analysis error: { NAME } \" ) NAME ( LIT )"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer.__init__",
      "lineno": 30,
      "end_lineno": 36,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "43135040565c220d99b2c7b22ba4c2bea64f3496",
      "simhash64": 8641066347509752851,
      "normalized": "def NAME ( NAME ) : LIT NAME . NAME = NAME . NAME ( ) NAME . NAME = NAME . NAME ( ) NAME . NAME = NAME ( ) NAME . NAME = True NAME . NAME = NAME . NAME ( )"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._load_message_templates",
      "lineno": 38,
      "end_lineno": 71,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 8,
      "loc": 34,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "b0c9a36d3e6fe544b3f29128390af8b5c0ae27e5",
      "simhash64": 7488144838607942675,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT try : from NAME . NAME import NAME from NAME import NAME NAME = NAME ( ) with NAME . NAME ( ) as NAME : if not NAME : NAME . NAME ( LIT ) return { } # Fetch all templates from database NAME = NAME . NAME ( NAME ) . NAME ( ) # Build dictionary with full message content (subject + body) NAME = { } for NAME in NAME : # Reconstruct full message content with subject line if NAME . NAME and NAME . NAME : NAME = f\" Subject: { NAME . NAME } \\n\\n { NAME . NAME } \" elif NAME . NAME : NAME = NAME . NAME else : continue NAME [ NAME . NAME ] = NAME NAME . NAME ( f\" Loaded { NAME ( NAME ) } message templates from database \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Error loading message templates from database: { NAME } \" ) return { }"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._load_personalization_config",
      "lineno": 73,
      "end_lineno": 85,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "b87234d840a58fe3f20cf466c4976d2bd9dd187e",
      "simhash64": 5145878255143654955,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : LIT , LIT : LIT , LIT : LIT , LIT : True , LIT : True , LIT : [ LIT , LIT , LIT , LIT , LIT ] , LIT : LIT , # 50/50 split for A/B testing LIT : LIT , # Minimum usage before optimization kicks in LIT : LIT # Minimum effectiveness score to consider template good }"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._build_personalization_registry",
      "lineno": 87,
      "end_lineno": 125,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 39,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "a8c7a2a224d71791966d2038ae105208c250b330",
      "simhash64": 7451588276007646215,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME [ [ NAME [ NAME , NAME ] ] , NAME ] ] : LIT return { # Existing functions LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , # New advanced functions LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME }"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer.create_personalized_message",
      "lineno": 127,
      "end_lineno": 218,
      "is_method": true,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 8,
      "loc": 92,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self, template_key, person_data, extracted_data, base_format_data, _track_effectiveness)",
      "fingerprint": "11479d56c3e3d878e4cba76f5471bb1d823a0f8d",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME = True ) -> NAME [ NAME , NAME [ NAME ] ] : LIT try : # Get the template (with A/B testing if enabled) if NAME not in NAME . NAME : NAME . NAME ( f\" Template ' { NAME } ' not found, using fallback \" ) NAME = NAME . NAME ( NAME ) # Apply A/B testing for template selection if enabled if NAME . NAME : NAME = NAME . NAME ( NAME , NAME ) NAME = NAME . NAME . NAME ( NAME , LIT ) if not NAME : return NAME . NAME ( NAME , NAME ) , [ ] # Select optimal personalization functions based on data and effectiveness NAME = NAME . NAME ( NAME ) # Create enhanced format data using selected functions NAME = NAME . NAME ( NAME , NAME , NAME , NAME ) # Format the message with safe formatting try : NAME = NAME . NAME ( ** NAME ) except NAME as NAME : NAME . NAME ( f\" Missing template key { NAME } , using fallback formatting \" ) # Add missing keys with default values NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } # Add any missing keys to enhanced_format_data for NAME , NAME in NAME . NAME ( ) : if NAME not in NAME : NAME [ NAME ] = NAME # Try formatting again NAME = NAME . NAME ( ** NAME ) NAME . NAME ( f\" Created personalized message using template ' { NAME } ' with { NAME ( NAME ) } personalization functions \" ) return NAME , NAME except NAME as NAME : NAME . NAME ( f\" Error creating personalized message: { NAME } \" ) return NAME . NAME ( NAME , NAME ) , [ ]"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._apply_ab_testing",
      "lineno": 220,
      "end_lineno": 239,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, template_key, _extracted_data)",
      "fingerprint": "eaebb5629d0377db27b441d75a61443ec3a4533b",
      "simhash64": 7488109654236902419,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT # Get alternative templates for A/B testing NAME = NAME . NAME ( NAME ) if not NAME : return NAME # Check effectiveness scores NAME = NAME . NAME . NAME ( NAME ) for NAME in NAME : NAME = NAME . NAME . NAME ( NAME ) # If alternative is significantly better, use it if NAME > NAME + LIT : NAME . NAME ( f\" A/B testing: switching from ' { NAME } ' to ' { NAME } ' (score: { NAME : .1f } vs { NAME : .1f } ) \" ) return NAME return NAME"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._get_alternative_templates",
      "lineno": 241,
      "end_lineno": 254,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 14,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, template_key)",
      "fingerprint": "e0e2ea6f14125b9d2bf945785d45f4178b987363",
      "simhash64": 7452151226028168227,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT # Define template families for A/B testing NAME = { LIT : [ LIT , LIT ] , LIT : [ LIT , LIT ] , LIT : [ LIT , LIT ] } for NAME , NAME in NAME . NAME ( ) : if NAME in NAME : return [ NAME for NAME in NAME if NAME != NAME and NAME in NAME . NAME ] return [ ]"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._select_optimal_personalization_functions",
      "lineno": 256,
      "end_lineno": 296,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 11,
      "loc": 41,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "63d91637dbde8cf2911082c003f727fe43150b66",
      "simhash64": 7488180023047140387,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT NAME = [ ] # Always include basic functions NAME = [ LIT , LIT , LIT ] NAME . NAME ( NAME ) # Add functions based on data availability if NAME . NAME ( LIT ) : NAME = [ LIT , LIT , LIT , LIT ] # Select best performing DNA function NAME = NAME . NAME ( NAME ) if NAME : NAME . NAME ( NAME ) if NAME . NAME ( LIT ) : NAME = [ LIT , LIT , LIT ] NAME = NAME . NAME ( NAME ) if NAME : NAME . NAME ( NAME ) if NAME . NAME ( LIT ) : NAME = [ LIT , LIT ] NAME = NAME . NAME ( NAME ) if NAME : NAME . NAME ( NAME ) if NAME . NAME ( LIT ) : NAME . NAME ( LIT ) if NAME . NAME ( LIT ) : NAME . NAME ( LIT ) # Add advanced functions based on effectiveness NAME = [ LIT , LIT ] for NAME in NAME : if NAME . NAME ( NAME ) : NAME . NAME ( NAME ) return NAME ( NAME ( NAME ) ) # Remove duplicates"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._get_best_performing_function",
      "lineno": 298,
      "end_lineno": 313,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 16,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, function_list)",
      "fingerprint": "479ef89babdaf9fe01551e59c11c4ad013bee400",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] ) -> NAME [ NAME ] : LIT NAME = None NAME = LIT for NAME in NAME : if NAME in NAME . NAME . NAME [ LIT ] : NAME = NAME . NAME . NAME [ LIT ] [ NAME ] if NAME [ LIT ] >= LIT : # Minimum usage for consideration NAME = NAME [ LIT ] if NAME > NAME : NAME = NAME NAME = NAME # If no function has enough data, return the first one return NAME or ( NAME [ LIT ] if NAME else None )"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._is_function_effective",
      "lineno": 315,
      "end_lineno": 326,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, function_name)",
      "fingerprint": "e22624c0bae7eb8afd813a592c617beef4af82ed",
      "simhash64": 5182266645357704195,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT if NAME not in NAME . NAME . NAME [ LIT ] : return True # New functions get a chance NAME = NAME . NAME . NAME [ LIT ] [ NAME ] if NAME [ LIT ] < LIT : return True # Not enough data yet # Consider effective if positive response rate > 50% or avg engagement > 3.0 NAME = NAME [ LIT ] / NAME [ LIT ] return NAME > LIT or NAME [ LIT ] > LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_enhanced_format_data",
      "lineno": 328,
      "end_lineno": 365,
      "is_method": true,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 38,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self, extracted_data, base_format_data, _person_data, selected_functions)",
      "fingerprint": "a0e1afc6d040f33d0b11403bb83a0a071e84f1c3",
      "simhash64": 7452151225961067603,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME [ NAME ] ] = None ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME ( ) # If no specific functions selected, use all available functions if NAME is None : NAME = NAME ( NAME . NAME . NAME ( ) ) # Apply selected personalization functions for NAME in NAME : if NAME in NAME . NAME : try : NAME = NAME . NAME [ NAME ] NAME [ NAME ] = NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error applying personalization function ' { NAME } ': { NAME } \" ) # Provide fallback value NAME [ NAME ] = NAME . NAME ( NAME ) # Ensure all required template keys have values (backward compatibility) NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } for NAME , NAME in NAME . NAME ( ) : if NAME not in NAME : NAME [ NAME ] = NAME return NAME"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._get_fallback_value",
      "lineno": 367,
      "end_lineno": 378,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, func_name)",
      "fingerprint": "2322926ea86ffb7e795527561da70c74423b1ba4",
      "simhash64": 5726842660759967275,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } return NAME . NAME ( NAME , LIT )"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._format_shared_ancestors",
      "lineno": 380,
      "end_lineno": 402,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 9,
      "loc": 23,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "2ca97bc16b8eb520b785016e498759ffdccedb59",
      "simhash64": 7452151226028168227,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) if not NAME : return LIT # Get up to 3 most relevant names NAME = [ ] for NAME in NAME [ : NAME . NAME [ LIT ] ] : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if NAME : NAME . NAME ( NAME ) elif NAME ( NAME , NAME ) : NAME . NAME ( NAME ) if not NAME : return LIT if NAME ( NAME ) == LIT : return NAME [ LIT ] if NAME ( NAME ) == LIT : return f\" { NAME [ LIT ] } and { NAME [ LIT ] } \" return f\" { LIT . NAME ( NAME [ : - LIT ] ) } , and { NAME [ - LIT ] } \""
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._format_ancestor_details",
      "lineno": 404,
      "end_lineno": 428,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 11,
      "loc": 25,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "0e2a142554a9485b52141a4ff33f23fad9b46d72",
      "simhash64": 7488180022980023339,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) if not NAME : return LIT NAME = [ ] for NAME in NAME [ : LIT ] : # Limit to 2 most relevant records if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) if NAME and ( NAME or NAME ) : NAME = [ NAME ] if NAME and NAME : NAME . NAME ( f\" { NAME } { NAME } \" ) if NAME : NAME . NAME ( f\" in { NAME } \" ) NAME . NAME ( LIT . NAME ( NAME ) ) if NAME : return f\" ( { LIT . NAME ( NAME ) } ) \" return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_genealogical_context",
      "lineno": 430,
      "end_lineno": 448,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "9c06eccf16fabf3312c9794d07341f1f5d15fdca",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = [ ] # Add location information NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME = NAME . NAME ( NAME ) if NAME : NAME . NAME ( f\" Our family history traces through { NAME } . \" ) # Add occupation information NAME = NAME . NAME ( LIT , [ ] ) if NAME and NAME . NAME [ LIT ] : NAME = NAME . NAME ( NAME ) if NAME : NAME . NAME ( NAME ) return LIT . NAME ( NAME ) if NAME else LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._format_occupations",
      "lineno": 450,
      "end_lineno": 465,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 7,
      "loc": 16,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(self, occupations)",
      "fingerprint": "ddd8343154ade630f91f3c03ab3f111f3a9d5db4",
      "simhash64": 7452151225961059371,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] ) -> NAME : LIT if not NAME : return LIT NAME = [ ] for NAME in NAME [ : LIT ] : # Limit to 2 occupations if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) if NAME and NAME : NAME . NAME ( f\" { NAME } worked as a { NAME } \" ) if NAME : return f\" Family records show { LIT . NAME ( NAME ) } . \" return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._identify_research_focus",
      "lineno": 467,
      "end_lineno": 475,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "eaaff6bd490f95218268daa3a8ac180c9296338c",
      "simhash64": 5128293818237891635,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) if NAME : # Use the first research question as focus return f\" { NAME [ LIT ] . NAME ( ) } \" # Fallback to general family history return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._generate_specific_questions",
      "lineno": 477,
      "end_lineno": 497,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 8,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "91c2fad3fc5d0e642d9ae6fd25fc519dd31b39f8",
      "simhash64": 7452151225961067555,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = [ ] # Questions based on research gaps NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME [ : NAME . NAME [ LIT ] ] : if NAME ( NAME , NAME ) and NAME : NAME . NAME ( f\" Do you have any information about { NAME . NAME ( ) } ? \" ) # Questions based on locations NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME [ : LIT ] : # Just one location question if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if NAME : NAME . NAME ( f\" Do you have any family connections to { NAME } ? \" ) if NAME : return LIT . NAME ( NAME ) return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_geographic_context",
      "lineno": 499,
      "end_lineno": 512,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 14,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "67411caf70115be52b4d67f10af8791d54746cfb",
      "simhash64": 7488180022980031523,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) if not NAME : return LIT # Get the most relevant location for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if NAME : return NAME return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._format_location_context",
      "lineno": 516,
      "end_lineno": 533,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 7,
      "loc": 18,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "f85267495e906ae5377b4005fa2e54ce1a0396ae",
      "simhash64": 7452151226028168227,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) if not NAME : return LIT NAME = [ ] for NAME in NAME [ : NAME . NAME [ LIT ] ] : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if NAME : NAME . NAME ( NAME ) if NAME : if NAME ( NAME ) == LIT : return f\" { NAME [ LIT ] } \" return f\" { LIT . NAME ( NAME [ : - LIT ] ) } , and { NAME [ - LIT ] } \" return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_research_suggestions",
      "lineno": 535,
      "end_lineno": 551,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 17,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "25b2ebfe92a9b6b84c06478392b4bdea9e0a2ac8",
      "simhash64": 7452151226028176419,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = [ ] # Suggestions based on mentioned people NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME = NAME [ LIT ] . NAME ( LIT , LIT ) if NAME ( NAME [ LIT ] , NAME ) else NAME ( NAME [ LIT ] ) if NAME : NAME . NAME ( f\" I'm particularly interested in learning more about { NAME } and their family line. \" ) # Suggestions based on research questions NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME . NAME ( f\" I'm currently researching { NAME [ LIT ] . NAME ( ) } . \" ) return LIT . NAME ( NAME ) if NAME else LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._format_research_questions",
      "lineno": 553,
      "end_lineno": 558,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:tiny"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "7b87247da018f420cf59f5c26e53629ef313fdf7",
      "simhash64": 7452151225961067571,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) if NAME : return f\" - particularly about { NAME [ LIT ] . NAME ( ) } \" return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._get_fallback_template",
      "lineno": 560,
      "end_lineno": 568,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self, original_key)",
      "fingerprint": "62724cc97df3f76f4a9433d70dfb9e185deda3e4",
      "simhash64": 5762872006465197611,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT if LIT in NAME : return LIT if LIT in NAME : return LIT if LIT in NAME : return LIT return LIT # Default fallback"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_fallback_message",
      "lineno": 570,
      "end_lineno": 573,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self, _person_data, base_format_data)",
      "fingerprint": "5a831356ff6d90ef360474477b717243c5a97f89",
      "simhash64": 7488180024053773331,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , LIT ) return f\" Dear { NAME } ,\\n\\nThank you for connecting! I'm excited to learn more about our family history.\\n\\nWarmest regards,\\n\\nWayne\\nAberdeen, Scotland \""
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._format_mentioned_people",
      "lineno": 576,
      "end_lineno": 595,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 8,
      "loc": 20,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "1d388809e7d8088e9f75303ee30fc00d370ebe57",
      "simhash64": 7452151226028168227,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) if not NAME : return LIT NAME = [ ] for NAME in NAME [ : LIT ] : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if NAME : NAME . NAME ( NAME ) if NAME : if NAME ( NAME ) == LIT : return NAME [ LIT ] if NAME ( NAME ) == LIT : return f\" { NAME [ LIT ] } and { NAME [ LIT ] } \" return f\" { LIT . NAME ( NAME [ : - LIT ] ) } , and { NAME [ - LIT ] } \" return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_research_context",
      "lineno": 597,
      "end_lineno": 610,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 14,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "f0f95b298c809dd9552610da2a96b3258966929f",
      "simhash64": 5146308216747373603,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) if NAME : return NAME [ LIT ] # Fallback to general context NAME = NAME . NAME ( LIT , [ ] ) if NAME and NAME ( NAME [ LIT ] , NAME ) : NAME = NAME [ LIT ] . NAME ( LIT , LIT ) if NAME : return f\" family connections in { NAME } \" return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_personalized_response",
      "lineno": 612,
      "end_lineno": 615,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self, _extracted_data)",
      "fingerprint": "e378c11ae3e4a6115ecae69234b084d291bcb1a9",
      "simhash64": 7452221594705769571,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT # This would be populated by AI-generated content return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_research_insights",
      "lineno": 617,
      "end_lineno": 631,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 15,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "09df5667c5e0d12c10a31147c0f264649aada5c0",
      "simhash64": 5182337013833446435,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = [ ] # Insights from vital records NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME . NAME ( LIT ) # Insights from relationships NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME . NAME ( LIT ) return LIT . NAME ( NAME ) if NAME else LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_follow_up_questions",
      "lineno": 633,
      "end_lineno": 644,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "4d0e0099cc969084e7096ffb6af33c067210c8a1",
      "simhash64": 7488180023047140387,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = [ ] NAME = NAME . NAME ( LIT , [ ] ) if NAME : NAME . NAME ( f\" Do you have any additional information about { NAME [ LIT ] . NAME ( ) } ? \" ) if not NAME : NAME . NAME ( LIT ) return LIT . NAME ( NAME )"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._format_estimated_relationship",
      "lineno": 646,
      "end_lineno": 652,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:tiny"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "6cb12c1ba39282c020d5dd79035d75d82d58b085",
      "simhash64": 7488180022980023339,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : if LIT in NAME ( NAME ) . NAME ( ) or LIT in NAME ( NAME ) . NAME ( ) : return NAME ( NAME ) return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._format_shared_dna",
      "lineno": 654,
      "end_lineno": 660,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:tiny"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "6cb12c1ba39282c020d5dd79035d75d82d58b085",
      "simhash64": 7488180022980023339,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : if LIT in NAME ( NAME ) . NAME ( ) or LIT in NAME ( NAME ) . NAME ( ) : return NAME ( NAME ) return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_dna_context",
      "lineno": 662,
      "end_lineno": 664,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self, _extracted_data)",
      "fingerprint": "d59a19e2ebc23720a86a9e109c384417f5ed4158",
      "simhash64": 7488320761542128739,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._format_shared_ancestor_info",
      "lineno": 666,
      "end_lineno": 668,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self, _extracted_data)",
      "fingerprint": "d59a19e2ebc23720a86a9e109c384417f5ed4158",
      "simhash64": 7488320761542128739,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_collaboration_request",
      "lineno": 670,
      "end_lineno": 672,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self, _extracted_data)",
      "fingerprint": "d59a19e2ebc23720a86a9e109c384417f5ed4158",
      "simhash64": 7488320761542128739,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._identify_research_topic",
      "lineno": 674,
      "end_lineno": 679,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "5d8201b1b2fa13e55fdf691b026808d946f458fd",
      "simhash64": 5146308216747373603,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) if NAME : return NAME [ LIT ] return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._format_research_needs",
      "lineno": 681,
      "end_lineno": 683,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self, _extracted_data)",
      "fingerprint": "d59a19e2ebc23720a86a9e109c384417f5ed4158",
      "simhash64": 7488320761542128739,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_collaboration_proposal",
      "lineno": 685,
      "end_lineno": 687,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self, _extracted_data)",
      "fingerprint": "d59a19e2ebc23720a86a9e109c384417f5ed4158",
      "simhash64": 7488320761542128739,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_dna_segment_analysis",
      "lineno": 691,
      "end_lineno": 698,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "e1f43d0f4d41d3d9d24fe1da4a6b3e6c78c1aee3",
      "simhash64": 7488180022980023379,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : NAME = NAME ( NAME ) . NAME ( ) if LIT in NAME or LIT in NAME : return f\" The DNA segment data shows { NAME } , which helps narrow down our common ancestor timeframe. \" return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_migration_pattern_context",
      "lineno": 700,
      "end_lineno": 718,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 7,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "cb79d3e70623fb3d62de0310e6d1dc55232b6d8f",
      "simhash64": 7488180022980023355,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) if NAME ( NAME ) >= LIT : NAME = [ ] for NAME in NAME [ : LIT ] : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) if NAME : if NAME : NAME . NAME ( f\" { NAME } ( { NAME } ) \" ) else : NAME . NAME ( NAME ) if NAME ( NAME ) >= LIT : return f\" I'm tracking family migration patterns from { NAME [ LIT ] } to { NAME [ LIT ] } , which aligns with historical movement patterns. \" return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_historical_context_analysis",
      "lineno": 720,
      "end_lineno": 747,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 16,
      "loc": 28,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "78237012cafdcde09de346f32788a599c9579081",
      "simhash64": 7452151225961059387,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) NAME = [ ] for NAME in NAME [ : LIT ] : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) if NAME and NAME : # Extract year for historical context for NAME in NAME . NAME ( ) : if NAME . NAME ( ) and NAME ( NAME ) == LIT : NAME = NAME ( NAME ) if LIT <= NAME <= LIT : if LIT in NAME and LIT <= NAME <= LIT : NAME . NAME ( f\" The { NAME } in { NAME } around { NAME } coincides with significant Scottish emigration periods. \" ) elif LIT in NAME and LIT <= NAME <= LIT : NAME . NAME ( f\" The { NAME } in { NAME } around { NAME } was during the Irish Potato Famine era. \" ) elif NAME >= LIT and NAME <= LIT : NAME . NAME ( f\" The { NAME } timeframe was during World War I, which affected many family records. \" ) break if NAME : return NAME [ LIT ] return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_record_availability_assessment",
      "lineno": 749,
      "end_lineno": 766,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 8,
      "loc": 18,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "b614670f35c69f656801ea4669b646d1ebd8efe4",
      "simhash64": 7488320760535487531,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if LIT in NAME : return LIT if LIT in NAME : return LIT if LIT in NAME : return LIT if LIT in NAME or LIT in NAME : return LIT return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_dna_ethnicity_correlation",
      "lineno": 768,
      "end_lineno": 790,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 9,
      "loc": 23,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "bca442f077cedfe7e957ef84d7915d39a1552651",
      "simhash64": 7488180023047132203,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME . NAME ( LIT , [ ] ) NAME = [ ] NAME = [ ] for NAME in NAME : NAME = NAME ( NAME ) . NAME ( ) if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT ] ) : NAME . NAME ( NAME ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if NAME : NAME . NAME ( NAME . NAME ( ) ) if NAME and NAME : return LIT return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_surname_distribution_analysis",
      "lineno": 792,
      "end_lineno": 818,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 10,
      "loc": 27,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "4da39fc627c45f11e570b4c861586dc9c07a1614",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME . NAME ( LIT , [ ] ) NAME = [ ] NAME = [ ] for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if NAME and LIT in NAME : NAME = NAME . NAME ( ) [ - LIT ] NAME . NAME ( NAME ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) if NAME : NAME . NAME ( NAME ) if NAME and NAME : NAME = NAME [ LIT ] NAME = NAME [ LIT ] return f\" The { NAME } surname distribution in { NAME } can help identify other family branches and potential connections. \" return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_occupation_social_context",
      "lineno": 820,
      "end_lineno": 840,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 13,
      "loc": 21,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "d3e3d155d3daa8d3fb7f03c8d49b4481434f4ca0",
      "simhash64": 7488180023047132715,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) NAME = NAME . NAME ( LIT , LIT ) if LIT in NAME or LIT in NAME : return f\" { NAME } 's agricultural work suggests rural family roots, which often means strong community ties and local records. \" if LIT in NAME or LIT in NAME : return f\" { NAME } 's mining work indicates industrial family history, often with company records and mining community connections. \" if LIT in NAME or LIT in NAME : return f\" { NAME } 's fishing occupation suggests coastal family traditions and maritime community connections. \" if LIT in NAME or LIT in NAME : return f\" { NAME } 's teaching profession indicates educated family background with potential school and community records. \" if LIT in NAME or LIT in NAME : return f\" { NAME } 's merchant work suggests business connections and potential commercial records. \" return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_family_size_analysis",
      "lineno": 842,
      "end_lineno": 864,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 8,
      "loc": 23,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "284721307a91bd2acf585c6ccb126a4fcf709de0",
      "simhash64": 7451588277148489275,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) NAME = LIT NAME = LIT for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) if NAME == LIT : NAME += LIT elif NAME == LIT : NAME += LIT if NAME >= LIT : return f\" Large families of { NAME } + children were common in that era and often indicate strong family traditions and extensive cousin networks. \" if NAME >= LIT : return f\" The family size of { NAME } children suggests good survival rates and potential for extensive descendant research. \" if NAME >= LIT : return f\" Large sibling groups of { NAME } + often mean multiple family lines to research and potential DNA matches through various branches. \" return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_generational_gap_analysis",
      "lineno": 866,
      "end_lineno": 896,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 12,
      "loc": 31,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "de9158fd1d9edd15fe659a7ed873a44e1932d8fb",
      "simhash64": 7488180023047140411,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) NAME = [ ] NAME = [ ] for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) # Extract year for NAME in NAME ( NAME ) . NAME ( ) : if NAME . NAME ( ) and NAME ( NAME ) == LIT : NAME = NAME ( NAME ) if LIT <= NAME <= LIT : if NAME == LIT : NAME . NAME ( NAME ) elif NAME == LIT : NAME . NAME ( NAME ) break if NAME ( NAME ) >= LIT : NAME = NAME ( NAME [ LIT ] - NAME [ LIT ] ) if NAME >= LIT : return f\" The { NAME } -year generational gap suggests we may be looking at parent-child relationships, which helps narrow our connection. \" if NAME <= LIT : return f\" The { NAME } -year age gap suggests sibling or cousin relationships, indicating we share more recent common ancestors. \" return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessagePersonalizer._create_document_preservation_likelihood",
      "lineno": 898,
      "end_lineno": 914,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 8,
      "loc": 17,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, extracted_data)",
      "fingerprint": "fbb2538105b10370d0fca1fc56d985c23c6b2053",
      "simhash64": 7487617073093710891,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) if LIT in NAME . NAME ( ) or LIT in NAME . NAME ( ) : return f\" Church connections in { NAME } suggest good preservation of parish records and potential for baptism, marriage, and burial documentation. \" if LIT in NAME . NAME ( ) : return f\" Military service records from { NAME } are often well-preserved and can provide detailed family information. \" if LIT in NAME . NAME ( ) or LIT in NAME . NAME ( ) : return f\" Immigration records for { NAME } often include family details and can help trace origins and destinations. \" return LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessageEffectivenessTracker.__init__",
      "lineno": 923,
      "end_lineno": 934,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "e860ba0c8f1edc829a12c984f11c18fa5036732a",
      "simhash64": 5726842660764161579,
      "normalized": "def NAME ( NAME ) : LIT NAME . NAME = NAME . NAME ( ) NAME . NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT }"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessageEffectivenessTracker._load_effectiveness_data",
      "lineno": 936,
      "end_lineno": 955,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 20,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "5a37b38f4175fe445aa8cd395981a1d98002b820",
      "simhash64": 7452854914476578347,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT try : NAME = NAME ( NAME ) . NAME ( ) . NAME NAME = NAME / LIT if NAME . NAME ( ) : with NAME . NAME ( LIT , NAME = LIT ) as NAME : return NAME . NAME ( NAME ) else : return { LIT : { } , LIT : { } , LIT : { } , LIT : { } , LIT : NAME . NAME ( ) . NAME ( ) } except NAME as NAME : NAME . NAME ( f\" Error loading effectiveness data: { NAME } \" ) return { LIT : { } , LIT : { } }"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessageEffectivenessTracker.track_message_response",
      "lineno": 957,
      "end_lineno": 1045,
      "is_method": true,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 8,
      "loc": 89,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, template_key, personalization_functions_used, response_intent, response_quality_score, _conversation_length, genealogical_data_extracted)",
      "fingerprint": "ee6658bb4a3f56153bf25d217fb35630d138ad2f",
      "simhash64": 7452151226028176439,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME ) -> None : LIT try : # Update template performance if NAME not in NAME . NAME [ LIT ] : NAME . NAME [ LIT ] [ NAME ] = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : { } , LIT : LIT } NAME = NAME . NAME [ LIT ] [ NAME ] NAME [ LIT ] += LIT if NAME != LIT : NAME [ LIT ] += LIT # Update intent distribution if NAME not in NAME [ LIT ] : NAME [ LIT ] [ NAME ] = LIT NAME [ LIT ] [ NAME ] += LIT # Update average response quality NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME [ LIT ] = ( ( NAME * ( NAME - LIT ) + NAME ) / NAME ) # Update average data extracted NAME = NAME [ LIT ] NAME [ LIT ] = ( ( NAME * ( NAME - LIT ) + NAME ) / NAME ) # Track personalization function effectiveness for NAME in NAME : if NAME not in NAME . NAME [ LIT ] : NAME . NAME [ LIT ] [ NAME ] = { LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME . NAME [ LIT ] [ NAME ] NAME [ LIT ] += LIT # Consider ENTHUSIASTIC, PRODUCTIVE, CAUTIOUSLY_INTERESTED as positive if NAME in [ LIT , LIT , LIT ] : NAME [ LIT ] += LIT # Update engagement score NAME = NAME . NAME . NAME ( NAME , LIT ) NAME = NAME [ LIT ] NAME = NAME [ LIT ] NAME [ LIT ] = ( ( NAME * ( NAME - LIT ) + NAME ) / NAME ) # Update last modified NAME . NAME [ LIT ] = NAME . NAME ( ) . NAME ( ) # Save updated data NAME . NAME ( ) NAME . NAME ( f\" Tracked message effectiveness for template ' { NAME } ' with response ' { NAME } ' \" ) except NAME as NAME : NAME . NAME ( f\" Error tracking message response: { NAME } \" )"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessageEffectivenessTracker.get_template_effectiveness_score",
      "lineno": 1047,
      "end_lineno": 1067,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 21,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self, template_key)",
      "fingerprint": "f6d33e45f9fa4229b67c6a8ddd6dec2873c12401",
      "simhash64": 14369680253660869667,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT if NAME not in NAME . NAME [ LIT ] : return LIT # Default neutral score NAME = NAME . NAME [ LIT ] [ NAME ] if NAME [ LIT ] == LIT : return LIT # Calculate response rate (0-4 points) NAME = NAME [ LIT ] / NAME [ LIT ] NAME = NAME * LIT # Add quality bonus (0-3 points) NAME = ( NAME [ LIT ] / LIT ) * LIT # Add data extraction bonus (0-3 points) NAME = NAME ( NAME [ LIT ] / LIT , LIT ) * LIT return NAME ( NAME + NAME + NAME , LIT )"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessageEffectivenessTracker.get_optimization_recommendations",
      "lineno": 1069,
      "end_lineno": 1105,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 10,
      "loc": 37,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "4587ba40bdb1b913407ca873f40fad9c64115e53",
      "simhash64": 7452151226028176403,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME = [ ] # Analyze template performance NAME = { } for NAME in NAME . NAME [ LIT ] : NAME [ NAME ] = NAME . NAME ( NAME ) if NAME : NAME = NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ NAME ] ) NAME = NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ NAME ] ) if NAME [ NAME ] > LIT : NAME . NAME ( f\" Template ' { NAME } ' is performing excellently (score: { NAME [ NAME ] : .1f } ). Consider using it more frequently. \" ) if NAME [ NAME ] < LIT : NAME . NAME ( f\" Template ' { NAME } ' needs improvement (score: { NAME [ NAME ] : .1f } ). Consider revising or replacing. \" ) # Analyze personalization function effectiveness NAME = { } for NAME , NAME in NAME . NAME [ LIT ] . NAME ( ) : if NAME [ LIT ] >= LIT : # Only consider functions used at least 5 times NAME = NAME [ LIT ] / NAME [ LIT ] NAME [ NAME ] = NAME if NAME : NAME = NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ NAME ] ) NAME = NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ NAME ] ) if NAME [ NAME ] > LIT : NAME . NAME ( f\" Personalization function ' { NAME } ' is highly effective ( { NAME [ NAME ] : .1% } positive response rate). Use it more often. \" ) if NAME [ NAME ] < LIT : NAME . NAME ( f\" Personalization function ' { NAME } ' has low effectiveness ( { NAME [ NAME ] : .1% } positive response rate). Consider improving or replacing. \" ) return NAME"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "MessageEffectivenessTracker._save_effectiveness_data",
      "lineno": 1107,
      "end_lineno": 1117,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "e4693d9195ff40662193840434496cd6dfd6470a",
      "simhash64": 7452151225961067547,
      "normalized": "def NAME ( NAME ) -> None : LIT try : NAME = NAME ( NAME ) . NAME ( ) . NAME NAME = NAME / LIT with NAME . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME . NAME , NAME , NAME = LIT , NAME = False ) except NAME as NAME : NAME . NAME ( f\" Error saving effectiveness data: { NAME } \" )"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "test_message_personalization",
      "lineno": 1121,
      "end_lineno": 1160,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 40,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "8918c167516110557bda6af4bcc0dd27263a1ee8",
      "simhash64": 5150390704554808875,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) NAME = NAME ( ) # Test data NAME = { LIT : [ { LIT : LIT , LIT : [ ] , LIT : None } ] , LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ] , LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT } ] , LIT : [ LIT ] } NAME = { LIT : LIT } NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } # Test message creation NAME , NAME = NAME . NAME ( LIT , NAME , NAME , NAME ) NAME = NAME ( NAME ) > LIT and LIT in NAME NAME . NAME ( f\" Message personalization test: { LIT if NAME else LIT } \" ) return NAME"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "test_fallback_template_path",
      "lineno": 1162,
      "end_lineno": 1174,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "74363ab7d7a3384b3fa65a37180896fc76c6ad0b",
      "simhash64": 7456232614197106219,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( ) # Force empty templates to guarantee fallback path NAME . NAME = { LIT : LIT } NAME , NAME = NAME . NAME ( LIT , { LIT : LIT } , { } , { LIT : LIT } ) # Either fallback message or resolved fallback template must appear return ( LIT in NAME ) and NAME ( NAME ) > LIT"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "test_shared_ancestors_formatting",
      "lineno": 1176,
      "end_lineno": 1186,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d16e9f4f8624d1ff275877d8e140b6b8f52e570e",
      "simhash64": 7456232614264215083,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( ) NAME = { LIT : [ { LIT : LIT } , { LIT : LIT } , { LIT : LIT } , ] } NAME = NAME . NAME ( NAME ) # Expect: \"Alice Brown, Robert Clark, and Sarah Davis\" return NAME . NAME ( LIT ) == LIT and NAME . NAME ( LIT ) and LIT in NAME"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "test_location_context_limit",
      "lineno": 1188,
      "end_lineno": 1200,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "0ae934b2ed4bb18c98c4b786677d9964b2e079fe",
      "simhash64": 7456232614264215083,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( ) NAME . NAME [ LIT ] = LIT NAME = { LIT : [ { LIT : LIT } , { LIT : LIT } , { LIT : LIT } , ] } NAME = NAME . NAME ( NAME ) # Should include only two locations and the word 'and' between them # Pattern: ' Aberdeen and Glasgow' (order preserved, third excluded) return NAME . NAME ( ) . NAME ( LIT ) <= LIT and LIT not in NAME and LIT in NAME"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "message_personalization_module_tests",
      "lineno": 1203,
      "end_lineno": 1243,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 41,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "3266165f4907fc1177feb242cc7dba584cdaf38b",
      "simhash64": 5145886009646814251,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "message_personalization.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 1246,
      "end_lineno": 1248,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "ms_graph_utils.py",
      "qualname": "save_cache_on_exit",
      "lineno": 116,
      "end_lineno": 144,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 29,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "756bce89e4dd81b115b0f544ebe3794f834e3739",
      "simhash64": 7488215173059482643,
      "normalized": "def NAME ( ) -> None : LIT # Check if cache path is valid and cache object exists if not NAME or not NAME : NAME . NAME ( LIT ) return NAME . NAME ( LIT ) try : # Check if cache state actually changed since loading/last save if NAME . NAME : NAME . NAME ( f\" MSAL cache has changed. Saving to: { NAME } \" ) # Ensure directory exists again (paranoid check) NAME . NAME . NAME ( NAME = True , NAME = True ) # Serialize and write cache data NAME = NAME . NAME ( ) NAME . NAME ( f\" Serialized cache data length: { NAME ( NAME ) } bytes. \" ) NAME . NAME ( NAME , NAME = LIT ) NAME . NAME ( LIT ) # Optional: Reset flag manually after save if needed, though MSAL might handle this. # persistent_cache.has_state_changed = False else : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Failed to save MSAL cache to { NAME } : { NAME } \" , NAME = True )"
    },
    {
      "module_path": "ms_graph_utils.py",
      "qualname": "acquire_token_device_flow",
      "lineno": 174,
      "end_lineno": 271,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 14,
      "loc": 98,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "5edce72b77414fe2281a9f2d5996ba15281d11f4",
      "simhash64": 7452151225961059379,
      "normalized": "def NAME ( ) -> NAME [ NAME ] : LIT # Step 1: Check if MSAL App instance is available if not NAME : NAME . NAME ( LIT ) return None NAME = NAME # Use the shared instance # Step 2: Attempt Silent Token Acquisition (from cache) NAME = None NAME = NAME . NAME ( ) # Get accounts known to the cache if NAME : NAME . NAME ( f\" Account(s) found in cache ( { NAME ( NAME ) } ). Attempting silent token acquisition... \" ) NAME = NAME [ LIT ] # Use the first account found NAME = NAME . NAME ( NAME , NAME = NAME ) # Step 2a: Check silent result if NAME and LIT in NAME : NAME . NAME ( LIT ) return NAME [ LIT ] # Return cached token NAME . NAME ( LIT ) # Optional: Could remove account if silent fails: app.remove_account(account) # Step 3: Fallback to Interactive Device Code Flow NAME . NAME ( LIT ) try : NAME = NAME . NAME ( NAME = NAME ) except NAME as NAME : NAME . NAME ( f\" Error initiating device flow: { NAME } \" , NAME = True ) return None # Step 3a: Check if flow initiation failed (e.g., config error) if LIT not in NAME : NAME = NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" Failed to create device flow. Response: { NAME } \" ) return None # Step 3b: Display user instructions (use print for immediate visibility) NAME ( LIT + LIT * LIT ) NAME ( LIT ) NAME ( LIT * LIT ) NAME ( f\" 1. Open a web browser to: { NAME [ LIT ] } \" ) NAME ( f\" 2. Enter the code: { NAME [ LIT ] } \" ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT * LIT + LIT ) NAME = NAME . NAME ( LIT , LIT ) # Get timeout from response NAME . NAME ( f\" Device flow started. Please authenticate using the code above ( { NAME } s timeout). \" ) # Step 3c: Wait for user authentication (blocking call) try : NAME = NAME . NAME ( NAME ) # This waits for completion/timeout except NAME as NAME : # Catch errors during the waiting/acquisition phase NAME . NAME ( f\" Error acquiring token via device flow: { NAME } \" , NAME = True ) NAME = None # Ensure result is None on exception # Step 4: Process device flow result if NAME and LIT in NAME : NAME . NAME ( LIT ) # Log user info if available NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT ) or NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) NAME . NAME ( f\" Authenticated as: { NAME } \" ) # Mark cache as changed *only* after successful interactive flow if NAME : NAME . NAME = True NAME . NAME ( LIT ) return NAME [ LIT ] # Return the newly acquired token if NAME and LIT in NAME : # Log specific error message from MS identity platform NAME . NAME ( f\" Failed to acquire token via device flow: { NAME . NAME ( LIT , LIT ) } \" ) return None # Handle timeout or other unexpected failures NAME . NAME ( f\" Device flow failed, timed out, or returned unexpected result: { NAME } \" ) return None"
    },
    {
      "module_path": "ms_graph_utils.py",
      "qualname": "get_todo_list_id",
      "lineno": 277,
      "end_lineno": 364,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 8,
      "yield_count": 0,
      "complexity": 12,
      "loc": 88,
      "tags": [
        "impure",
        "network",
        "json",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(access_token, list_name)",
      "fingerprint": "de0ac221bd27973bf037ef9ffd849216c4fd5ecc",
      "simhash64": 7452186410333156371,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME ] : LIT # Step 1: Validate inputs (Unchanged) if not NAME or not NAME : NAME . NAME ( LIT ) return None # Step 2: Prepare API request details (Unchanged) NAME = { LIT : f\" Bearer { NAME } \" } NAME = ( f\" { NAME } /me/todo/lists?$filter=displayName eq ' { NAME } ' \" ) NAME . NAME ( f\" Querying MS Graph API for To-Do list named ' { NAME } '... \" ) NAME . NAME ( f\" List query URL: { NAME } \" ) # Step 3: Execute the API request try : NAME = NAME . NAME ( NAME , NAME = NAME , NAME = LIT ) NAME . NAME ( ) # Raise HTTPError for bad status codes # Step 4: Parse the JSON response (Unchanged) NAME = NAME . NAME ( ) # Step 5: Process the result list (Unchanged) if ( NAME and LIT in NAME and NAME ( NAME [ LIT ] , NAME ) and NAME ( NAME [ LIT ] ) > LIT ) : NAME = NAME [ LIT ] [ LIT ] NAME = NAME . NAME ( LIT ) if NAME : NAME . NAME ( f\" Found To-Do list ' { NAME } ' with ID: { NAME } \" ) return NAME NAME . NAME ( f\" List ' { NAME } ' found, but 'id' field missing: { NAME } \" ) return None NAME . NAME ( f\" Microsoft To-Do list named ' { NAME } ' not found. \" ) NAME . NAME ( f\" API response for list query: { NAME } \" ) return None # --- Step 6: Handle potential errors (REVISED) --- except NAME . NAME . NAME as NAME : NAME = NAME . NAME . NAME # Log specific common errors if NAME in [ LIT , LIT ] : NAME . NAME ( f\" MS Graph Auth Error ( { NAME } ) querying To-Do lists. Token expired or invalid permissions? Error: { NAME } \" ) elif NAME == LIT : # This shouldn't happen with a $filter query unless the base endpoint is wrong NAME . NAME ( f\" MS Graph Not Found Error (404) querying To-Do lists. Base API endpoint correct? Error: { NAME } \" ) else : # Log other HTTP errors NAME . NAME ( f\" HTTP error querying To-Do lists: { NAME } \" , NAME = False ) # Log response body for debugging with NAME . NAME ( NAME ) : NAME . NAME ( f\" Error response content: { NAME . NAME . NAME [ : LIT ] } \" ) return None except NAME . NAME . NAME as NAME : # Network errors, timeouts, etc. NAME . NAME ( f\" Network error querying To-Do lists: { NAME } \" , NAME = False ) return None except NAME . NAME as NAME : # Error parsing the response (shouldn't happen on success) NAME . NAME ( f\" Error decoding JSON response from list query: { NAME } \" ) if LIT in NAME ( ) and NAME ( NAME , LIT ) : # Check if response exists NAME . NAME ( f\" Response content causing JSON error: { NAME . NAME [ : LIT ] } \" ) return None except NAME as NAME : # Catch-all for unexpected errors NAME . NAME ( f\" Unexpected error getting To-Do list ID: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "ms_graph_utils.py",
      "qualname": "create_todo_task",
      "lineno": 370,
      "end_lineno": 451,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 10,
      "loc": 82,
      "tags": [
        "impure",
        "network",
        "json",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(access_token, list_id, task_title, task_body)",
      "fingerprint": "0d04381d4b1ae0fbe0a1f69f0676b20a2553aff2",
      "simhash64": 7452151225961059347,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT # Step 1: Validate inputs (Unchanged) if not NAME or not NAME or not NAME : NAME . NAME ( LIT ) return False # Step 2: Prepare API request details (Unchanged) NAME = { LIT : f\" Bearer { NAME } \" , LIT : LIT , } NAME = f\" { NAME } /me/todo/lists/ { NAME } /tasks \" # Step 3: Construct the task data payload (Unchanged) NAME : NAME [ NAME , NAME ] = { LIT : NAME } if NAME : NAME [ LIT ] = { LIT : NAME , LIT : LIT } NAME . NAME ( f\" Attempting to create MS To-Do task ' { NAME [ : LIT ] } ...' in list ID ' { NAME } '... \" ) NAME . NAME ( f\" Task creation payload: { NAME . NAME ( NAME ) } \" ) # Step 4: Execute the POST request try : NAME = NAME . NAME ( NAME , NAME = NAME , NAME = NAME , NAME = LIT ) NAME . NAME ( ) # Raise HTTPError for bad status codes # Step 5: Process successful response (HTTP 201 Created) (Unchanged) NAME . NAME ( f\" Successfully created task ' { NAME [ : LIT ] } ...'. \" ) try : NAME . NAME ( f\" Create task response details: { NAME . NAME ( ) } \" ) except NAME . NAME : NAME . NAME ( LIT ) return True # --- Step 6: Handle potential errors (REVISED) --- except NAME . NAME . NAME as NAME : NAME = NAME . NAME . NAME if NAME in [ LIT , LIT ] : NAME . NAME ( f\" MS Graph Auth Error ( { NAME } ) creating task. Token expired/invalid permissions? Error: { NAME } \" ) elif NAME == LIT : NAME . NAME ( f\" MS Graph Bad Request (400) creating task. Payload invalid? Error: { NAME } \" ) elif NAME == LIT : NAME . NAME ( f\" MS Graph Not Found Error (404) creating task. List ID ' { NAME } ' invalid? Error: { NAME } \" ) else : NAME . NAME ( f\" HTTP error creating To-Do task: { NAME } \" , NAME = False ) # Log response body for debugging with NAME . NAME ( NAME ) : NAME . NAME ( f\" Error response content: { NAME . NAME . NAME [ : LIT ] } \" ) return False except NAME . NAME . NAME as NAME : NAME . NAME ( f\" Network error creating To-Do task: { NAME } \" , NAME = False ) return False except NAME as NAME : NAME . NAME ( f\" Unexpected error creating To-Do task: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "ms_graph_utils.py",
      "qualname": "test_initialization",
      "lineno": 460,
      "end_lineno": 475,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9cc59a71ebfd78d850dd2454f39d30bd4caf52f6",
      "simhash64": 8605072730567906403,
      "normalized": "def NAME ( ) : LIT # Test that required configuration is accessible assert NAME ( NAME . NAME , LIT ) , LIT # Test token cache directory creation capability NAME = NAME . NAME . NAME or NAME ( ) assert ( NAME . NAME ( ) or NAME . NAME . NAME ( ) ) , LIT # Test MSAL availability assert NAME is not None , LIT # Test test data with 12345 identifier NAME = LIT assert LIT in NAME , LIT"
    },
    {
      "module_path": "ms_graph_utils.py",
      "qualname": "test_core_functionality",
      "lineno": 478,
      "end_lineno": 506,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 29,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d09edd58c096fd9df3999f9b082fba4f5b6a446b",
      "simhash64": 7452151225961067539,
      "normalized": "def NAME ( ) : LIT # Test authentication function structure assert NAME ( NAME ) , LIT # Test with mock MSAL client using test data NAME = LIT with NAME ( LIT ) as NAME : NAME = NAME ( ) NAME . NAME = NAME NAME . NAME . NAME = [ ] NAME . NAME . NAME = None NAME . NAME . NAME = { LIT : LIT , LIT : LIT , } NAME . NAME . NAME = { LIT : NAME } # Test device flow with mock response NAME = NAME ( ) # Result may be None due to mocked environment, which is acceptable assert NAME is None or NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "ms_graph_utils.py",
      "qualname": "test_edge_cases",
      "lineno": 509,
      "end_lineno": 537,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 29,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "e5403d40d9e4293e9166d4670949c5ea80474318",
      "simhash64": 8605107915007112211,
      "normalized": "def NAME ( ) : LIT # Test invalid client ID handling NAME = LIT assert NAME ( NAME ) == LIT , LIT # Test with mock error responses with NAME ( LIT ) as NAME : NAME = NAME ( ) NAME . NAME = NAME NAME . NAME . NAME = [ ] NAME . NAME . NAME = None NAME . NAME . NAME = None # Simulate failure # Test handling of None device flow NAME = NAME ( ) # Should handle gracefully assert NAME is None or NAME ( NAME , NAME ) # Test file operations error handling with NAME ( LIT , NAME = NAME ( LIT ) ) : try : # Test that permission errors are handled from NAME import NAME with NAME ( LIT ) . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( LIT ) except NAME : pass # Expected behavior"
    },
    {
      "module_path": "ms_graph_utils.py",
      "qualname": "test_integration",
      "lineno": 540,
      "end_lineno": 559,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "15a00779266a1843ce7939cba78effacb4081653",
      "simhash64": 5145887104926389819,
      "normalized": "def NAME ( ) : LIT # Test token validation structure NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } # Validate token structure assert LIT in NAME , LIT assert LIT in NAME , LIT assert NAME [ LIT ] == LIT , LIT # Test API endpoint construction NAME = LIT NAME = f\" { NAME } /me \" assert LIT in NAME , LIT assert LIT in NAME , LIT"
    },
    {
      "module_path": "ms_graph_utils.py",
      "qualname": "test_performance",
      "lineno": 562,
      "end_lineno": 586,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 25,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "1748a09726f3f8fb32ed74ebe6c8e9d61709f969",
      "simhash64": 7452291964581877307,
      "normalized": "def NAME ( ) : LIT import NAME # Test function execution time NAME = NAME . NAME ( ) # Simulate Graph API call structure NAME = { LIT : [ { LIT : f\" item_ { NAME } \" , LIT : f\" Test Item { NAME } \" } for NAME in NAME ( LIT ) ] } # Test data processing NAME = LIT for NAME in NAME [ LIT ] : if LIT in NAME and LIT in NAME : NAME += LIT NAME = NAME . NAME ( ) NAME = NAME - NAME # Performance assertions assert NAME == LIT , LIT assert NAME < LIT , LIT"
    },
    {
      "module_path": "ms_graph_utils.py",
      "qualname": "test_error_handling",
      "lineno": 589,
      "end_lineno": 617,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 29,
      "tags": [
        "impure",
        "network",
        "json",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "02a0a6a08078c56cb7c0e66b5b67884272ba0838",
      "simhash64": 7452327148895245331,
      "normalized": "def NAME ( ) : LIT # Test HTTP error simulation from NAME . NAME import NAME # Test 401 Unauthorized handling NAME = NAME ( ) NAME . NAME = LIT NAME . NAME . NAME = { LIT : LIT } # Test error response structure assert NAME . NAME == LIT , LIT # Test 403 Forbidden handling NAME = NAME ( ) NAME . NAME = LIT NAME . NAME . NAME = { LIT : LIT } assert NAME . NAME == LIT , LIT # Test network timeout simulation with NAME ( LIT , NAME = NAME ( LIT ) ) : try : import NAME NAME . NAME ( LIT , NAME = LIT ) except NAME : pass # Expected behavior for timeout handling"
    },
    {
      "module_path": "ms_graph_utils.py",
      "qualname": "ms_graph_utils_module_tests",
      "lineno": 620,
      "end_lineno": 678,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 59,
      "tags": [
        "impure",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "b5c059dade8c5d4a88d1d8589c42806b97814af7",
      "simhash64": 5145885975287075883,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( LIT , NAME ) NAME . NAME ( ) # Run all test categories with 5-parameter format with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "ms_graph_utils.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 681,
      "end_lineno": 683,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "my_selectors.py",
      "qualname": "my_selectors_module_tests",
      "lineno": 113,
      "end_lineno": 209,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 97,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "0fef1c5a13b034924df43d0c8511728cfafdb5c6",
      "simhash64": 5127871611137332267,
      "normalized": "def NAME ( ) -> NAME : LIT with NAME ( ) : NAME = NAME ( LIT , LIT ) # Run all tests NAME ( LIT ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Generate summary report return NAME . NAME ( )"
    },
    {
      "module_path": "my_selectors.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 212,
      "end_lineno": 214,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "my_selectors.py",
      "qualname": "test_selector_definitions",
      "lineno": 218,
      "end_lineno": 230,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "89cc25da0006db7ddee172509a25cac696a163e2",
      "simhash64": 7452291964523156539,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME in NAME ( ) , f\" { NAME } should be defined \" NAME = NAME ( ) [ NAME ] assert NAME ( NAME , NAME ) , f\" { NAME } should be a string \" assert NAME ( NAME . NAME ( ) ) > LIT , f\" { NAME } should not be empty \""
    },
    {
      "module_path": "my_selectors.py",
      "qualname": "test_css_format",
      "lineno": 233,
      "end_lineno": 248,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "regex",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2e953e5d5902011ec6bbd5bded9bcdbd99b3bbbe",
      "simhash64": 7452151225962116115,
      "normalized": "def NAME ( ) -> None : LIT import NAME NAME = LIT NAME = [ NAME , NAME , NAME , NAME , ] for NAME in NAME : assert NAME . NAME ( NAME , NAME ) , f\" Invalid CSS selector: { NAME } \" assert NAME . NAME ( ) == NAME , f\" Selector has whitespace: { NAME } \""
    },
    {
      "module_path": "my_selectors.py",
      "qualname": "test_selector_organization",
      "lineno": 251,
      "end_lineno": 264,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2d5478625089834fd86ca0091db63f36fec5e21f",
      "simhash64": 7488180023047132211,
      "normalized": "def NAME ( ) -> None : LIT # Count selectors by category NAME = [ NAME for NAME in NAME ( ) if NAME . NAME ( LIT ) ] NAME = [ NAME for NAME in NAME if LIT in NAME or LIT in NAME ] assert NAME ( NAME ) > LIT , LIT assert NAME ( NAME ) >= LIT , LIT # Test naming convention for NAME in NAME [ : LIT ] : # Test first 5 for performance assert NAME . NAME ( ) , f\" Selector { NAME } should be uppercase \""
    },
    {
      "module_path": "my_selectors.py",
      "qualname": "test_placeholder_selectors",
      "lineno": 267,
      "end_lineno": 276,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "cdf09b9c0118673b00cd541bd65645d7eca5f1c1",
      "simhash64": 7488180023047132219,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ ] for NAME , NAME in NAME ( ) . NAME ( ) : if NAME ( NAME , NAME ) and LIT in NAME and LIT in NAME : NAME . NAME ( ( NAME , NAME ) ) # Test placeholder format if any exist for NAME , NAME in NAME [ : LIT ] : # Limit for performance assert NAME . NAME ( LIT ) == NAME . NAME ( LIT ) , f\" Unmatched braces in { NAME } \""
    },
    {
      "module_path": "my_selectors.py",
      "qualname": "test_login_selectors",
      "lineno": 279,
      "end_lineno": 296,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "95ac44c0bf290596dbf7b7a60c2738da3882d701",
      "simhash64": 7452291964524729899,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ LIT , LIT , LIT , LIT , ] for NAME in NAME : if NAME in NAME ( ) : NAME = NAME ( ) [ NAME ] assert NAME ( NAME , NAME ) , f\" Login selector { NAME } should be string \" assert ( NAME ( NAME ) > LIT ) , f\" Login selector { NAME } should not be empty \""
    },
    {
      "module_path": "my_selectors.py",
      "qualname": "test_error_selectors",
      "lineno": 299,
      "end_lineno": 316,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "a9bcf187268464bd3cdf0fa1d40407a7e959959f",
      "simhash64": 7452291964523680811,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ LIT , LIT , LIT , LIT , ] for NAME in NAME : if NAME in NAME ( ) : NAME = NAME ( ) [ NAME ] assert NAME ( NAME , NAME ) , f\" Error selector { NAME } should be string \" assert ( NAME ( NAME ) > LIT ) , f\" Error selector { NAME } should not be empty \""
    },
    {
      "module_path": "my_selectors.py",
      "qualname": "test_selector_integrity",
      "lineno": 319,
      "end_lineno": 333,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "28511711a83ff7f42e0745773dd513199a49b7df",
      "simhash64": 8623122318818710579,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ NAME for NAME in NAME ( ) if NAME . NAME ( LIT ) ] for NAME in NAME : NAME = NAME ( ) [ NAME ] assert NAME ( NAME , NAME ) , f\" Selector { NAME } should be string \" assert ( NAME ( NAME . NAME ( ) ) > LIT ) , f\" Selector { NAME } should not be empty \" assert ( not NAME . NAME ( ) ) , f\" Selector { NAME } should not be whitespace only \""
    },
    {
      "module_path": "my_selectors.py",
      "qualname": "test_special_characters",
      "lineno": 336,
      "end_lineno": 352,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "a740a4db7ffac391eade3cae7e382b5f60ec8ff9",
      "simhash64": 7487757811657380907,
      "normalized": "def NAME ( ) -> None : LIT # Test that selectors with special characters are valid NAME = [ ] for NAME , NAME in NAME ( ) . NAME ( ) : if NAME ( NAME , NAME ) and NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT ] ) : NAME . NAME ( ( NAME , NAME ) ) assert NAME ( NAME ) > LIT , LIT for NAME , NAME in NAME [ : LIT ] : # Test first few for performance # Basic validation that it looks like a CSS selector assert NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT ] ) , f\" Special selector { NAME } should contain CSS syntax \""
    },
    {
      "module_path": "my_selectors.py",
      "qualname": "test_selector_accessibility",
      "lineno": 355,
      "end_lineno": 367,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "48f261e163237e4abff03b0e302b9bd91f6c70f8",
      "simhash64": 7488180023047132731,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ NAME for NAME in NAME ( ) if NAME . NAME ( LIT ) ] NAME = LIT for NAME in NAME : try : NAME = NAME ( ) [ NAME ] NAME += LIT except NAME : pass # Some selectors might not be accessible, which is acceptable assert NAME > LIT , LIT"
    },
    {
      "module_path": "my_selectors.py",
      "qualname": "test_performance",
      "lineno": 370,
      "end_lineno": 382,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6e07718751cda862bde41a4e9d71db9422541d78",
      "simhash64": 7452186411407938651,
      "normalized": "def NAME ( ) -> None : LIT import NAME NAME = NAME . NAME ( ) # Test rapid selector access for NAME in NAME ( LIT ) : NAME = NAME NAME = NAME NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Selector access should be fast, took { NAME : .3f } s \""
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "CacheableObject.__init__",
      "lineno": 35,
      "end_lineno": 36,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, value)",
      "fingerprint": "7727b7b4fc563ed0a7337e5b2b01f2625f2e202e",
      "simhash64": 8606269515690316819,
      "normalized": "def NAME ( NAME , NAME : NAME = None ) -> None : NAME . NAME = NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "PerformanceCache.__init__",
      "lineno": 55,
      "end_lineno": 80,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 26,
      "tags": [
        "impure",
        "filesystem",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self, max_memory_cache_size)",
      "fingerprint": "96cb941114aab6994593835764ec0ca79f454e06",
      "simhash64": 7452291964590273555,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) -> None : # Increased cache size for better performance NAME . NAME : NAME [ NAME , NAME [ NAME , NAME ] ] = { } NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME : NAME [ NAME , NAME ] = { } # Track cache hit frequency NAME . NAME : NAME [ NAME , NAME ] = { } # Track access times for LRU NAME . NAME : NAME [ NAME , NAME [ NAME ] ] = { } # Track cache dependencies NAME . NAME : NAME [ NAME , NAME ] = { } # Track individual cache entry sizes NAME . NAME = NAME NAME . NAME = True # Enable adaptive cache sizing NAME . NAME = LIT # Trigger cleanup at 80% capacity NAME . NAME = NAME ( LIT ) NAME . NAME . NAME ( NAME = True , NAME = True ) NAME . NAME = NAME NAME . NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } NAME . NAME ( f\" Performance cache initialized with max size { NAME } (Phase 7.3.1 Enhanced) \" )"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "PerformanceCache.cache_stats",
      "lineno": 83,
      "end_lineno": 91,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "971b6b3a496d1b800d2747d43ab1a7ef47fc4fa6",
      "simhash64": 7451588277081379883,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , LIT : NAME . NAME , LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , }"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "PerformanceCache._calculate_memory_usage",
      "lineno": 93,
      "end_lineno": 102,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 10,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "b26ad1c6e36cd81157f2821ed340f1ee2e2f9bef",
      "simhash64": 7487617073026610179,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : import NAME NAME = LIT for NAME , NAME in NAME . NAME . NAME ( ) : NAME += NAME . NAME ( NAME ) + NAME . NAME ( NAME ) return NAME / ( LIT * LIT ) # Convert to MB except NAME : return LIT"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "PerformanceCache._calculate_memory_pressure",
      "lineno": 104,
      "end_lineno": 108,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "749e6dd99ecfd1c6c23eb378d683a8038960cb7d",
      "simhash64": 7487617073026610179,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if NAME . NAME == LIT : return LIT return NAME ( NAME . NAME ) / NAME . NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "PerformanceCache._should_trigger_cleanup",
      "lineno": 110,
      "end_lineno": 113,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "9e874e11dab2566afcbbb4cabe447a0b3e6da853",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) return NAME >= NAME . NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "PerformanceCache._adaptive_resize",
      "lineno": 115,
      "end_lineno": 138,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "6d3682894d7195a8f33f2c272b02f9ad060727c5",
      "simhash64": 7452151226028176403,
      "normalized": "def NAME ( NAME ) -> None : LIT if not NAME . NAME : return NAME = NAME . NAME [ LIT ] / NAME ( LIT , NAME . NAME [ LIT ] + NAME . NAME [ LIT ] ) # If hit rate is very high (>90%), consider increasing cache size if NAME > LIT and NAME ( NAME . NAME ) >= NAME . NAME * LIT : NAME = NAME . NAME NAME . NAME = NAME ( NAME . NAME * LIT , LIT ) # Cap at 1000 entries if NAME . NAME != NAME : NAME . NAME [ LIT ] += LIT NAME . NAME ( f\" Adaptive resize: increased cache size from { NAME } to { NAME . NAME } \" ) # If hit rate is low (<50%) and cache is large, consider shrinking elif NAME < LIT and NAME . NAME > LIT : NAME = NAME . NAME NAME . NAME = NAME ( NAME . NAME * LIT , LIT ) # Minimum 100 entries if NAME . NAME != NAME : NAME . NAME [ LIT ] += LIT NAME . NAME ( f\" Adaptive resize: decreased cache size from { NAME } to { NAME . NAME } \" ) # Trigger cleanup to match new size NAME . NAME ( )"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "PerformanceCache._generate_cache_key",
      "lineno": 140,
      "end_lineno": 143,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, *args, **kwargs)",
      "fingerprint": "4fe6acce230f1367008c31f3e2a2ce741c738928",
      "simhash64": 7487652262231049251,
      "normalized": "def NAME ( NAME , * NAME , ** NAME ) -> NAME : LIT NAME = NAME ( NAME ) + NAME ( NAME ( NAME . NAME ( ) ) ) return NAME . NAME ( NAME . NAME ( ) ) . NAME ( )"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "PerformanceCache._cleanup_old_entries",
      "lineno": 145,
      "end_lineno": 175,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 31,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, force_cleanup)",
      "fingerprint": "c7251e1c83f5ea7d109c4c268d5cb54091ed9696",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME , NAME : NAME = False ) : LIT NAME = NAME or NAME ( NAME . NAME ) > NAME . NAME or NAME . NAME ( ) if NAME : # Enhanced LRU eviction strategy with dependency awareness NAME = NAME ( NAME . NAME * LIT ) # Clean to 80% capacity NAME = NAME ( LIT , NAME ( NAME . NAME ) - NAME ) if NAME . NAME ( ) : NAME . NAME [ LIT ] += LIT # Sort by combination of access time, hit count, and size (LRU with frequency and size bias) NAME = NAME ( NAME . NAME . NAME ( ) , NAME = lambda NAME : ( NAME . NAME . NAME ( NAME , LIT ) , # Last access time (primary) NAME . NAME . NAME ( NAME , LIT ) , # Hit frequency (secondary) - NAME . NAME . NAME ( NAME , LIT ) # Size (larger items evicted first, hence negative) ) ) [ : NAME ] # Remove entries and their dependencies NAME = LIT for NAME in NAME : NAME += NAME . NAME ( NAME ) NAME . NAME ( f\" Cleaned up { NAME } cache entries using enhanced LRU (target: { NAME } ) \" ) # Trigger adaptive resize check NAME . NAME ( )"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "PerformanceCache._remove_cache_entry",
      "lineno": 177,
      "end_lineno": 204,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, key)",
      "fingerprint": "121c9fdd01c169bd93ead5a14c1babd62c9d43e9",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT if NAME not in NAME . NAME : return LIT NAME = LIT # Remove the entry NAME . NAME . NAME ( NAME , None ) NAME . NAME . NAME ( NAME , None ) NAME . NAME . NAME ( NAME , None ) NAME . NAME . NAME ( NAME , None ) NAME . NAME . NAME ( NAME , None ) # Handle dependencies NAME = NAME . NAME . NAME ( NAME , [ ] ) for NAME in NAME : if NAME in NAME . NAME : NAME += NAME . NAME ( NAME ) NAME . NAME [ LIT ] += LIT # Remove this key from other entries' dependencies for NAME in NAME . NAME . NAME ( ) : if NAME in NAME : NAME . NAME ( NAME ) NAME . NAME [ LIT ] += LIT return NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "PerformanceCache.invalidate_dependencies",
      "lineno": 206,
      "end_lineno": 221,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 16,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self, pattern)",
      "fingerprint": "eb46595d61ed320cfdf94eb806e17747ec48689c",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME , NAME : NAME ) : LIT NAME = LIT NAME = [ ] for NAME in NAME . NAME : if NAME in NAME or NAME ( NAME in NAME for NAME in NAME . NAME . NAME ( NAME , [ ] ) ) : NAME . NAME ( NAME ) for NAME in NAME : NAME += NAME . NAME ( NAME ) if NAME > LIT : NAME . NAME ( f\" Invalidated { NAME } cache entries matching pattern: { NAME } \" ) return NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "PerformanceCache.get",
      "lineno": 223,
      "end_lineno": 253,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 31,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(self, cache_key)",
      "fingerprint": "a6ee56aa6e6a0866c0c827363bc6fc996b174299",
      "simhash64": 7452151226028176467,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT # Check memory cache first if NAME in NAME . NAME : # Update access statistics for LRU NAME . NAME [ NAME ] = NAME . NAME . NAME ( NAME , LIT ) + LIT NAME . NAME [ NAME ] = NAME . NAME ( ) NAME . NAME [ LIT ] += LIT NAME . NAME ( f\" Cache HIT (memory): { NAME [ : LIT ] } ... \" ) return NAME . NAME [ NAME ] # Check disk cache NAME = NAME . NAME / f\" { NAME } .pkl \" if NAME . NAME ( ) : try : with NAME . NAME ( LIT ) as NAME : NAME = NAME . NAME ( NAME ) # Move to memory cache for faster access NAME . NAME [ NAME ] = NAME NAME . NAME [ NAME ] = NAME . NAME ( ) NAME . NAME [ NAME ] = NAME . NAME ( ) NAME . NAME [ NAME ] = LIT NAME . NAME [ LIT ] += LIT NAME . NAME ( f\" Cache HIT (disk): { NAME [ : LIT ] } ... \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Failed to load disk cache { NAME } : { NAME } \" ) NAME . NAME [ LIT ] += LIT NAME . NAME ( f\" Cache MISS: { NAME [ : LIT ] } ... \" ) return None"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "PerformanceCache.set",
      "lineno": 255,
      "end_lineno": 293,
      "is_method": true,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 39,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(self, cache_key, value, disk_cache, dependencies)",
      "fingerprint": "dcdbaa32e49e2a830183f90dd24d1267a372b31e",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME = True , NAME : NAME [ NAME [ NAME ] ] = None ) : LIT # Calculate and store entry size try : import NAME NAME = NAME . NAME ( NAME ) NAME . NAME [ NAME ] = NAME except NAME : NAME . NAME [ NAME ] = LIT # Store in memory NAME . NAME [ NAME ] = NAME NAME . NAME [ NAME ] = NAME . NAME ( ) NAME . NAME [ NAME ] = NAME . NAME ( ) NAME . NAME [ NAME ] = LIT # Store dependencies if NAME : NAME . NAME [ NAME ] = NAME . NAME ( ) # Store on disk if requested and serializable if NAME : try : NAME . NAME ( NAME ) # Test serialization NAME = NAME . NAME / f\" { NAME } .pkl \" with NAME . NAME ( LIT ) as NAME : NAME . NAME ( NAME , NAME ) NAME . NAME ( f\" Cache SET (disk): { NAME [ : LIT ] } ... \" ) except ( NAME . NAME , NAME ) as NAME : NAME . NAME ( f\" Skipping disk cache for non-serializable data { NAME } : { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Failed to save disk cache { NAME } : { NAME } \" ) # Cleanup if needed NAME . NAME ( ) NAME . NAME ( f\" Cache SET: { NAME [ : LIT ] } ... \" )"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "cache_gedcom_results",
      "lineno": 303,
      "end_lineno": 344,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 42,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(ttl, disk_cache)",
      "fingerprint": "8139235099247478762934565ad361ce92252239",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME = True ) : LIT def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # Generate cache key NAME = NAME . NAME ( NAME . NAME , * NAME , ** NAME ) # Try to get from cache NAME = NAME . NAME ( NAME ) if NAME is not None : NAME , NAME = NAME if NAME . NAME ( ) - NAME < NAME : NAME . NAME ( f\" Using cached result for { NAME . NAME } \" ) return NAME # Execute function and cache result NAME = NAME . NAME ( ) try : NAME = NAME ( * NAME , ** NAME ) except NAME as NAME : NAME . NAME ( f\" Error in cached function { NAME . NAME } : { NAME } \" ) raise NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" { NAME . NAME } executed in { NAME : .2f } s \" ) # Cache the result NAME = ( NAME . NAME ( ) , NAME ) NAME . NAME ( NAME , NAME , NAME ) return NAME return NAME return NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "decorator",
      "lineno": 309,
      "end_lineno": 342,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 34,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(func)",
      "fingerprint": "4e790f59009ed21514e73d37f4d2beb65dc74ec7",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # Generate cache key NAME = NAME . NAME ( NAME . NAME , * NAME , ** NAME ) # Try to get from cache NAME = NAME . NAME ( NAME ) if NAME is not None : NAME , NAME = NAME if NAME . NAME ( ) - NAME < NAME : NAME . NAME ( f\" Using cached result for { NAME . NAME } \" ) return NAME # Execute function and cache result NAME = NAME . NAME ( ) try : NAME = NAME ( * NAME , ** NAME ) except NAME as NAME : NAME . NAME ( f\" Error in cached function { NAME . NAME } : { NAME } \" ) raise NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" { NAME . NAME } executed in { NAME : .2f } s \" ) # Cache the result NAME = ( NAME . NAME ( ) , NAME ) NAME . NAME ( NAME , NAME , NAME ) return NAME return NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "wrapper",
      "lineno": 311,
      "end_lineno": 340,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 30,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "0a102392a68860c2c48e6e5e538db4e81aa81893",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # Generate cache key NAME = NAME . NAME ( NAME . NAME , * NAME , ** NAME ) # Try to get from cache NAME = NAME . NAME ( NAME ) if NAME is not None : NAME , NAME = NAME if NAME . NAME ( ) - NAME < NAME : NAME . NAME ( f\" Using cached result for { NAME . NAME } \" ) return NAME # Execute function and cache result NAME = NAME . NAME ( ) try : NAME = NAME ( * NAME , ** NAME ) except NAME as NAME : NAME . NAME ( f\" Error in cached function { NAME . NAME } : { NAME } \" ) raise NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" { NAME . NAME } executed in { NAME : .2f } s \" ) # Cache the result NAME = ( NAME . NAME ( ) , NAME ) NAME . NAME ( NAME , NAME , NAME ) return NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "fast_test_cache",
      "lineno": 347,
      "end_lineno": 374,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 28,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(func)",
      "fingerprint": "f348fdc7a249776d29a548d39cc8e4b214c7fb8b",
      "simhash64": 7488144838607938643,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # For test functions, use simple memory-only caching NAME = f\" test_ { NAME . NAME } _ { NAME ( NAME ( NAME ) ) } \" NAME = NAME . NAME ( NAME ) if NAME is not None : NAME . NAME ( f\" Fast test cache hit: { NAME . NAME } \" ) return NAME # Execute test NAME = NAME . NAME ( ) NAME = NAME ( * NAME , ** NAME ) NAME = NAME . NAME ( ) - NAME # Cache result (memory only for tests) NAME . NAME ( NAME , NAME , NAME = False ) NAME . NAME ( f\" Test { NAME . NAME } cached in { NAME : .2f } s \" ) return NAME return NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "wrapper",
      "lineno": 354,
      "end_lineno": 372,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 19,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "4a815b73d9128e31c6f2781bb7497a4ad8e08747",
      "simhash64": 7488144838608987219,
      "normalized": "def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # For test functions, use simple memory-only caching NAME = f\" test_ { NAME . NAME } _ { NAME ( NAME ( NAME ) ) } \" NAME = NAME . NAME ( NAME ) if NAME is not None : NAME . NAME ( f\" Fast test cache hit: { NAME . NAME } \" ) return NAME # Execute test NAME = NAME . NAME ( ) NAME = NAME ( * NAME , ** NAME ) NAME = NAME . NAME ( ) - NAME # Cache result (memory only for tests) NAME . NAME ( NAME , NAME , NAME = False ) NAME . NAME ( f\" Test { NAME . NAME } cached in { NAME : .2f } s \" ) return NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "progressive_processing",
      "lineno": 377,
      "end_lineno": 421,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 45,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(chunk_size, progress_callback)",
      "fingerprint": "35eb5e4af8a9b675a36c76c2fcd61f5c61a89c81",
      "simhash64": 7488180022980019219,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME [ NAME ] = None ) : LIT def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # If data is large enough, process in chunks NAME = NAME . NAME ( LIT ) or ( NAME [ LIT ] if NAME else None ) if NAME is not None and NAME ( NAME , LIT ) and NAME ( NAME ) > NAME : NAME . NAME ( f\" Processing { NAME ( NAME ) } items in chunks of { NAME } \" ) NAME = [ ] NAME = ( NAME ( NAME ) + NAME - LIT ) // NAME for NAME in NAME ( LIT , NAME ( NAME ) , NAME ) : NAME = NAME [ NAME : NAME + NAME ] NAME = NAME ( NAME , * NAME [ LIT : ] , ** NAME ) NAME . NAME ( NAME if NAME ( NAME , NAME ) else [ NAME ] ) # Progress callback if NAME : NAME = ( NAME // NAME + LIT ) / NAME NAME ( NAME ) # Log progress NAME = NAME // NAME + LIT NAME . NAME ( f\" Processed chunk { NAME } / { NAME } \" ) return NAME # Process normally for small datasets return NAME ( * NAME , ** NAME ) return NAME return NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "decorator",
      "lineno": 385,
      "end_lineno": 419,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 35,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(func)",
      "fingerprint": "987ebc4aad8deb790075b72880da8a3b8c1f12a7",
      "simhash64": 7488180022980019219,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # If data is large enough, process in chunks NAME = NAME . NAME ( LIT ) or ( NAME [ LIT ] if NAME else None ) if NAME is not None and NAME ( NAME , LIT ) and NAME ( NAME ) > NAME : NAME . NAME ( f\" Processing { NAME ( NAME ) } items in chunks of { NAME } \" ) NAME = [ ] NAME = ( NAME ( NAME ) + NAME - LIT ) // NAME for NAME in NAME ( LIT , NAME ( NAME ) , NAME ) : NAME = NAME [ NAME : NAME + NAME ] NAME = NAME ( NAME , * NAME [ LIT : ] , ** NAME ) NAME . NAME ( NAME if NAME ( NAME , NAME ) else [ NAME ] ) # Progress callback if NAME : NAME = ( NAME // NAME + LIT ) / NAME NAME ( NAME ) # Log progress NAME = NAME // NAME + LIT NAME . NAME ( f\" Processed chunk { NAME } / { NAME } \" ) return NAME # Process normally for small datasets return NAME ( * NAME , ** NAME ) return NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "wrapper",
      "lineno": 387,
      "end_lineno": 417,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 31,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "bc2d8a91a186c8344d3273e701302d2b70a8a436",
      "simhash64": 7488180022980019219,
      "normalized": "def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # If data is large enough, process in chunks NAME = NAME . NAME ( LIT ) or ( NAME [ LIT ] if NAME else None ) if NAME is not None and NAME ( NAME , LIT ) and NAME ( NAME ) > NAME : NAME . NAME ( f\" Processing { NAME ( NAME ) } items in chunks of { NAME } \" ) NAME = [ ] NAME = ( NAME ( NAME ) + NAME - LIT ) // NAME for NAME in NAME ( LIT , NAME ( NAME ) , NAME ) : NAME = NAME [ NAME : NAME + NAME ] NAME = NAME ( NAME , * NAME [ LIT : ] , ** NAME ) NAME . NAME ( NAME if NAME ( NAME , NAME ) else [ NAME ] ) # Progress callback if NAME : NAME = ( NAME // NAME + LIT ) / NAME NAME ( NAME ) # Log progress NAME = NAME // NAME + LIT NAME . NAME ( f\" Processed chunk { NAME } / { NAME } \" ) return NAME # Process normally for small datasets return NAME ( * NAME , ** NAME )"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "clear_performance_cache",
      "lineno": 427,
      "end_lineno": 444,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3d77eacf50a7d668805e11c36c5ef4b824391f31",
      "simhash64": 8641136716253930499,
      "normalized": "def NAME ( ) -> None : LIT NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) # Clear disk cache try : import NAME if NAME . NAME . NAME ( ) : NAME . NAME ( NAME . NAME ) NAME . NAME . NAME ( NAME = True , NAME = True ) except NAME as NAME : NAME . NAME ( f\" Failed to clear disk cache: { NAME } \" ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "warm_performance_cache",
      "lineno": 447,
      "end_lineno": 483,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 37,
      "tags": [
        "impure",
        "filesystem",
        "size:medium"
      ],
      "signature": "(gedcom_paths, warm_strategies)",
      "fingerprint": "da6e63d45f35572ac11b2802c0377bdedc2b7d96",
      "simhash64": 7488180022980023347,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME ] ] = None , NAME : NAME [ NAME [ NAME ] ] = None ) -> None : LIT if not NAME : return if NAME is None : NAME = [ LIT , LIT ] NAME . NAME ( f\" Warming performance cache with { NAME ( NAME ) } GEDCOM files using strategies: { NAME } \" ) for NAME in NAME : try : NAME = NAME ( NAME ) if not NAME . NAME ( ) : NAME . NAME ( f\" GEDCOM file not found for warming: { NAME } \" ) continue # Strategy 1: Metadata warming if LIT in NAME : NAME ( NAME , NAME ) # Strategy 2: Common queries warming if LIT in NAME : NAME ( NAME ) # Strategy 3: Relationship data warming if LIT in NAME : NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Failed to warm cache for { NAME } : { NAME } \" )"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "_warm_metadata_cache",
      "lineno": 486,
      "end_lineno": 497,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:small"
      ],
      "signature": "(gedcom_path, path)",
      "fingerprint": "a5a3dd5592a11a6fbe38bfc050aca7c308d1cb5b",
      "simhash64": 7487617074100343819,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT NAME = NAME . NAME ( LIT , NAME ) if NAME not in NAME . NAME : NAME = { LIT : NAME . NAME ( ) . NAME , LIT : NAME . NAME ( ) . NAME , LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) . NAME / ( LIT * LIT ) } NAME . NAME ( NAME , NAME , NAME = True ) NAME . NAME ( f\" Warmed metadata cache for { NAME } \" )"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "_warm_common_queries_cache",
      "lineno": 500,
      "end_lineno": 521,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 22,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(gedcom_path)",
      "fingerprint": "9eb7e466ed5e50f1c30b803ff3580217161e4594",
      "simhash64": 7487617074101392427,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT NAME = [ ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) ] for NAME , NAME in NAME : NAME = NAME . NAME ( NAME , NAME ) if NAME not in NAME . NAME : # Create placeholder data for common indexes NAME = { LIT : NAME , LIT : NAME , LIT : NAME . NAME ( ) , LIT : True } NAME . NAME ( NAME , NAME , NAME = True ) NAME . NAME ( f\" Warmed common queries cache for { NAME } \" )"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "_warm_relationships_cache",
      "lineno": 524,
      "end_lineno": 545,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 22,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(gedcom_path)",
      "fingerprint": "32cd26169eb2883ca9bf454ef3a9afe80271fd5e",
      "simhash64": 7487617074100343867,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT NAME = [ ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) ] for NAME , NAME in NAME : NAME = NAME . NAME ( NAME , NAME ) if NAME not in NAME . NAME : NAME = { LIT : NAME , LIT : NAME , LIT : NAME . NAME ( ) , LIT : True } # Set dependencies for relationship data NAME = [ NAME . NAME ( LIT , NAME ) ] NAME . NAME ( NAME , NAME , NAME = True , NAME = NAME ) NAME . NAME ( f\" Warmed relationships cache for { NAME } \" )"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "get_cache_stats",
      "lineno": 548,
      "end_lineno": 595,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 48,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "e5beea0d942de56b614231b12c57b4017d457560",
      "simhash64": 5146308216814482435,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , LIT : NAME . NAME , LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME . NAME , LIT : NAME ( NAME . NAME ) , LIT : ( NAME ( NAME . NAME . NAME ( ) ) if NAME . NAME else None ) , LIT : ( NAME ( NAME . NAME . NAME ( ) ) if NAME . NAME else None ) , } # Add performance statistics NAME . NAME ( NAME . NAME ) # Calculate hit rates and efficiency metrics NAME = NAME [ LIT ] + NAME [ LIT ] if NAME > LIT : NAME [ LIT ] = NAME [ LIT ] / NAME NAME [ LIT ] = NAME [ LIT ] / NAME NAME [ LIT ] = ( NAME [ LIT ] - NAME [ LIT ] ) / NAME else : NAME [ LIT ] = LIT NAME [ LIT ] = LIT NAME [ LIT ] = LIT # Calculate cache efficiency metrics if NAME [ LIT ] > LIT : NAME [ LIT ] = NAME ( NAME . NAME . NAME ( ) ) / NAME [ LIT ] NAME [ LIT ] = NAME [ LIT ] / NAME ( LIT , NAME [ LIT ] ) else : NAME [ LIT ] = LIT NAME [ LIT ] = LIT # Add cache health indicators NAME [ LIT ] = NAME ( NAME ) return NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "_calculate_cache_health",
      "lineno": 598,
      "end_lineno": 636,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 39,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(stats)",
      "fingerprint": "ed623694df860171a3954c3ba8b680c486f895ba",
      "simhash64": 5146308209289892907,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : [ ] } # Memory health if NAME [ LIT ] > LIT : NAME [ LIT ] = LIT NAME [ LIT ] . NAME ( LIT ) elif NAME [ LIT ] > LIT : NAME [ LIT ] = LIT NAME [ LIT ] . NAME ( LIT ) # Hit rate health if NAME [ LIT ] < LIT : NAME [ LIT ] = LIT NAME [ LIT ] . NAME ( LIT ) elif NAME [ LIT ] < LIT : NAME [ LIT ] = LIT NAME [ LIT ] . NAME ( LIT ) # Turnover health if NAME [ LIT ] > LIT : NAME [ LIT ] = LIT NAME [ LIT ] . NAME ( LIT ) # Calculate overall score NAME = NAME ( LIT , LIT - NAME [ LIT ] ) NAME = NAME [ LIT ] NAME = NAME ( LIT , LIT - NAME ( LIT , NAME [ LIT ] / LIT ) ) NAME [ LIT ] = ( NAME + NAME + NAME ) / LIT return NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "FastMockDataFactory.create_mock_gedcom_data",
      "lineno": 649,
      "end_lineno": 675,
      "is_method": true,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 27,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ad4c0576431ada21714e299393beccf7a94b3b63",
      "simhash64": 5150390704553760299,
      "normalized": "def NAME ( ) : LIT from NAME . NAME import NAME NAME = NAME ( ) NAME . NAME = { LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } , } NAME . NAME = NAME . NAME NAME . NAME = LIT NAME . NAME = LIT NAME . NAME = LIT return NAME"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "FastMockDataFactory.create_mock_filter_criteria",
      "lineno": 678,
      "end_lineno": 685,
      "is_method": true,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "e9cb8bda0958c1c3bdad7ed6c659a6282630da1d",
      "simhash64": 5726561151424566827,
      "normalized": "def NAME ( ) : LIT return { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , }"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "FastMockDataFactory.create_mock_scoring_criteria",
      "lineno": 688,
      "end_lineno": 694,
      "is_method": true,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "37fd0804a932942a5e7d487cce715a9170a91ec7",
      "simhash64": 5726561151424566827,
      "normalized": "def NAME ( ) : LIT return { LIT : LIT , LIT : LIT , LIT : LIT , }"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "test_performance_cache_initialization",
      "lineno": 699,
      "end_lineno": 709,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "8d86f5d3e45c8d41da7092af61abf130597173e9",
      "simhash64": 7487757777228960811,
      "normalized": "def NAME ( ) -> None : LIT try : NAME = NAME ( NAME = LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) return True except NAME : return False"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "test_memory_cache_operations",
      "lineno": 711,
      "end_lineno": 718,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "932785885eb9f2a8e6b04fd652158166639fb08c",
      "simhash64": 5145877213625095723,
      "normalized": "def NAME ( ) -> None : LIT try : NAME = NAME ( NAME = LIT ) NAME . NAME ( LIT , LIT , NAME = False ) return NAME . NAME ( LIT ) == LIT except NAME : return False"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "test_cache_key_generation",
      "lineno": 720,
      "end_lineno": 728,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "f64507d6768fb9825696c1fb9cd8c4b84bf7941d",
      "simhash64": 5145886005423150091,
      "normalized": "def NAME ( ) -> None : LIT try : NAME = NAME ( NAME = LIT ) NAME = NAME . NAME ( LIT , LIT , NAME = LIT ) NAME = NAME . NAME ( LIT , LIT , NAME = LIT ) return NAME == NAME except NAME : return False"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "test_cache_expiration",
      "lineno": 730,
      "end_lineno": 736,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "b14a22ea68de3a1b650439d35a076062938a78d4",
      "simhash64": 6335427264476255787,
      "normalized": "def NAME ( ) -> None : LIT try : NAME = NAME ( NAME = LIT ) return NAME . NAME ( LIT ) is None except NAME : return False"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "test_cache_statistics_collection",
      "lineno": 738,
      "end_lineno": 746,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "edcf85dd67bcc0cc9497e4616d03f9b8f985bb84",
      "simhash64": 7488320760535487547,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME ( NAME = LIT ) NAME = NAME . NAME NAME = [ LIT , LIT , LIT ] return NAME ( NAME in NAME for NAME in NAME ) except NAME : return False"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "test_cache_health_status",
      "lineno": 748,
      "end_lineno": 755,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "087088b5ca0f6f9fa8d25c7bd833a95c9a5b38e4",
      "simhash64": 7488320761609229355,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME ( ) NAME = [ LIT , LIT , LIT ] return NAME ( NAME in NAME for NAME in NAME ) except NAME : return False"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "test_cache_performance_metrics",
      "lineno": 757,
      "end_lineno": 764,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "610c588e84e9b875539c00a3b022862e70f6a744",
      "simhash64": 7456232614255826475,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME ( NAME = LIT ) NAME . NAME ( LIT , { LIT : LIT } , NAME = True ) return NAME . NAME ( LIT ) == { LIT : LIT } except NAME : return False"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "test_memory_management_cleanup",
      "lineno": 766,
      "end_lineno": 776,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9a2b49cb75db814d28b1fbe6fa0bc999f044b085",
      "simhash64": 7487617078462420011,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME ( NAME = LIT ) NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) NAME . NAME ( ) return NAME ( NAME . NAME ) <= NAME . NAME except NAME : return False"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "performance_cache_module_tests",
      "lineno": 778,
      "end_lineno": 854,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 77,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "2df04cb4639c62b8d69b1a10b617c8ee3446066a",
      "simhash64": 5127871611137332267,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME with NAME ( ) : NAME = NAME ( LIT , NAME ) NAME . NAME ( ) # Run all tests using the suite NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "performance_cache.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 856,
      "end_lineno": 858,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard.__init__",
      "lineno": 30,
      "end_lineno": 39,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "time",
        "json",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self, data_file)",
      "fingerprint": "2d465c07568dc8a0bf265739f5c74b2667ff2fbf",
      "simhash64": 7488109654302962707,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) : LIT NAME . NAME = NAME or LIT NAME . NAME : NAME [ NAME , NAME ] = NAME . NAME ( ) NAME . NAME = NAME . NAME ( )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard._load_performance_data",
      "lineno": 41,
      "end_lineno": 60,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 20,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "e191c42695c54485c498ab4adbea20e46f136c9e",
      "simhash64": 7452151226028176435,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT try : NAME = NAME ( NAME . NAME ) if NAME . NAME ( ) : with NAME . NAME ( LIT ) as NAME : NAME = NAME . NAME ( NAME ) NAME . NAME ( f\" Loaded performance data from { NAME . NAME } \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Could not load performance data: { NAME } \" ) # Return default structure return { LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : [ ] }"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard._save_performance_data",
      "lineno": 62,
      "end_lineno": 70,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "245ec8f00d228395f21aef880e4861a6d6cf1f9f",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME ) -> None : LIT try : NAME = NAME ( NAME . NAME ) with NAME . NAME ( LIT ) as NAME : NAME . NAME ( NAME . NAME , NAME , NAME = LIT , NAME = NAME ) NAME . NAME ( f\" Saved performance data to { NAME . NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Could not save performance data: { NAME } \" )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard.record_session_start",
      "lineno": 72,
      "end_lineno": 83,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, session_info)",
      "fingerprint": "50aa13d7cc2a69932efa7b7bac14e072bbd2fe83",
      "simhash64": 7434136827518686219,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) : LIT NAME = { LIT : f\" session_ { NAME . NAME ( ) . NAME ( LIT ) } \" , LIT : NAME . NAME ( ) . NAME ( ) , LIT : NAME , LIT : [ ] } NAME . NAME [ LIT ] . NAME ( NAME ) NAME . NAME = NAME NAME . NAME ( f\" Started performance monitoring session: { NAME [ LIT ] } \" )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard.record_rate_limiting_metrics",
      "lineno": 85,
      "end_lineno": 97,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, metrics)",
      "fingerprint": "b4cf5caaed93f771810537ae4cc449d8847a4ed0",
      "simhash64": 7433573878639006767,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) : LIT NAME = { LIT : NAME . NAME ( ) . NAME ( ) , LIT : LIT , LIT : NAME } NAME . NAME [ LIT ] . NAME ( NAME ) # Also add to current session if available if NAME ( NAME , LIT ) : NAME . NAME [ LIT ] . NAME ( NAME )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard.record_batch_processing_metrics",
      "lineno": 99,
      "end_lineno": 111,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, metrics)",
      "fingerprint": "b4cf5caaed93f771810537ae4cc449d8847a4ed0",
      "simhash64": 7433573878639006767,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) : LIT NAME = { LIT : NAME . NAME ( ) . NAME ( ) , LIT : LIT , LIT : NAME } NAME . NAME [ LIT ] . NAME ( NAME ) # Also add to current session if available if NAME ( NAME , LIT ) : NAME . NAME [ LIT ] . NAME ( NAME )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard.record_optimization_event",
      "lineno": 113,
      "end_lineno": 125,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, optimization_data)",
      "fingerprint": "b4cf5caaed93f771810537ae4cc449d8847a4ed0",
      "simhash64": 7433573878639006767,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) : LIT NAME = { LIT : NAME . NAME ( ) . NAME ( ) , LIT : LIT , LIT : NAME } NAME . NAME [ LIT ] . NAME ( NAME ) # Also add to current session if available if NAME ( NAME , LIT ) : NAME . NAME [ LIT ] . NAME ( NAME )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard.record_system_metrics",
      "lineno": 127,
      "end_lineno": 139,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, system_data)",
      "fingerprint": "b4cf5caaed93f771810537ae4cc449d8847a4ed0",
      "simhash64": 7433573878639006767,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) : LIT NAME = { LIT : NAME . NAME ( ) . NAME ( ) , LIT : LIT , LIT : NAME } NAME . NAME [ LIT ] . NAME ( NAME ) # Also add to current session if available if NAME ( NAME , LIT ) : NAME . NAME [ LIT ] . NAME ( NAME )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard.generate_performance_report",
      "lineno": 141,
      "end_lineno": 189,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 49,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, hours_back)",
      "fingerprint": "ab43103a5e61a27cd49af18f7d7457733fed21a2",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) -> NAME : LIT NAME = NAME . NAME ( ) - NAME ( NAME = NAME ) # Filter recent data NAME = [ NAME for NAME in NAME . NAME [ LIT ] if NAME . NAME ( NAME [ LIT ] ) > NAME ] NAME = [ NAME for NAME in NAME . NAME [ LIT ] if NAME . NAME ( NAME [ LIT ] ) > NAME ] NAME = [ NAME for NAME in NAME . NAME [ LIT ] if NAME . NAME ( NAME [ LIT ] ) > NAME ] # Generate report NAME = f\"\"\" ANCESTRY PROJECT PERFORMANCE REPORT\n===================================\nReport Period: Last { NAME } hours\nGenerated: { NAME . NAME ( ) . NAME ( LIT ) } RATE LIMITING PERFORMANCE: { NAME . NAME ( NAME ) } BATCH PROCESSING PERFORMANCE: { NAME . NAME ( NAME ) } OPTIMIZATION EVENTS: { NAME . NAME ( NAME ) } RECOMMENDATIONS: { NAME . NAME ( NAME , NAME ) } \"\"\" return NAME . NAME ( )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard._generate_rate_limiting_summary",
      "lineno": 191,
      "end_lineno": 207,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, rate_limiting_data)",
      "fingerprint": "e694d364d37a20b1b0811222711f808c9f49c934",
      "simhash64": 7433714616060253227,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] ) -> NAME : LIT if not NAME : return LIT NAME = NAME [ - LIT ] [ LIT ] NAME = f\"\"\" Current RPS: { NAME . NAME ( LIT , LIT ) } Success Rate: { NAME . NAME ( LIT , LIT ) : .2% } Average Response Time: { NAME . NAME ( LIT , LIT ) : .2f } s\n  Rate Limit Errors: { NAME . NAME ( LIT , LIT ) } Adaptive Adjustments: { NAME . NAME ( LIT , LIT ) } Status: { NAME . NAME ( LIT , LIT ) } \"\"\" return NAME . NAME ( )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard._generate_batch_processing_summary",
      "lineno": 209,
      "end_lineno": 225,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, batch_data)",
      "fingerprint": "e29c987d4f296e860ef6cdc56f7fa97be8f3556b",
      "simhash64": 7433714616061301807,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] ) -> NAME : LIT if not NAME : return LIT NAME = NAME [ - LIT ] [ LIT ] NAME = f\"\"\" Current Batch Size: { NAME . NAME ( LIT , LIT ) } Average Processing Time: { NAME . NAME ( LIT , LIT ) : .1f } s\n  Average Success Rate: { NAME . NAME ( LIT , LIT ) : .2% } Batches Processed: { NAME . NAME ( LIT , LIT ) } Efficiency: { NAME . NAME ( LIT , LIT ) : .2f } Status: { NAME . NAME ( LIT , LIT ) } \"\"\" return NAME . NAME ( )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard._generate_optimization_summary",
      "lineno": 227,
      "end_lineno": 247,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, optimization_data)",
      "fingerprint": "3d12f0fe5872fa910254f79cc0a3dc8f140ac79a",
      "simhash64": 7469602675590861883,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] ) -> NAME : LIT if not NAME : return LIT NAME = NAME ( LIT for NAME in NAME if NAME ( NAME . NAME ( LIT ) == LIT for NAME in NAME . NAME ( LIT , { } ) . NAME ( LIT , [ ] ) ) ) NAME = NAME ( LIT for NAME in NAME if NAME ( NAME . NAME ( LIT ) == LIT for NAME in NAME . NAME ( LIT , { } ) . NAME ( LIT , [ ] ) ) ) NAME = f\"\"\" Total Optimization Events: { NAME ( NAME ) } High Priority Recommendations: { NAME } Medium Priority Recommendations: { NAME } Latest Event: { NAME [ - LIT ] [ LIT ] if NAME else LIT } \"\"\" return NAME . NAME ( )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard._generate_recommendations",
      "lineno": 249,
      "end_lineno": 277,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 29,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, rate_data, batch_data)",
      "fingerprint": "747fd001bb2de1fcb14b9598af5522b8ad6a777c",
      "simhash64": 7451588276074755107,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME ] ) -> NAME : LIT NAME = [ ] # Analyze rate limiting performance if NAME : NAME = NAME [ - LIT ] [ LIT ] NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) if NAME < LIT : NAME . NAME ( LIT ) elif NAME > LIT and NAME < LIT : NAME . NAME ( LIT ) # Analyze batch processing performance if NAME : NAME = NAME [ - LIT ] [ LIT ] NAME = NAME . NAME ( LIT , LIT ) if NAME > LIT : NAME . NAME ( LIT ) elif NAME < LIT : NAME . NAME ( LIT ) if not NAME : NAME . NAME ( LIT ) return LIT . NAME ( [ LIT , * NAME ] )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard.get_current_session_summary",
      "lineno": 279,
      "end_lineno": 292,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "2a9d96a08475457571371a4c0c052c6676f363a9",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT if not NAME ( NAME , LIT ) : return { LIT : LIT } NAME = NAME . NAME ( ) - NAME . NAME NAME = NAME ( NAME . NAME . NAME ( LIT , [ ] ) ) return { LIT : NAME . NAME . NAME ( LIT ) , LIT : NAME ( NAME ) , LIT : NAME , LIT : NAME . NAME . NAME ( ) }"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard.export_data",
      "lineno": 294,
      "end_lineno": 304,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:small"
      ],
      "signature": "(self, export_file)",
      "fingerprint": "e97b96ebf7e967af917b33ea6359bacecfdcdb1e",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT try : NAME = NAME ( NAME ) with NAME . NAME ( LIT ) as NAME : NAME . NAME ( NAME . NAME , NAME , NAME = LIT , NAME = NAME ) NAME . NAME ( f\" Exported performance data to { NAME } \" ) return True except NAME as NAME : NAME . NAME ( f\" Failed to export performance data: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard.cleanup_old_data",
      "lineno": 306,
      "end_lineno": 334,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 8,
      "loc": 29,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, days_to_keep)",
      "fingerprint": "f2f1bc1ecc5b10fd593469faace61e2cd61c103d",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) : LIT NAME = NAME . NAME ( ) - NAME ( NAME = NAME ) # Clean up each data type for NAME in [ LIT , LIT , LIT , LIT ] : if NAME in NAME . NAME : NAME = NAME ( NAME . NAME [ NAME ] ) NAME . NAME [ NAME ] = [ NAME for NAME in NAME . NAME [ NAME ] if NAME . NAME ( NAME [ LIT ] ) > NAME ] NAME = NAME - NAME ( NAME . NAME [ NAME ] ) if NAME > LIT : NAME . NAME ( f\" Cleaned up { NAME } old { NAME } entries \" ) # Clean up old sessions if LIT in NAME . NAME : NAME = NAME ( NAME . NAME [ LIT ] ) NAME . NAME [ LIT ] = [ NAME for NAME in NAME . NAME [ LIT ] if NAME . NAME ( NAME [ LIT ] ) > NAME ] NAME = NAME - NAME ( NAME . NAME [ LIT ] ) if NAME > LIT : NAME . NAME ( f\" Cleaned up { NAME } old session entries \" ) NAME . NAME ( )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "PerformanceDashboard.finalize_session",
      "lineno": 336,
      "end_lineno": 343,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "c5f6442908ba6a2742cef2b8f32579ed37728942",
      "simhash64": 7470200813204714499,
      "normalized": "def NAME ( NAME ) -> None : LIT if NAME ( NAME , LIT ) : NAME . NAME [ LIT ] = NAME . NAME ( ) . NAME ( ) NAME . NAME [ LIT ] = NAME ( NAME . NAME ( ) - NAME . NAME ) NAME . NAME ( f\" Finalized session: { NAME . NAME [ LIT ] } \" ) NAME . NAME ( )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "test_performance_dashboard",
      "lineno": 347,
      "end_lineno": 373,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 27,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7382f6a51143837fc94833278e267e822da92cf3",
      "simhash64": 5146448919877031463,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Use a simple test that doesn't rely on file I/O NAME = NAME ( LIT ) # Use in-memory to avoid file issues # Test basic instantiation assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT # Test basic functionality without file operations NAME . NAME = { LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : [ ] } # Test report generation with minimal data NAME = NAME . NAME ( NAME = LIT ) assert NAME ( NAME , NAME ) , LIT return True except NAME as NAME : NAME ( f\" Performance dashboard test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "test_session_and_metric_recording",
      "lineno": 376,
      "end_lineno": 383,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "98f2d29c351929bbb5e816970e219886952b01da",
      "simhash64": 7456233713767454251,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( LIT ) NAME . NAME ( { LIT : LIT } ) NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : LIT } ) NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : LIT } ) NAME = NAME . NAME ( ) assert NAME . NAME ( LIT , LIT ) >= LIT"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "test_report_recommendations_variants",
      "lineno": 386,
      "end_lineno": 396,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5e717b6d7bc5b06bca10df8bfa1ac006b542eda6",
      "simhash64": 8609155218374301227,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( LIT ) NAME . NAME ( { LIT : LIT , LIT : LIT } ) NAME . NAME ( { LIT : LIT } ) NAME = NAME . NAME ( NAME = LIT ) assert LIT in NAME or LIT in NAME . NAME ( ) NAME . NAME ( { LIT : LIT , LIT : LIT } ) NAME . NAME ( { LIT : LIT } ) NAME = NAME . NAME ( NAME = LIT ) assert LIT in NAME or LIT in NAME"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "test_export_and_cleanup",
      "lineno": 399,
      "end_lineno": 414,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "bf0b50d1f1cdb0b0e4cf6869729af99aef057fa4",
      "simhash64": 7487617074167452715,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( LIT ) NAME . NAME ( { LIT : LIT } ) assert NAME . NAME ( LIT ) # Inject an old entry NAME = ( NAME . NAME ( ) - NAME ( NAME = LIT ) ) . NAME ( ) NAME . NAME [ LIT ] . NAME ( { LIT : NAME , LIT : LIT , LIT : { } } ) NAME = NAME ( NAME . NAME [ LIT ] ) NAME . NAME ( NAME = LIT ) NAME = NAME ( NAME . NAME [ LIT ] ) assert NAME < NAME # Cleanup files for NAME in [ LIT , LIT ] : with NAME . NAME ( NAME ) : NAME ( NAME ) . NAME ( )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "performance_dashboard_module_tests",
      "lineno": 417,
      "end_lineno": 457,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 41,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "3266165f4907fc1177feb242cc7dba584cdaf38b",
      "simhash64": 5145886009646814251,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "performance_dashboard.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 460,
      "end_lineno": 462,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor.__init__",
      "lineno": 99,
      "end_lineno": 120,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 22,
      "tags": [
        "pure-ish",
        "time",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self, max_history, alert_thresholds)",
      "fingerprint": "bb0570be7a087fe33c29b39c07f1ed94064c19a2",
      "simhash64": 7488109654302962707,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , NAME : NAME [ NAME [ NAME , NAME ] ] = None , ) : NAME . NAME = NAME NAME . NAME : NAME = NAME ( NAME = NAME ) NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME = NAME or NAME . NAME ( ) NAME . NAME = NAME . NAME ( ) NAME . NAME = NAME . NAME ( ) NAME . NAME = True # System monitoring NAME . NAME = NAME . NAME ( ) # Background monitoring thread NAME . NAME = None NAME . NAME = False NAME . NAME ( LIT )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor._default_thresholds",
      "lineno": 122,
      "end_lineno": 131,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "2bfd5279491069a003db3326fe26f84aa8ad6dbb",
      "simhash64": 5726842626401802027,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : LIT , # 1GB LIT : LIT , LIT : LIT , # 5 seconds LIT : LIT , # 50% LIT : LIT , # 1 second LIT : LIT , # 3 seconds }"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor.start_monitoring",
      "lineno": 133,
      "end_lineno": 141,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "2571cd0491641e0f7863be648f06a54b29f15479",
      "simhash64": 8641136711958963203,
      "normalized": "def NAME ( NAME ) -> None : LIT if NAME . NAME is None or not NAME . NAME . NAME ( ) : NAME . NAME = False NAME . NAME = NAME . NAME ( NAME = NAME . NAME , NAME = True ) NAME . NAME . NAME ( ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor.stop_monitoring",
      "lineno": 143,
      "end_lineno": 148,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "70ba0a3d7c619b6b43707aa0c1ace8b28d7c83ca",
      "simhash64": 8640573762072650755,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = True if NAME . NAME and NAME . NAME . NAME ( ) : NAME . NAME . NAME ( NAME = LIT ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor._background_monitor",
      "lineno": 150,
      "end_lineno": 159,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 10,
      "tags": [
        "pure-ish",
        "time",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "1497073a1946e6c1e8c43d811b1b71998b4c9e4b",
      "simhash64": 8640573762072654907,
      "normalized": "def NAME ( NAME ) -> None : LIT while not NAME . NAME : try : NAME . NAME ( ) NAME . NAME ( ) NAME . NAME ( LIT ) # Monitor every 30 seconds except NAME as NAME : NAME . NAME ( f\" Error in background monitoring: { NAME } \" ) NAME . NAME ( LIT ) # Wait longer on error"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor._collect_system_metrics",
      "lineno": 161,
      "end_lineno": 187,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 27,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "91c00dd90f60371803ce1d79e0b2cf0d2fad5f5f",
      "simhash64": 7487617073026610179,
      "normalized": "def NAME ( NAME ) -> None : LIT try : # Memory usage NAME = NAME . NAME . NAME ( ) NAME = NAME . NAME / LIT / LIT NAME . NAME ( LIT , NAME , LIT ) # CPU usage NAME = NAME . NAME . NAME ( ) NAME . NAME ( LIT , NAME , LIT ) # System memory NAME = NAME . NAME ( ) NAME . NAME ( LIT , NAME . NAME , LIT ) # Disk usage (project directory) NAME = NAME . NAME ( NAME ( NAME . NAME ( ) ) ) NAME = ( NAME . NAME / NAME . NAME ) * LIT NAME . NAME ( LIT , NAME , LIT ) # Thread count NAME = NAME . NAME ( ) NAME . NAME ( LIT , NAME , LIT ) except NAME as NAME : NAME . NAME ( f\" Error collecting system metrics: { NAME } \" )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor.record_metric",
      "lineno": 189,
      "end_lineno": 208,
      "is_method": true,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 20,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, name, value, category, metadata)",
      "fingerprint": "b4dabcd1a6b15c324050554b3b692a06a50cdfb7",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None , ) -> None : LIT if not NAME . NAME : return with NAME . NAME : NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME . NAME ( ) , NAME = NAME , NAME = NAME or { } , ) NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor.profile_function",
      "lineno": 210,
      "end_lineno": 285,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 7,
      "loc": 76,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, func)",
      "fingerprint": "d320a2d891c1f8561b200fb3c26feca5ed0cd3ce",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT if not NAME . NAME : return NAME @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : NAME = f\" { NAME . NAME } . { NAME . NAME } \" # Get memory before NAME . NAME ( ) NAME = NAME . NAME . NAME ( ) . NAME / LIT / LIT NAME = NAME . NAME ( ) NAME = False try : return NAME ( * NAME , ** NAME ) except NAME : NAME = True raise finally : NAME = NAME . NAME ( ) NAME = NAME - NAME # Get memory after NAME = NAME . NAME . NAME ( ) . NAME / LIT / LIT NAME = NAME - NAME # Update profile with NAME . NAME : if NAME not in NAME . NAME : NAME . NAME [ NAME ] = NAME ( NAME ) NAME = NAME . NAME [ NAME ] NAME . NAME += LIT NAME . NAME += NAME NAME . NAME = NAME ( NAME . NAME , NAME ) NAME . NAME = NAME ( NAME . NAME , NAME ) NAME . NAME = NAME . NAME / NAME . NAME NAME . NAME . NAME ( NAME ) NAME . NAME . NAME ( NAME ) NAME . NAME = NAME . NAME ( ) if NAME : NAME . NAME += LIT # Record metric NAME . NAME ( LIT , NAME * LIT , LIT , { LIT : NAME , LIT : NAME , LIT : NAME ( NAME ) , LIT : NAME ( NAME ) , } , ) # Check for slow functions if NAME * LIT > NAME . NAME . NAME ( LIT , LIT ) : NAME . NAME ( NAME . NAME , f\" Slow function execution: { NAME } \" , LIT , NAME * LIT , NAME . NAME [ LIT ] , f\" Consider optimizing { NAME } - took { NAME : .2f } s \" , ) return NAME"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor.wrapper",
      "lineno": 216,
      "end_lineno": 283,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 68,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "b9e98fd015bfb260e30fd9ecec72d22da00631aa",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( * NAME , ** NAME ) : NAME = f\" { NAME . NAME } . { NAME . NAME } \" # Get memory before NAME . NAME ( ) NAME = NAME . NAME . NAME ( ) . NAME / LIT / LIT NAME = NAME . NAME ( ) NAME = False try : return NAME ( * NAME , ** NAME ) except NAME : NAME = True raise finally : NAME = NAME . NAME ( ) NAME = NAME - NAME # Get memory after NAME = NAME . NAME . NAME ( ) . NAME / LIT / LIT NAME = NAME - NAME # Update profile with NAME . NAME : if NAME not in NAME . NAME : NAME . NAME [ NAME ] = NAME ( NAME ) NAME = NAME . NAME [ NAME ] NAME . NAME += LIT NAME . NAME += NAME NAME . NAME = NAME ( NAME . NAME , NAME ) NAME . NAME = NAME ( NAME . NAME , NAME ) NAME . NAME = NAME . NAME / NAME . NAME NAME . NAME . NAME ( NAME ) NAME . NAME . NAME ( NAME ) NAME . NAME = NAME . NAME ( ) if NAME : NAME . NAME += LIT # Record metric NAME . NAME ( LIT , NAME * LIT , LIT , { LIT : NAME , LIT : NAME , LIT : NAME ( NAME ) , LIT : NAME ( NAME ) , } , ) # Check for slow functions if NAME * LIT > NAME . NAME . NAME ( LIT , LIT ) : NAME . NAME ( NAME . NAME , f\" Slow function execution: { NAME } \" , LIT , NAME * LIT , NAME . NAME [ LIT ] , f\" Consider optimizing { NAME } - took { NAME : .2f } s \" , )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor._check_alerts",
      "lineno": 287,
      "end_lineno": 322,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 36,
      "tags": [
        "pure-ish",
        "time",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "b684b09c23e70dc0308106f9be2eba6c3248892c",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME ) -> None : LIT if not NAME . NAME : return # Get recent metrics (last 5 minutes) NAME = NAME . NAME ( ) - NAME ( NAME = LIT ) NAME = [ NAME for NAME in NAME . NAME if NAME . NAME >= NAME ] # Group by metric name NAME = NAME ( NAME ) for NAME in NAME : NAME [ NAME . NAME ] . NAME ( NAME . NAME ) # Check thresholds for NAME , NAME in NAME . NAME ( ) : if not NAME : continue NAME = NAME . NAME ( NAME ) NAME = NAME . NAME . NAME ( NAME ) if NAME is not None and NAME > NAME : NAME = ( NAME . NAME if NAME > NAME * LIT else NAME . NAME ) NAME . NAME ( NAME , f\" High { NAME } : { NAME : .2f } \" , NAME , NAME , NAME , NAME . NAME ( NAME , NAME ) , )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor._create_alert",
      "lineno": 324,
      "end_lineno": 355,
      "is_method": true,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 32,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self, level, message, metric_name, current_value, threshold, recommendation)",
      "fingerprint": "17e2455adaf35aae243c27367fd2c39ce670db3c",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None , ) -> None : LIT NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME . NAME ( ) , NAME = NAME , ) with NAME . NAME : NAME . NAME . NAME ( NAME ) # Keep only last 1000 alerts if NAME ( NAME . NAME ) > LIT : NAME . NAME = NAME . NAME [ - LIT : ] if NAME == NAME . NAME : NAME . NAME ( f\" CRITICAL PERFORMANCE ALERT: { NAME } \" ) elif NAME == NAME . NAME : NAME . NAME ( f\" Performance warning: { NAME } \" ) else : NAME . NAME ( f\" Performance info: { NAME } \" )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor._get_optimization_recommendation",
      "lineno": 357,
      "end_lineno": 369,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, metric_name, value)",
      "fingerprint": "4c3e3c1dc52e6dd60fddf2a97e33a63704f88580",
      "simhash64": 3400072646656168507,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT NAME = { LIT : f\" High memory usage ( { NAME : .0f } MB). Consider: 1) Implementing object pooling, 2) Optimizing data structures, 3) Adding memory cleanup routines \" , LIT : f\" High CPU usage ( { NAME : .1f } %). Consider: 1) Adding caching, 2) Optimizing algorithms, 3) Using background processing for heavy tasks \" , LIT : f\" Slow function ( { NAME : .0f } ms). Consider: 1) Adding profiling, 2) Optimizing database queries, 3) Implementing caching \" , LIT : f\" Low cache hit ratio ( { NAME : .1% } ). Consider: 1) Reviewing cache keys, 2) Increasing cache size, 3) Improving cache warming \" , LIT : f\" Slow database queries ( { NAME : .0f } ms). Consider: 1) Adding indexes, 2) Query optimization, 3) Connection pooling \" , LIT : f\" Slow API responses ( { NAME : .0f } ms). Consider: 1) Response caching, 2) Request batching, 3) Timeout optimization \" , } return NAME . NAME ( NAME , f\" Performance issue detected with { NAME } : { NAME } \" )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor.get_report",
      "lineno": 371,
      "end_lineno": 457,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 11,
      "loc": 87,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self, hours)",
      "fingerprint": "fccc80c85a34c54bae07eb7f923d555f44b4151b",
      "simhash64": 7487617073026601995,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME ( ) - NAME ( NAME = NAME ) NAME = [ NAME for NAME in NAME . NAME if NAME . NAME >= NAME ] NAME = [ NAME for NAME in NAME . NAME if NAME . NAME >= NAME ] # Calculate statistics NAME = NAME ( NAME ) for NAME in NAME : NAME [ NAME . NAME ] . NAME ( NAME . NAME ) NAME = { } for NAME , NAME in NAME . NAME ( ) : if NAME : NAME [ NAME ] = { LIT : NAME ( NAME ) , LIT : NAME ( NAME ) , LIT : NAME ( NAME ) , LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME ( NAME ) if NAME ( NAME ) > LIT else LIT , } # Function performance summary NAME = { } for NAME , NAME in NAME . NAME . NAME ( ) : NAME [ NAME ] = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME / NAME ( NAME . NAME , LIT ) , LIT : ( NAME . NAME ( NAME . NAME ) if NAME . NAME else LIT ) , LIT : ( NAME . NAME . NAME ( ) if NAME . NAME else None ) , } return { LIT : { LIT : NAME , LIT : NAME . NAME ( ) . NAME ( ) , LIT : NAME . NAME ( ) - NAME . NAME , LIT : NAME ( NAME ) , LIT : NAME ( NAME ) , LIT : { LIT : NAME ( [ NAME for NAME in NAME if NAME . NAME == NAME . NAME ] ) , LIT : NAME ( [ NAME for NAME in NAME if NAME . NAME == NAME . NAME ] ) , LIT : NAME ( [ NAME for NAME in NAME if NAME . NAME == NAME . NAME ] ) , } , LIT : NAME ( NAME . NAME ) , LIT : NAME . NAME , } , LIT : NAME , LIT : NAME , LIT : [ { LIT : NAME . NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME . NAME ( ) , LIT : NAME . NAME , } for NAME in NAME [ - LIT : ] # Last 20 alerts ] , LIT : { LIT : NAME . NAME , LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) . NAME / LIT / LIT / LIT , LIT : NAME . NAME ( NAME ( NAME . NAME ( ) ) ) . NAME / LIT / LIT / LIT , } , LIT : NAME . NAME ( NAME , NAME ) , }"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor._generate_recommendations",
      "lineno": 459,
      "end_lineno": 491,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 33,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, stats_summary, function_summary)",
      "fingerprint": "dc3085f9838752817d253c410139946e807854de",
      "simhash64": 7488320760535487547,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME ] : LIT NAME = [ ] # Check for high error rates for NAME , NAME in NAME . NAME ( ) : if NAME . NAME ( LIT , LIT ) > LIT : NAME . NAME ( f\" High error rate in { NAME } : consider error handling improvements \" ) # Check for slow functions for NAME , NAME in NAME . NAME ( ) : if NAME . NAME ( LIT , LIT ) > LIT : NAME . NAME ( f\" Function { NAME } is slow (avg: { NAME [ LIT ] : .3f } s): consider optimization \" ) # Check for memory usage patterns for NAME , NAME in NAME . NAME ( ) : if LIT in NAME . NAME ( ) and NAME . NAME ( LIT , LIT ) > LIT : NAME . NAME ( f\" High memory usage detected for { NAME } : consider memory optimization \" ) if not NAME : NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "PerformanceMonitor.export_report",
      "lineno": 493,
      "end_lineno": 505,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "size:small"
      ],
      "signature": "(self, filepath, hours)",
      "fingerprint": "407c2f3a81849404342833f792e0c1edf8d1ee9f",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None , NAME : NAME = LIT ) -> NAME : LIT NAME = NAME . NAME ( NAME ) if NAME is None : NAME = NAME . NAME ( ) . NAME ( LIT ) NAME = NAME ( f\" performance_report_ { NAME } .json \" ) with NAME ( NAME ) . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME , NAME = LIT , NAME = NAME ) NAME . NAME ( f\" Performance report exported to { NAME } \" ) return NAME"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "profile",
      "lineno": 513,
      "end_lineno": 515,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(func)",
      "fingerprint": "1de768032d2e286122fff09aac9dd1e4b6e3440a",
      "simhash64": 7488215208425858147,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return NAME . NAME ( NAME )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "monitor_performance",
      "lineno": 518,
      "end_lineno": 520,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(func)",
      "fingerprint": "1de768032d2e286122fff09aac9dd1e4b6e3440a",
      "simhash64": 7488215208425858147,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return NAME . NAME ( NAME )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor.__init__",
      "lineno": 540,
      "end_lineno": 555,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "json",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self, config_path)",
      "fingerprint": "836ea16779727dd19a4141897bf706d2eab9aa54",
      "simhash64": 7452856014046925871,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) : NAME . NAME = NAME or LIT NAME . NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] NAME . NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] NAME . NAME : NAME = LIT NAME . NAME = False NAME . NAME : NAME [ NAME . NAME ] = None # Performance thresholds NAME . NAME = { LIT : { LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT } }"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor.start_advanced_monitoring",
      "lineno": 557,
      "end_lineno": 577,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "895265a7322cbec38b594b0a1ef51d4ab7ce5c1d",
      "simhash64": 7488144838607942659,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if NAME . NAME : NAME . NAME ( LIT ) return True try : NAME . NAME = True NAME . NAME = NAME . NAME ( NAME = NAME . NAME , NAME = True , NAME = LIT ) NAME . NAME . NAME ( ) NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" Failed to start advanced monitoring: { NAME } \" ) NAME . NAME = False return False"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor.stop_advanced_monitoring",
      "lineno": 579,
      "end_lineno": 591,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "de0cdfbed78ede7242a15777c5ed95dcde4eb631",
      "simhash64": 7487617073026610179,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME . NAME = False if NAME . NAME and NAME . NAME . NAME ( ) : NAME . NAME . NAME ( NAME = LIT ) return { LIT : NAME . NAME , LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , LIT : NAME . NAME ( ) }"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor._advanced_monitoring_loop",
      "lineno": 593,
      "end_lineno": 615,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 23,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "2c955a15ba2670befc7423783657628417988921",
      "simhash64": 7487652257465807923,
      "normalized": "def NAME ( NAME ) -> None : LIT while NAME . NAME : try : # Collect comprehensive metrics NAME = NAME . NAME ( ) NAME . NAME . NAME ( NAME ) # Analyze trends and generate recommendations NAME . NAME ( ) # Update system health score NAME . NAME ( ) # Keep history manageable (last 1000 samples) if NAME ( NAME . NAME ) > LIT : NAME . NAME = NAME . NAME [ - LIT : ] NAME . NAME ( LIT ) # Monitor every 30 seconds except NAME as NAME : NAME . NAME ( f\" Error in advanced monitoring loop: { NAME } \" ) NAME . NAME ( LIT ) # Wait longer on error"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor._collect_comprehensive_metrics",
      "lineno": 617,
      "end_lineno": 652,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 36,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "acce0eba62c08e7f9e1352ebb49b5e404a2e2788",
      "simhash64": 7451588277081379883,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT try : # System metrics NAME = NAME . NAME ( NAME = LIT ) NAME = NAME . NAME ( ) NAME = NAME . NAME ( LIT ) # Process-specific metrics NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) return { LIT : NAME . NAME ( ) . NAME ( ) , LIT : { LIT : NAME , LIT : NAME . NAME , LIT : NAME . NAME / ( LIT ** LIT ) , LIT : NAME . NAME , LIT : NAME . NAME / ( LIT ** LIT ) } , LIT : { LIT : NAME , LIT : NAME . NAME / ( LIT ** LIT ) , LIT : ( NAME . NAME / NAME . NAME ) * LIT } , LIT : { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) } } except NAME as NAME : NAME . NAME ( f\" Error collecting metrics: { NAME } \" ) return { LIT : NAME . NAME ( ) . NAME ( ) , LIT : NAME ( NAME ) }"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor._analyze_performance_trends",
      "lineno": 654,
      "end_lineno": 683,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "2ce4855a8972fcb1360fa2dc1dc266fcb0a3d759",
      "simhash64": 7451729014636844075,
      "normalized": "def NAME ( NAME ) -> None : LIT if NAME ( NAME . NAME ) < LIT : return # Need sufficient data for trend analysis NAME = NAME . NAME [ - LIT : ] # Analyze CPU trend NAME = [ NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) for NAME in NAME ] if NAME and NAME . NAME ( NAME ) > NAME . NAME [ LIT ] [ LIT ] : NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME [ LIT ] [ LIT ] } ) # Analyze memory trend NAME = [ NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) for NAME in NAME ] if NAME and NAME . NAME ( NAME ) > NAME . NAME [ LIT ] [ LIT ] : NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME [ LIT ] [ LIT ] } )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor._calculate_system_health_score",
      "lineno": 685,
      "end_lineno": 715,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 31,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "6afb89a668d5120181403764abff4e620c6548d1",
      "simhash64": 7452151226028176419,
      "normalized": "def NAME ( NAME ) -> None : LIT if not NAME . NAME : return NAME = NAME . NAME [ - LIT ] NAME = LIT # CPU impact NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) if NAME > NAME . NAME [ LIT ] [ LIT ] : NAME -= LIT elif NAME > NAME . NAME [ LIT ] [ LIT ] : NAME -= LIT # Memory impact NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) if NAME > NAME . NAME [ LIT ] [ LIT ] : NAME -= LIT elif NAME > NAME . NAME [ LIT ] [ LIT ] : NAME -= LIT # Cache performance impact NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , LIT ) if NAME < NAME . NAME [ LIT ] [ LIT ] : NAME -= LIT elif NAME < NAME . NAME [ LIT ] [ LIT ] : NAME -= LIT NAME . NAME = NAME ( LIT , NAME )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor._add_recommendation",
      "lineno": 717,
      "end_lineno": 730,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 14,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, recommendation)",
      "fingerprint": "716320f9cd64acdac6aeb287da6e6bf916996e66",
      "simhash64": 7487617073093719043,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> None : LIT # Check for existing similar recommendation for NAME in NAME . NAME : if ( NAME . NAME ( LIT ) == NAME . NAME ( LIT ) and NAME . NAME ( LIT ) == NAME . NAME ( LIT ) ) : return # Avoid duplicate NAME [ LIT ] = NAME . NAME ( ) . NAME ( ) NAME . NAME . NAME ( NAME ) # Keep recommendations manageable if NAME ( NAME . NAME ) > LIT : NAME . NAME = NAME . NAME [ - LIT : ]"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor._get_cache_statistics",
      "lineno": 732,
      "end_lineno": 741,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "115cf4388bf2a2cf4990844da03d583d23de98dc",
      "simhash64": 5150381874100999211,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT try : # Try to get cache stats from cache module from NAME import NAME return NAME ( ) except NAME : pass return { LIT : LIT , LIT : LIT , LIT : LIT }"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor._get_database_connections",
      "lineno": 743,
      "end_lineno": 749,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "afddd0b509f7073c64e296abd9c8d6d48d5e01ff",
      "simhash64": 7492854046968944383,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : # This would integrate with actual database manager return LIT # Placeholder except NAME : return LIT"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor._get_api_statistics",
      "lineno": 751,
      "end_lineno": 762,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "39ec3698bfaaf2b62e51f9dde960e773b29ede95",
      "simhash64": 7456224883314693679,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT try : # This would integrate with actual API monitoring return { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } except NAME : return { }"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor.generate_performance_dashboard",
      "lineno": 764,
      "end_lineno": 805,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 42,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "4e029ecc26befdd68bdc759599d7c2bb61676392",
      "simhash64": 7433714616060253227,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME . NAME : return LIT NAME = NAME . NAME [ - LIT ] NAME = [ LIT , LIT * LIT , LIT , f\" \ud83d\udcc8 System Health Score: { NAME . NAME : .1f } /100 \" , f\" \u23f0 Last Updated: { NAME . NAME ( LIT , LIT ) } \" , f\" \ud83d\udcca Data Points: { NAME ( NAME . NAME ) } \" , LIT , LIT , f\" CPU Usage: { NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) : .1f } % \" , f\" Memory Usage: { NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) : .1f } % \" , f\" Available Memory: { NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) : .1f } GB \" , f\" Disk Usage: { NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) : .1f } % \" , LIT , LIT , ] if not NAME . NAME : NAME . NAME ( LIT ) else : for NAME in NAME . NAME [ - LIT : ] : # Show last 5 NAME = LIT if NAME . NAME ( LIT ) == LIT else LIT NAME . NAME ( f\" { NAME } { NAME . NAME ( LIT , LIT ) } \" ) NAME . NAME ( f\" \u2192 { NAME . NAME ( LIT , LIT ) } \" ) NAME . NAME ( [ LIT , LIT , NAME . NAME ( ) , LIT , f\" \ud83c\udfaf Monitoring Status: { LIT if NAME . NAME else LIT } \" , LIT * LIT ] ) return LIT . NAME ( NAME )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor._generate_trend_summary",
      "lineno": 807,
      "end_lineno": 837,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 7,
      "loc": 31,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "b9795f2d3ca2df00023ad955d2771902e99a523d",
      "simhash64": 7488180024053765147,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if NAME ( NAME . NAME ) < LIT : return LIT NAME = NAME . NAME [ - LIT : ] # Calculate averages NAME = NAME . NAME ( [ NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) for NAME in NAME ] ) NAME = NAME . NAME ( [ NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) for NAME in NAME ] ) NAME = [ f\" Average CPU (last 10 samples): { NAME : .1f } % \" , f\" Average Memory (last 10 samples): { NAME : .1f } % \" ] # Trend indicators if NAME ( NAME . NAME ) >= LIT : NAME = NAME . NAME [ - LIT : - LIT ] NAME = NAME . NAME ( [ NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) for NAME in NAME ] ) NAME = NAME . NAME ( [ NAME . NAME ( LIT , { } ) . NAME ( LIT , LIT ) for NAME in NAME ] ) NAME = LIT if NAME > NAME else LIT if NAME < NAME else LIT NAME = LIT if NAME > NAME else LIT if NAME < NAME else LIT NAME . NAME ( [ f\" CPU Trend: { NAME } ( { NAME - NAME : +.1f } %) \" , f\" Memory Trend: { NAME } ( { NAME - NAME : +.1f } %) \" ] ) return LIT . NAME ( NAME )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "AdvancedPerformanceMonitor.validate_configuration",
      "lineno": 839,
      "end_lineno": 898,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 10,
      "loc": 60,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "c821c7fa24b24f2ae06f28f150f89140b3f1141f",
      "simhash64": 5145745266861061163,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = { LIT : LIT , LIT : [ ] , LIT : [ ] , LIT : LIT } try : # Load current configuration import NAME from NAME import NAME NAME = NAME ( NAME . NAME ) if not NAME . NAME ( ) : NAME [ LIT ] . NAME ( LIT ) NAME [ LIT ] -= LIT return NAME with NAME ( NAME ) . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( NAME ) # Validate API settings NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) if NAME > LIT : NAME [ LIT ] . NAME ( f\" API delay very conservative: { NAME } s \" ) NAME [ LIT ] . NAME ( LIT ) NAME [ LIT ] -= LIT if NAME == LIT : NAME [ LIT ] . NAME ( LIT ) NAME [ LIT ] . NAME ( LIT ) NAME [ LIT ] -= LIT if NAME < LIT : NAME [ LIT ] . NAME ( f\" Batch size { NAME } could be increased to 10-15 for better efficiency \" ) NAME [ LIT ] -= LIT # Validate cache settings NAME = NAME . NAME ( LIT , { } ) if not NAME . NAME ( LIT , True ) : NAME [ LIT ] . NAME ( LIT ) NAME [ LIT ] . NAME ( LIT ) NAME [ LIT ] -= LIT except NAME as NAME : NAME [ LIT ] . NAME ( f\" Configuration validation error: { NAME } \" ) NAME [ LIT ] -= LIT if NAME [ LIT ] < LIT : NAME [ LIT ] = LIT elif NAME [ LIT ] < LIT : NAME [ LIT ] = LIT return NAME"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "track_api_performance",
      "lineno": 904,
      "end_lineno": 929,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 26,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(api_name, duration, status)",
      "fingerprint": "56b8928f694945ae751d34ddeaf4230ebfda5dba",
      "simhash64": 7451764197935191071,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME = LIT ) -> None : LIT try : # Simple performance tracking - just log and store basic metrics - OPTIMIZATION: Less pessimistic threshold if NAME > LIT : # OPTIMIZATION: Increased from 5.0s to 20.0s - align with action6_gather.py thresholds NAME . NAME ( f\" API Performance Alert: { NAME } took { NAME : .3f } s (status: { NAME } )\\n \" ) # Update advanced monitor performance history if available NAME = { LIT : NAME . NAME ( ) . NAME ( ) , LIT : NAME , LIT : NAME , LIT : NAME , LIT : LIT } NAME . NAME . NAME ( NAME ) # Keep history manageable if NAME ( NAME . NAME ) > LIT : NAME . NAME = NAME . NAME [ - LIT : ] except NAME as NAME : # Graceful degradation - don't let performance monitoring break the main application NAME . NAME ( f\" Performance tracking error: { NAME } \" ) pass"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "start_advanced_monitoring",
      "lineno": 931,
      "end_lineno": 933,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d47288f6127502799f806b1d647827a7f4d80a3e",
      "simhash64": 8645218654783181859,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME . NAME ( )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "stop_advanced_monitoring",
      "lineno": 935,
      "end_lineno": 937,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "cb45e5d238bf4d2167818b42bca357cb2ea31f9f",
      "simhash64": 7488180022980031523,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return NAME . NAME ( )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "get_performance_dashboard",
      "lineno": 939,
      "end_lineno": 941,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d47288f6127502799f806b1d647827a7f4d80a3e",
      "simhash64": 8645218654783181859,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME . NAME ( )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "validate_system_configuration",
      "lineno": 943,
      "end_lineno": 945,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "cb45e5d238bf4d2167818b42bca357cb2ea31f9f",
      "simhash64": 7488180022980031523,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return NAME . NAME ( )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "get_system_health_score",
      "lineno": 947,
      "end_lineno": 949,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "a06e71fbdf3628313724150b54212553520c2120",
      "simhash64": 7492860095297401955,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME . NAME"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 956,
      "end_lineno": 1337,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 18,
      "loc": 382,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "b9a8bedcc8e805050f8e0b47dbbf1b67d932c082",
      "simhash64": 7452151225961059371,
      "normalized": "def NAME ( ) -> NAME : LIT try : from NAME import NAME # Using TestSuite only except NAME : NAME ( LIT ) return NAME ( ) NAME = NAME ( LIT , LIT ) def NAME ( ) : LIT # Test default initialization NAME = NAME ( ) assert NAME . NAME == LIT # Default value is 10000 assert NAME ( NAME . NAME ) == LIT assert NAME ( NAME . NAME ) == LIT assert NAME ( NAME . NAME ) == LIT assert NAME . NAME # Test custom initialization NAME = { LIT : LIT } NAME = NAME ( NAME = LIT , NAME = NAME ) assert NAME . NAME == LIT assert LIT in NAME . NAME def NAME ( ) : LIT NAME = NAME ( ) # Test basic metric recording NAME . NAME ( LIT , LIT , LIT ) assert NAME ( NAME . NAME ) == LIT NAME = NAME . NAME [ LIT ] assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME ( NAME . NAME , NAME ) # Test with metadata NAME = { LIT : LIT , LIT : LIT } NAME . NAME ( LIT , LIT , LIT , NAME = NAME ) assert NAME ( NAME . NAME ) == LIT assert NAME . NAME [ LIT ] . NAME == NAME # Test metric retrieval by category using list comprehension NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] assert NAME ( NAME ) == LIT assert NAME [ LIT ] . NAME == LIT def NAME ( ) : LIT NAME = NAME ( ) # Test function profiling decorator @ NAME . NAME def NAME ( NAME , NAME = LIT ) : import NAME NAME . NAME ( LIT ) # Small sleep for timing return NAME + NAME # Call function multiple times NAME = NAME ( LIT ) NAME = NAME ( LIT , NAME = LIT ) NAME = NAME ( LIT ) assert NAME == LIT assert NAME == LIT assert NAME == LIT # Check profiling data NAME = NAME ( NAME . NAME . NAME ( ) ) assert NAME ( NAME ) > LIT # Find the test function profile NAME = None for NAME in NAME : if LIT in NAME : NAME = NAME . NAME [ NAME ] break assert NAME is not None assert NAME . NAME == LIT assert NAME . NAME > LIT assert NAME . NAME > LIT def NAME ( ) : LIT NAME = NAME ( NAME = { LIT : LIT } ) # Record metrics that should trigger alerts NAME . NAME ( LIT , LIT , LIT ) NAME . NAME ( LIT , LIT , LIT ) # Trigger alert check NAME . NAME ( ) # Check alert generation - look for slow_operation alerts NAME = [ NAME for NAME in NAME . NAME if LIT in NAME . NAME ] assert NAME ( NAME ) > LIT # Test alert levels using the dataclass constructor correctly NAME = NAME ( NAME = NAME . NAME , NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = NAME . NAME ( ) , NAME = LIT ) assert NAME . NAME == NAME . NAME assert LIT in NAME . NAME def NAME ( ) : LIT NAME = NAME ( ) # Record multiple metrics NAME = [ LIT , LIT , LIT , LIT , LIT ] for NAME , NAME in NAME ( NAME ) : NAME . NAME ( f\" metric_ { NAME } \" , NAME , LIT ) # Test statistics calculation using list comprehension NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] assert NAME ( NAME ) == LIT # Calculate basic statistics NAME = [ NAME . NAME for NAME in NAME ] NAME = NAME ( NAME ) / NAME ( NAME ) assert NAME == LIT def NAME ( ) : LIT # Test advanced monitor initialization NAME = NAME ( ) assert NAME . NAME == [ ] assert NAME . NAME == [ ] # Test performance tracking NAME ( LIT , LIT , LIT ) assert NAME ( NAME . NAME ) > LIT # Test dashboard generation NAME = NAME ( ) assert NAME ( NAME , NAME ) assert NAME ( NAME ) > LIT # Test system health score NAME = NAME ( ) assert NAME ( NAME , ( NAME , NAME ) ) assert LIT <= NAME <= LIT def NAME ( ) : LIT # Test configuration validation NAME = NAME ( ) assert NAME ( NAME , NAME ) assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME # Validation results should be well-formed assert NAME ( NAME [ LIT ] , ( NAME , NAME ) ) assert NAME ( NAME [ LIT ] , NAME ) assert NAME ( NAME [ LIT ] , NAME ) def NAME ( ) : LIT NAME = NAME ( ) # Create some objects to monitor memory NAME ( NAME ( LIT ) ) # Record memory metrics import NAME import NAME NAME = NAME . NAME ( NAME . NAME ( ) ) NAME = NAME . NAME ( ) . NAME / LIT / LIT NAME . NAME ( LIT , NAME , LIT ) # Check memory metric was recorded using list comprehension NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] assert NAME ( NAME ) > LIT NAME = NAME [ LIT ] assert NAME . NAME == LIT assert NAME . NAME > LIT def NAME ( ) : LIT NAME = NAME ( ) # Record some performance metrics that might trigger optimization suggestions NAME . NAME ( LIT , LIT , LIT ) NAME . NAME ( LIT , LIT , LIT ) NAME . NAME ( LIT , LIT , LIT ) # Test that metrics are recorded using list comprehensions NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] assert NAME ( NAME ) > LIT assert NAME ( NAME ) > LIT assert NAME ( NAME ) > LIT def NAME ( ) : LIT # Test API performance tracking NAME ( LIT , LIT , LIT ) # Test advanced monitoring start/stop NAME = NAME ( ) assert NAME ( NAME , NAME ) NAME = NAME ( ) assert NAME ( NAME , NAME ) def NAME ( ) : LIT NAME = NAME ( ) # Test with invalid metric values try : NAME . NAME ( LIT , LIT , LIT ) # Empty strings NAME . NAME ( LIT , NAME ( LIT ) , LIT ) # NaN value except NAME : pass # Should handle gracefully # Test profiling with function that raises exception @ NAME . NAME def NAME ( ) : raise NAME ( LIT ) try : NAME ( ) except NAME : pass # Expected # Function should still be in profiles despite error NAME = [ NAME for NAME in NAME . NAME if LIT in NAME ] assert NAME ( NAME ) > LIT def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME ( ) , f\" Function { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] ) , f\" Function { NAME } should be callable \" for NAME in NAME : assert NAME in NAME ( ) , f\" Class { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] , NAME ) , f\" { NAME } should be a class \" # Run all tests NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) return NAME . NAME ( )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "test_performance_monitor_initialization",
      "lineno": 974,
      "end_lineno": 988,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6fb229a4ffbf711418a9da2030a1826d9b24e02a",
      "simhash64": 7452151225961068051,
      "normalized": "def NAME ( ) : LIT # Test default initialization NAME = NAME ( ) assert NAME . NAME == LIT # Default value is 10000 assert NAME ( NAME . NAME ) == LIT assert NAME ( NAME . NAME ) == LIT assert NAME ( NAME . NAME ) == LIT assert NAME . NAME # Test custom initialization NAME = { LIT : LIT } NAME = NAME ( NAME = LIT , NAME = NAME ) assert NAME . NAME == LIT assert LIT in NAME . NAME"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "test_metric_recording_and_retrieval",
      "lineno": 990,
      "end_lineno": 1013,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 24,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9dde2600116c6c516f4026664ea690e0c66b39de",
      "simhash64": 7452151225961067539,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test basic metric recording NAME . NAME ( LIT , LIT , LIT ) assert NAME ( NAME . NAME ) == LIT NAME = NAME . NAME [ LIT ] assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME ( NAME . NAME , NAME ) # Test with metadata NAME = { LIT : LIT , LIT : LIT } NAME . NAME ( LIT , LIT , LIT , NAME = NAME ) assert NAME ( NAME . NAME ) == LIT assert NAME . NAME [ LIT ] . NAME == NAME # Test metric retrieval by category using list comprehension NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] assert NAME ( NAME ) == LIT assert NAME [ LIT ] . NAME == LIT"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "test_function_profiling",
      "lineno": 1015,
      "end_lineno": 1049,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 35,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "580502725740a4dce202ff4a932e20de026204ee",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test function profiling decorator @ NAME . NAME def NAME ( NAME , NAME = LIT ) : import NAME NAME . NAME ( LIT ) # Small sleep for timing return NAME + NAME # Call function multiple times NAME = NAME ( LIT ) NAME = NAME ( LIT , NAME = LIT ) NAME = NAME ( LIT ) assert NAME == LIT assert NAME == LIT assert NAME == LIT # Check profiling data NAME = NAME ( NAME . NAME . NAME ( ) ) assert NAME ( NAME ) > LIT # Find the test function profile NAME = None for NAME in NAME : if LIT in NAME : NAME = NAME . NAME [ NAME ] break assert NAME is not None assert NAME . NAME == LIT assert NAME . NAME > LIT assert NAME . NAME > LIT"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "test_function",
      "lineno": 1021,
      "end_lineno": 1024,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(x, y)",
      "fingerprint": "eb0e3d845c14d9f988eef642c22a2e0c75eea39d",
      "simhash64": 7488109654235841587,
      "normalized": "def NAME ( NAME , NAME = LIT ) : import NAME NAME . NAME ( LIT ) # Small sleep for timing return NAME + NAME"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "test_alert_generation",
      "lineno": 1051,
      "end_lineno": 1077,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 27,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6d7b64d57b8eca08bee7f48932f758a5e9f414dc",
      "simhash64": 7488320761542128699,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( NAME = { LIT : LIT } ) # Record metrics that should trigger alerts NAME . NAME ( LIT , LIT , LIT ) NAME . NAME ( LIT , LIT , LIT ) # Trigger alert check NAME . NAME ( ) # Check alert generation - look for slow_operation alerts NAME = [ NAME for NAME in NAME . NAME if LIT in NAME . NAME ] assert NAME ( NAME ) > LIT # Test alert levels using the dataclass constructor correctly NAME = NAME ( NAME = NAME . NAME , NAME = LIT , NAME = LIT , NAME = LIT , NAME = LIT , NAME = NAME . NAME ( ) , NAME = LIT ) assert NAME . NAME == NAME . NAME assert LIT in NAME . NAME"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "test_performance_statistics",
      "lineno": 1079,
      "end_lineno": 1095,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "273e141137f69a945c7fb0a18f10f86c5d30c14e",
      "simhash64": 7488180022980031539,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Record multiple metrics NAME = [ LIT , LIT , LIT , LIT , LIT ] for NAME , NAME in NAME ( NAME ) : NAME . NAME ( f\" metric_ { NAME } \" , NAME , LIT ) # Test statistics calculation using list comprehension NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] assert NAME ( NAME ) == LIT # Calculate basic statistics NAME = [ NAME . NAME for NAME in NAME ] NAME = NAME ( NAME ) / NAME ( NAME ) assert NAME == LIT"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "test_advanced_monitoring",
      "lineno": 1097,
      "end_lineno": 1116,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b93ed9c44aaad3e00c3ccd94f84ce48e28cd1508",
      "simhash64": 7488179988620293171,
      "normalized": "def NAME ( ) : LIT # Test advanced monitor initialization NAME = NAME ( ) assert NAME . NAME == [ ] assert NAME . NAME == [ ] # Test performance tracking NAME ( LIT , LIT , LIT ) assert NAME ( NAME . NAME ) > LIT # Test dashboard generation NAME = NAME ( ) assert NAME ( NAME , NAME ) assert NAME ( NAME ) > LIT # Test system health score NAME = NAME ( ) assert NAME ( NAME , ( NAME , NAME ) ) assert LIT <= NAME <= LIT"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "test_configuration_validation",
      "lineno": 1118,
      "end_lineno": 1131,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "74bd77196844d7852ec7a89dd5b8fb3efe0312cb",
      "simhash64": 7488180023248458867,
      "normalized": "def NAME ( ) : LIT # Test configuration validation NAME = NAME ( ) assert NAME ( NAME , NAME ) assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME # Validation results should be well-formed assert NAME ( NAME [ LIT ] , ( NAME , NAME ) ) assert NAME ( NAME [ LIT ] , NAME ) assert NAME ( NAME [ LIT ] , NAME )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "test_memory_monitoring",
      "lineno": 1133,
      "end_lineno": 1155,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 23,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "17158f74cad62af2074efb0a1776f023c08e8f52",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Create some objects to monitor memory NAME ( NAME ( LIT ) ) # Record memory metrics import NAME import NAME NAME = NAME . NAME ( NAME . NAME ( ) ) NAME = NAME . NAME ( ) . NAME / LIT / LIT NAME . NAME ( LIT , NAME , LIT ) # Check memory metric was recorded using list comprehension NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] assert NAME ( NAME ) > LIT NAME = NAME [ LIT ] assert NAME . NAME == LIT assert NAME . NAME > LIT"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "test_performance_optimization",
      "lineno": 1157,
      "end_lineno": 1173,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "e3720bced8d9810a0cb908b259e3e65889854488",
      "simhash64": 7488180023047140387,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Record some performance metrics that might trigger optimization suggestions NAME . NAME ( LIT , LIT , LIT ) NAME . NAME ( LIT , LIT , LIT ) NAME . NAME ( LIT , LIT , LIT ) # Test that metrics are recorded using list comprehensions NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] NAME = [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] assert NAME ( NAME ) > LIT assert NAME ( NAME ) > LIT assert NAME ( NAME ) > LIT"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "test_global_performance_functions",
      "lineno": 1175,
      "end_lineno": 1185,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "8fb13c4ce2adebe24ae6cb60ef530537030f932f",
      "simhash64": 7488320727183954987,
      "normalized": "def NAME ( ) : LIT # Test API performance tracking NAME ( LIT , LIT , LIT ) # Test advanced monitoring start/stop NAME = NAME ( ) assert NAME ( NAME , NAME ) NAME = NAME ( ) assert NAME ( NAME , NAME )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "test_error_handling",
      "lineno": 1187,
      "end_lineno": 1210,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6b943bbbf0d9f12a4a668fe9eb76a5f5886568a4",
      "simhash64": 7488355911622112303,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test with invalid metric values try : NAME . NAME ( LIT , LIT , LIT ) # Empty strings NAME . NAME ( LIT , NAME ( LIT ) , LIT ) # NaN value except NAME : pass # Should handle gracefully # Test profiling with function that raises exception @ NAME . NAME def NAME ( ) : raise NAME ( LIT ) try : NAME ( ) except NAME : pass # Expected # Function should still be in profiles despite error NAME = [ NAME for NAME in NAME . NAME if LIT in NAME ] assert NAME ( NAME ) > LIT"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "error_function",
      "lineno": 1200,
      "end_lineno": 1201,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "49d0d0e75e4661eae84ab2825c7082a05f8e6a31",
      "simhash64": 9221670576702002731,
      "normalized": "def NAME ( ) : raise NAME ( LIT )"
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "test_function_availability",
      "lineno": 1212,
      "end_lineno": 1238,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 27,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ed8807ecf2998c5b5a75a9564ff75bd9d92b3291",
      "simhash64": 7452291964518962219,
      "normalized": "def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME ( ) , f\" Function { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] ) , f\" Function { NAME } should be callable \" for NAME in NAME : assert NAME in NAME ( ) , f\" Class { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] , NAME ) , f\" { NAME } should be a class \""
    },
    {
      "module_path": "performance_monitor.py",
      "qualname": "_run_basic_tests",
      "lineno": 1340,
      "end_lineno": 1355,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "1c1cd52c63d493602408f1edf1bff163f53c5a3f",
      "simhash64": 7451728980209997355,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Test basic functionality NAME = NAME ( ) NAME . NAME ( LIT , LIT , LIT ) assert NAME ( NAME . NAME ) == LIT # Test API tracking NAME ( LIT , LIT , LIT ) NAME ( LIT ) return True except NAME as NAME : NAME ( f\" \u274c Basic tests failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "SmartQueryOptimizer.__init__",
      "lineno": 61,
      "end_lineno": 65,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "7fb1f61d20fb94ca02e6eec1a8d4395b8706f263",
      "simhash64": 7451764199008932875,
      "normalized": "def NAME ( NAME ) : NAME . NAME = { } NAME . NAME = NAME ( NAME = LIT ) NAME . NAME = NAME ( lambda : { LIT : LIT , LIT : LIT , LIT : LIT } ) NAME . NAME = NAME . NAME ( )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "SmartQueryOptimizer.track_query",
      "lineno": 67,
      "end_lineno": 82,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, query, execution_time)",
      "fingerprint": "cc986471b843206ffd66b2c3a49b7c3d5a390315",
      "simhash64": 7452151226028176387,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> None : LIT with NAME . NAME : # Update statistics NAME = NAME . NAME [ NAME ] NAME [ LIT ] += LIT NAME [ LIT ] += NAME NAME [ LIT ] = NAME [ LIT ] / NAME [ LIT ] # Track slow queries (> 100ms) if NAME > LIT : NAME . NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME . NAME ( ) } )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "SmartQueryOptimizer.get_optimization_suggestions",
      "lineno": 84,
      "end_lineno": 99,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 16,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "4aa29d08730fdc39ec15b688579cae5191f0b611",
      "simhash64": 7452151226028176419,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] with NAME . NAME : # Find frequently run slow queries for NAME , NAME in NAME . NAME . NAME ( ) : if NAME [ LIT ] > LIT and NAME [ LIT ] > LIT : # >50ms average, >5 executions NAME . NAME ( { LIT : NAME [ : LIT ] + LIT if NAME ( NAME ) > LIT else NAME , LIT : NAME [ LIT ] * LIT , LIT : NAME [ LIT ] , LIT : LIT } ) return NAME ( NAME , NAME = lambda NAME : NAME [ LIT ] , NAME = True )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "SmartQueryOptimizer.optimize_common_patterns",
      "lineno": 101,
      "end_lineno": 129,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 29,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "a1a5fd64c007442544d958b2ed3213a417e14022",
      "simhash64": 7452221595778978843,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : # Analyze query patterns and suggest optimizations NAME = NAME . NAME ( ) NAME = NAME ( NAME ) if NAME > LIT : NAME . NAME ( f\" Identified { NAME } queries for optimization \" ) return NAME ( NAME = True , NAME = LIT , NAME = NAME ( LIT , NAME * LIT ) , NAME = f\" Identified { NAME } optimization opportunities \" ) return NAME ( NAME = True , NAME = LIT , NAME = LIT , NAME = LIT ) except NAME as NAME : return NAME ( NAME = False , NAME = LIT , NAME = f\" Query optimization error: { NAME } \" )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "MemoryPressureMonitor.__init__",
      "lineno": 135,
      "end_lineno": 139,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, pressure_threshold)",
      "fingerprint": "2c0a515fa7282c9f86c0e66e40ffe00bac733d16",
      "simhash64": 7488109654302962707,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) : NAME . NAME = NAME NAME . NAME = False NAME . NAME = [ ] NAME . NAME = NAME . NAME ( )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "MemoryPressureMonitor.get_memory_info",
      "lineno": 141,
      "end_lineno": 152,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "f25815f0304bc69063a79c4cb71a39b5385a28fe",
      "simhash64": 7451588276074746883,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) return { LIT : NAME . NAME / LIT / LIT , LIT : NAME . NAME / LIT / LIT , LIT : NAME , LIT : NAME . NAME ( ) . NAME / LIT / LIT }"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "MemoryPressureMonitor.is_memory_pressure_high",
      "lineno": 154,
      "end_lineno": 157,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "02ee6ba77ce1cef251b975a84022406aed3059aa",
      "simhash64": 7488109654235849731,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) return NAME [ LIT ] > NAME . NAME"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "MemoryPressureMonitor.optimize_memory_usage",
      "lineno": 159,
      "end_lineno": 205,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 47,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "7c5dee416672f0dcabce70d539f92537bf0bc7d1",
      "simhash64": 7452151227101910059,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : NAME = NAME . NAME ( ) # Force garbage collection NAME = NAME . NAME ( ) # Additional memory optimizations if NAME ( NAME , LIT ) : # Adjust garbage collection thresholds for better performance NAME . NAME ( LIT , LIT , LIT ) # More aggressive GC # Clear any large cached objects if memory pressure is very high if NAME [ LIT ] > LIT : # Clear various internal caches if NAME ( NAME , LIT ) : NAME . NAME ( ) NAME = NAME . NAME ( ) NAME = NAME ( LIT , NAME [ LIT ] - NAME [ LIT ] ) with NAME . NAME : NAME . NAME . NAME ( { LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , LIT : NAME [ LIT ] , LIT : NAME [ LIT ] } ) NAME = NAME ( LIT , NAME [ LIT ] - NAME [ LIT ] ) return NAME ( NAME = True , NAME = LIT , NAME = NAME , NAME = NAME , NAME = f\" Collected { NAME } objects, saved { NAME : .1f } MB \" ) except NAME as NAME : return NAME ( NAME = False , NAME = LIT , NAME = f\" Memory optimization error: { NAME } \" )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "APIBatchCoordinator.__init__",
      "lineno": 211,
      "end_lineno": 216,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, batch_size, batch_timeout)",
      "fingerprint": "469d1afc8854cb4ea6f1ae3a6c832d744652904d",
      "simhash64": 7452221595846087707,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , NAME : NAME = LIT ) : NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME ( NAME ) NAME . NAME = { LIT : LIT , LIT : LIT , LIT : LIT } NAME . NAME = NAME . NAME ( )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "APIBatchCoordinator.add_to_batch",
      "lineno": 218,
      "end_lineno": 229,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, request_type, request_data)",
      "fingerprint": "0b3eb22b7f3660c40c2fb21446aa68e0ebdddff8",
      "simhash64": 7452080857216889875,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT with NAME . NAME : # Use high precision timestamp to ensure unique batch IDs NAME = NAME . NAME ( ) NAME = f\" { NAME } _ { NAME : .6f } _ { NAME ( NAME . NAME [ NAME ] ) } \" NAME . NAME [ NAME ] . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME } ) return NAME"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "APIBatchCoordinator.should_execute_batch",
      "lineno": 231,
      "end_lineno": 243,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 13,
      "tags": [
        "impure",
        "network",
        "time",
        "size:small"
      ],
      "signature": "(self, request_type)",
      "fingerprint": "fde1d35018bf31cd603fe044f1be0856ad7e09a5",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT with NAME . NAME : NAME = NAME . NAME [ NAME ] if not NAME : return False # Execute if batch is full or oldest request is past timeout if NAME ( NAME ) >= NAME . NAME : return True NAME = NAME [ LIT ] [ LIT ] return NAME . NAME ( ) - NAME >= NAME . NAME"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "APIBatchCoordinator.get_batch_for_execution",
      "lineno": 245,
      "end_lineno": 257,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "impure",
        "network",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self, request_type)",
      "fingerprint": "977efaf8c4be5ca0747e132caec74feb6c9d1c68",
      "simhash64": 7452151226028176451,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT with NAME . NAME : NAME = NAME . NAME [ NAME ] [ : NAME . NAME ] NAME . NAME [ NAME ] = NAME . NAME [ NAME ] [ NAME . NAME : ] # Update statistics NAME . NAME [ LIT ] += LIT NAME . NAME [ LIT ] += NAME ( NAME ) # Estimate time saved by batching (assume 100ms per individual request overhead) NAME . NAME [ LIT ] += NAME ( LIT , ( NAME ( NAME ) - LIT ) * LIT ) return NAME"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "APIBatchCoordinator.get_optimization_stats",
      "lineno": 259,
      "end_lineno": 279,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 21,
      "tags": [
        "impure",
        "network",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "329d583cb7306d2fcfb15829c3ad5cc2b9216477",
      "simhash64": 7452151226028168211,
      "normalized": "def NAME ( NAME ) -> NAME : LIT with NAME . NAME : if NAME . NAME [ LIT ] > LIT : NAME = NAME . NAME [ LIT ] / NAME . NAME [ LIT ] NAME = NAME ( LIT , ( NAME / NAME . NAME ) * LIT ) return NAME ( NAME = True , NAME = LIT , NAME = NAME / LIT , # Convert to improvement percentage NAME = NAME . NAME [ LIT ] , NAME = f\" Batched { NAME . NAME [ LIT ] } requests into { NAME . NAME [ LIT ] } batches \" ) return NAME ( NAME = True , NAME = LIT , NAME = LIT , NAME = LIT )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "ModuleLoadOptimizer.__init__",
      "lineno": 285,
      "end_lineno": 288,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "d2efe3b5c4367b9dd633aff83d280096b179f6d5",
      "simhash64": 8641066347509752851,
      "normalized": "def NAME ( NAME ) : NAME . NAME = { } NAME . NAME = NAME ( ) NAME . NAME = NAME . NAME ( )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "ModuleLoadOptimizer.get_cached_import",
      "lineno": 292,
      "end_lineno": 297,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(module_name)",
      "fingerprint": "e68c5d2d0ec56ced36404e5825c1a544943c4be8",
      "simhash64": 8645174085429400619,
      "normalized": "def NAME ( NAME : NAME ) : LIT try : return NAME ( NAME ) except NAME : return None"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "ModuleLoadOptimizer.track_module_load",
      "lineno": 299,
      "end_lineno": 304,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 6,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(self, module_name, load_time)",
      "fingerprint": "ffb513b3eb4208cb2a7836eeb5ba5ee7f1d537a9",
      "simhash64": 7488180022980031571,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> None : LIT with NAME . NAME : if NAME not in NAME . NAME : NAME . NAME [ NAME ] = [ ] NAME . NAME [ NAME ] . NAME ( NAME )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "ModuleLoadOptimizer.optimize_slow_imports",
      "lineno": 306,
      "end_lineno": 343,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 8,
      "loc": 38,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "6c4ca73039638d0bc2b848b50392f0605ad8c457",
      "simhash64": 7488109654235845659,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : with NAME . NAME : NAME = [ ] for NAME , NAME in NAME . NAME . NAME ( ) : NAME = NAME ( NAME ) / NAME ( NAME ) if NAME > LIT and NAME not in NAME . NAME : # >100ms average NAME . NAME ( ( NAME , NAME ) ) NAME . NAME . NAME ( NAME ) if NAME : # Apply optimizations for slow modules NAME = NAME ( NAME ) NAME = NAME ( NAME for NAME , NAME in NAME ) * LIT # Estimate 20% improvement NAME . NAME ( f\" Optimized { NAME } slow-loading modules \" ) return NAME ( NAME = True , NAME = LIT , NAME = NAME * LIT , NAME = NAME * LIT , NAME = f\" Optimized { NAME } slow-loading modules \" ) return NAME ( NAME = True , NAME = LIT , NAME = LIT , NAME = LIT ) except NAME as NAME : return NAME ( NAME = False , NAME = LIT , NAME = f\" Module optimization error: { NAME } \" )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "PerformanceOptimizer.__init__",
      "lineno": 349,
      "end_lineno": 359,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "time",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "1e60eb83c81c99c6befeb930b0a785093782d6ee",
      "simhash64": 8641066347509752851,
      "normalized": "def NAME ( NAME ) : NAME . NAME = NAME ( ) NAME . NAME = NAME ( ) NAME . NAME = NAME ( ) NAME . NAME = NAME ( ) NAME . NAME = [ ] NAME . NAME = NAME . NAME ( ) NAME . NAME = NAME . NAME ( ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "PerformanceOptimizer.run_comprehensive_optimization",
      "lineno": 361,
      "end_lineno": 396,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 36,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "18f0cbf6d6bd655597c722d331bdb58e99bb6fa6",
      "simhash64": 7488144842902905875,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME = [ ] NAME . NAME ( LIT ) # 1. Memory optimization (if needed) if NAME . NAME . NAME ( ) : NAME . NAME ( LIT ) NAME = NAME . NAME . NAME ( ) NAME . NAME ( NAME ) else : # Light memory optimization NAME = NAME . NAME . NAME ( ) NAME . NAME ( NAME ) # 2. Query optimization NAME = NAME . NAME . NAME ( ) NAME . NAME ( NAME ) # 3. API batching optimization NAME = NAME . NAME . NAME ( ) NAME . NAME ( NAME ) # 4. Module loading optimization NAME = NAME . NAME . NAME ( ) NAME . NAME ( NAME ) # Store results NAME . NAME . NAME ( NAME ) NAME . NAME = NAME . NAME ( ) NAME = [ NAME for NAME in NAME if NAME . NAME ] NAME . NAME ( f\" Completed optimization: { NAME ( NAME ) } / { NAME ( NAME ) } successful \" ) return NAME"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "PerformanceOptimizer.get_performance_report",
      "lineno": 398,
      "end_lineno": 451,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 12,
      "loc": 54,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "164266a1a81e41515ec3e629eb60146cf30d1fc0",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) - NAME . NAME NAME = NAME . NAME . NAME ( ) NAME = NAME ( NAME . NAME for NAME in NAME . NAME if NAME . NAME ) NAME = NAME ( NAME . NAME for NAME in NAME . NAME if NAME . NAME ) NAME = NAME ( NAME . NAME for NAME in NAME . NAME if NAME . NAME ) NAME = NAME ( [ NAME for NAME in NAME . NAME if NAME . NAME ] ) NAME = NAME ( [ NAME for NAME in NAME . NAME if not NAME . NAME ] ) NAME = f\"\"\" \ud83d\ude80 PERFORMANCE OPTIMIZER REPORT - PRIORITY 4 IMPLEMENTATION\n============================================================\n\n\ud83d\udcca SYSTEM STATUS:\n   Uptime: { NAME : .1f } s\n   Memory Usage: { NAME [ LIT ] : .1f } % ( { NAME [ LIT ] : .1f } MB)\n   Available Memory: { NAME [ LIT ] : .1f } MB\n   Memory Pressure: { LIT if NAME [ LIT ] > LIT else LIT } \ud83d\udca1 OPTIMIZATION SUMMARY:\n   Total Optimizations Applied: { NAME } Failed Optimizations: { NAME } Total Performance Improvement: { NAME : .1f } %\n   Total Memory Saved: { NAME : .1f } MB\n   Total Time Saved: { NAME : .0f } ms\n\n\ud83c\udfaf OPTIMIZATION DETAILS: \"\"\" # Add details for each optimization type NAME = NAME ( NAME ) for NAME in NAME . NAME : if NAME . NAME : NAME [ NAME . NAME ] . NAME ( NAME ) for NAME , NAME in NAME . NAME ( ) : NAME = NAME ( NAME ) NAME = NAME ( NAME . NAME for NAME in NAME ) / NAME NAME += f\" \u2022 { NAME . NAME ( LIT , LIT ) . NAME ( ) } : { NAME } optimizations, { NAME : .1f } % avg improvement\\n \" # Query optimization suggestions NAME = NAME . NAME . NAME ( ) if NAME : NAME += LIT for NAME , NAME in NAME ( NAME [ : LIT ] ) : # Top 3 NAME += f\" { NAME + LIT } . Query (avg { NAME [ LIT ] : .1f } ms): { NAME [ LIT ] } \\n \" NAME += LIT NAME += LIT return NAME"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "get_global_optimizer",
      "lineno": 461,
      "end_lineno": 470,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 10,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "533c444ed1d5b686c3f2dd079fc8c210ef7e29c2",
      "simhash64": 8641277999204701187,
      "normalized": "def NAME ( ) -> NAME : LIT global NAME if NAME is None : with NAME : if NAME is None : NAME = NAME ( ) return NAME"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "optimize_performance",
      "lineno": 472,
      "end_lineno": 475,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "c187f34327296a708d853ec2ae24d1a5e6940153",
      "simhash64": 7488215212721353763,
      "normalized": "def NAME ( ) -> NAME [ NAME ] : LIT NAME = NAME ( ) return NAME . NAME ( )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "get_performance_report",
      "lineno": 477,
      "end_lineno": 480,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "c4dbf5dbdad35d21d46ec824cf4c384ec5143154",
      "simhash64": 8640573733015028771,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( ) return NAME . NAME ( )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "track_query_performance",
      "lineno": 482,
      "end_lineno": 485,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(query, execution_time)",
      "fingerprint": "af2d02408ecade798fa7ca148e50ef20ed06d186",
      "simhash64": 7488180024053769219,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT NAME = NAME ( ) NAME . NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "monitor_memory_pressure",
      "lineno": 487,
      "end_lineno": 490,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "af9eef69feef150e73ad8fd19bb859b290457471",
      "simhash64": 8640573767374242819,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( ) return NAME . NAME . NAME ( )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "optimize_on_high_usage",
      "lineno": 497,
      "end_lineno": 519,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 23,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(memory_threshold)",
      "fingerprint": "9831b805880c86bfe29c517f972ce4f4f8926a80",
      "simhash64": 7488144843976639491,
      "normalized": "def NAME ( NAME : NAME = LIT ) : LIT def NAME ( NAME ) : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : # Check memory pressure before execution if NAME ( ) : NAME . NAME ( LIT ) NAME ( ) # Execute function and track performance NAME = NAME . NAME ( ) NAME = NAME ( * NAME , ** NAME ) NAME = NAME . NAME ( ) - NAME # Track slow functions if NAME > LIT : # >100ms NAME = NAME ( ) NAME . NAME . NAME ( NAME . NAME , NAME ) return NAME return NAME return NAME"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "decorator",
      "lineno": 499,
      "end_lineno": 518,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 20,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(func)",
      "fingerprint": "3aacaa558c58ad3d04b76667a0177d18a8bc17a5",
      "simhash64": 7488144842902905859,
      "normalized": "def NAME ( NAME ) : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : # Check memory pressure before execution if NAME ( ) : NAME . NAME ( LIT ) NAME ( ) # Execute function and track performance NAME = NAME . NAME ( ) NAME = NAME ( * NAME , ** NAME ) NAME = NAME . NAME ( ) - NAME # Track slow functions if NAME > LIT : # >100ms NAME = NAME ( ) NAME . NAME . NAME ( NAME . NAME , NAME ) return NAME return NAME"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "wrapper",
      "lineno": 501,
      "end_lineno": 517,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "88cbf67743128147bd075f3860ff7c7b7333a810",
      "simhash64": 7488144842904478723,
      "normalized": "def NAME ( * NAME , ** NAME ) : # Check memory pressure before execution if NAME ( ) : NAME . NAME ( LIT ) NAME ( ) # Execute function and track performance NAME = NAME . NAME ( ) NAME = NAME ( * NAME , ** NAME ) NAME = NAME . NAME ( ) - NAME # Track slow functions if NAME > LIT : # >100ms NAME = NAME ( ) NAME . NAME . NAME ( NAME . NAME , NAME ) return NAME"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 530,
      "end_lineno": 873,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 9,
      "loc": 344,
      "tags": [
        "impure",
        "network",
        "logging",
        "time",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "aa15e9baa464b30e9c5f93550ba2b11b4de46af1",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( ) -> NAME : LIT try : from NAME import NAME # Using TestSuite only except NAME : NAME ( LIT ) return NAME ( ) NAME = NAME ( LIT , LIT ) def NAME ( ) : LIT NAME = NAME ( ) # Track some test queries NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) # Verify query tracking assert NAME ( NAME . NAME ) > LIT # Get optimization suggestions NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) # Test optimization NAME = NAME . NAME ( ) assert NAME . NAME assert NAME . NAME == LIT def NAME ( ) : LIT NAME = NAME ( NAME = LIT ) # Low threshold for testing # Get memory info NAME = NAME . NAME ( ) assert LIT in NAME assert LIT in NAME assert NAME [ LIT ] > LIT # Test memory optimization NAME = NAME . NAME ( ) assert NAME . NAME assert NAME . NAME == LIT assert NAME . NAME >= LIT def NAME ( ) : LIT NAME = NAME ( NAME = LIT , NAME = LIT ) # Add requests to batch NAME = NAME . NAME ( LIT , { LIT : LIT } ) NAME = NAME . NAME ( LIT , { LIT : LIT } ) NAME . NAME ( LIT , { LIT : LIT } ) assert NAME != NAME assert NAME ( NAME , NAME ) # Check if batch should execute NAME = NAME . NAME ( LIT ) assert NAME # Batch size reached # Get batch for execution NAME = NAME . NAME ( LIT ) assert NAME ( NAME ) == LIT # Get statistics NAME = NAME . NAME ( ) assert NAME . NAME assert NAME . NAME == LIT def NAME ( ) : LIT NAME = NAME ( ) # Track some module loads NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) # Slow module NAME . NAME ( LIT , LIT ) # Slow module again # Verify tracking using load_times attribute assert NAME ( NAME . NAME ) > LIT # Test optimization NAME = NAME . NAME ( ) assert NAME . NAME assert NAME . NAME == LIT assert NAME ( NAME . NAME , ( NAME , NAME ) ) def NAME ( ) : LIT NAME = NAME ( ) # Run comprehensive optimization NAME = NAME . NAME ( ) assert NAME ( NAME ) > LIT # Check that we have results for different optimization types NAME = { NAME . NAME for NAME in NAME } NAME = { LIT , LIT , LIT , LIT } assert NAME == NAME # Verify all results are OptimizationResult objects for NAME in NAME : assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Test performance report NAME = NAME . NAME ( ) assert LIT in NAME assert LIT in NAME def NAME ( ) : LIT # Test global optimization NAME = NAME ( ) assert NAME ( NAME , NAME ) assert NAME ( NAME ) > LIT # Verify all results are successful OptimizationResult objects for NAME in NAME : assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Test performance report NAME = NAME ( ) assert NAME ( NAME , NAME ) assert LIT in NAME # Test query tracking NAME ( LIT , LIT ) # Test memory monitoring NAME = NAME ( ) assert NAME ( NAME , NAME ) def NAME ( ) : LIT @ NAME ( NAME = LIT ) # Very low threshold for testing def NAME ( ) : import NAME NAME . NAME ( LIT ) # Small delay return LIT NAME = NAME ( ) assert NAME == LIT def NAME ( ) : LIT NAME = NAME ( ) # Test metric collection by running optimization which collects metrics NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) assert NAME ( NAME ) > LIT # Verify result structure (which represents our metrics) for NAME in NAME : assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME . NAME , ( NAME , NAME ) ) def NAME ( ) : LIT NAME = NAME ( ) # Test different optimization techniques NAME . NAME ( ) [ LIT ] # Force garbage collection import NAME NAME . NAME ( ) # Test memory monitoring NAME = NAME . NAME ( ) [ LIT ] assert NAME ( NAME , ( NAME , NAME ) ) assert NAME > LIT def NAME ( ) : LIT NAME = NAME ( ) # Track patterns NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) # Test pattern analysis NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) # Test common pattern optimization NAME = NAME . NAME ( ) assert NAME . NAME def NAME ( ) : LIT NAME = NAME ( ) # Test with invalid inputs try : # This should handle errors gracefully NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) except NAME as NAME : # Should not raise unhandled exceptions raise NAME ( f\" Optimization should handle errors gracefully: { NAME } \" ) def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT ] NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME ( ) , f\" Function { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] ) , f\" Function { NAME } should be callable \" for NAME in NAME : assert NAME in NAME ( ) , f\" Class { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] , NAME ) , f\" { NAME } should be a class \" # Run all tests NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) return NAME . NAME ( )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "test_query_optimizer_functionality",
      "lineno": 548,
      "end_lineno": 567,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "45e9842f88f9b2a5b030363a97e87a74919c7d88",
      "simhash64": 7488215207352120355,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Track some test queries NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) # Verify query tracking assert NAME ( NAME . NAME ) > LIT # Get optimization suggestions NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) # Test optimization NAME = NAME . NAME ( ) assert NAME . NAME assert NAME . NAME == LIT"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "test_memory_pressure_monitoring",
      "lineno": 569,
      "end_lineno": 583,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "0625577d16834aaa83305582e6d4a57b6aa73461",
      "simhash64": 7488180023047140467,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( NAME = LIT ) # Low threshold for testing # Get memory info NAME = NAME . NAME ( ) assert LIT in NAME assert LIT in NAME assert NAME [ LIT ] > LIT # Test memory optimization NAME = NAME . NAME ( ) assert NAME . NAME assert NAME . NAME == LIT assert NAME . NAME >= LIT"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "test_api_batch_coordination",
      "lineno": 585,
      "end_lineno": 608,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 24,
      "tags": [
        "impure",
        "network",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ebc6f699c6211640ac8d8277ac24309da4138aa6",
      "simhash64": 7452291964523156539,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( NAME = LIT , NAME = LIT ) # Add requests to batch NAME = NAME . NAME ( LIT , { LIT : LIT } ) NAME = NAME . NAME ( LIT , { LIT : LIT } ) NAME . NAME ( LIT , { LIT : LIT } ) assert NAME != NAME assert NAME ( NAME , NAME ) # Check if batch should execute NAME = NAME . NAME ( LIT ) assert NAME # Batch size reached # Get batch for execution NAME = NAME . NAME ( LIT ) assert NAME ( NAME ) == LIT # Get statistics NAME = NAME . NAME ( ) assert NAME . NAME assert NAME . NAME == LIT"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "test_module_load_optimization",
      "lineno": 610,
      "end_lineno": 626,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f1d178e56a8de302d63520d8af0868eab794a645",
      "simhash64": 7451623460379735075,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Track some module loads NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) # Slow module NAME . NAME ( LIT , LIT ) # Slow module again # Verify tracking using load_times attribute assert NAME ( NAME . NAME ) > LIT # Test optimization NAME = NAME . NAME ( ) assert NAME . NAME assert NAME . NAME == LIT assert NAME ( NAME . NAME , ( NAME , NAME ) )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "test_comprehensive_performance_optimization",
      "lineno": 628,
      "end_lineno": 650,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "54c2cf710c2a4405061f32d0227b8caabe1949bf",
      "simhash64": 7488320761542120507,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Run comprehensive optimization NAME = NAME . NAME ( ) assert NAME ( NAME ) > LIT # Check that we have results for different optimization types NAME = { NAME . NAME for NAME in NAME } NAME = { LIT , LIT , LIT , LIT } assert NAME == NAME # Verify all results are OptimizationResult objects for NAME in NAME : assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Test performance report NAME = NAME . NAME ( ) assert LIT in NAME assert LIT in NAME"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "test_global_optimization_functions",
      "lineno": 652,
      "end_lineno": 674,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ff72248f78b0ee5e020058387a01bc3f8eef3666",
      "simhash64": 7488355911556043899,
      "normalized": "def NAME ( ) : LIT # Test global optimization NAME = NAME ( ) assert NAME ( NAME , NAME ) assert NAME ( NAME ) > LIT # Verify all results are successful OptimizationResult objects for NAME in NAME : assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Test performance report NAME = NAME ( ) assert NAME ( NAME , NAME ) assert LIT in NAME # Test query tracking NAME ( LIT , LIT ) # Test memory monitoring NAME = NAME ( ) assert NAME ( NAME , NAME )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "test_optimization_decorators",
      "lineno": 676,
      "end_lineno": 685,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "91e8420dfae02b145025691be012fb3274782192",
      "simhash64": 7488355911621575739,
      "normalized": "def NAME ( ) : LIT @ NAME ( NAME = LIT ) # Very low threshold for testing def NAME ( ) : import NAME NAME . NAME ( LIT ) # Small delay return LIT NAME = NAME ( ) assert NAME == LIT"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "test_function",
      "lineno": 679,
      "end_lineno": 682,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "6d9ff145f556ec1449dbbb949e092501bd18fe01",
      "simhash64": 14409684851448788091,
      "normalized": "def NAME ( ) : import NAME NAME . NAME ( LIT ) # Small delay return LIT"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "test_performance_metrics",
      "lineno": 687,
      "end_lineno": 701,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "54ffa76a295c27fe34972e8678474fbe5a0328f0",
      "simhash64": 7487617038666871851,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test metric collection by running optimization which collects metrics NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) assert NAME ( NAME ) > LIT # Verify result structure (which represents our metrics) for NAME in NAME : assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME . NAME , ( NAME , NAME ) )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "test_memory_optimization_techniques",
      "lineno": 703,
      "end_lineno": 717,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "bdc29a559a0fb56d83502d3062552a397540c81e",
      "simhash64": 7488179989762192439,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test different optimization techniques NAME . NAME ( ) [ LIT ] # Force garbage collection import NAME NAME . NAME ( ) # Test memory monitoring NAME = NAME . NAME ( ) [ LIT ] assert NAME ( NAME , ( NAME , NAME ) ) assert NAME > LIT"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "test_query_optimization_patterns",
      "lineno": 719,
      "end_lineno": 734,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "fa7a512da43d9f05cc513e7d5b47117746bfadad",
      "simhash64": 7488215208425853987,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Track patterns NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT , LIT ) # Test pattern analysis NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) # Test common pattern optimization NAME = NAME . NAME ( ) assert NAME . NAME"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "test_error_handling_and_resilience",
      "lineno": 736,
      "end_lineno": 747,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "db606193860be40b99259227df28e933a1d06ed5",
      "simhash64": 8641136677600793619,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( ) # Test with invalid inputs try : # This should handle errors gracefully NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) except NAME as NAME : # Should not raise unhandled exceptions raise NAME ( f\" Optimization should handle errors gracefully: { NAME } \" )"
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "test_function_availability",
      "lineno": 749,
      "end_lineno": 774,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2eba3b115f45edc39251da428e727a7320894889",
      "simhash64": 7452291964518962235,
      "normalized": "def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT ] NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME ( ) , f\" Function { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] ) , f\" Function { NAME } should be callable \" for NAME in NAME : assert NAME in NAME ( ) , f\" Class { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] , NAME ) , f\" { NAME } should be a class \""
    },
    {
      "module_path": "performance_orchestrator.py",
      "qualname": "_run_basic_tests",
      "lineno": 876,
      "end_lineno": 892,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7e8a8f320c3409114a11d777e938d88e376a0a36",
      "simhash64": 8641136678672962683,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Test basic functionality NAME = NAME ( ) NAME = NAME . NAME ( ) assert NAME ( NAME ) > LIT # Test global functions NAME = NAME ( ) assert NAME ( NAME , NAME ) NAME ( LIT ) return True except NAME as NAME : NAME ( f\" \u274c Basic tests failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_csrf_token_caching",
      "lineno": 32,
      "end_lineno": 63,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 32,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "0e9f76064c5fea606a902ef437b751ea2d109a9c",
      "simhash64": 8641066343214781459,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) # Mock session manager with caching NAME = NAME ( ) NAME . NAME = LIT NAME . NAME = NAME . NAME ( ) NAME . NAME = LIT # 5 minutes def NAME ( ) -> NAME : return ( NAME . NAME ( ) - NAME . NAME ) < NAME . NAME NAME . NAME = NAME # Test cached retrieval (should be fast) NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : if NAME . NAME ( ) : pass NAME = NAME . NAME ( ) - NAME # Test mock WebDriver retrieval (slower) NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : # Simulate WebDriver call overhead NAME . NAME ( LIT ) # 1ms overhead per call NAME = NAME . NAME ( ) - NAME NAME = NAME / NAME if NAME > LIT else NAME ( LIT ) NAME . NAME ( f\" \u2705 CSRF caching: { NAME : .1f } x faster ( { NAME : .3f } s vs { NAME : .3f } s) \" ) return NAME > LIT # Should be much faster"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "_is_csrf_token_valid",
      "lineno": 42,
      "end_lineno": 43,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "time",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "1f3ec619b2b3e922e7d06fc8d7625932ca727717",
      "simhash64": 8640573766837380099,
      "normalized": "def NAME ( ) -> NAME : return ( NAME . NAME ( ) - NAME . NAME ) < NAME . NAME"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_rate_limiter_caching",
      "lineno": 66,
      "end_lineno": 104,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 39,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "f88fdd1f7bfaf77d65b9c3620ddd9880aa5e0a18",
      "simhash64": 7488144838607942675,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) # Mock session manager with cache NAME = NAME ( ) NAME . NAME = { } NAME . NAME = NAME . NAME ( ) NAME . NAME = NAME ( ) NAME . NAME . NAME . NAME = LIT NAME . NAME = NAME ( ) NAME . NAME . NAME . NAME = LIT # Import the optimized function try : from NAME import NAME except NAME : NAME . NAME ( LIT ) return True # Test with caching (repeated calls should be faster) NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( NAME , LIT , LIT ) NAME = NAME . NAME ( ) - NAME # Clear cache and test without caching NAME . NAME = { } NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( NAME , f\" Test API { NAME } \" , LIT ) # Different keys NAME = NAME . NAME ( ) - NAME if NAME > LIT : NAME = NAME / NAME NAME . NAME ( f\" \u2705 Rate limiter caching: { NAME : .1f } x faster ( { NAME : .3f } s vs { NAME : .3f } s) \" ) return NAME > LIT NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_database_session_reuse",
      "lineno": 107,
      "end_lineno": 141,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 35,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "552dab0a8813bc7b75808bf381302833e8318e32",
      "simhash64": 7487546704349541435,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) # Simulate old approach: create/close for each operation NAME = NAME . NAME ( ) NAME = LIT for NAME in NAME ( LIT ) : # 20 operations per batch # Simulate session creation overhead NAME . NAME ( LIT ) # 1ms overhead NAME += LIT # Simulate work NAME . NAME ( LIT ) # 0.5ms work # Simulate session close overhead NAME . NAME ( LIT ) # 0.5ms close NAME = NAME . NAME ( ) - NAME # Simulate new approach: reuse session for batch NAME = NAME . NAME ( ) NAME = LIT # One session for whole batch NAME . NAME ( LIT ) # 1ms creation for NAME in NAME ( LIT ) : # Same 20 operations # Simulate work (no creation/close overhead) NAME . NAME ( LIT ) # 0.5ms work NAME . NAME ( LIT ) # 0.5ms final close NAME = NAME . NAME ( ) - NAME NAME = NAME / NAME if NAME > LIT else NAME ( LIT ) NAME = ( NAME - NAME ) / NAME * LIT NAME . NAME ( f\" \u2705 DB session reuse: { NAME : .1f } x faster, { NAME : .0f } % fewer sessions \" ) NAME . NAME ( f\" Old: { NAME } sessions in { NAME : .3f } s \" ) NAME . NAME ( f\" New: { NAME } session in { NAME : .3f } s \" ) return NAME > LIT # Should be significantly faster"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_logging_optimization",
      "lineno": 144,
      "end_lineno": 180,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 37,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "e8d9244ef02a0d86cb352376760d320968ec12c6",
      "simhash64": 7452116041588966427,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) # Test verbose logging (old approach) NAME = NAME . NAME ( ) NAME = NAME . NAME ( LIT ) NAME . NAME ( NAME . NAME ) for NAME in NAME ( LIT ) : # Simulate old verbose logging NAME . NAME ( f\" Rate limit wait: 0. { NAME : 02d } s (Dynamic: 0. { NAME : 02d } s, Adaptive: 0. { NAME : 02d } s) (Attempt 1) \" ) NAME . NAME ( f\" \u26a1 Adaptive rate limiter optimizing: 0. { NAME : 02d } s vs 0. { NAME + LIT : 02d } s \" ) NAME = NAME . NAME ( ) - NAME # Test optimized logging (new approach - only significant waits) NAME = NAME . NAME ( ) NAME = NAME . NAME ( LIT ) NAME . NAME ( NAME . NAME ) for NAME in NAME ( LIT ) : NAME = LIT + ( NAME * LIT ) # Simulate varying wait times if NAME > LIT : # Only log significant waits (optimization) NAME . NAME ( f\" Rate limit wait: { NAME : .2f } s \" ) elif NAME > LIT : # Reduced optimization logging NAME . NAME ( f\" \u26a1 Optimizing: { NAME : .2f } s \" ) NAME = NAME . NAME ( ) - NAME if NAME > LIT : NAME = NAME / NAME if NAME > LIT else NAME ( LIT ) NAME = ( LIT - ( NAME / NAME ) ) * LIT if NAME > LIT else LIT NAME . NAME ( f\" \u2705 Logging optimization: { NAME : .1f } x faster, { NAME : .0f } % less overhead \" ) return NAME > LIT # Should be significantly faster NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "validate_all_optimizations",
      "lineno": 183,
      "end_lineno": 235,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 53,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "c99b4312fb4bf153b664b90abc562c0e491141d3",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) NAME . NAME ( LIT * LIT ) NAME = [ ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ] NAME = { } NAME = NAME . NAME ( ) for NAME , NAME in NAME : try : NAME = NAME ( ) NAME [ NAME ] = LIT if NAME else LIT except NAME as NAME : NAME [ NAME ] = f\" \u274c ERROR: { NAME } \" NAME . NAME ( LIT ) # Add spacing NAME = NAME . NAME ( ) - NAME # Print summary NAME . NAME ( LIT * LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT * LIT ) NAME = LIT for NAME , NAME in NAME . NAME ( ) : NAME . NAME ( f\" { NAME : <20 } { NAME } \" ) if LIT in NAME : NAME += LIT NAME . NAME ( LIT ) NAME . NAME ( f\" \ud83d\udcca Results: { NAME } / { NAME ( NAME ) } tests passed \" ) NAME . NAME ( f\" \u23f1\ufe0f  Total validation time: { NAME : .3f } s \" ) NAME . NAME ( LIT * LIT ) if NAME == NAME ( NAME ) : NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) return True NAME . NAME ( f\" \u26a0\ufe0f { NAME ( NAME ) - NAME } optimization(s) may need attention \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_csrf_token_performance_metrics",
      "lineno": 240,
      "end_lineno": 273,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 34,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "8b47736e4426eaa246f56c6bdbc2df333971b537",
      "simhash64": 7488215207352116243,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Mock session manager with caching NAME = NAME ( ) NAME . NAME = LIT NAME . NAME = NAME . NAME ( ) NAME . NAME = LIT def NAME ( ) -> NAME : return ( NAME . NAME ( ) - NAME . NAME ) < NAME . NAME NAME . NAME = NAME # Test that cached access is faster than driver access NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : # Reduced iterations for test if NAME . NAME ( ) : pass NAME = NAME . NAME ( ) - NAME # Simulate driver overhead NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME . NAME ( LIT ) # Reduced overhead for test NAME = NAME . NAME ( ) - NAME NAME = NAME / NAME if NAME > LIT else NAME ( LIT ) assert NAME >= LIT , f\" Expected speedup >= 5x, got { NAME : .1f } x \" assert NAME . NAME == LIT return True except NAME as NAME : NAME . NAME ( f\" CSRF token performance test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "_is_csrf_token_valid",
      "lineno": 249,
      "end_lineno": 250,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "time",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "1f3ec619b2b3e922e7d06fc8d7625932ca727717",
      "simhash64": 8640573766837380099,
      "normalized": "def NAME ( ) -> NAME : return ( NAME . NAME ( ) - NAME . NAME ) < NAME . NAME"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_rate_limiter_optimization_logic",
      "lineno": 275,
      "end_lineno": 295,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 21,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ea462747fcb79f5d7256298b7311476e462f1054",
      "simhash64": 7488215207352120339,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Test rate limiter mock setup NAME = NAME ( ) NAME . NAME = { } NAME . NAME = NAME . NAME ( ) NAME . NAME = NAME ( ) NAME . NAME . NAME . NAME = LIT NAME . NAME = NAME ( ) NAME . NAME . NAME . NAME = LIT # Verify cache structure assert NAME ( NAME . NAME , NAME ) assert NAME ( NAME . NAME , NAME ) assert NAME . NAME . NAME . NAME == LIT assert NAME . NAME . NAME . NAME == LIT return True except NAME as NAME : NAME . NAME ( f\" Rate limiter optimization test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_database_session_simulation",
      "lineno": 297,
      "end_lineno": 335,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 39,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "9179f5a5fe1edcd4b8fad01e4a4ef6086f2864f2",
      "simhash64": 7452186410333148211,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Simulate session creation overhead measurement NAME = NAME . NAME ( ) NAME = LIT for NAME in NAME ( LIT ) : # Reduced iterations for test NAME . NAME ( LIT ) # Increased sleep for more reliable timing NAME += LIT NAME = NAME . NAME ( ) - NAME # Simulate optimized approach - should be clearly faster NAME = NAME . NAME ( ) NAME = LIT NAME . NAME ( LIT ) # Only one session creation overhead for NAME in NAME ( LIT ) : NAME . NAME ( LIT ) # Much smaller work simulation NAME = NAME . NAME ( ) - NAME NAME = NAME / NAME if NAME > LIT else LIT NAME = ( NAME - NAME ) / NAME * LIT # Test the calculations and logic, not the exact timing assert NAME == LIT , f\" Expected sessions_created=5, got { NAME } \" assert NAME == LIT , f\" Expected sessions_created_new=1, got { NAME } \" assert NAME == LIT , f\" Expected session_reduction=80.0, got { NAME } \" # More lenient speedup test - just verify the concept works # The optimized approach should generally be faster, but timing can vary assert NAME > LIT , f\" Expected reasonable speedup>0.5, got { NAME } \" # Test that we measured something reasonable assert NAME > LIT , LIT assert NAME > LIT , LIT return True except NAME as NAME : NAME . NAME ( f\" Database session simulation test failed: { NAME ! NAME } \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_logging_optimization_measurement",
      "lineno": 337,
      "end_lineno": 366,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 30,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "5bdc0fa56502f643ac220628c22a4cab4357d5aa",
      "simhash64": 7488215207352120339,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Test logging setup NAME = NAME . NAME ( LIT ) NAME . NAME ( NAME . NAME ) # Test verbose logging timing NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : # Reduced iterations NAME . NAME ( f\" Test log message { NAME } \" ) NAME = NAME . NAME ( ) - NAME # Test optimized logging timing NAME = NAME . NAME ( LIT ) NAME . NAME ( NAME . NAME ) NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME = LIT + ( NAME * LIT ) if NAME > LIT : # Only log some messages (optimization) NAME . NAME ( f\" Optimized log: { NAME : .2f } s \" ) NAME = NAME . NAME ( ) - NAME assert NAME >= LIT assert NAME >= LIT return True except NAME as NAME : NAME . NAME ( f\" Logging optimization test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_validation_function_availability",
      "lineno": 368,
      "end_lineno": 388,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f5828b304a3e422915448e33a0a3b97972f1e72d",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Check that all main functions are available NAME = [ NAME , NAME , NAME , NAME , NAME ] for NAME in NAME : assert NAME ( NAME ) , f\" Function { NAME . NAME } is not callable \" assert NAME ( NAME , LIT ) , f\" Function { NAME } has no __name__ attribute \" assert NAME . NAME is not None , f\" Function { NAME . NAME } has no docstring \" return True except NAME as NAME : NAME . NAME ( f\" Function availability test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_performance_thresholds",
      "lineno": 390,
      "end_lineno": 412,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "bc8ead739811894fd7befb57dc1723a3c114ea69",
      "simhash64": 7452221594705245747,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Test threshold calculations NAME = LIT NAME = LIT NAME = NAME / NAME if NAME > LIT else NAME ( LIT ) assert NAME == LIT assert NAME > LIT # Minimum expected speedup # Test session reduction calculation NAME = LIT NAME = LIT NAME = ( NAME - NAME ) / NAME * LIT assert NAME == LIT assert NAME > LIT # Minimum expected reduction return True except NAME as NAME : NAME . NAME ( f\" Performance thresholds test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_mock_configuration_validation",
      "lineno": 414,
      "end_lineno": 441,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 28,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "45b4d37ebfb1404aaa8616d0b8de1032170d677a",
      "simhash64": 7488215207352120339,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Test session manager mock NAME = NAME ( ) NAME . NAME = LIT NAME . NAME = NAME . NAME ( ) NAME . NAME = LIT NAME . NAME = { } assert NAME . NAME == LIT assert NAME ( NAME . NAME , NAME ) assert NAME . NAME == LIT assert NAME ( NAME . NAME , NAME ) # Test rate limiter mocks NAME . NAME = NAME ( ) NAME . NAME = NAME ( ) NAME . NAME . NAME . NAME = LIT NAME . NAME . NAME . NAME = LIT assert NAME . NAME . NAME ( ) == LIT assert NAME . NAME . NAME ( ) == LIT return True except NAME as NAME : NAME . NAME ( f\" Mock configuration test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_optimization_results_validation",
      "lineno": 443,
      "end_lineno": 473,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 31,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "1e49f856b5c0228153208fe11b5eb28ad1f193da",
      "simhash64": 7488320760468379195,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Test result structure validation NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } # Validate result format for NAME , NAME in NAME . NAME ( ) : assert NAME ( NAME , NAME ) assert NAME ( NAME ) > LIT assert NAME ( NAME , NAME ) assert LIT in NAME or LIT in NAME # Test pass rate calculation NAME = NAME ( LIT for NAME in NAME . NAME ( ) if LIT in NAME ) NAME = NAME ( NAME ) NAME = NAME / NAME if NAME > LIT else LIT assert NAME == LIT assert NAME == LIT assert NAME == LIT return True except NAME as NAME : NAME . NAME ( f\" Optimization results validation test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_timing_measurement_accuracy",
      "lineno": 475,
      "end_lineno": 504,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 30,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "2be21d2e8c20c6d185bef8cd724c5b9e4cbf3895",
      "simhash64": 7452186410333148219,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Test timing precision NAME = NAME . NAME ( ) NAME . NAME ( LIT ) # 10ms sleep NAME = NAME . NAME ( ) - NAME # Should be approximately 10ms with some tolerance assert LIT <= NAME <= LIT , f\" Expected ~0.01s, got { NAME : .3f } s \" # Test multiple timing measurements NAME = [ ] for NAME in NAME ( LIT ) : NAME = NAME . NAME ( ) NAME . NAME ( LIT ) # 1ms sleep NAME . NAME ( NAME . NAME ( ) - NAME ) # All timings should be reasonable for NAME in NAME : assert LIT <= NAME <= LIT , f\" Unreasonable timing: { NAME : .6f } s \" # Average should be close to expected NAME = NAME ( NAME ) / NAME ( NAME ) assert LIT <= NAME <= LIT , f\" Average timing out of range: { NAME : .6f } s \" return True except NAME as NAME : NAME . NAME ( f\" Timing measurement test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_error_handling_robustness",
      "lineno": 506,
      "end_lineno": 535,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "e09034453ffb1d2d5cc47aa2b4aa351327a6f9c5",
      "simhash64": 7488355910480729107,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Test with broken mock NAME = NAME ( ) NAME . NAME = None NAME . NAME = LIT # Should handle invalid data gracefully try : NAME = NAME ( NAME . NAME , NAME ) assert NAME except NAME : pass # Expected to potentially fail # Test with missing attributes NAME = NAME ( ) assert NAME ( NAME , LIT ) # Test division by zero handling try : NAME = LIT / LIT raise NAME ( LIT ) except NAME : pass # Expected return True except NAME as NAME : NAME . NAME ( f\" Error handling test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_utils_import_handling",
      "lineno": 537,
      "end_lineno": 557,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "59df50f16302b05312696016b96266667bf2c653",
      "simhash64": 8605028715743065171,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Test import availability check try : from NAME import NAME NAME = True except NAME : NAME = False # Should handle both cases gracefully if NAME : assert NAME ( NAME ) else : # Should continue without error pass return True except NAME as NAME : NAME . NAME ( f\" Utils import test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 559,
      "end_lineno": 628,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 70,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:test_runner",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "9f7235a31d7b170589d39682c5a0e93f28b2a081",
      "simhash64": 5125619776965481515,
      "normalized": "def NAME ( ) -> NAME : LIT if not NAME : NAME . NAME ( LIT ) return NAME ( ) NAME = NAME ( LIT , NAME ) NAME . NAME ( ) NAME = [ ( LIT , NAME , LIT , LIT , LIT ) , ( LIT , NAME , LIT , LIT , LIT ) , ( LIT , NAME , LIT , LIT , LIT ) , ( LIT , NAME , LIT , LIT , LIT ) , ( LIT , NAME , LIT , LIT , LIT ) , ( LIT , NAME , LIT , LIT , LIT ) , ( LIT , NAME , LIT , LIT , LIT ) , ( LIT , NAME , LIT , LIT , LIT ) , ( LIT , NAME , LIT , LIT , LIT ) , ( LIT , NAME , LIT , LIT , LIT ) , ( LIT , NAME , LIT , LIT , LIT ) ] for NAME , NAME , NAME , NAME , NAME in NAME : NAME . NAME ( NAME , NAME , NAME , NAME , NAME ) return NAME . NAME ( )"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "test_original_validation_integration",
      "lineno": 630,
      "end_lineno": 653,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9e36bedd885f72342123d18a88dd57d375dd9264",
      "simhash64": 7488355911555527739,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Run each original validation function individually NAME = NAME ( ) assert NAME , LIT NAME = NAME ( ) assert NAME , LIT NAME = NAME ( ) assert NAME , LIT NAME = NAME ( ) assert NAME , LIT # Test the full validation workflow NAME = NAME ( ) assert NAME , LIT return True except NAME as NAME : NAME . NAME ( f\" Original validation integration test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "performance_validation.py",
      "qualname": "_run_basic_tests",
      "lineno": 655,
      "end_lineno": 698,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 44,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "5c9b3e8037d306b5ed8e5091f59016cb5a17dc5b",
      "simhash64": 7487757777230533675,
      "normalized": "def NAME ( ) -> NAME : LIT NAME ( f\" \\n { LIT * LIT } \" ) NAME ( LIT ) NAME ( f\" { LIT * LIT } \" ) NAME = [ ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ] NAME = LIT NAME = NAME ( NAME ) for NAME , NAME in NAME : try : NAME ( f\" \u23f3 { NAME } ... \" , NAME = LIT ) NAME = NAME ( ) if NAME : NAME ( LIT ) NAME += LIT else : NAME ( LIT ) except NAME as NAME : NAME ( f\" \u274c ERROR: { NAME } \" ) NAME ( f\" \\n\ud83d\udcca Results: { NAME } / { NAME } tests passed \" ) NAME = NAME == NAME if NAME : NAME ( LIT ) else : NAME ( LIT ) return NAME"
    },
    {
      "module_path": "person_search.py",
      "qualname": "search_gedcom_persons",
      "lineno": 52,
      "end_lineno": 84,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 33,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(search_criteria, max_results, gedcom_path)",
      "fingerprint": "752c8ff5e14d90e4ea720de1980fb477e52d097d",
      "simhash64": 5145886005423150127,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME = LIT , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME : return [ ] # Simple mock search for testing - returns sample data return [ { LIT : LIT , LIT : LIT , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : LIT , } ] [ : NAME ]"
    },
    {
      "module_path": "person_search.py",
      "qualname": "search_ancestry_api_persons",
      "lineno": 88,
      "end_lineno": 121,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 34,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(session_manager, search_criteria, max_results)",
      "fingerprint": "26b035236c47b5707b01ebe28458599b0f3bdeb5",
      "simhash64": 5145745266861052975,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME = LIT , ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME or not NAME : return [ ] if not NAME . NAME ( ) : NAME . NAME ( LIT ) return [ ] # Simple mock search for testing - returns sample data return [ { LIT : LIT , LIT : LIT , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT ) , LIT : LIT , } ] [ : NAME ]"
    },
    {
      "module_path": "person_search.py",
      "qualname": "get_person_family_details",
      "lineno": 125,
      "end_lineno": 158,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 34,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(person_id, source, session_manager, gedcom_path)",
      "fingerprint": "3ee3d89ca8364c607ff401e7d6e6b6f42b62bc0c",
      "simhash64": 5147574818777240623,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME = LIT , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME , NAME ] : LIT if not NAME : return { } # Simple mock family details for testing return { LIT : NAME , LIT : f\" Person { NAME } \" , LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : NAME , }"
    },
    {
      "module_path": "person_search.py",
      "qualname": "get_person_relationship_path",
      "lineno": 162,
      "end_lineno": 190,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 29,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(person_id, reference_id, source, session_manager, gedcom_path)",
      "fingerprint": "d857209bced86cf559a2bc98cdb43ac52454b12a",
      "simhash64": 7452151225962107923,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME [ NAME ] = None , NAME : NAME = LIT , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , ) -> NAME : LIT if not NAME : return LIT # Simple mock relationship path for testing NAME = NAME or LIT return f\" { NAME } is connected to { NAME } (relationship path) \""
    },
    {
      "module_path": "person_search.py",
      "qualname": "unified_person_search",
      "lineno": 194,
      "end_lineno": 244,
      "is_method": false,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 51,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(search_criteria, max_results, include_gedcom, include_api, session_manager, gedcom_path)",
      "fingerprint": "956b0c0ef090859907b63e8ec93353fe9fac83ff",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME = LIT , NAME : NAME = True , NAME : NAME = True , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME [ NAME , NAME ] ] : LIT NAME = [ ] # GEDCOM search if NAME : NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , ) for NAME in NAME : NAME [ LIT ] = LIT NAME . NAME ( NAME ) # API search if NAME and NAME and NAME . NAME ( ) : NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , ) for NAME in NAME : NAME [ LIT ] = LIT NAME . NAME ( NAME ) # Sort by score if available with NAME . NAME ( NAME , NAME ) : NAME . NAME ( NAME = lambda NAME : NAME . NAME ( LIT , LIT ) , NAME = True ) return NAME [ : NAME * LIT ] # Return up to double max_results"
    },
    {
      "module_path": "person_search.py",
      "qualname": "parse_person_name",
      "lineno": 248,
      "end_lineno": 277,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(name)",
      "fingerprint": "023270f69c401518b736e3fec1d9b74ec47221c5",
      "simhash64": 7451729014636844587,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME , NAME ] : LIT if not NAME or not NAME ( NAME , NAME ) : return { LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) if not NAME : return { LIT : LIT , LIT : LIT , LIT : NAME } # Simple parsing logic NAME = NAME [ LIT ] NAME = NAME [ - LIT ] if NAME ( NAME ) > LIT else LIT NAME = LIT . NAME ( NAME [ LIT : - LIT ] ) if NAME ( NAME ) > LIT else LIT return { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , }"
    },
    {
      "module_path": "person_search.py",
      "qualname": "calculate_name_similarity",
      "lineno": 281,
      "end_lineno": 307,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 27,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(name1, name2)",
      "fingerprint": "169aad72f9ad3bea2d40e0cb453a5ed570f2e7ae",
      "simhash64": 8641031158842696707,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT if not NAME or not NAME : return LIT NAME = NAME . NAME ( ) . NAME ( ) NAME = NAME . NAME ( ) . NAME ( ) if NAME == NAME : return LIT # Simple similarity based on common characters NAME = NAME ( NAME ) NAME = NAME ( NAME ) NAME = NAME ( NAME . NAME ( NAME ) ) NAME = NAME ( NAME . NAME ( NAME ) ) return NAME / NAME if NAME > LIT else LIT"
    },
    {
      "module_path": "person_search.py",
      "qualname": "person_search_module_tests",
      "lineno": 314,
      "end_lineno": 654,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 341,
      "tags": [
        "impure",
        "time",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "63d7c16c4a22a2b4872e2f873fb409460df89359",
      "simhash64": 5145885970996302891,
      "normalized": "def NAME ( ) -> NAME : LIT import NAME from NAME . NAME import NAME from NAME import NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # === INITIALIZATION TESTS === def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME in NAME ( ) , f\" Function { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] ) , f\" Function { NAME } should be callable \" def NAME ( ) : LIT # Test core infrastructure imports assert LIT in NAME ( ) , LIT assert LIT in NAME ( ) , LIT assert LIT in NAME ( ) , LIT # Test error handling imports NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME ( ) , f\" Error handling import { NAME } should be available \" # === CORE FUNCTIONALITY TESTS === def NAME ( ) : LIT # Test normal name parsing NAME = NAME ( LIT ) assert NAME [ LIT ] == LIT , LIT assert NAME [ LIT ] == LIT , LIT assert NAME [ LIT ] == LIT , LIT assert NAME [ LIT ] == LIT , LIT # Test single name NAME = NAME ( LIT ) assert NAME [ LIT ] == LIT , LIT assert NAME [ LIT ] == LIT , LIT # Test empty name NAME = NAME ( LIT ) assert NAME [ LIT ] == LIT , LIT assert NAME [ LIT ] == LIT , LIT def NAME ( ) : LIT # Test exact match assert NAME ( LIT , LIT ) == LIT , LIT # Test no match assert NAME ( LIT , LIT ) < LIT , LIT # Test similar names NAME = NAME ( LIT , LIT ) assert LIT < NAME < LIT , LIT # Test empty names assert NAME ( LIT , LIT ) == LIT , LIT def NAME ( ) : LIT # Test with mock search criteria NAME = { LIT : LIT , LIT : LIT , LIT : LIT } # This will return mock data due to safe_execute wrapper NAME = NAME ( NAME , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test with invalid criteria NAME = NAME ( { } , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT def NAME ( ) : LIT # Test with None session manager NAME = NAME ( None , { LIT : LIT } , LIT ) assert NAME == [ ] , LIT # Test with mock session manager NAME = NAME ( ) NAME . NAME . NAME = False NAME = NAME ( NAME , { LIT : LIT } , LIT ) assert NAME == [ ] , LIT # === EDGE CASE TESTS === def NAME ( ) : LIT # Test with invalid person ID NAME = NAME ( LIT , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test with API source but no session NAME = NAME ( LIT , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test auto detection NAME = NAME ( LIT , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT def NAME ( ) : LIT # Test GEDCOM relationship path NAME = NAME ( LIT , LIT , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test API relationship path without session NAME = NAME ( LIT , LIT , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test auto detection NAME = NAME ( LIT , LIT , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # === INTEGRATION TESTS === def NAME ( ) : LIT NAME = { LIT : LIT , LIT : LIT } # Test with no session manager NAME = NAME ( NAME , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test with mock session manager NAME = NAME ( ) NAME . NAME . NAME = True NAME = NAME ( NAME , NAME = LIT , NAME = NAME ) assert NAME ( NAME , NAME ) , LIT # Test with disabled sources NAME = NAME ( NAME , NAME = False , NAME = False ) assert NAME == [ ] , LIT def NAME ( ) : LIT # Test that functions can work with session manager interface NAME = NAME ( ) NAME . NAME . NAME = True # Test API search with valid session NAME = NAME ( NAME , { LIT : LIT } , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test unified search with session manager NAME = NAME ( { LIT : LIT } , NAME = NAME , NAME = True ) assert NAME ( NAME , NAME ) , LIT # === PERFORMANCE TESTS === def NAME ( ) : LIT # Test that operations complete within reasonable time NAME = NAME . NAME ( ) # Run multiple operations for NAME in NAME ( LIT ) : NAME ( LIT ) NAME ( LIT , LIT ) NAME ( { LIT : LIT } , LIT ) NAME ( LIT , NAME = LIT ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Performance test should complete quickly, took { NAME : .3f } s \" def NAME ( ) : LIT # Test name parsing performance NAME = [ LIT , LIT , LIT , LIT , LIT ] NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : for NAME in NAME : NAME ( NAME ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Bulk name parsing should be fast, took { NAME : .3f } s \" # === ERROR HANDLING TESTS === def NAME ( ) : LIT # Test functions with invalid inputs assert NAME ( None , LIT ) == [ ] , LIT assert NAME ( None , None , LIT ) == [ ] , LIT assert NAME ( None ) == { } , LIT assert NAME ( None ) == LIT , LIT def NAME ( ) : LIT # Test that functions return safe defaults on errors # Note: Using type ignore for intentional None testing NAME = NAME ( None ) # type: ignore assert NAME ( NAME , NAME ) , LIT NAME = NAME ( None , None ) # type: ignore assert NAME == LIT , LIT # Run all tests with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) return NAME . NAME ( )"
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_function_availability",
      "lineno": 328,
      "end_lineno": 341,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c5bceb600c133f0a629e66a2b258442905a9914e",
      "simhash64": 7451728980205802539,
      "normalized": "def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME in NAME ( ) , f\" Function { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] ) , f\" Function { NAME } should be callable \""
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_module_imports",
      "lineno": 343,
      "end_lineno": 356,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "59f198c73fbc957a11fd63d8bfd83e6e1089674d",
      "simhash64": 7452010489542776363,
      "normalized": "def NAME ( ) : LIT # Test core infrastructure imports assert LIT in NAME ( ) , LIT assert LIT in NAME ( ) , LIT assert LIT in NAME ( ) , LIT # Test error handling imports NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME ( ) , f\" Error handling import { NAME } should be available \""
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_parse_person_name",
      "lineno": 359,
      "end_lineno": 376,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "eb4bd29d32b6a1b19640e5683a8560430a421fe1",
      "simhash64": 5145878299173885479,
      "normalized": "def NAME ( ) : LIT # Test normal name parsing NAME = NAME ( LIT ) assert NAME [ LIT ] == LIT , LIT assert NAME [ LIT ] == LIT , LIT assert NAME [ LIT ] == LIT , LIT assert NAME [ LIT ] == LIT , LIT # Test single name NAME = NAME ( LIT ) assert NAME [ LIT ] == LIT , LIT assert NAME [ LIT ] == LIT , LIT # Test empty name NAME = NAME ( LIT ) assert NAME [ LIT ] == LIT , LIT assert NAME [ LIT ] == LIT , LIT"
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_name_similarity",
      "lineno": 378,
      "end_lineno": 391,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "68675f5fc29c59bec4b22373d5d82a77eba02a28",
      "simhash64": 5145878403219428911,
      "normalized": "def NAME ( ) : LIT # Test exact match assert NAME ( LIT , LIT ) == LIT , LIT # Test no match assert NAME ( LIT , LIT ) < LIT , LIT # Test similar names NAME = NAME ( LIT , LIT ) assert LIT < NAME < LIT , LIT # Test empty names assert NAME ( LIT , LIT ) == LIT , LIT"
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_gedcom_search_functions",
      "lineno": 393,
      "end_lineno": 404,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7a5eb05612e175c7026fe731882b7ae492726a4c",
      "simhash64": 5145885970987914795,
      "normalized": "def NAME ( ) : LIT # Test with mock search criteria NAME = { LIT : LIT , LIT : LIT , LIT : LIT } # This will return mock data due to safe_execute wrapper NAME = NAME ( NAME , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test with invalid criteria NAME = NAME ( { } , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_api_search_functions",
      "lineno": 406,
      "end_lineno": 416,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c291ff5df36036bd4328c1ac2e0b83f3e1f96c3f",
      "simhash64": 7452291934459434031,
      "normalized": "def NAME ( ) : LIT # Test with None session manager NAME = NAME ( None , { LIT : LIT } , LIT ) assert NAME == [ ] , LIT # Test with mock session manager NAME = NAME ( ) NAME . NAME . NAME = False NAME = NAME ( NAME , { LIT : LIT } , LIT ) assert NAME == [ ] , LIT"
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_family_details_edge_cases",
      "lineno": 419,
      "end_lineno": 431,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "577f4ac0a34efa73ea218420ade87d74c5ed0cfb",
      "simhash64": 5146448920951297067,
      "normalized": "def NAME ( ) : LIT # Test with invalid person ID NAME = NAME ( LIT , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test with API source but no session NAME = NAME ( LIT , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test auto detection NAME = NAME ( LIT , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_relationship_path_edge_cases",
      "lineno": 433,
      "end_lineno": 445,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ed094e299e66a8abccc1da7f98f9b2c7cd257db4",
      "simhash64": 5145885970997875755,
      "normalized": "def NAME ( ) : LIT # Test GEDCOM relationship path NAME = NAME ( LIT , LIT , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test API relationship path without session NAME = NAME ( LIT , LIT , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test auto detection NAME = NAME ( LIT , LIT , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_unified_search_integration",
      "lineno": 448,
      "end_lineno": 468,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2448bc7b5a5bd6125db727248d910745989a2560",
      "simhash64": 7452291934458385471,
      "normalized": "def NAME ( ) : LIT NAME = { LIT : LIT , LIT : LIT } # Test with no session manager NAME = NAME ( NAME , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test with mock session manager NAME = NAME ( ) NAME . NAME . NAME = True NAME = NAME ( NAME , NAME = LIT , NAME = NAME ) assert NAME ( NAME , NAME ) , LIT # Test with disabled sources NAME = NAME ( NAME , NAME = False , NAME = False ) assert NAME == [ ] , LIT"
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_session_manager_integration",
      "lineno": 470,
      "end_lineno": 490,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "575ac0fba2a2049bbd2c8ff6f70b71356d635d9a",
      "simhash64": 7488320731477873727,
      "normalized": "def NAME ( ) : LIT # Test that functions can work with session manager interface NAME = NAME ( ) NAME . NAME . NAME = True # Test API search with valid session NAME = NAME ( NAME , { LIT : LIT } , NAME = LIT ) assert NAME ( NAME , NAME ) , LIT # Test unified search with session manager NAME = NAME ( { LIT : LIT } , NAME = NAME , NAME = True ) assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_performance",
      "lineno": 493,
      "end_lineno": 506,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b508c416d0e35755ee945a533bc93337767db69a",
      "simhash64": 8604650484817892395,
      "normalized": "def NAME ( ) : LIT # Test that operations complete within reasonable time NAME = NAME . NAME ( ) # Run multiple operations for NAME in NAME ( LIT ) : NAME ( LIT ) NAME ( LIT , LIT ) NAME ( { LIT : LIT } , LIT ) NAME ( LIT , NAME = LIT ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Performance test should complete quickly, took { NAME : .3f } s \""
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_bulk_operations",
      "lineno": 508,
      "end_lineno": 519,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "286a79e39fd36f5e83b5032f22205c8f4ce68b77",
      "simhash64": 7451729014637892667,
      "normalized": "def NAME ( ) : LIT # Test name parsing performance NAME = [ LIT , LIT , LIT , LIT , LIT ] NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : for NAME in NAME : NAME ( NAME ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Bulk name parsing should be fast, took { NAME : .3f } s \""
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_error_handling",
      "lineno": 522,
      "end_lineno": 528,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "a6d189c4d9520aae79907ff696cc1ed1fc95be38",
      "simhash64": 5144760050132096047,
      "normalized": "def NAME ( ) : LIT # Test functions with invalid inputs assert NAME ( None , LIT ) == [ ] , LIT assert NAME ( None , None , LIT ) == [ ] , LIT assert NAME ( None ) == { } , LIT assert NAME ( None ) == LIT , LIT"
    },
    {
      "module_path": "person_search.py",
      "qualname": "test_safe_execute_decorator",
      "lineno": 530,
      "end_lineno": 538,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "impure",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "83102b8b1e481646b816c8f5bbb250a46cc6fb26",
      "simhash64": 5183638804933547047,
      "normalized": "def NAME ( ) : LIT # Test that functions return safe defaults on errors # Note: Using type ignore for intentional None testing NAME = NAME ( None ) # type: ignore assert NAME ( NAME , NAME ) , LIT NAME = NAME ( None , None ) # type: ignore assert NAME == LIT , LIT"
    },
    {
      "module_path": "person_search.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 657,
      "end_lineno": 659,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_stable_hash",
      "lineno": 39,
      "end_lineno": 42,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(value)",
      "fingerprint": "bb707becd9331f6b76764d5314d2001dc3fc79a1",
      "simhash64": 8641093282391036931,
      "normalized": "def NAME ( NAME : NAME | None ) -> NAME | None : if not NAME : return None return NAME . NAME ( NAME . NAME ( LIT ) ) . NAME ( ) [ : LIT ]"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "record_extraction_experiment_event",
      "lineno": 44,
      "end_lineno": 81,
      "is_method": false,
      "is_async": false,
      "args_count": 12,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 9,
      "loc": 38,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "size:medium"
      ],
      "signature": "(variant_label, prompt_key, prompt_version, parse_success, extracted_data, suggested_tasks, raw_response_text, user_id, error, quality_score, component_coverage, anomaly_summary)",
      "fingerprint": "e4dae0e73bf3de7b293ab10542c2c3c99a49b402",
      "simhash64": 7489446627090797611,
      "normalized": "def NAME ( * , NAME : NAME , NAME : NAME , NAME : NAME | None , NAME : NAME , NAME : NAME [ NAME , NAME ] | None = None , NAME : NAME [ NAME ] | None = None , NAME : NAME | None = None , NAME : NAME | None = None , NAME : NAME | None = None , NAME : NAME | None = None , NAME : NAME | None = None , NAME : NAME | None = None ) -> None : LIT try : NAME : NAME [ NAME , NAME ] = { } if NAME ( NAME , NAME ) : for NAME , NAME in NAME . NAME ( ) : if NAME ( NAME , NAME ) : NAME [ NAME ] = NAME ( NAME ) NAME = { LIT : NAME . NAME ( NAME . NAME ) . NAME ( NAME = LIT ) , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : ( NAME [ : NAME ] if NAME else None ) , LIT : NAME or None , LIT : NAME ( NAME ( NAME ) ) if NAME else LIT , LIT : NAME ( NAME ) if NAME ( NAME , NAME ) else None , LIT : NAME ( NAME ) , LIT : NAME ( NAME ( NAME ) , LIT ) if NAME ( NAME , ( NAME , NAME ) ) else None , LIT : NAME ( NAME ( NAME ) , LIT ) if NAME ( NAME , ( NAME , NAME ) ) else None , LIT : NAME or None , } with NAME ( NAME ) . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME . NAME ( NAME , NAME = False ) + LIT ) # Lightweight auto-alert hook (Phase 11.2 item 2) from NAME import NAME with NAME ( NAME ) : NAME ( ) except NAME : pass"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_read_recent_jsonl",
      "lineno": 83,
      "end_lineno": 100,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 8,
      "loc": 18,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:small"
      ],
      "signature": "(file_path, last_n)",
      "fingerprint": "15d5f7926a8095a061e77423b2ddcae5ebd02c84",
      "simhash64": 7488180023047140375,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME . NAME ( ) : return [ ] try : with NAME . NAME ( NAME = LIT ) as NAME : NAME = [ NAME for NAME in NAME if NAME . NAME ( ) ] if NAME > LIT : NAME = NAME [ - NAME : ] NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] for NAME in NAME : try : NAME . NAME ( NAME . NAME ( NAME ) ) except NAME : continue return NAME except NAME : return [ ]"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_accumulate_variant_stats",
      "lineno": 106,
      "end_lineno": 133,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(events)",
      "fingerprint": "26fbc17c7025cd3fed9ee8c5e3a64ebca28b6f5b",
      "simhash64": 7452151227101918211,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME [ NAME [ NAME , NAME [ NAME , NAME ] ] , NAME , NAME , NAME ] : LIT NAME : NAME [ NAME , NAME [ NAME , NAME ] ] = { } NAME = LIT NAME = LIT NAME = LIT for NAME in NAME : NAME = NAME . NAME ( LIT ) or LIT NAME = NAME . NAME ( NAME , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , ) NAME [ LIT ] += LIT if NAME . NAME ( LIT ) : NAME [ LIT ] += LIT NAME += LIT NAME = NAME . NAME ( LIT ) or LIT NAME [ LIT ] = ( ( NAME [ LIT ] - LIT ) * NAME [ LIT ] + NAME ) / NAME [ LIT ] NAME = NAME . NAME ( LIT ) if NAME ( NAME , ( NAME , NAME ) ) : NAME = NAME ( NAME ) NAME [ LIT ] += NAME NAME [ LIT ] += LIT NAME += NAME NAME += LIT return NAME , NAME , NAME , NAME"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_finalize_variant_stats",
      "lineno": 136,
      "end_lineno": 145,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(variant_stats)",
      "fingerprint": "8dba3aded1476eb0e9808811ab84a247f8e962ea",
      "simhash64": 5145745267934794787,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME [ NAME , NAME ] ] ) -> None : LIT for NAME in NAME . NAME ( ) : NAME = NAME . NAME ( LIT , LIT ) or LIT NAME [ LIT ] = NAME . NAME ( LIT , LIT ) / NAME NAME [ LIT ] = NAME ( NAME . NAME ( LIT , LIT ) , LIT ) if NAME . NAME ( LIT ) : NAME [ LIT ] = NAME ( NAME [ LIT ] / NAME [ LIT ] , LIT ) NAME . NAME ( LIT , None ) NAME . NAME ( LIT , None )"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "summarize_experiments",
      "lineno": 148,
      "end_lineno": 171,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(last_n)",
      "fingerprint": "a800d99cf0426a2b47d4b39ed911fad4f4538312",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( NAME : NAME = LIT ) -> NAME [ NAME , NAME ] : LIT try : NAME = NAME ( NAME , NAME ) NAME = NAME ( NAME ) if not NAME : return { LIT : LIT , LIT : { } , LIT : LIT } NAME , NAME , NAME , NAME = NAME ( NAME ) NAME ( NAME ) NAME : NAME [ NAME , NAME ] = { LIT : NAME , LIT : NAME ( ( NAME / NAME ) if NAME else LIT , LIT ) , LIT : NAME , } if NAME : NAME [ LIT ] = NAME ( NAME / NAME , LIT ) return NAME except NAME : return { LIT : LIT , LIT : { } , LIT : LIT }"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_load_recent_events",
      "lineno": 175,
      "end_lineno": 194,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 8,
      "loc": 20,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:small"
      ],
      "signature": "(window)",
      "fingerprint": "28936b26c77f8299133b618019aac5e9ecce8f99",
      "simhash64": 7488180023047140375,
      "normalized": "def NAME ( NAME : NAME = LIT ) -> NAME [ NAME [ NAME , NAME ] ] : if not NAME . NAME ( ) : return [ ] NAME : NAME [ NAME [ NAME , NAME ] ] = [ ] try : with NAME ( NAME ) . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( ) if NAME > LIT : NAME = NAME [ - NAME : ] for NAME in NAME : NAME = NAME . NAME ( ) if not NAME : continue try : NAME . NAME ( NAME . NAME ( NAME ) ) except NAME : continue except NAME : return [ ] return NAME"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_aggregate_variant_data",
      "lineno": 196,
      "end_lineno": 211,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(events)",
      "fingerprint": "f1f23100406b495152845f25e5c391a8f1693b41",
      "simhash64": 7452151226028176419,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME [ NAME , NAME [ NAME , NAME ] ] : LIT NAME : NAME [ NAME , NAME [ NAME , NAME ] ] = { } for NAME in NAME : NAME = NAME . NAME ( LIT ) or LIT NAME = NAME . NAME ( NAME , { LIT : [ ] , LIT : LIT , LIT : LIT , LIT : [ ] } ) NAME [ LIT ] += LIT if NAME . NAME ( LIT ) : NAME [ LIT ] += LIT NAME = NAME . NAME ( LIT ) if NAME ( NAME , ( NAME , NAME ) ) : NAME [ LIT ] . NAME ( NAME ( NAME ) ) NAME = NAME . NAME ( LIT ) if NAME ( NAME , NAME ) : NAME [ LIT ] . NAME ( NAME ) return NAME"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_compute_variant_metrics",
      "lineno": 214,
      "end_lineno": 231,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(variants)",
      "fingerprint": "435ff334bce4a65d0d93026fcfdc0b47e27ed809",
      "simhash64": 5182337013833438211,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME [ NAME , NAME ] ] ) -> NAME [ NAME , NAME ] : LIT NAME : NAME [ NAME , NAME ] = { } for NAME , NAME in NAME . NAME ( ) : NAME = NAME ( NAME [ LIT ] , LIT ) NAME = NAME [ LIT ] NAME = NAME . NAME ( NAME ) if NAME else None NAME = NAME ( NAME ) / NAME ( NAME ) if NAME else None NAME = NAME ( NAME [ LIT ] ) / NAME ( NAME [ LIT ] ) if NAME [ LIT ] else LIT NAME = NAME [ LIT ] / NAME NAME [ NAME ] = { LIT : NAME [ LIT ] , LIT : NAME ( NAME , LIT ) , LIT : NAME ( NAME , LIT ) if NAME is not None else None , LIT : NAME ( NAME , LIT ) if NAME is not None else None , LIT : NAME ( NAME , LIT ) , } return NAME"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_compare_control_alt",
      "lineno": 234,
      "end_lineno": 247,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(result_variants, min_events_per_variant, quality_margin, success_margin)",
      "fingerprint": "69d0d171c0a445a6bc5fb932be293bfe91d537bb",
      "simhash64": 7452151226028176387,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME : NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME : NAME [ NAME , NAME ] = { } if NAME and NAME and NAME [ LIT ] >= NAME and NAME [ LIT ] >= NAME : NAME = ( NAME . NAME ( LIT ) or LIT ) - ( NAME . NAME ( LIT ) or LIT ) NAME = NAME . NAME ( LIT , LIT ) - NAME . NAME ( LIT , LIT ) NAME [ LIT ] = NAME ( NAME , LIT ) NAME [ LIT ] = NAME ( NAME , LIT ) NAME [ LIT ] = NAME >= NAME NAME [ LIT ] = NAME >= NAME NAME [ LIT ] = NAME ( NAME [ LIT ] or NAME [ LIT ] ) return NAME"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "analyze_experiments",
      "lineno": 250,
      "end_lineno": 265,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(window, min_events_per_variant, quality_margin, success_margin)",
      "fingerprint": "7d3d24574aed599901632a2e2257cc745860baef",
      "simhash64": 7451729014570783787,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( NAME ) if not NAME : return { LIT : LIT , LIT : { } , LIT : LIT } NAME = NAME ( NAME ) NAME = NAME ( NAME ) NAME = NAME ( NAME , NAME , NAME , NAME ) return { LIT : NAME ( NAME ) , LIT : NAME , LIT : NAME }"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_write_alert",
      "lineno": 267,
      "end_lineno": 272,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 6,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(alert)",
      "fingerprint": "3974a54af5bd40699dbe1f5354af124863282719",
      "simhash64": 7488180022980023339,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> None : try : with NAME ( NAME ) . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME . NAME ( NAME , NAME = False ) + LIT ) except NAME : pass"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_already_alerted",
      "lineno": 274,
      "end_lineno": 284,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 11,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "(signature)",
      "fingerprint": "def2979a52097ad4bac16d87412a7ca12358acca",
      "simhash64": 8645636463362741803,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : if not NAME . NAME ( ) : return False try : with NAME ( NAME ) . NAME ( NAME = LIT ) as NAME : for NAME in NAME : if NAME in NAME : return True except NAME : return False return False"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_auto_analyze_and_alert",
      "lineno": 286,
      "end_lineno": 303,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 18,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "12c5e9d9300414dff44152ca92226fbd17fe095b",
      "simhash64": 8640679316196594731,
      "normalized": "def NAME ( ) -> None : NAME = NAME ( ) NAME = NAME . NAME ( LIT , { } ) if not NAME : return if not NAME . NAME ( LIT ) : return NAME = f\" q { NAME . NAME ( LIT ) } _s { NAME . NAME ( LIT ) } \" if NAME ( NAME ) : return NAME = { LIT : NAME . NAME ( ) . NAME ( NAME = LIT ) , LIT : LIT , LIT : NAME , LIT : NAME , LIT : LIT } NAME ( NAME )"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "build_quality_baseline",
      "lineno": 307,
      "end_lineno": 334,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 8,
      "loc": 28,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(variant, window, min_events)",
      "fingerprint": "89322356f396eb7cd7fea371a0378b2335d15503",
      "simhash64": 7488180024053765163,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT ) -> NAME [ NAME , NAME ] | None : NAME = NAME ( NAME ) NAME : NAME [ NAME ] = [ ] for NAME in NAME : if NAME . NAME ( LIT ) != NAME : continue NAME = NAME . NAME ( LIT ) if NAME ( NAME , ( NAME , NAME ) ) : try : NAME . NAME ( NAME ( NAME ) ) except NAME : continue if NAME ( NAME ) < NAME : return None NAME = { LIT : NAME , LIT : NAME ( NAME ) , LIT : NAME . NAME ( NAME ) , LIT : NAME . NAME ( NAME , NAME = LIT ) [ LIT ] if NAME ( NAME ) >= LIT else None , LIT : NAME . NAME ( NAME , NAME = LIT ) [ LIT ] if NAME ( NAME ) >= LIT else None , LIT : NAME . NAME ( ) . NAME ( NAME = LIT ) , } try : with NAME ( NAME ) . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME , NAME = LIT ) except NAME : pass return NAME"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "load_quality_baseline",
      "lineno": 336,
      "end_lineno": 343,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 8,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "a98e6d4ec0321f0866ff10c5d05a550f5112510b",
      "simhash64": 8641101497522631683,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] | None : if not NAME . NAME ( ) : return None try : with NAME ( NAME ) . NAME ( NAME = LIT ) as NAME : return NAME . NAME ( NAME ) except NAME : return None"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "detect_quality_regression",
      "lineno": 345,
      "end_lineno": 366,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 9,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(current_window, drop_threshold, variant)",
      "fingerprint": "430b5986b716d71331f356d8580e4887ac275f08",
      "simhash64": 7488320761542120491,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT ) -> NAME [ NAME , NAME ] : NAME = NAME ( ) if not NAME or NAME . NAME ( LIT ) != NAME : return { LIT : LIT } NAME = NAME ( NAME ) NAME : NAME [ NAME ] = [ ] for NAME in NAME : if NAME . NAME ( LIT ) != NAME : continue NAME = NAME . NAME ( LIT ) if NAME ( NAME , ( NAME , NAME ) ) : try : NAME . NAME ( NAME ( NAME ) ) except NAME : continue if not NAME : return { LIT : LIT } NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( LIT ) or LIT NAME = NAME - NAME NAME = NAME >= NAME return { LIT : LIT , LIT : NAME , LIT : NAME , LIT : NAME ( NAME , LIT ) , LIT : NAME }"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_test_record_and_summarize",
      "lineno": 369,
      "end_lineno": 387,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7dab725a68fbc4535a1468616996a5e0b72f5bda",
      "simhash64": 5145886005357089835,
      "normalized": "def NAME ( ) -> None : LIT # Capture starting count NAME = NAME ( ) . NAME ( LIT , LIT ) for NAME in NAME ( LIT ) : NAME ( NAME = LIT , NAME = f\" k { NAME } \" , NAME = LIT , NAME = True , NAME = { LIT : [ LIT , LIT ] } , NAME = [ { LIT : LIT } ] , NAME = LIT , NAME = LIT , NAME = LIT + NAME , NAME = LIT , ) NAME = NAME ( ) assert NAME . NAME ( LIT , LIT ) >= NAME + LIT , LIT"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_test_variant_analysis",
      "lineno": 389,
      "end_lineno": 403,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3fa7bd6705d9c32d5b7e093f1a10d60a7da2595d",
      "simhash64": 5145886005423150651,
      "normalized": "def NAME ( ) -> None : LIT for NAME in NAME ( LIT ) : NAME ( NAME = LIT , NAME = f\" alt { NAME } \" , NAME = LIT , NAME = NAME ( NAME % LIT == LIT ) , NAME = { LIT : [ LIT ] } , NAME = [ ] , NAME = LIT + NAME , NAME = LIT , ) NAME = NAME ( NAME = LIT , NAME = LIT ) assert LIT in NAME and NAME . NAME ( LIT , LIT ) > LIT"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "_test_build_baseline_and_regression",
      "lineno": 405,
      "end_lineno": 426,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 22,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "41ea25ecc5325ba18be9300719252d8fec3dd4cb",
      "simhash64": 5146448955310511163,
      "normalized": "def NAME ( ) -> None : LIT # Ensure enough control events to build baseline (min_events=8) NAME = LIT NAME = NAME ( ) NAME = NAME . NAME ( LIT , { } ) . NAME ( LIT , { } ) . NAME ( LIT , LIT ) NAME = NAME ( LIT , NAME - NAME ) for NAME in NAME ( NAME ) : NAME ( NAME = LIT , NAME = f\" b { NAME } \" , NAME = LIT , NAME = True , NAME = { } , NAME = [ ] , NAME = LIT + ( NAME % LIT ) , NAME = LIT , ) NAME = NAME ( NAME = LIT , NAME = LIT , NAME = LIT ) assert NAME is None or NAME . NAME ( LIT ) == LIT NAME = NAME ( NAME = LIT , NAME = LIT , NAME = LIT ) # Force non-regression assert LIT in NAME"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "prompt_telemetry_module_tests",
      "lineno": 428,
      "end_lineno": 448,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "0f424dc4654b65ed4d9ab38bee63a89dbcafc4c3",
      "simhash64": 5181914772310234155,
      "normalized": "def NAME ( ) -> NAME : try : from NAME import NAME , NAME except NAME : # pragma: no cover return True # Skip if framework missing NAME = NAME ( LIT , LIT ) NAME . NAME ( ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) return NAME . NAME ( )"
    },
    {
      "module_path": "prompt_telemetry.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 450,
      "end_lineno": 451,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "321022c6996046739f78db19f8b767250f978a20",
      "simhash64": 5180049981792224369,
      "normalized": "def NAME ( ) -> NAME : # Consistent entrypoint naming return NAME ( )"
    },
    {
      "module_path": "quality_regression_gate.py",
      "qualname": "_get_env_float",
      "lineno": 45,
      "end_lineno": 49,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(name, default)",
      "fingerprint": "12e621d0eec10a3f661c6635e62c65ea23d25870",
      "simhash64": 7488180022980027395,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : try : return NAME ( NAME . NAME . NAME ( NAME , NAME ) ) except NAME : return NAME"
    },
    {
      "module_path": "quality_regression_gate.py",
      "qualname": "main",
      "lineno": 52,
      "end_lineno": 86,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 7,
      "loc": 35,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "json",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "104f8a0a511472f79f5278d917f056abb4374887",
      "simhash64": 7488109655309587483,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME . NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME . NAME ( LIT , LIT ) or LIT ) NAME = NAME ( LIT , LIT ) NAME = NAME . NAME . NAME ( LIT ) is not None try : NAME : NAME [ NAME , NAME ] = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , ) except NAME as NAME : NAME ( f\" ERROR: quality regression detection failed: { NAME } \" , NAME = NAME . NAME ) return LIT NAME = NAME . NAME ( LIT ) NAME = NAME ( NAME . NAME ( LIT ) ) if NAME : NAME ( NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME } , NAME = LIT ) ) # Concise line elif NAME == LIT : NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME ( f\" QualityGate status=ok variant= { NAME } median_now= { NAME } baseline_median= { NAME } drop= { NAME } threshold= { NAME } regression= { NAME } \" ) else : NAME ( f\" QualityGate status= { NAME } variant= { NAME } (no enforcement) \" ) # Enforcement logic if NAME == LIT and NAME : return LIT # lenient pass if no baseline / no data / ok without regression return LIT"
    },
    {
      "module_path": "quality_regression_gate.py",
      "qualname": "_test_no_baseline_pass",
      "lineno": 90,
      "end_lineno": 99,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 10,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "1f873529efdb71f63ab75e71acbac0775d7386a2",
      "simhash64": 7488215207353164915,
      "normalized": "def NAME ( ) -> None : # Ensure regression gate passes when no baseline file exists from NAME import NAME NAME = NAME ( NAME ) . NAME / LIT / LIT if NAME . NAME ( ) : from NAME import NAME with NAME ( NAME ) : NAME . NAME ( ) NAME = NAME ( ) # Should return 0 (no baseline) assert NAME == LIT"
    },
    {
      "module_path": "quality_regression_gate.py",
      "qualname": "_test_regression_structure",
      "lineno": 101,
      "end_lineno": 105,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "da8d58cd1aad79c77bd89ee0faa19a9dd47b5e36",
      "simhash64": 5146378552205546555,
      "normalized": "def NAME ( ) -> None : # Call detect directly via imported function to ensure keys from NAME import NAME NAME = NAME ( NAME = LIT , NAME = LIT , NAME = LIT ) assert LIT in NAME"
    },
    {
      "module_path": "quality_regression_gate.py",
      "qualname": "quality_regression_gate_module_tests",
      "lineno": 107,
      "end_lineno": 123,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c661d143239db9025e6d0c18cb2d61bcda14e333",
      "simhash64": 7487757781523928107,
      "normalized": "def NAME ( ) -> NAME : try : from NAME import NAME , NAME except NAME : # pragma: no cover return True NAME = NAME ( LIT , LIT ) NAME . NAME ( ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) return NAME . NAME ( )"
    },
    {
      "module_path": "quality_regression_gate.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 125,
      "end_lineno": 126,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "029a2369e64f9c03dad5626271350f86412ad905",
      "simhash64": 8638454424890410019,
      "normalized": "def NAME ( ) -> NAME : return NAME ( )"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "_are_spouses",
      "lineno": 42,
      "end_lineno": 44,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(person1_id, person2_id, reader)",
      "fingerprint": "b4c136a13be4d042b1192184d50a8549072a2391",
      "simhash64": 7488320761542640739,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME ) -> NAME : LIT return NAME ( NAME , NAME , NAME )"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "format_name",
      "lineno": 47,
      "end_lineno": 91,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 13,
      "loc": 45,
      "tags": [
        "impure",
        "regex",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "(name)",
      "fingerprint": "6955d017920d14d5d368d3080f36210808e56b84",
      "simhash64": 7487617073093710883,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME : LIT if not NAME or not NAME ( NAME , NAME ) : return LIT if NAME . NAME ( ) or NAME . NAME ( LIT , NAME ) : return NAME . NAME ( ) try : NAME = NAME . NAME ( ) # Handle GEDCOM slashes more robustly NAME = NAME . NAME ( LIT , LIT , NAME ) # Middle NAME = NAME . NAME ( LIT , LIT , NAME ) # Start NAME = NAME . NAME ( LIT , LIT , NAME ) # End # Split into words NAME = NAME . NAME ( ) NAME = [ ] for NAME in NAME : if not NAME : continue # Preserve fully uppercase words (likely initials/acronyms) if NAME . NAME ( ) and NAME ( NAME ) <= LIT : NAME . NAME ( NAME ) # Handle name particles and prefixes elif NAME . NAME ( ) in [ LIT , LIT , LIT ] : NAME . NAME ( NAME . NAME ( ) ) # Handle quoted nicknames elif NAME . NAME ( LIT ) and NAME . NAME ( LIT ) : NAME . NAME ( f' \" { NAME [ LIT : - LIT ] . NAME ( ) } \" ' ) # Regular title case else : NAME . NAME ( NAME . NAME ( ) ) return LIT . NAME ( NAME ) except NAME : # Fallback to basic title case return NAME . NAME ( )"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "_find_direct_relationship",
      "lineno": 124,
      "end_lineno": 160,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 37,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(id1, id2, id_to_parents, id_to_children)",
      "fingerprint": "8d7d979f1b84d7acf20735bc6a1860b77c133d6e",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME [ NAME ] ] , ) -> NAME [ NAME ] : LIT # Check if id2 is a parent of id1 if NAME in NAME . NAME ( NAME , NAME ( ) ) : return [ NAME , NAME ] # Check if id2 is a child of id1 if NAME in NAME . NAME ( NAME , NAME ( ) ) : return [ NAME , NAME ] # Check if id1 and id2 are siblings (share at least one parent) NAME = NAME . NAME ( NAME , NAME ( ) ) NAME = NAME . NAME ( NAME , NAME ( ) ) NAME = NAME . NAME ( NAME ) if NAME : # Use the first common parent NAME = NAME ( NAME ( NAME ) ) return [ NAME , NAME , NAME ] # No direct relationship found return [ ]"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "_has_direct_relationship",
      "lineno": 163,
      "end_lineno": 200,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 8,
      "loc": 38,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(id1, id2, id_to_parents, id_to_children)",
      "fingerprint": "46e5a8af5d4f65d390a071ebc8a580a88a5b91d7",
      "simhash64": 7488180022980019251,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME [ NAME ] ] , ) -> NAME : LIT # Parent-child relationship if NAME in NAME . NAME ( NAME , NAME ( ) ) or NAME in NAME . NAME ( NAME , NAME ( ) ) : return True # Sibling relationship (share at least one parent) NAME = NAME . NAME ( NAME , NAME ( ) ) NAME = NAME . NAME ( NAME , NAME ( ) ) if NAME and NAME and not NAME . NAME ( NAME ) : return True # Check for grandparent relationship for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME in NAME . NAME ( NAME , NAME ( ) ) : return True # Check for grandchild relationship return NAME ( NAME in NAME . NAME ( NAME , NAME ( ) ) for NAME in NAME . NAME ( NAME , NAME ( ) ) )"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "fast_bidirectional_bfs",
      "lineno": 206,
      "end_lineno": 398,
      "is_method": false,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 39,
      "loc": 193,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:large"
      ],
      "signature": "(start_id, end_id, id_to_parents, id_to_children, max_depth, node_limit, timeout_sec)",
      "fingerprint": "36a8b8e3a50f660c89d42e140f8c381c4a2d1ae6",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME [ NAME ] ] ] , NAME : NAME [ NAME [ NAME , NAME [ NAME ] ] ] , NAME = LIT , NAME = LIT , NAME = LIT , ) -> NAME [ NAME ] : LIT NAME = NAME . NAME ( ) if NAME == NAME : return [ NAME ] if NAME is None or NAME is None : NAME . NAME ( LIT ) return [ ] if not NAME or not NAME : NAME . NAME ( LIT ) return [ ] # First try to find a direct relationship (parent, child, sibling) # This is a quick check before running the full BFS NAME = NAME ( NAME , NAME , NAME , NAME ) if NAME : NAME . NAME ( f\" [FastBiBFS] Found direct relationship: { NAME } \" ) return NAME # Initialize BFS queues and visited sets # Forward queue from start_id NAME = NAME ( [ ( NAME , LIT , [ NAME ] ) ] ) # (id, depth, path) # Backward queue from end_id NAME = NAME ( [ ( NAME , LIT , [ NAME ] ) ] ) # (id, depth, path) # Track visited nodes and their paths NAME = { NAME : ( LIT , [ NAME ] ) } # {id: (depth, path)} NAME = { NAME : ( LIT , [ NAME ] ) } # {id: (depth, path)} # Track all complete paths found NAME = [ ] # Process nodes until we find paths or exhaust the search NAME = LIT NAME . NAME ( f\" [FastBiBFS] Starting BFS: { NAME } <-> { NAME } \" ) # Main search loop - continue until we find paths or exhaust the search while NAME and NAME and NAME ( NAME ) < LIT : # Limit to finding 5 paths # Check timeout and node limit if NAME . NAME ( ) - NAME > NAME : NAME . NAME ( f\" [FastBiBFS] Timeout after { NAME : .1f } seconds. \" ) break if NAME > NAME : NAME . NAME ( f\" [FastBiBFS] Node limit ( { NAME } ) reached. \" ) break # Process forward queue (from start) if NAME : NAME , NAME , NAME = NAME . NAME ( ) NAME += LIT # Check if we've reached a node visited by backward search if NAME in NAME : # Found a meeting point - reconstruct the path NAME , NAME = NAME [ NAME ] # depth unused # Combine paths (remove duplicate meeting point) NAME = NAME + NAME [ LIT : ] NAME . NAME ( NAME ) NAME . NAME ( f\" [FastBiBFS] Path found via { NAME } : { NAME ( NAME ) } nodes \" ) # Continue searching for potentially shorter/better paths if len(all_paths) < 5 if NAME ( NAME ) >= LIT : break # Stop if we have enough paths # Stop expanding if we've reached max depth if NAME >= NAME : continue # Expand to parents (direct relationship) for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME not in NAME : NAME = [ * NAME , NAME ] NAME [ NAME ] = ( NAME + LIT , NAME ) NAME . NAME ( ( NAME , NAME + LIT , NAME ) ) # Expand to children (direct relationship) for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME not in NAME : NAME = [ * NAME , NAME ] NAME [ NAME ] = ( NAME + LIT , NAME ) NAME . NAME ( ( NAME , NAME + LIT , NAME ) ) # Expand to siblings (through parent) for NAME in NAME . NAME ( NAME , NAME ( ) ) : for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME != NAME and NAME not in NAME : # Include parent in path for proper relationship context NAME = [ * NAME , NAME , NAME ] NAME [ NAME ] = ( NAME + LIT , NAME , ) # Depth increases by 2 (to parent, then to sibling) NAME . NAME ( ( NAME , NAME + LIT , NAME ) ) # Process backward queue (from end) if NAME : # Check if queue_bwd is not empty NAME , NAME , NAME = NAME . NAME ( ) NAME += LIT # Check if we've reached a node visited by forward search if NAME in NAME : # Found a meeting point - reconstruct the path NAME , NAME = NAME [ NAME ] # depth unused # Combine paths (remove duplicate meeting point) NAME = NAME + NAME [ LIT : ] NAME . NAME ( NAME ) NAME . NAME ( f\" [FastBiBFS] Path found via { NAME } : { NAME ( NAME ) } nodes \" ) if NAME ( NAME ) >= LIT : break # Stop if we have enough paths # Stop expanding if we've reached max depth if NAME >= NAME : continue # Expand to parents (direct relationship) for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME not in NAME : NAME = [ NAME , * NAME ] NAME [ NAME ] = ( NAME + LIT , NAME ) NAME . NAME ( ( NAME , NAME + LIT , NAME ) ) # Expand to children (direct relationship) for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME not in NAME : NAME = [ NAME , * NAME ] NAME [ NAME ] = ( NAME + LIT , NAME ) NAME . NAME ( ( NAME , NAME + LIT , NAME ) ) # Expand to siblings (through parent) for NAME in NAME . NAME ( NAME , NAME ( ) ) : for NAME in NAME . NAME ( NAME , NAME ( ) ) : if NAME != NAME and NAME not in NAME : # Include parent in path for proper relationship context NAME = [ NAME , NAME , * NAME ] NAME [ NAME ] = ( NAME + LIT , NAME ) NAME . NAME ( ( NAME , NAME + LIT , NAME ) ) # If we found paths, select the best one if NAME : # Score paths based on directness of relationships NAME = [ ] for NAME in NAME : # Renamed path to p to avoid conflict with outer scope # Check if each adjacent pair has a direct relationship NAME = LIT for NAME in NAME ( NAME ( NAME ) - LIT ) : if NAME ( NAME [ NAME ] , NAME [ NAME + LIT ] , NAME , NAME ) : NAME += LIT # Calculate score: prefer paths with more direct relationships and shorter length NAME = NAME / ( NAME ( NAME ) - LIT ) if NAME ( NAME ) > LIT else LIT NAME = NAME ( NAME ) / LIT # Slight penalty for longer paths NAME = NAME - NAME NAME . NAME ( ( NAME , NAME ) ) # Sort by score (highest first) NAME . NAME ( NAME = lambda NAME : NAME [ LIT ] , NAME = True ) # Return the path with the highest score NAME = NAME [ LIT ] [ LIT ] NAME . NAME ( f\" [FastBiBFS] Selected best path: { NAME ( NAME ) } nodes with score { NAME [ LIT ] [ LIT ] : .2f } \" ) return NAME # If we didn't find any paths NAME . NAME ( f\" [FastBiBFS] No paths found between { NAME } and { NAME } . \" ) # Fallback: Return a list containing only start and end IDs if no path found return [ NAME , NAME ]"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "explain_relationship_path",
      "lineno": 401,
      "end_lineno": 452,
      "is_method": false,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 52,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(path_ids, reader, id_to_parents, id_to_children, indi_index, owner_name, relationship_type)",
      "fingerprint": "baf7564f39ed3bb703a0cc0d6d82d01eaf6119f1",
      "simhash64": 5182337013767386147,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME ] , NAME : NAME = LIT , NAME : NAME = LIT , ) -> NAME : LIT if not NAME or NAME ( NAME ) < LIT : return LIT if NAME is None or NAME is None or NAME is None : return LIT # Convert the GEDCOM path to the unified format NAME = NAME ( NAME , NAME , NAME , NAME , NAME ) if not NAME : return LIT # Get the target name from the first person in the path NAME = NAME [ LIT ] . NAME ( LIT , LIT ) # Format the path using the unified formatter return NAME ( NAME , NAME if NAME is not None else LIT , NAME , NAME , )"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "format_api_relationship_path",
      "lineno": 455,
      "end_lineno": 674,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 13,
      "yield_count": 0,
      "complexity": 39,
      "loc": 220,
      "tags": [
        "impure",
        "filesystem",
        "regex",
        "purpose:formatting",
        "size:large"
      ],
      "signature": "(api_response_data, owner_name, target_name, relationship_type)",
      "fingerprint": "48a2e473e94ef3d75251a17adbfff0b96f05b7d0",
      "simhash64": 7488180022980023307,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME , None ] , NAME : NAME , NAME : NAME , NAME : NAME = LIT , ) -> NAME : LIT if not NAME : NAME . NAME ( LIT ) return LIT NAME : NAME [ NAME ] = None NAME : NAME [ NAME ] = None # Extract HTML content from API response if NAME ( NAME , NAME ) : # Handle JSONP response format: no({...}) NAME = NAME . NAME ( LIT , NAME , NAME . NAME ) # Added re.DOTALL if NAME : try : NAME = NAME . NAME ( LIT ) NAME = NAME ( NAME ) NAME = ( NAME . NAME ( LIT ) if NAME is not None else None ) except NAME as NAME : NAME . NAME ( f\" Error parsing JSONP response: { NAME } \" , NAME = True ) return f\" (Error parsing JSONP response: { NAME } ) \" else : # Direct HTML response NAME = NAME elif NAME ( NAME , NAME ) : # Handle direct JSON/dict response NAME = NAME NAME = NAME . NAME ( LIT ) if NAME is not None else None # Handle Discovery API JSON format if NAME and LIT in NAME : NAME = [ ] NAME = NAME [ LIT ] if NAME ( NAME , NAME ) and NAME : NAME . NAME ( LIT ) NAME . NAME ( f\" * { NAME ( NAME ) } \" ) for NAME in NAME : NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( None , NAME ) . NAME ( ) NAME . NAME ( f\" -> is { NAME } of \" ) NAME . NAME ( f\" * { NAME } \" ) NAME . NAME ( LIT ) NAME . NAME ( f\" * { NAME } (You) \" ) return LIT . NAME ( NAME ) # Process HTML content if available if not NAME : NAME . NAME ( LIT ) return LIT # Check if this is a simple text relationship description before trying HTML parsing if NAME and not NAME . NAME ( ) . NAME ( LIT ) : # Simple text processing for strings like \"John Doe is the father of Jane Doe\" NAME = NAME . NAME ( ) # Look for relationship patterns NAME = [ LIT , LIT , ] for NAME in NAME : NAME = NAME . NAME ( NAME , NAME , NAME . NAME ) if NAME : NAME = NAME . NAME ( LIT ) . NAME ( ) return f\" { NAME } is the { NAME } of { NAME } \" # If no pattern found, return the original text if NAME ( NAME in NAME . NAME ( ) for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] ) : return NAME if not NAME : NAME . NAME ( LIT ) return LIT # Decode HTML entities NAME = NAME . NAME ( NAME ) if NAME else LIT # Parse HTML with BeautifulSoup try : if not NAME or NAME is None : NAME . NAME ( LIT ) return LIT NAME = NAME ( NAME , LIT ) # Find all list items NAME = NAME . NAME ( LIT ) if not NAME or NAME ( NAME ) < LIT : NAME . NAME ( f\" Not enough list items found in HTML: { NAME ( NAME ) if NAME else LIT } \" ) return LIT # Extract relationship information NAME = [ ] for NAME in NAME : # Skip icon items - check if item is a Tag first try : if not NAME ( NAME , NAME ) : continue # Skip non-Tag elements NAME = NAME . NAME ( LIT ) == LIT NAME = NAME . NAME ( LIT ) if NAME is None : NAME = [ ] NAME = ( NAME ( NAME , NAME ) and LIT in NAME ) if NAME or NAME : continue except ( NAME , NAME ) : NAME . NAME ( f\" Error checking item attributes: { NAME ( NAME ) } \" ) continue # Extract name, relationship, and lifespan try : NAME = NAME . NAME ( LIT ) if NAME ( NAME , NAME ) else None NAME = ( NAME . NAME ( NAME = True ) # Added strip=True if NAME and NAME ( NAME , LIT ) else ( NAME ( NAME . NAME ) . NAME ( ) if NAME ( NAME , LIT ) and NAME . NAME else LIT ) # Added strip and check for item.string ) except ( NAME , NAME ) : NAME = LIT NAME . NAME ( f\" Error extracting name: { NAME ( NAME ) } \" ) # Extract relationship description try : NAME = NAME . NAME ( LIT ) if NAME ( NAME , NAME ) else None NAME = ( # Renamed to avoid conflict NAME . NAME ( NAME = True ) # Added strip=True if NAME and NAME ( NAME , LIT ) else LIT ) except ( NAME , NAME ) : NAME = LIT NAME . NAME ( f\" Error extracting relationship: { NAME ( NAME ) } \" ) # Extract lifespan try : NAME = ( NAME . NAME ( NAME = True ) if NAME ( NAME , LIT ) else NAME ( NAME ) ) # Added strip=True NAME = NAME . NAME ( LIT , NAME , NAME . NAME ) # Allow \"Living\" NAME = NAME . NAME ( LIT ) if NAME else LIT except ( NAME , NAME ) : NAME = LIT NAME . NAME ( f\" Error extracting lifespan: { NAME ( NAME ) } \" ) NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME } ) # Convert API relationship data to unified format and format it if NAME : # Convert the API data to the unified format NAME = NAME ( NAME , NAME ) if not NAME : return LIT # Format the path using the unified formatter return NAME ( NAME , NAME , NAME , NAME ) return LIT except NAME as NAME : NAME . NAME ( f\" Error parsing relationship HTML: { NAME } \" , NAME = True ) return f\" (Error parsing relationship HTML: { NAME } ) \""
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "convert_gedcom_path_to_unified_format",
      "lineno": 677,
      "end_lineno": 873,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 23,
      "loc": 197,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:large"
      ],
      "signature": "(path_ids, reader, id_to_parents, id_to_children, indi_index)",
      "fingerprint": "66574221eb9ea98566f701e1593d41a229e9c94f",
      "simhash64": 5182337013767377963,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME [ NAME ] ] , NAME : NAME [ NAME , NAME ] , ) -> NAME [ NAME [ NAME , NAME [ NAME ] ] ] : # Value type changed to Optional[str] LIT if not NAME or NAME ( NAME ) < LIT : return [ ] NAME : NAME [ NAME [ NAME , NAME [ NAME ] ] ] = [ ] # Ensure list type # Process the first person (no relationship) NAME = NAME [ LIT ] NAME = NAME . NAME ( NAME ) if NAME : # Get name NAME = NAME ( NAME ) # Get birth/death years NAME , NAME , NAME = NAME ( NAME , NAME ) NAME , NAME , NAME = NAME ( NAME , NAME ) NAME = NAME ( NAME . NAME ) if NAME else None NAME = NAME ( NAME . NAME ) if NAME else None # Get gender NAME = NAME . NAME ( NAME ) # Use imported constant NAME : NAME [ NAME ] = None # Ensure type if ( NAME and NAME ( NAME , LIT ) and NAME . NAME is not None ) : # Check value is not None NAME = NAME ( NAME . NAME ) . NAME ( ) if NAME in ( LIT , LIT ) : NAME = NAME # Add to result NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME , LIT : None , # First person has no relationship to previous person LIT : NAME , # Add gender information } ) else : # Handle missing first person NAME . NAME ( { LIT : f\" Unknown ( { NAME } ) \" , LIT : None , LIT : None , LIT : None , LIT : None , } ) # Process the rest of the path for NAME in NAME ( LIT , NAME ( NAME ) ) : NAME , NAME = NAME [ NAME - LIT ] , NAME [ NAME ] NAME = NAME . NAME ( NAME ) if not NAME : # Handle missing person NAME . NAME ( { LIT : f\" Unknown ( { NAME } ) \" , LIT : None , LIT : None , LIT : LIT , LIT : None , } ) continue # Get name NAME = NAME ( NAME ) # Get birth/death years NAME , NAME , NAME = NAME ( NAME , NAME ) NAME , NAME , NAME = NAME ( NAME , NAME ) NAME = NAME ( NAME . NAME ) if NAME else None NAME = NAME ( NAME . NAME ) if NAME else None # Determine gender for relationship terms NAME = NAME . NAME ( NAME ) # Use imported constant NAME = None if ( NAME and NAME ( NAME , LIT ) and NAME . NAME is not None ) : # Check value is not None NAME = NAME ( NAME . NAME ) . NAME ( ) if NAME in ( LIT , LIT ) : NAME = NAME # Determine relationship NAME : NAME [ NAME ] = LIT # Default # Check if current is a PARENT of prev if NAME in NAME . NAME ( NAME , NAME ( ) ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) # Check if current is a CHILD of prev elif NAME in NAME . NAME ( NAME , NAME ( ) ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) # Check if current is a SIBLING of prev elif NAME ( NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) # Check if current is a SPOUSE of prev elif NAME ( NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) # Check for grandparent elif NAME ( NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) # Check for grandchild elif NAME ( NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) # Check for great-grandparent elif NAME ( NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) # Check for great-grandchild elif NAME ( NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) # Check for aunt/uncle elif NAME ( NAME , NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) # Check for niece/nephew elif NAME ( NAME , NAME , NAME , NAME ) : NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) # Check for cousins elif NAME ( NAME , NAME , NAME , NAME ) : NAME = LIT # Add to result NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , # Add gender information } ) return NAME"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "convert_discovery_api_path_to_unified_format",
      "lineno": 876,
      "end_lineno": 981,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 18,
      "loc": 106,
      "tags": [
        "pure-ish",
        "regex",
        "purpose:formatting",
        "size:large"
      ],
      "signature": "(discovery_data, target_name)",
      "fingerprint": "db2de07750eaa23a084de1691e4990347d716ac6",
      "simhash64": 5146309317400892459,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME [ NAME , NAME [ NAME ] ] ] : # Value type changed to Optional[str] LIT if ( not NAME or not NAME ( NAME , NAME ) or LIT not in NAME ) : NAME . NAME ( LIT ) return [ ] NAME = NAME . NAME ( LIT , [ ] ) if not NAME ( NAME , NAME ) or not NAME : NAME . NAME ( LIT ) return [ ] NAME : NAME [ NAME [ NAME , NAME [ NAME ] ] ] = [ ] # Ensure list type # Process the first person (target) # The Discovery API doesn't include the target person in the path, so we add them manually NAME = NAME ( NAME ) # Add first person to result NAME . NAME ( { LIT : NAME , LIT : None , # Discovery API doesn't provide birth/death years LIT : None , LIT : None , # First person has no relationship to previous person LIT : None , # Discovery API doesn't provide gender information } ) # Process each step in the path for NAME in NAME : if not NAME ( NAME , NAME ) : NAME . NAME ( f\" Invalid path step: { NAME } \" ) continue # Get name NAME = NAME . NAME ( LIT , LIT ) NAME = NAME ( NAME ) # Get relationship NAME : NAME [ NAME ] = LIT # Ensure type NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) # Determine gender and relationship term from relationship text NAME : NAME [ NAME ] = None # Ensure type if LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT else : # Try to extract the relationship term from the text NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME = NAME . NAME ( LIT ) # Try to determine gender from relationship term if NAME in [ LIT , LIT , LIT , LIT ] : NAME = LIT elif NAME in [ LIT , LIT , LIT , LIT ] : NAME = LIT # Add to result NAME . NAME ( { LIT : NAME , LIT : None , # Discovery API doesn't provide birth/death years LIT : None , LIT : NAME , LIT : NAME , } ) return NAME"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "convert_api_path_to_unified_format",
      "lineno": 984,
      "end_lineno": 1301,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 46,
      "loc": 318,
      "tags": [
        "pure-ish",
        "regex",
        "purpose:formatting",
        "size:large"
      ],
      "signature": "(relationship_data, target_name)",
      "fingerprint": "fac18dae0bde29df4fcbe45972682d92167acc15",
      "simhash64": 5146448955376571435,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME ) -> NAME [ NAME [ NAME , NAME [ NAME ] ] ] : # Value type changed to Optional[str] LIT if not NAME : return [ ] NAME : NAME [ NAME [ NAME , NAME [ NAME ] ] ] = [ ] # Ensure list type # Process the first person (target) NAME = NAME [ LIT ] NAME = NAME ( NAME . NAME ( LIT , NAME ) ) NAME = NAME . NAME ( LIT , LIT ) # Extract birth/death years NAME : NAME [ NAME ] = None # Ensure type NAME : NAME [ NAME ] = None # Ensure type if NAME : NAME = NAME . NAME ( LIT , NAME , NAME . NAME ) # Allow \"Living\" if NAME : NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = None if NAME == LIT or NAME . NAME ( ) == LIT else NAME # Determine gender from name and other information NAME : NAME [ NAME ] = ( NAME . NAME ( LIT , LIT ) . NAME ( ) or None ) # Ensure None if empty # If gender is not explicitly provided, try to infer from the name if not NAME : # Check if the name contains gender-specific titles or common names NAME = NAME . NAME ( ) # Check for male indicators if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] ) : NAME = LIT NAME . NAME ( f\" Inferred male gender for { NAME } based on name \" ) # Check for female indicators elif NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] ) : NAME = LIT NAME . NAME ( f\" Inferred female gender for { NAME } based on name \" ) # If we still don't have gender, try to infer from relationship text if available if not NAME and NAME ( NAME ) > LIT : NAME = NAME [ LIT ] . NAME ( LIT , LIT ) . NAME ( ) if ( LIT in NAME or LIT in NAME or LIT in NAME or LIT in NAME or LIT in NAME or LIT in NAME or LIT in NAME ) : NAME = LIT NAME . NAME ( f\" Inferred male gender for { NAME } from relationship text: { NAME } \" ) elif ( LIT in NAME or LIT in NAME or LIT in NAME or LIT in NAME or LIT in NAME or LIT in NAME or LIT in NAME ) : NAME = LIT NAME . NAME ( f\" Inferred female gender for { NAME } from relationship text: { NAME } \" ) # Special case for Gordon Milne if LIT in NAME . NAME ( ) : NAME = LIT NAME . NAME ( LIT ) # Add first person to result NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME , LIT : None , # First person has no relationship to previous person LIT : NAME , # Add gender information } ) # Process the rest of the path for NAME in NAME ( LIT , NAME ( NAME ) ) : NAME = NAME [ NAME ] # Get name NAME = NAME ( NAME . NAME ( LIT , LIT ) ) # Remove any year suffixes like \"1943-Brother Of Fraser Gault\" NAME = NAME . NAME ( LIT , LIT , NAME ) # Get lifespan NAME = NAME . NAME ( LIT , LIT ) NAME : NAME [ NAME ] = None # Ensure type NAME : NAME [ NAME ] = None # Ensure type if NAME : NAME = NAME . NAME ( LIT , NAME , NAME . NAME ) # Allow \"Living\" if NAME : NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) if ( NAME == LIT or NAME . NAME ( ) == LIT ) : NAME = None else : NAME = NAME # Get relationship NAME : NAME [ NAME ] = LIT # Ensure type NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) # Determine gender from relationship text and name NAME : NAME [ NAME ] = ( NAME . NAME ( LIT , LIT ) . NAME ( ) or None ) # Ensure type # If gender is not explicitly provided, try to infer from relationship text if not NAME : if LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT elif LIT in NAME : NAME = LIT NAME = LIT else : # Try to extract the relationship term from the text NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME = NAME . NAME ( LIT ) # Try to determine gender from relationship term if NAME in [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] : NAME = LIT elif NAME in [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] : NAME = LIT # If we still don't have gender, try to infer from the name if not NAME : NAME = NAME . NAME ( ) # Check for male indicators if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] ) : NAME = LIT NAME . NAME ( f\" Inferred male gender for { NAME } based on name \" ) # Check for female indicators elif NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] ) : NAME = LIT NAME . NAME ( f\" Inferred female gender for { NAME } based on name \" ) # Special case for Gordon Milne if LIT in NAME . NAME ( ) : NAME = LIT NAME . NAME ( LIT ) # Add to result NAME . NAME ( { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , # Add gender information } ) return NAME"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "format_relationship_path_unified",
      "lineno": 1304,
      "end_lineno": 1564,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 50,
      "loc": 261,
      "tags": [
        "impure",
        "filesystem",
        "regex",
        "purpose:formatting",
        "size:large"
      ],
      "signature": "(path_data, target_name, owner_name, relationship_type)",
      "fingerprint": "cfbdef5a564a931da3620ebb9b810fafb9bcdea2",
      "simhash64": 7452151226029216827,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME [ NAME ] ] ] , # Value type changed to Optional[str] NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None , ) -> NAME : LIT if not NAME or NAME ( NAME ) < LIT : return f\" (No relationship path data available for { NAME } ) \" # Format the header NAME = f\" ===Relationship Path to { NAME } === \" # Format the target person with birth/death years NAME = NAME [ LIT ] NAME = NAME # Add birth/death years if available NAME = LIT NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) if NAME and NAME : NAME = f\" ( { NAME } - { NAME } ) \" elif NAME : NAME = f\" (b. { NAME } ) \" elif NAME : # Handle case where only death year is known NAME = f\" (d. { NAME } ) \" # Determine the specific relationship type if not provided if NAME is None or NAME == LIT : # Try to determine the relationship type based on the path if NAME ( NAME ) >= LIT : # Check for common relationship patterns # Uncle/Aunt: Target's sibling is parent of owner if NAME [ LIT ] . NAME ( LIT ) in [ LIT , LIT ] and NAME [ LIT ] . NAME ( LIT ) in [ LIT , LIT ] : NAME = NAME [ LIT ] . NAME ( LIT ) NAME = NAME ( NAME ) if NAME is not None else LIT NAME = LIT if NAME . NAME ( ) == LIT else LIT # Uncle/Aunt: Target's parent's child is parent of owner (through parent) elif ( NAME [ LIT ] . NAME ( LIT ) in [ LIT , LIT ] and NAME ( NAME ) >= LIT ) : # This block was previously broken and contained unfinished logic. # If the third person in the path is a son or daughter, and the target's gender is known, set uncle/aunt. if NAME [ LIT ] . NAME ( LIT ) in [ LIT , LIT ] : NAME = NAME [ LIT ] . NAME ( LIT ) NAME = NAME ( NAME ) if NAME is not None else LIT NAME = ( LIT if NAME . NAME ( ) == LIT else LIT if NAME . NAME ( ) == LIT else LIT ) # Grandparent: Target's child is parent of owner elif NAME [ LIT ] . NAME ( LIT ) in [ LIT , LIT ] and NAME [ LIT ] . NAME ( LIT ) in [ LIT , LIT ] : # Check the gender of the first person in the path NAME = NAME [ LIT ] . NAME ( LIT , LIT ) NAME = ( NAME . NAME ( ) if NAME ( NAME , NAME ) else None ) # Ensure None if not a string # If gender is not explicitly set, try to infer from the name if not NAME : NAME = NAME [ LIT ] . NAME ( LIT ) NAME = NAME ( NAME ) . NAME ( ) if NAME is not None else LIT # Common male names or titles if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] ) : NAME = LIT # Common female names or titles elif NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] ) : NAME = LIT # Debug log to see what's happening NAME . NAME ( f\" Grandparent relationship: name= { NAME [ LIT ] . NAME ( LIT ) } , gender= { NAME } , raw gender= { NAME [ LIT ] . NAME ( LIT ) } \" ) # Force gender to M for Gordon Milne NAME = NAME [ LIT ] . NAME ( LIT ) if NAME ( NAME , NAME ) and LIT in NAME . NAME ( ) : NAME = LIT NAME . NAME ( LIT ) # Special case for Gordon Milne (1920-1994) NAME = NAME [ LIT ] . NAME ( LIT ) if ( NAME ( NAME , NAME ) and LIT in NAME . NAME ( ) and LIT in NAME ( NAME [ LIT ] . NAME ( LIT , LIT ) ) ) : NAME = LIT NAME . NAME ( LIT ) NAME = ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) # Added fallback # Cousin: Target's parent's sibling's child is owner elif ( NAME [ LIT ] . NAME ( LIT ) in [ LIT , LIT ] and NAME ( NAME ) >= LIT ) : if NAME [ LIT ] . NAME ( LIT ) in [ LIT , LIT , ] and NAME [ LIT ] . NAME ( LIT ) in [ LIT , LIT ] : NAME = LIT # Nephew/Niece: Target's parent's child is owner elif NAME [ LIT ] . NAME ( LIT ) in [ LIT , LIT ] and NAME [ LIT ] . NAME ( LIT ) in [ LIT , LIT ] : # This logic determines if TARGET is Nephew/Niece of OWNER. # The current phrasing \"owner_name.endswith(\"Gault\") and \"Wayne\" in owner_name\" # seems to be a specific rule for a particular owner. # A more general approach would be to check the gender of the TARGET. NAME = NAME [ LIT ] . NAME ( LIT ) NAME = ( NAME ( NAME ) . NAME ( ) if NAME is not None else LIT ) if NAME == LIT : NAME = LIT elif NAME == LIT : NAME = LIT else : # Fallback if gender unknown NAME = LIT # Default to \"relative\" if we couldn't determine a specific relationship NAME = NAME or LIT # Format the summary line NAME = f\" { NAME } { NAME } is { NAME } 's { NAME } : \" # Format each step in the path NAME = [ ] # Keep track of names we've already seen to avoid adding years multiple times NAME = NAME ( ) NAME . NAME ( NAME . NAME ( ) ) # Add the first person to seen names for NAME in NAME ( NAME ( NAME ) - LIT ) : NAME = NAME [ NAME ] NAME = NAME [ NAME + LIT ] # Get names NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) # Get relationship NAME = NAME . NAME ( LIT , LIT ) # Format the line using possessive form # Remove Name('...') if present - handle both single and double quotes if NAME ( NAME , NAME ) : # Try different regex patterns to handle various Name formats if LIT in NAME : NAME = NAME . NAME ( LIT , LIT , NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) else : NAME = NAME else : NAME = NAME ( NAME ) if NAME ( NAME , NAME ) : # Try different regex patterns to handle various Name formats if LIT in NAME : NAME = NAME . NAME ( LIT , LIT , NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) else : NAME = NAME else : NAME = NAME ( NAME ) # Format years for current person - only if we haven't seen this name before NAME = LIT if NAME . NAME ( ) not in NAME : NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) if NAME and NAME : NAME = f\" ( { NAME } - { NAME } ) \" elif NAME : NAME = f\" (b. { NAME } ) \" elif NAME : # Handle case where only death year is known NAME = f\" (d. { NAME } ) \" # Add to seen names NAME . NAME ( NAME . NAME ( ) ) # Format years for next person - only if we haven't seen this name before NAME = LIT if NAME . NAME ( ) not in NAME : NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) if NAME and NAME : NAME = f\" ( { NAME } - { NAME } ) \" elif NAME : NAME = f\" (b. { NAME } ) \" elif NAME : # Handle case where only death year is known NAME = f\" (d. { NAME } ) \" # Add to seen names NAME . NAME ( NAME . NAME ( ) ) NAME = f\" - { NAME } { NAME } 's { NAME } is { NAME } { NAME } \" NAME . NAME ( NAME ) # Combine all parts return f\" { NAME } \\n { NAME } \\n\\n \" + LIT . NAME ( NAME ) # Renamed result to result_str"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "_get_relationship_term",
      "lineno": 1567,
      "end_lineno": 1613,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 10,
      "yield_count": 0,
      "complexity": 12,
      "loc": 47,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(gender, relationship_code)",
      "fingerprint": "8bf7ebaab5c3f3cdb0c2fa223a7704a47010a6c5",
      "simhash64": 5762870348607821355,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME ) -> NAME : LIT NAME = NAME . NAME ( ) # Use a different variable name # Direct relationships if NAME == LIT : return LIT if NAME == LIT else LIT if NAME == LIT else LIT if NAME == LIT : return LIT if NAME == LIT else LIT if NAME == LIT else LIT if NAME == LIT : return LIT if NAME == LIT else LIT if NAME == LIT else LIT if NAME == LIT : return LIT if NAME == LIT else LIT if NAME == LIT else LIT # Extended relationships if LIT in NAME : return ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) if LIT in NAME : return ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) if LIT in NAME or LIT in NAME : return LIT if NAME == LIT else LIT if NAME == LIT else LIT if LIT in NAME or LIT in NAME : return ( LIT if NAME == LIT else LIT if NAME == LIT else LIT ) if LIT in NAME : return LIT # Default return NAME # Return original if no match"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "relationship_module_tests",
      "lineno": 1616,
      "end_lineno": 1793,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 12,
      "loc": 178,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "5bde9f0a048a95234a35e838de04204358a132cb",
      "simhash64": 7451729014570783787,
      "normalized": "def NAME ( ) -> None : LIT import NAME NAME = [ ] # Test 1: Function availability def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT ] from NAME import NAME return NAME ( NAME , NAME ( ) , LIT ) NAME . NAME ( ( LIT , NAME ) ) # Test 2: Name formatting def NAME ( ) : LIT NAME = [ ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( None , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME , NAME in NAME : try : NAME = NAME ( NAME ) NAME = NAME == NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" Input: { NAME ! NAME } \u2192 Output: { NAME ! NAME } (Expected: { NAME ! NAME } ) \" ) NAME . NAME ( NAME ) assert ( NAME == NAME ) , f\" format_name( { NAME } ) should return { NAME } , got { NAME } \" except NAME as NAME : NAME ( f\" \u274c { NAME } \" ) NAME ( f\" Input: { NAME ! NAME } \u2192 Error: { NAME } \" ) NAME . NAME ( False ) raise NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } name formatting tests passed \" ) NAME . NAME ( ( LIT , NAME ) ) # Test 3: Bidirectional BFS pathfinding def NAME ( ) : LIT # Simple family tree: Grandparent -> Parent -> Child NAME = { LIT : { LIT } , # Parent has Grandparent LIT : { LIT } , # Child has Parent } NAME = { LIT : { LIT } , # Grandparent has Parent LIT : { LIT } , # Parent has Child } NAME ( LIT ) NAME = [ ] # Test 1: Multi-generation path finding try : NAME = NAME ( LIT , LIT , NAME , NAME ) NAME = NAME ( NAME , NAME ) and NAME ( NAME ) >= LIT NAME = LIT if NAME else LIT NAME ( f\" { NAME } Multi-generation pathfinding \" ) NAME ( f\" From: @I001@ \u2192 To: @I003@, Path: { NAME } , Length: { NAME ( NAME ) if NAME else LIT } \" ) NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME ) >= LIT , LIT except NAME as NAME : NAME ( LIT ) NAME ( f\" Error: { NAME } \" ) NAME . NAME ( False ) raise # Test 2: Same person path try : NAME = NAME ( LIT , LIT , NAME , NAME ) NAME = NAME ( NAME , NAME ) and NAME ( NAME ) == LIT NAME = LIT if NAME else LIT NAME ( f\" { NAME } Same person pathfinding \" ) NAME ( f\" From: @I001@ \u2192 To: @I001@, Path: { NAME } , Length: { NAME ( NAME ) if NAME else LIT } \" ) NAME . NAME ( NAME ) assert NAME ( NAME ) == LIT , LIT except NAME as NAME : NAME ( LIT ) NAME ( f\" Error: { NAME } \" ) NAME . NAME ( False ) raise # Test 3: No path available try : NAME = NAME ( LIT , LIT , NAME , NAME ) NAME = NAME is None or ( NAME ( NAME , NAME ) and NAME ( NAME ) == LIT ) NAME = LIT if NAME else LIT NAME ( f\" { NAME } No path available handling \" ) NAME ( f\" From: @I001@ \u2192 To: @I999@ (non-existent), Result: { NAME } \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( LIT ) NAME ( f\" Error: { NAME } \" ) NAME . NAME ( False ) # Don't raise for this test as it might be expected behavior NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } BFS pathfinding tests passed \" ) NAME . NAME ( ( LIT , NAME ) ) # Test 4: Relationship term mapping def NAME ( ) : NAME = [ ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( None , LIT , LIT ) , # Unknown gender fallback ] for NAME , NAME , NAME in NAME : NAME = NAME ( NAME , NAME ) assert ( NAME == NAME ) , f\" Term for { NAME } / { NAME } should be { NAME } \" NAME . NAME ( ( LIT , NAME ) ) # Test 5: Performance validation def NAME ( ) : # Test name formatting performance NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( LIT ) NAME ( LIT ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Name formatting should be fast, took { NAME : .3f } s \" NAME . NAME ( ( LIT , NAME ) ) return NAME"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_function_availability",
      "lineno": 1623,
      "end_lineno": 1632,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "4754398a471239b6e446da012fa119d43d63338e",
      "simhash64": 5143634175473390635,
      "normalized": "def NAME ( ) : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT ] from NAME import NAME return NAME ( NAME , NAME ( ) , LIT )"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_name_formatting",
      "lineno": 1637,
      "end_lineno": 1674,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 38,
      "tags": [
        "impure",
        "logging",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "8bb915e9dbf5f061e9e2d47501b66fafcd81987b",
      "simhash64": 7433714616061301803,
      "normalized": "def NAME ( ) : LIT NAME = [ ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( None , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME , NAME in NAME : try : NAME = NAME ( NAME ) NAME = NAME == NAME NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } \" ) NAME ( f\" Input: { NAME ! NAME } \u2192 Output: { NAME ! NAME } (Expected: { NAME ! NAME } ) \" ) NAME . NAME ( NAME ) assert ( NAME == NAME ) , f\" format_name( { NAME } ) should return { NAME } , got { NAME } \" except NAME as NAME : NAME ( f\" \u274c { NAME } \" ) NAME ( f\" Input: { NAME ! NAME } \u2192 Error: { NAME } \" ) NAME . NAME ( False ) raise NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } name formatting tests passed \" )"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_bfs_pathfinding",
      "lineno": 1679,
      "end_lineno": 1760,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 8,
      "loc": 82,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "96d98ffb4fbbaae98d7545b314c75c90d53ce869",
      "simhash64": 7487757811588699707,
      "normalized": "def NAME ( ) : LIT # Simple family tree: Grandparent -> Parent -> Child NAME = { LIT : { LIT } , # Parent has Grandparent LIT : { LIT } , # Child has Parent } NAME = { LIT : { LIT } , # Grandparent has Parent LIT : { LIT } , # Parent has Child } NAME ( LIT ) NAME = [ ] # Test 1: Multi-generation path finding try : NAME = NAME ( LIT , LIT , NAME , NAME ) NAME = NAME ( NAME , NAME ) and NAME ( NAME ) >= LIT NAME = LIT if NAME else LIT NAME ( f\" { NAME } Multi-generation pathfinding \" ) NAME ( f\" From: @I001@ \u2192 To: @I003@, Path: { NAME } , Length: { NAME ( NAME ) if NAME else LIT } \" ) NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME ) >= LIT , LIT except NAME as NAME : NAME ( LIT ) NAME ( f\" Error: { NAME } \" ) NAME . NAME ( False ) raise # Test 2: Same person path try : NAME = NAME ( LIT , LIT , NAME , NAME ) NAME = NAME ( NAME , NAME ) and NAME ( NAME ) == LIT NAME = LIT if NAME else LIT NAME ( f\" { NAME } Same person pathfinding \" ) NAME ( f\" From: @I001@ \u2192 To: @I001@, Path: { NAME } , Length: { NAME ( NAME ) if NAME else LIT } \" ) NAME . NAME ( NAME ) assert NAME ( NAME ) == LIT , LIT except NAME as NAME : NAME ( LIT ) NAME ( f\" Error: { NAME } \" ) NAME . NAME ( False ) raise # Test 3: No path available try : NAME = NAME ( LIT , LIT , NAME , NAME ) NAME = NAME is None or ( NAME ( NAME , NAME ) and NAME ( NAME ) == LIT ) NAME = LIT if NAME else LIT NAME ( f\" { NAME } No path available handling \" ) NAME ( f\" From: @I001@ \u2192 To: @I999@ (non-existent), Result: { NAME } \" ) NAME . NAME ( NAME ) except NAME as NAME : NAME ( LIT ) NAME ( f\" Error: { NAME } \" ) NAME . NAME ( False ) # Don't raise for this test as it might be expected behavior NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } BFS pathfinding tests passed \" )"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_relationship_terms",
      "lineno": 1765,
      "end_lineno": 1777,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b99dd924e4b5c1f352fb550ddd52a2a40e7720fa",
      "simhash64": 5127871576779166763,
      "normalized": "def NAME ( ) : NAME = [ ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ( None , LIT , LIT ) , # Unknown gender fallback ] for NAME , NAME , NAME in NAME : NAME = NAME ( NAME , NAME ) assert ( NAME == NAME ) , f\" Term for { NAME } / { NAME } should be { NAME } \""
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_performance",
      "lineno": 1782,
      "end_lineno": 1789,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "263a90052dc591b2b3e57c6f19c7a28961e02f66",
      "simhash64": 8640714500569207867,
      "normalized": "def NAME ( ) : # Test name formatting performance NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( LIT ) NAME ( LIT ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Name formatting should be fast, took { NAME : .3f } s \""
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 1796,
      "end_lineno": 2090,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 17,
      "loc": 295,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "11f71dc2704c5157d0146c616c0d8577c9863143",
      "simhash64": 5145885970997351467,
      "normalized": "def NAME ( ) -> NAME : LIT NAME ( LIT ) # Quick basic test first try : # Test basic name formatting NAME = NAME ( LIT ) assert NAME == LIT NAME ( LIT ) NAME ( LIT ) except NAME as NAME : NAME ( f\" \u274c Basic Relationship Utils tests failed: { NAME } \" ) return False with NAME ( ) : NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # Name formatting functionality def NAME ( ) : # Test normal name assert NAME ( LIT ) == LIT # Test empty/None name - returns \"Valued Relative\" assert NAME ( None ) == LIT assert NAME ( LIT ) == LIT # Test name with extra spaces NAME = NAME ( LIT ) assert LIT in NAME and LIT in NAME # Test special characters and GEDCOM slashes NAME = NAME ( LIT ) assert LIT in NAME and LIT in NAME # Test title case conversion NAME = NAME ( LIT ) assert LIT in NAME and LIT in NAME # Bidirectional BFS functionality def NAME ( ) : # Create test relationship data NAME = { LIT : { LIT , LIT } , LIT : { LIT , LIT } , LIT : { LIT } , } NAME = { LIT : { LIT , LIT } , LIT : { LIT } , LIT : { LIT } , LIT : { LIT } , } # Test path finding NAME = NAME ( LIT , LIT , NAME , NAME ) assert NAME is not None , LIT assert NAME ( NAME ) >= LIT , LIT assert NAME [ LIT ] == LIT , LIT assert NAME [ - LIT ] == LIT , LIT # GEDCOM path conversion functionality def NAME ( ) : # Create mock GEDCOM data class NAME : def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : return { LIT : f\" Person { NAME } \" , LIT : NAME } NAME = NAME ( ) NAME = [ LIT , LIT ] NAME = { LIT : { LIT } } NAME = { LIT : { LIT } } NAME = { LIT : { LIT : LIT } , LIT : { LIT : LIT } } try : NAME = NAME ( NAME , NAME , NAME , NAME , NAME ) assert NAME is not None , LIT assert NAME ( NAME , NAME ) , LIT except NAME : # Function might require more complex setup, so pass if it fails gracefully pass # Discovery API path conversion def NAME ( ) : # Test function availability assert NAME ( NAME ) , LIT # Test with minimal valid data structure (if we can determine it) try : # This function requires specific data format - test that it's available NAME = NAME assert NAME is not None , LIT except NAME : # Complex function - just verify it exists pass # General API path conversion def NAME ( ) : # Test function availability assert NAME ( NAME ) , LIT # Test basic availability try : NAME = NAME assert NAME is not None , LIT except NAME : # Complex function - just verify it exists pass # Unified path formatting def NAME ( ) : # Test function availability assert NAME ( NAME ) , LIT # Test basic availability try : NAME = NAME assert NAME is not None , LIT except NAME : # Complex function - just verify it exists pass # API relationship path formatting def NAME ( ) : # Test function availability assert NAME ( NAME ) , LIT # Test basic availability try : NAME = NAME assert NAME is not None , LIT except NAME : # Complex function - just verify it exists pass # Error handling def NAME ( ) : # Test with None inputs assert NAME ( None ) == LIT # Test with empty string assert NAME ( LIT ) == LIT # Test with whitespace NAME = NAME ( LIT ) assert NAME == LIT , LIT # Test name formatting handles various edge cases NAME = [ LIT , # lowercase LIT , # uppercase LIT , # GEDCOM format LIT , # extra spaces ] for NAME in NAME : NAME = NAME ( NAME ) assert NAME ( NAME , NAME ) , f\" Should return string for: { NAME } \" assert NAME ( NAME ) > LIT , f\" Should return non-empty string for: { NAME } \" # Performance validation def NAME ( ) : import NAME # Test name formatting performance NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( f\" Person { NAME } \" ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Name formatting too slow: { NAME : .3f } s \" # Test BFS performance with small dataset NAME = { NAME ( NAME ) : { NAME ( NAME - LIT ) } for NAME in NAME ( LIT , LIT ) } NAME = { NAME ( NAME ) : { NAME ( NAME + LIT ) } for NAME in NAME ( LIT ) } NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( LIT , LIT , NAME , NAME ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" BFS too slow: { NAME : .3f } s \" # Function availability test def NAME ( ) : # Verify all major functions are available NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ] from NAME import NAME NAME ( NAME , NAME ( ) , LIT ) # Run all tests with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_name_formatting",
      "lineno": 1823,
      "end_lineno": 1841,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5be4c9ce663f9e47b93c6eb90e59cb6ebadf29fd",
      "simhash64": 7452291964556711475,
      "normalized": "def NAME ( ) : # Test normal name assert NAME ( LIT ) == LIT # Test empty/None name - returns \"Valued Relative\" assert NAME ( None ) == LIT assert NAME ( LIT ) == LIT # Test name with extra spaces NAME = NAME ( LIT ) assert LIT in NAME and LIT in NAME # Test special characters and GEDCOM slashes NAME = NAME ( LIT ) assert LIT in NAME and LIT in NAME # Test title case conversion NAME = NAME ( LIT ) assert LIT in NAME and LIT in NAME"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_bidirectional_bfs",
      "lineno": 1844,
      "end_lineno": 1865,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 22,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "1e0606dd73848880275b6fd5916ffc69906987a4",
      "simhash64": 5147012970403239467,
      "normalized": "def NAME ( ) : # Create test relationship data NAME = { LIT : { LIT , LIT } , LIT : { LIT , LIT } , LIT : { LIT } , } NAME = { LIT : { LIT , LIT } , LIT : { LIT } , LIT : { LIT } , LIT : { LIT } , } # Test path finding NAME = NAME ( LIT , LIT , NAME , NAME ) assert NAME is not None , LIT assert NAME ( NAME ) >= LIT , LIT assert NAME [ LIT ] == LIT , LIT assert NAME [ - LIT ] == LIT , LIT"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_gedcom_path_conversion",
      "lineno": 1868,
      "end_lineno": 1888,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f6f969b22619fc8b555398139fab37485168de9a",
      "simhash64": 7453417830071309883,
      "normalized": "def NAME ( ) : # Create mock GEDCOM data class NAME : def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : return { LIT : f\" Person { NAME } \" , LIT : NAME } NAME = NAME ( ) NAME = [ LIT , LIT ] NAME = { LIT : { LIT } } NAME = { LIT : { LIT } } NAME = { LIT : { LIT : LIT } , LIT : { LIT : LIT } } try : NAME = NAME ( NAME , NAME , NAME , NAME , NAME ) assert NAME is not None , LIT assert NAME ( NAME , NAME ) , LIT except NAME : # Function might require more complex setup, so pass if it fails gracefully pass"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "MockReader.get_element_by_id",
      "lineno": 1871,
      "end_lineno": 1872,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self, id_val)",
      "fingerprint": "6f0d9abcd880aa62a34f7436e12ed2b8adffbe54",
      "simhash64": 7452291964524205115,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : return { LIT : f\" Person { NAME } \" , LIT : NAME }"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_discovery_api_conversion",
      "lineno": 1891,
      "end_lineno": 1904,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3f8fc2e0425d7fde4f6fb69265057f0793d74cac",
      "simhash64": 5146484087656985653,
      "normalized": "def NAME ( ) : # Test function availability assert NAME ( NAME ) , LIT # Test with minimal valid data structure (if we can determine it) try : # This function requires specific data format - test that it's available NAME = NAME assert NAME is not None , LIT except NAME : # Complex function - just verify it exists pass"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_general_api_conversion",
      "lineno": 1907,
      "end_lineno": 1919,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9b8cb611afa033da1b9c9ec68c199acb1e22ad3d",
      "simhash64": 6299396796724450935,
      "normalized": "def NAME ( ) : # Test function availability assert NAME ( NAME ) , LIT # Test basic availability try : NAME = NAME assert NAME is not None , LIT except NAME : # Complex function - just verify it exists pass"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_unified_path_formatting",
      "lineno": 1922,
      "end_lineno": 1932,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9b8cb611afa033da1b9c9ec68c199acb1e22ad3d",
      "simhash64": 6299396796724450935,
      "normalized": "def NAME ( ) : # Test function availability assert NAME ( NAME ) , LIT # Test basic availability try : NAME = NAME assert NAME is not None , LIT except NAME : # Complex function - just verify it exists pass"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_api_relationship_formatting",
      "lineno": 1935,
      "end_lineno": 1945,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9b8cb611afa033da1b9c9ec68c199acb1e22ad3d",
      "simhash64": 6299396796724450935,
      "normalized": "def NAME ( ) : # Test function availability assert NAME ( NAME ) , LIT # Test basic availability try : NAME = NAME assert NAME is not None , LIT except NAME : # Complex function - just verify it exists pass"
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_error_handling",
      "lineno": 1948,
      "end_lineno": 1970,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 23,
      "tags": [
        "impure",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "1a54231c7002d3d3f2677382df65dc853a0aa9ec",
      "simhash64": 5146448921219732531,
      "normalized": "def NAME ( ) : # Test with None inputs assert NAME ( None ) == LIT # Test with empty string assert NAME ( LIT ) == LIT # Test with whitespace NAME = NAME ( LIT ) assert NAME == LIT , LIT # Test name formatting handles various edge cases NAME = [ LIT , # lowercase LIT , # uppercase LIT , # GEDCOM format LIT , # extra spaces ] for NAME in NAME : NAME = NAME ( NAME ) assert NAME ( NAME , NAME ) , f\" Should return string for: { NAME } \" assert NAME ( NAME ) > LIT , f\" Should return non-empty string for: { NAME } \""
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_performance",
      "lineno": 1973,
      "end_lineno": 1993,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 21,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "82e5f2d43067bbfc5d0e5da186dd41ada34147e0",
      "simhash64": 7487617039741654075,
      "normalized": "def NAME ( ) : import NAME # Test name formatting performance NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( f\" Person { NAME } \" ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Name formatting too slow: { NAME : .3f } s \" # Test BFS performance with small dataset NAME = { NAME ( NAME ) : { NAME ( NAME - LIT ) } for NAME in NAME ( LIT , LIT ) } NAME = { NAME ( NAME ) : { NAME ( NAME + LIT ) } for NAME in NAME ( LIT ) } NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( LIT , LIT , NAME , NAME ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" BFS too slow: { NAME : .3f } s \""
    },
    {
      "module_path": "relationship_utils.py",
      "qualname": "test_function_availability",
      "lineno": 1996,
      "end_lineno": 2006,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "276f93cc0353ff0ff19098466cac2fc4cd518f53",
      "simhash64": 5125619772670514219,
      "normalized": "def NAME ( ) : # Verify all major functions are available NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT ] from NAME import NAME NAME ( NAME , NAME ( ) , LIT )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer.__init__",
      "lineno": 76,
      "end_lineno": 80,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "0c61f1b1776ce5c48a6b931241dc5505d8e74db1",
      "simhash64": 7452151226028176469,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME : NAME [ NAME ] = [ ]"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer.prioritize_research_tasks",
      "lineno": 82,
      "end_lineno": 139,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 58,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, gedcom_analysis, dna_crossref_analysis, _existing_tasks)",
      "fingerprint": "ecc824366d4242739a8e5ab3edb361eb6d0d0b37",
      "simhash64": 7487617073026606083,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME [ NAME [ NAME , NAME ] ] ] = None ) -> NAME [ NAME , NAME ] : LIT try : NAME . NAME ( LIT ) # Clear previous analysis NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) # Analyze family line completeness NAME . NAME ( NAME ) # Create location-based research clusters NAME . NAME ( NAME ) # Generate prioritized research tasks NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( ) # Score and rank all priorities NAME . NAME ( ) # Generate research plan NAME = { LIT : NAME . NAME ( ) . NAME ( ) , LIT : NAME ( NAME . NAME ) , LIT : [ NAME . NAME ( NAME ) for NAME in NAME . NAME ] , LIT : [ NAME . NAME ( NAME ) for NAME in NAME . NAME ] , LIT : [ NAME . NAME ( NAME ) for NAME in NAME . NAME ] , LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) } NAME . NAME ( f\" Research prioritization completed: { NAME ( NAME . NAME ) } priorities identified \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Error during research prioritization: { NAME } \" ) return NAME . NAME ( )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._analyze_family_line_completeness",
      "lineno": 141,
      "end_lineno": 165,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 25,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gedcom_analysis)",
      "fingerprint": "223252b5c9e6bd9ba6763fb1e9d6c4a7d8697881",
      "simhash64": 7488109654235853851,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) : LIT try : # Extract family patterns from GEDCOM analysis NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , [ ] ) # Analyze each major surname line for NAME , NAME in NAME ( NAME [ : LIT ] ) : # Top 5 surnames NAME = NAME ( NAME = f\" line_ { NAME . NAME ( ) } \" , NAME = f\" { NAME } Family Line \" , NAME = NAME , NAME = NAME . NAME ( NAME , NAME ) , NAME = NAME . NAME ( NAME , NAME ) , NAME = NAME . NAME ( NAME , NAME ) , NAME = NAME . NAME ( NAME , NAME ) , NAME = NAME . NAME ( NAME , NAME ) ) NAME . NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error analyzing family line completeness: { NAME } \" )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._create_location_research_clusters",
      "lineno": 167,
      "end_lineno": 213,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 11,
      "loc": 47,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self, gedcom_analysis)",
      "fingerprint": "61f34a2a6cc0ece0a6f553dc54e29d2c9cd648c9",
      "simhash64": 7488180022980031499,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) : LIT try : # Group research opportunities by location NAME = NAME ( NAME ) NAME = NAME . NAME ( LIT , [ ] ) NAME = NAME . NAME ( LIT , [ ] ) # Group gaps by location for NAME in NAME : if NAME . NAME ( LIT ) in [ LIT , LIT ] : # Extract location context if available NAME = NAME . NAME ( NAME ) if NAME : NAME [ NAME ] . NAME ( { LIT : LIT , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) } ) # Group opportunities by location for NAME in NAME : if NAME . NAME ( LIT ) == LIT : NAME = NAME . NAME ( NAME ) if NAME : NAME [ NAME ] . NAME ( NAME . NAME ( LIT , [ ] ) ) # Create clusters for locations with multiple research targets for NAME , NAME in NAME . NAME ( ) : if NAME ( NAME ) >= LIT : # At least 2 research targets NAME = NAME ( NAME = f\" cluster_ { NAME . NAME ( LIT , LIT ) . NAME ( ) } \" , NAME = NAME , NAME = NAME . NAME ( NAME , NAME ) , NAME = NAME ( NAME ) , NAME = [ NAME . NAME ( LIT , LIT ) for NAME in NAME if NAME ( NAME , NAME ) ] , NAME = NAME . NAME ( NAME ) , NAME = NAME . NAME ( NAME , NAME ) , NAME = NAME . NAME ( NAME , NAME ) ) NAME . NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error creating location research clusters: { NAME } \" )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._generate_priority_tasks_from_gaps",
      "lineno": 215,
      "end_lineno": 240,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gedcom_analysis)",
      "fingerprint": "011e9a0495a7c509f3367b6435072eb6b427c3d6",
      "simhash64": 7487617078395311115,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) : LIT NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : NAME = NAME . NAME ( NAME ) NAME = NAME ( NAME = f\" gap_ { NAME . NAME ( LIT , LIT ) } \" , NAME = NAME . NAME ( NAME . NAME ( LIT , LIT ) ) , NAME = NAME . NAME ( LIT , LIT ) , NAME = [ NAME . NAME ( LIT , LIT ) ] , NAME = NAME , NAME = NAME . NAME ( NAME ) , NAME = { LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) } , NAME = [ LIT , LIT ] , NAME = NAME . NAME ( LIT , [ ] ) , NAME = NAME . NAME ( NAME ) , NAME = NAME . NAME ( NAME ) ) NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._generate_priority_tasks_from_conflicts",
      "lineno": 242,
      "end_lineno": 267,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gedcom_analysis)",
      "fingerprint": "2ffe7e15b9e43b761b238b76b2c8e5763773882a",
      "simhash64": 7451588277081379883,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) : LIT NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : NAME = NAME . NAME ( NAME ) NAME = NAME ( NAME = f\" conflict_ { NAME . NAME ( LIT , LIT ) } \" , NAME = LIT , NAME = f\" Resolve: { NAME . NAME ( LIT , LIT ) } \" , NAME = NAME . NAME ( LIT , [ ] ) , NAME = NAME , NAME = NAME . NAME ( NAME . NAME ( LIT , LIT ) ) , NAME = { LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT ) } , NAME = [ LIT , LIT ] , NAME = NAME . NAME ( LIT , [ ] ) , NAME = LIT , NAME = LIT ) NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._generate_priority_tasks_from_dna",
      "lineno": 269,
      "end_lineno": 296,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, dna_crossref_analysis)",
      "fingerprint": "13a27d424982a08836b4be53f6118e4f7e54c6a2",
      "simhash64": 5145886005423150123,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) : LIT if not NAME : return NAME = NAME . NAME ( LIT , [ ] ) for NAME in NAME : NAME = LIT if NAME . NAME ( LIT ) == LIT else LIT NAME = NAME ( NAME = f\" dna_ { NAME . NAME ( LIT , LIT ) } \" , NAME = LIT , NAME = NAME . NAME ( LIT , LIT ) , NAME = [ ] , # Would extract from opportunity data NAME = NAME , NAME = LIT , NAME = { LIT : NAME . NAME ( LIT ) , LIT : True } , NAME = [ LIT , LIT ] , NAME = NAME . NAME ( LIT , [ ] ) , NAME = LIT , NAME = LIT ) NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._generate_cluster_research_tasks",
      "lineno": 298,
      "end_lineno": 320,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "b5f35ffb4a4d44c61bf261c9a9c305f64296cda9",
      "simhash64": 7452080857216889883,
      "normalized": "def NAME ( NAME ) -> None : LIT for NAME in NAME . NAME : if NAME . NAME > LIT : # High efficiency clusters NAME = NAME ( NAME = f\" cluster_ { NAME . NAME } \" , NAME = LIT , NAME = f\" Cluster research in { NAME . NAME } ( { NAME . NAME } people) \" , NAME = NAME . NAME , NAME = NAME . NAME * LIT , NAME = LIT , NAME = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME } , NAME = [ LIT , LIT ] , NAME = NAME . NAME , NAME = LIT , NAME = LIT ) NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._score_and_rank_priorities",
      "lineno": 322,
      "end_lineno": 352,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 31,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "f2efee25abc9dac186a6a28abe5f4b3b106b2faf",
      "simhash64": 7451588276007646227,
      "normalized": "def NAME ( NAME ) -> None : LIT # Apply dependency tracking and workflow optimization NAME . NAME ( ) NAME . NAME ( ) # Sort by priority score (highest first) NAME . NAME . NAME ( NAME = lambda NAME : NAME . NAME , NAME = True ) # Enhanced scoring with research efficiency and success probability for NAME in NAME . NAME : # Efficiency adjustments NAME = LIT if NAME . NAME == LIT : NAME = LIT # Increased bonus for quick wins elif NAME . NAME == LIT : NAME = LIT elif NAME . NAME == LIT : NAME = - LIT # Reduced penalty for important high-effort tasks # Success probability bonus (more nuanced) NAME = ( NAME . NAME - LIT ) * LIT # Dependency bonus for prerequisite tasks NAME = NAME ( NAME , LIT , LIT ) # Workflow optimization bonus NAME = NAME ( NAME , LIT , LIT ) NAME . NAME += NAME + NAME + NAME + NAME NAME . NAME = NAME ( LIT , NAME ( LIT , NAME . NAME ) ) # Clamp to 0-100"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._analyze_task_dependencies",
      "lineno": 354,
      "end_lineno": 377,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 8,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "c566cf292d64970546fbf0ce6b50cce062a1e754",
      "simhash64": 7488109654235853879,
      "normalized": "def NAME ( NAME ) -> None : LIT for NAME in NAME . NAME : NAME = LIT # Tasks that enable other research get priority boost if NAME . NAME == LIT : # Vital records often enable other research NAME += LIT elif NAME . NAME == LIT : # Resolving conflicts enables accurate further research NAME += LIT elif NAME . NAME == LIT : # DNA verification can confirm or refute multiple hypotheses NAME += LIT # Check for prerequisite relationships for NAME in NAME . NAME : if NAME != NAME and NAME . NAME ( NAME , NAME ) : NAME += LIT NAME . NAME = NAME"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._optimize_research_workflow",
      "lineno": 379,
      "end_lineno": 405,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 12,
      "loc": 27,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "7980cbc53d06a5ccf72bf3bc871eb5c0aac43b2f",
      "simhash64": 7488180023047136307,
      "normalized": "def NAME ( NAME ) -> None : LIT # Group tasks by location for research efficiency NAME = NAME ( NAME ) for NAME in NAME . NAME : NAME = NAME . NAME ( NAME . NAME ) if NAME : NAME [ NAME ] . NAME ( NAME ) # Apply workflow bonuses for location clustering for NAME , NAME in NAME . NAME ( ) : if NAME ( NAME ) > LIT : # Multiple tasks in same location for NAME in NAME : NAME . NAME = NAME ( NAME , LIT , LIT ) + LIT # Group tasks by person for research efficiency NAME = NAME ( NAME ) for NAME in NAME . NAME : if NAME . NAME : for NAME in NAME . NAME : NAME [ NAME ] . NAME ( NAME ) # Apply workflow bonuses for person clustering for NAME , NAME in NAME . NAME ( ) : if NAME ( NAME ) > LIT : # Multiple tasks for same person for NAME in NAME : NAME . NAME = NAME ( NAME , LIT , LIT ) + LIT"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._is_prerequisite",
      "lineno": 407,
      "end_lineno": 420,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 9,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, task1, task2)",
      "fingerprint": "33473556718b3e7a8fab16402e93feeae4ae0b8b",
      "simhash64": 7487612674980099123,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT # Vital records often prerequisite for other research if NAME . NAME == LIT and NAME . NAME in [ LIT , LIT ] : # Check if they involve the same person if NAME ( NAME in NAME . NAME for NAME in NAME . NAME ) : return True # Conflict resolution prerequisite for verification tasks if NAME . NAME == LIT and NAME . NAME == LIT : if NAME ( NAME in NAME . NAME for NAME in NAME . NAME ) : return True return False"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._extract_location_from_context",
      "lineno": 422,
      "end_lineno": 428,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, context)",
      "fingerprint": "0fc361544f73c02d33aa19b13e916aa2f50f5a7c",
      "simhash64": 5146448954302829611,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT # Look for location indicators in context for NAME in [ LIT , LIT , LIT , LIT , LIT ] : if NAME in NAME : return NAME ( NAME [ NAME ] ) return LIT"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._estimate_generations_back",
      "lineno": 431,
      "end_lineno": 434,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, _surname, _gedcom_analysis)",
      "fingerprint": "f844d79839e13a7618ca5c8c2e86821365f4b481",
      "simhash64": 5146448920949732451,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT # Placeholder implementation return LIT"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._calculate_line_completeness",
      "lineno": 436,
      "end_lineno": 439,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, _surname, _gedcom_analysis)",
      "fingerprint": "f844d79839e13a7618ca5c8c2e86821365f4b481",
      "simhash64": 5146448920949732451,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT # Placeholder implementation return LIT"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._identify_missing_generations",
      "lineno": 441,
      "end_lineno": 444,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, _surname, _gedcom_analysis)",
      "fingerprint": "39259b70bb92a09973c07122bc2e5d0d89463bc6",
      "simhash64": 5146448954302837863,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT # Placeholder implementation return [ LIT , LIT ]"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._identify_research_bottlenecks",
      "lineno": 446,
      "end_lineno": 452,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, surname, _gedcom_analysis)",
      "fingerprint": "418bdfb8f374d1689e68b2688a1e51ad0c4c9173",
      "simhash64": 2840465208608461847,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT return [ f\" Missing parents for { NAME } ancestors \" , f\" No immigration records found for { NAME } family \" , f\" Birth records unavailable for early { NAME } generations \" ]"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._identify_priority_targets",
      "lineno": 454,
      "end_lineno": 460,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, surname, gedcom_analysis)",
      "fingerprint": "f26b720dcbcd80215b73b7fce019323fa1aa94a8",
      "simhash64": 2822450809025238099,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT return [ f\" Research { NAME } family immigration \" , f\" Find birth records for { NAME } ancestors \" , f\" Locate { NAME } family in census records \" ]"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._extract_location_context",
      "lineno": 462,
      "end_lineno": 473,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gap)",
      "fingerprint": "0f4aa3675951444a48d9990b8d1c79393d794748",
      "simhash64": 5182478850833421347,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT # This would analyze the gap description for location clues NAME = NAME . NAME ( LIT , LIT ) # Simple implementation - look for location keywords if LIT in NAME : return LIT if LIT in NAME : return LIT if LIT in NAME : return LIT return None"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._extract_opportunity_location",
      "lineno": 475,
      "end_lineno": 485,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, opportunity)",
      "fingerprint": "8c732baa4313ac843b62db252ac29514b45e959b",
      "simhash64": 5182478850825032747,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT NAME = NAME . NAME ( LIT , LIT ) # Simple implementation if LIT in NAME : return LIT if LIT in NAME : return LIT if LIT in NAME : return LIT return None"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._estimate_time_period_for_location",
      "lineno": 487,
      "end_lineno": 489,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "time",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self, _location, _items)",
      "fingerprint": "7778fcca2bae2517856c19721a133194c6a6840e",
      "simhash64": 5146308216747373683,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME : LIT return LIT # Placeholder"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._identify_available_records_for_location",
      "lineno": 491,
      "end_lineno": 498,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, _location)",
      "fingerprint": "de2de08bf961d79918ee04757497a8024595c068",
      "simhash64": 5145886005418955823,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT NAME = { LIT : [ LIT , LIT , LIT , LIT ] , LIT : [ LIT , LIT , LIT ] , LIT : [ LIT , LIT , LIT , LIT ] } return NAME . NAME ( NAME , [ LIT ] )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._calculate_cluster_efficiency",
      "lineno": 500,
      "end_lineno": 509,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, location, items)",
      "fingerprint": "bb1f45d6ad977df4fb044a6b9c39747ef2355376",
      "simhash64": 7452151226028168195,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME : LIT # Base efficiency on number of people and available records NAME = NAME ( NAME ) NAME = NAME ( LIT , NAME / LIT ) # More people = higher efficiency # Bonus for well-documented locations NAME = LIT if NAME in [ LIT , LIT , LIT ] else LIT return NAME ( LIT , NAME + NAME )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._generate_cluster_research_plan",
      "lineno": 511,
      "end_lineno": 518,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, location, items)",
      "fingerprint": "ec1e775e9b4d42aca9043581b7a6afd225b0e520",
      "simhash64": 7452151225962107935,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] ) -> NAME [ NAME ] : LIT return [ f\" Research { NAME } records for multiple family members \" , LIT , f\" Look for family connections in { NAME } records \" , f\" Cross-reference multiple sources for { NAME } \" ]"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._calculate_gap_priority_score",
      "lineno": 520,
      "end_lineno": 572,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 17,
      "loc": 53,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, gap)",
      "fingerprint": "7e444c54cd9050b3a6cddefe1eb9b63e0766c354",
      "simhash64": 7452151227035849767,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = LIT # Enhanced gap type scoring with genealogical research priorities NAME = NAME . NAME ( LIT , LIT ) if NAME == LIT : NAME += LIT # Critical for family tree extension elif NAME == LIT : NAME += LIT # Important for family completeness elif NAME == LIT : NAME += LIT # Valuable for descendant research elif NAME == LIT : NAME += LIT # Essential for timeline verification elif NAME == LIT : NAME += LIT # Important for location-based research elif NAME == LIT : NAME += LIT # Useful for social history # Priority level adjustments NAME = NAME . NAME ( LIT , LIT ) if NAME == LIT : NAME += LIT elif NAME == LIT : NAME += LIT elif NAME == LIT : NAME += LIT elif NAME == LIT : NAME += LIT # Research feasibility factors NAME = NAME . NAME ( LIT , LIT ) if NAME : # Boost score for direct ancestors (higher generations) NAME = NAME . NAME ( NAME ) if NAME <= LIT : # Parents, grandparents, great-grandparents NAME += ( LIT - NAME ) * LIT # Available evidence bonus NAME = NAME . NAME ( LIT , LIT ) if NAME == LIT : NAME += LIT elif NAME == LIT : NAME += LIT # Research difficulty adjustment NAME = NAME . NAME ( LIT , LIT ) if NAME == LIT : NAME += LIT # Quick wins are valuable elif NAME == LIT : NAME -= LIT # Reduce priority for very difficult research return NAME ( LIT , NAME ( LIT , NAME ) )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._calculate_conflict_priority_score",
      "lineno": 574,
      "end_lineno": 618,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 14,
      "loc": 45,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, conflict)",
      "fingerprint": "62f0b2c9ee39631abc28ae37a5cce35e837a1a54",
      "simhash64": 5146308217889272867,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = LIT # Enhanced severity scoring with genealogical impact assessment NAME = NAME . NAME ( LIT , LIT ) if NAME == LIT : NAME += LIT # Major tree accuracy issues elif NAME == LIT : NAME += LIT # Significant discrepancies elif NAME == LIT : NAME += LIT # Notable inconsistencies elif NAME == LIT : NAME += LIT # Small discrepancies # Conflict type impact on research NAME = NAME . NAME ( LIT , LIT ) if NAME == LIT : NAME += LIT # Timeline accuracy is crucial elif NAME == LIT : NAME += LIT # Geographic accuracy affects research strategy elif NAME == LIT : NAME += LIT # Family structure accuracy is critical elif NAME == LIT : NAME += LIT # Identity verification important # Number of people affected NAME = NAME . NAME ( LIT , [ ] ) if NAME ( NAME ) > LIT : NAME += LIT # Multi-person conflicts have broader impact elif NAME ( NAME ) > LIT : NAME += LIT # Available resolution evidence NAME = NAME . NAME ( LIT , LIT ) if NAME == LIT : NAME += LIT # High chance of successful resolution elif NAME == LIT : NAME += LIT # Research blocking factor if NAME . NAME ( LIT , False ) : NAME += LIT # Conflicts that block further research get priority return NAME ( LIT , NAME ( LIT , NAME ) )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._estimate_generation_level",
      "lineno": 620,
      "end_lineno": 634,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 7,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, person_id)",
      "fingerprint": "f44c2467ea2ed1e0af568497f6112015340efd75",
      "simhash64": 7492262509981111339,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT # This is a simplified estimation - in a real system this would # analyze the actual family tree structure if not NAME : return LIT # Default to mid-level # Simple heuristic based on ID patterns (this would be more sophisticated in practice) if LIT in NAME . NAME ( ) or LIT in NAME . NAME ( ) or LIT in NAME . NAME ( ) : return LIT if LIT in NAME . NAME ( ) or LIT in NAME . NAME ( ) : return LIT if LIT in NAME . NAME ( ) : return LIT return LIT # Default for other relatives"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._map_gap_to_task_type",
      "lineno": 636,
      "end_lineno": 645,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, gap_type)",
      "fingerprint": "f68a79bb4807bbcd9158c778ec0958fe90dbd8db",
      "simhash64": 5150381908460738091,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } return NAME . NAME ( NAME , LIT )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._determine_urgency_from_score",
      "lineno": 647,
      "end_lineno": 655,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, score)",
      "fingerprint": "fa09cfb7b3b26b363108ad768291b04bda942df0",
      "simhash64": 5726841552662599211,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT if NAME >= LIT : return LIT if NAME >= LIT : return LIT if NAME >= LIT : return LIT return LIT"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._map_severity_to_urgency",
      "lineno": 657,
      "end_lineno": 664,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, severity)",
      "fingerprint": "47ea3e2d05e87ef32a42e1623ad3e28f26d0aed1",
      "simhash64": 7456232614188717611,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT NAME = { LIT : LIT , LIT : LIT , LIT : LIT } return NAME . NAME ( NAME , LIT )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._estimate_research_effort",
      "lineno": 666,
      "end_lineno": 673,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, gap)",
      "fingerprint": "a469a853eb2e0806306c022ebde7f506fd80deeb",
      "simhash64": 5145886005423150123,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , LIT ) if NAME in [ LIT , LIT ] : return LIT if NAME == LIT : return LIT return LIT"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._estimate_success_probability",
      "lineno": 675,
      "end_lineno": 752,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 33,
      "loc": 78,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, gap)",
      "fingerprint": "3ae3454079383f783c470977024c753aa5d95774",
      "simhash64": 5145746367439082531,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , LIT ) NAME = LIT # Start with realistic baseline # Priority level impact on success probability if NAME == LIT : NAME += LIT # Critical gaps often have more evidence elif NAME == LIT : NAME += LIT elif NAME == LIT : NAME += LIT elif NAME == LIT : NAME += LIT # Gap type success probability based on genealogical research experience if NAME == LIT : NAME += LIT # Dates often found in multiple record types elif NAME == LIT : NAME += LIT # Places often documented in various records elif NAME == LIT : NAME += LIT # More challenging but often achievable elif NAME == LIT : NAME += LIT # Marriage records often well-documented elif NAME == LIT : NAME += LIT # Can be challenging due to infant mortality elif NAME == LIT : NAME += LIT # Often found in census and directories # Time period impact (older records are harder to find) NAME = NAME . NAME ( LIT , LIT ) if NAME : if LIT in NAME : # 1800s if LIT in NAME or LIT in NAME : # Early 1800s NAME -= LIT else : # Later 1800s NAME += LIT elif LIT in NAME : # 1900s NAME += LIT # Better record keeping elif LIT in NAME : # 1700s NAME -= LIT # Much more challenging # Location impact on success probability NAME = NAME . NAME ( LIT , LIT ) if NAME : NAME = NAME . NAME ( ) if NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT ] ) : NAME += LIT # Good record keeping traditions elif NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT ] ) : NAME += LIT # Excellent early American records elif NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT ] ) : NAME -= LIT # Some record loss from wars elif NAME ( NAME in NAME for NAME in [ LIT , LIT , LIT ] ) : NAME -= LIT # Frontier areas had less record keeping # Available evidence quality impact NAME = NAME . NAME ( LIT , LIT ) if NAME == LIT : NAME += LIT elif NAME == LIT : NAME += LIT elif NAME == LIT : NAME -= LIT # Research difficulty adjustment NAME = NAME . NAME ( LIT , LIT ) if NAME == LIT : NAME += LIT elif NAME == LIT : NAME += LIT elif NAME == LIT : NAME -= LIT elif NAME == LIT : NAME -= LIT return NAME ( LIT , NAME ( LIT , NAME ) ) # Keep between 10% and 100%"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._generate_research_recommendations",
      "lineno": 754,
      "end_lineno": 773,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "f4004c6a43f9caf16166cd123f625be1a9324e4e",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME = [ ] if NAME ( NAME . NAME ) > LIT : NAME . NAME ( LIT ) NAME = NAME ( [ NAME for NAME in NAME . NAME if NAME . NAME in [ LIT , LIT ] ] ) if NAME > LIT : NAME . NAME ( f\" Address { NAME } high-priority items first \" ) NAME = NAME ( NAME . NAME ) if NAME > LIT : NAME . NAME ( f\" Consider cluster research approach for { NAME } geographic areas \" ) NAME = NAME ( [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] ) if NAME > LIT : NAME . NAME ( f\" Prioritize { NAME } DNA verification tasks for quick wins \" ) return NAME"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._analyze_research_efficiency",
      "lineno": 775,
      "end_lineno": 787,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "6969a9f96516e96718d2e26aa85dac26db40c51d",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( NAME . NAME ) NAME = NAME ( [ NAME for NAME in NAME . NAME if NAME . NAME == LIT ] ) NAME = NAME ( [ NAME for NAME in NAME . NAME if NAME . NAME > LIT ] ) return { LIT : NAME , LIT : NAME , LIT : NAME , LIT : ( NAME + NAME ) / NAME ( LIT , NAME ) , LIT : NAME ( NAME . NAME ) }"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._generate_next_steps",
      "lineno": 789,
      "end_lineno": 803,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "b4d628f964c3e26544d9d716f6d0310eea2cebb4",
      "simhash64": 7452151225961067539,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT if not NAME . NAME : return [ LIT ] NAME = NAME . NAME [ LIT ] NAME = [ f\" Start with highest priority: { NAME . NAME } \" , f\" Focus on { NAME . NAME } urgency tasks first \" ] if NAME . NAME : NAME . NAME ( f\" First step: { NAME . NAME [ LIT ] } \" ) return NAME"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._empty_prioritization_result",
      "lineno": 805,
      "end_lineno": 817,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "d47ed1d67122e45298c2702582e46cbf0c38210f",
      "simhash64": 5128989775872562223,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME ( ) . NAME ( ) , LIT : LIT , LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : { } , LIT : [ ] , LIT : LIT }"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._priority_to_dict",
      "lineno": 819,
      "end_lineno": 833,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, priority)",
      "fingerprint": "091388d28eccf425d3aa76c56c02c6b28413a5dd",
      "simhash64": 7451729014569743395,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME }"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._family_line_to_dict",
      "lineno": 835,
      "end_lineno": 846,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, family_line)",
      "fingerprint": "ce0f21c69270881021a507f6651680325f4486ac",
      "simhash64": 7451729014569743395,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME }"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "IntelligentResearchPrioritizer._location_cluster_to_dict",
      "lineno": 848,
      "end_lineno": 859,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, cluster)",
      "fingerprint": "ce0f21c69270881021a507f6651680325f4486ac",
      "simhash64": 7451729014569743395,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME }"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "test_research_prioritization",
      "lineno": 863,
      "end_lineno": 910,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 48,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "1ef4dccdd443207ee92a932296b760abc6021f4a",
      "simhash64": 5150390704549565995,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) NAME = NAME ( ) # Test with mock data NAME = { LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : [ LIT ] } ] , LIT : [ ] , LIT : [ ] , LIT : { LIT : { LIT : [ LIT , LIT ] } } } NAME = { LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : [ LIT ] } ] } NAME = NAME . NAME ( NAME , NAME ) assert LIT in NAME , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "test_priority_scoring_and_ranking",
      "lineno": 913,
      "end_lineno": 931,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9d8821c9ec8d4b803b483f4fe5fa394a0f2e21ec",
      "simhash64": 5147004174377326127,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) NAME = { LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : [ ] } , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : [ ] } , ] , LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : [ LIT ] , LIT : LIT , LIT : [ ] } ] , LIT : [ ] , LIT : { LIT : { LIT : [ LIT ] } } } NAME = { LIT : [ ] } NAME = NAME . NAME ( NAME , NAME ) NAME = NAME [ LIT ] NAME = [ NAME [ LIT ] for NAME in NAME ] assert NAME == NAME ( NAME , NAME = True ) , LIT"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "test_cluster_generation_and_efficiency",
      "lineno": 934,
      "end_lineno": 953,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6ec53a31231f9c32a79fee929b639d1cda8156dc",
      "simhash64": 5146450054880859695,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) # Provide multiple gaps referencing Scotland via description keyword extraction NAME = [ ] for NAME in NAME ( LIT ) : NAME . NAME ( { LIT : f\" I { NAME } \" , LIT : f\" Person { NAME } \" , LIT : LIT , LIT : f\" Missing birth location Scotland for Person { NAME } \" , LIT : LIT , LIT : [ ] } ) NAME = { LIT : NAME , LIT : [ ] , LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : [ ] } ] , LIT : { LIT : { LIT : [ ] } } } NAME = { LIT : [ ] } NAME = NAME . NAME ( NAME , NAME ) NAME = [ NAME for NAME in NAME [ LIT ] if NAME [ LIT ] == LIT ] if NAME : # Should exist assert NAME [ LIT ] [ LIT ] >= LIT , LIT"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "test_dna_verification_task_creation",
      "lineno": 956,
      "end_lineno": 962,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "e8e497c903284f7fd53d29299d6651fb44cf01fa",
      "simhash64": 5147013004834281007,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) NAME = { LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : { LIT : { LIT : [ ] } } } NAME = { LIT : [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : [ LIT ] } ] } NAME = NAME . NAME ( NAME , NAME ) assert NAME ( NAME [ LIT ] == LIT for NAME in NAME [ LIT ] )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "research_prioritization_module_tests",
      "lineno": 965,
      "end_lineno": 1005,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 41,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "3266165f4907fc1177feb242cc7dba584cdaf38b",
      "simhash64": 5145886009646814251,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "research_prioritization.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 1008,
      "end_lineno": 1010,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "run_all_tests.py",
      "qualname": "PerformanceMonitor.__init__",
      "lineno": 78,
      "end_lineno": 82,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "ec8ac0f63a98e928b85c2d32df97796502bc2c22",
      "simhash64": 8605038100313715729,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME = NAME . NAME ( ) NAME . NAME = False NAME . NAME = [ ] NAME . NAME = None"
    },
    {
      "module_path": "run_all_tests.py",
      "qualname": "PerformanceMonitor.start_monitoring",
      "lineno": 84,
      "end_lineno": 89,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "9f74430fe528c42132f9fe2fef3c38db9891e5aa",
      "simhash64": 7488144842970014739,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = True NAME . NAME = [ ] NAME . NAME = NAME . NAME ( NAME = NAME . NAME , NAME = True ) NAME . NAME . NAME ( )"
    },
    {
      "module_path": "run_all_tests.py",
      "qualname": "PerformanceMonitor.stop_monitoring",
      "lineno": 91,
      "end_lineno": 108,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "fd99f80f8361544ab39882e8b07867b66f07a321",
      "simhash64": 7488180023047132163,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME . NAME = False if NAME . NAME : NAME . NAME . NAME ( NAME = LIT ) if not NAME . NAME : return { LIT : LIT , LIT : LIT } NAME = [ NAME [ LIT ] for NAME in NAME . NAME ] NAME = [ NAME [ LIT ] for NAME in NAME . NAME ] return { LIT : NAME ( NAME ) / NAME ( NAME ) , LIT : NAME ( NAME ) , LIT : NAME ( NAME ) / NAME ( NAME ) , LIT : NAME ( NAME ) }"
    },
    {
      "module_path": "run_all_tests.py",
      "qualname": "PerformanceMonitor._monitor_loop",
      "lineno": 110,
      "end_lineno": 125,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "98ac073586b91ef94f4b3faef4b2653b4b50174d",
      "simhash64": 8645077361700025359,
      "normalized": "def NAME ( NAME ) : LIT while NAME . NAME : try : NAME = NAME . NAME . NAME ( ) NAME = NAME . NAME . NAME ( ) NAME . NAME . NAME ( { LIT : NAME . NAME / ( LIT * LIT ) , LIT : NAME , LIT : NAME . NAME ( ) } ) NAME . NAME ( LIT ) # Sample every 100ms except NAME : break"
    },
    {
      "module_path": "run_all_tests.py",
      "qualname": "run_linter",
      "lineno": 129,
      "end_lineno": 200,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 9,
      "loc": 72,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "1743ad7c15efcff4e75b85c1120dff92edcb8869",
      "simhash64": 5145745267934794795,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Check if ruff is available import NAME NAME = NAME . NAME ( [ NAME . NAME , LIT , LIT , LIT ] , NAME = False , NAME = True , NAME = True ) if NAME . NAME != LIT : NAME ( LIT ) return True # Step 1: safe auto-fixes NAME ( LIT ) NAME = [ NAME . NAME , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] NAME . NAME ( NAME , NAME = False , NAME = True , NAME = True , NAME = NAME . NAME ( ) ) # Step 2: blocking rule set (only critical errors) NAME ( LIT ) NAME = [ NAME . NAME , LIT , LIT , LIT , LIT , LIT , LIT , ] NAME = NAME . NAME ( NAME , NAME = False , NAME = True , NAME = True , NAME = NAME . NAME ( ) ) if NAME . NAME != LIT : NAME ( LIT ) # Tail the output to keep logs compact NAME = ( NAME . NAME or NAME . NAME or LIT ) . NAME ( ) [ - LIT : ] for NAME in NAME : NAME ( NAME ) return False # Step 3: non-blocking diagnostics (excluding PLR2004 and PLC0415) NAME ( LIT ) NAME = [ NAME . NAME , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] NAME = NAME . NAME ( NAME , NAME = False , NAME = True , NAME = True , NAME = NAME . NAME ( ) ) if NAME . NAME : NAME = [ NAME for NAME in NAME . NAME . NAME ( ) if NAME . NAME ( ) ] for NAME in NAME [ - LIT : ] : NAME ( NAME ) return True except NAME as NAME : NAME ( f\" \u26a0\ufe0f LINTER step skipped due to error: { NAME } \" ) return True"
    },
    {
      "module_path": "run_all_tests.py",
      "qualname": "run_quality_checks",
      "lineno": 203,
      "end_lineno": 252,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 7,
      "loc": 50,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "ee46dfda2970e0117b5e3ba2c099a40d111bffd9",
      "simhash64": 7451623461454517819,
      "normalized": "def NAME ( ) -> NAME : LIT try : NAME ( LIT ) # Import and run quality checker from NAME import NAME NAME = NAME ( ) NAME = NAME ( ) # Check key files for quality NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] NAME = LIT NAME = LIT for NAME in NAME : NAME = NAME / NAME if NAME . NAME ( ) : NAME = NAME . NAME ( NAME ) NAME += NAME . NAME NAME += LIT if NAME . NAME < LIT : NAME ( f\" \u26a0\ufe0f { NAME } : Quality score { NAME . NAME : .1f } /100 (below threshold) \" ) else : NAME ( f\" \u2705 { NAME } : Quality score { NAME . NAME : .1f } /100 \" ) if NAME > LIT : NAME = NAME / NAME NAME ( f\" \ud83d\udcca Average quality score: { NAME : .1f } /100 \" ) if NAME < LIT : NAME ( LIT ) return False return True except NAME as NAME : NAME ( f\" \u26a0\ufe0f QUALITY checks skipped due to error: { NAME } \" ) return True"
    },
    {
      "module_path": "run_all_tests.py",
      "qualname": "discover_test_modules",
      "lineno": 255,
      "end_lineno": 323,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 12,
      "loc": 69,
      "tags": [
        "impure",
        "filesystem",
        "purpose:test_runner",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "1ed361d82ae82d77731b24029a871cc251ffc708",
      "simhash64": 7488109654302954531,
      "normalized": "def NAME ( ) -> NAME [ NAME ] : LIT NAME = NAME ( NAME ) . NAME NAME = [ ] # Get all Python files in the project for NAME in NAME . NAME ( LIT ) : # Skip the test runner itself, main.py, and coordination files if NAME . NAME in [ LIT , LIT , LIT , LIT , ] : continue # Skip cache, backup, temp files, and virtual environment NAME = NAME ( NAME ) if ( LIT in NAME or NAME . NAME . NAME ( LIT ) or LIT in NAME or NAME . NAME . NAME ( LIT ) or NAME . NAME . NAME ( LIT ) or LIT in NAME . NAME or LIT in NAME or LIT in NAME or LIT in NAME or LIT in NAME ) : continue # Quietly skip demo/prototype scripts in repo (no output spam) NAME = [ LIT , LIT , LIT , LIT ] NAME = NAME . NAME . NAME ( ) if NAME ( NAME in NAME for NAME in NAME ) : continue # Check if the file has the standardized test function try : with NAME . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( ) # Skip files with interactive components that would block testing # But allow legitimate test modules that happen to have interactive functionality NAME = False if NAME . NAME in [ LIT , LIT ] : # Specifically known interactive modules that should be excluded NAME = True if NAME : continue # Look for the standardized test function (with or without parentheses) if LIT in NAME : # Convert to relative path from project root NAME = NAME . NAME ( NAME ) NAME . NAME ( NAME ( NAME ) ) except ( NAME , NAME ) : # Skip files that can't be read continue return NAME ( NAME )"
    },
    {
      "module_path": "run_all_tests.py",
      "qualname": "extract_module_description",
      "lineno": 326,
      "end_lineno": 396,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 22,
      "loc": 71,
      "tags": [
        "impure",
        "filesystem",
        "regex",
        "size:medium"
      ],
      "signature": "(module_path)",
      "fingerprint": "4fbd433565a81b5d43b55a010a4e795c6d27fdf1",
      "simhash64": 7488180023047140387,
      "normalized": "def NAME ( NAME : NAME ) -> NAME | None : LIT try : # Read the file and look for the module docstring from NAME import NAME with NAME ( NAME ) . NAME ( NAME = LIT ) as NAME : NAME = NAME . NAME ( ) # Look for triple-quoted docstring after any initial comments/shebang NAME = NAME . NAME ( LIT ) NAME = False NAME = [ ] for NAME in NAME : NAME = NAME . NAME ( ) # Skip shebang and comments at the top if NAME . NAME ( LIT ) or not NAME : continue # Look for start of docstring if not NAME and LIT in NAME : NAME = True # Extract content after opening quotes NAME = NAME . NAME ( LIT , LIT ) [ LIT ] . NAME ( ) if NAME : NAME . NAME ( NAME ) continue # If we're in docstring, collect lines until closing quotes if NAME : if LIT in NAME : # End of docstring - extract content before closing quotes NAME = NAME . NAME ( LIT ) [ LIT ] . NAME ( ) if NAME : NAME . NAME ( NAME ) break # Regular docstring line if NAME : NAME . NAME ( NAME ) # Return the first meaningful line as description if NAME : # Look for the first line that looks like a title/description for NAME in NAME : if NAME and not NAME . NAME ( LIT ) and NAME ( NAME ) > LIT : # Clean up common patterns NAME = NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) NAME = NAME . NAME ( NAME , LIT ) . NAME ( ) NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) # Remove leading dashes and clean up if NAME . NAME ( LIT ) : NAME = NAME [ LIT : ] . NAME ( ) if NAME . NAME ( LIT ) : NAME = NAME [ LIT : ] . NAME ( ) # Remove redundant module name patterns NAME = [ NAME . NAME ( ) , LIT , LIT ] for NAME in NAME : if NAME . NAME ( ) . NAME ( NAME ) : NAME = NAME [ NAME ( NAME ) : ] . NAME ( ) if NAME . NAME ( LIT ) : NAME = NAME [ LIT : ] . NAME ( ) return NAME return None except NAME : return None"
    },
    {
      "module_path": "run_all_tests.py",
      "qualname": "run_module_tests",
      "lineno": 399,
      "end_lineno": 784,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 101,
      "loc": 386,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "regex",
        "size:large"
      ],
      "signature": "(module_name, description, enable_monitoring, coverage)",
      "fingerprint": "5a4452d6b1727a87948fcde21752d9f212d4b3f0",
      "simhash64": 7488180024120874043,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME | None = None , NAME : NAME = False , NAME : NAME = False ) -> NAME [ NAME , NAME , NAME [ NAME ] ] : LIT import NAME # Ensure re is available in function scope # Initialize performance monitoring NAME = NAME ( ) if NAME else None NAME = None # Show description for consistency - avoid repeating module name if NAME : NAME ( f\" \ud83d\udcdd { NAME } \" ) # Create a meaningful description based on module name instead of just repeating it elif LIT in NAME : NAME = ( NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) . NAME ( ) ) NAME ( f\" \ud83d\udcdd Core { NAME } functionality \" ) elif LIT in NAME : NAME = ( NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) . NAME ( ) ) NAME ( f\" \ud83d\udcdd Configuration { NAME } management \" ) elif LIT in NAME : NAME = NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) . NAME ( ) NAME ( f\" \ud83d\udcdd { NAME } automation \" ) elif NAME . NAME ( LIT ) : NAME = NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) . NAME ( ) NAME ( f\" \ud83d\udcdd { NAME } utility functions \" ) elif NAME . NAME ( LIT ) : NAME = ( NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) . NAME ( ) ) NAME ( f\" \ud83d\udcdd { NAME } management system \" ) elif NAME . NAME ( LIT ) : NAME = NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) . NAME ( ) NAME ( f\" \ud83d\udcdd { NAME } caching system \" ) else : # Generic fallback that's more descriptive than just repeating the filename NAME = NAME . NAME ( LIT , LIT ) . NAME ( LIT , LIT ) . NAME ( ) NAME ( f\" \ud83d\udcdd { NAME } module functionality \" ) try : NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) . NAME ( ) # Start performance monitoring if enabled if NAME : NAME . NAME ( ) NAME = [ NAME . NAME ] NAME = None # For modules with internal test suite, set env var to trigger test output NAME = { LIT , LIT } if NAME in NAME : NAME = NAME ( NAME . NAME ) NAME [ LIT ] = LIT if NAME : NAME += [ LIT , LIT , LIT , LIT , NAME ] else : NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME , NAME = False , NAME = True , NAME = True , NAME = NAME . NAME ( ) , NAME = NAME ) NAME = NAME . NAME ( ) - NAME NAME = NAME . NAME ( ) . NAME ( ) # Stop monitoring and collect metrics NAME = NAME . NAME ( ) if NAME else { } # Run quality analysis on the module NAME = None try : NAME = NAME ( NAME ) if NAME . NAME ( ) and NAME . NAME == LIT : NAME = NAME ( ) NAME = NAME . NAME ( NAME ) except NAME : # Quality check failed, continue without it pass # Check for success based on return code AND output content NAME = NAME . NAME == LIT # Extract test counts from output - improved patterns (check both stdout and stderr) NAME = LIT NAME = [ ] if NAME . NAME : NAME . NAME ( NAME . NAME . NAME ( LIT ) ) if NAME . NAME : NAME . NAME ( NAME . NAME . NAME ( LIT ) ) if NAME : NAME = NAME # Use combined output for pattern matching # Pattern 1: Look for \"\u2705 Passed: X\" and \"\u274c Failed: Y\" for NAME in NAME : if LIT in NAME : try : NAME = NAME ( NAME . NAME ( LIT ) [ LIT ] . NAME ( ) [ LIT ] ) NAME = LIT # Look for failed count in same line or nearby lines if LIT in NAME : NAME = NAME ( NAME . NAME ( LIT ) [ LIT ] . NAME ( ) [ LIT ] ) else : # Check other lines for failed count for NAME in NAME : if LIT in NAME : NAME = NAME ( NAME . NAME ( LIT ) [ LIT ] . NAME ( ) [ LIT ] ) break NAME = f\" { NAME + NAME } tests \" break except ( NAME , NAME ) : continue # Pattern 2: Look for \"X/Y tests passed\" or \"Results: X/Y\" if NAME == LIT : for NAME in NAME : if LIT in NAME and LIT in NAME : try : # Extract from \"\ud83d\udcca Results: 3/3 tests passed\" NAME = NAME . NAME ( LIT ) if NAME ( NAME ) >= LIT : NAME = NAME [ LIT ] . NAME ( ) [ LIT ] NAME = f\" { NAME } tests \" break except ( NAME , NAME ) : continue # Pattern 3: Look for \"\u2705 Passed: X\" and \"\u274c Failed: Y\" format (common in many modules) if NAME == LIT : NAME = None NAME = None for NAME in NAME : # Remove ANSI color codes and whitespace NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) if LIT in NAME : try : NAME = NAME ( NAME . NAME ( LIT ) [ LIT ] . NAME ( ) ) except ( NAME , NAME ) : continue elif LIT in NAME : try : NAME = NAME ( NAME . NAME ( LIT ) [ LIT ] . NAME ( ) ) except ( NAME , NAME ) : continue if NAME is not None and NAME is not None : NAME = f\" { NAME + NAME } tests \" elif NAME is not None : NAME = f\" { NAME } + tests \" # Pattern 4: Look for Python unittest format \"Ran X tests in Y.Zs\" if NAME == LIT : for NAME in NAME : NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) if LIT in NAME and LIT in NAME : try : # Extract from \"Ran 24 tests in 0.458s\" NAME = NAME . NAME ( ) NAME = NAME . NAME ( LIT ) if NAME + LIT < NAME ( NAME ) : NAME = NAME ( NAME [ NAME + LIT ] ) NAME = f\" { NAME } tests \" break except ( NAME , NAME ) : continue # Pattern 5: Look for numbered test patterns like \"Test 1:\", \"Test 2:\", etc. if NAME == LIT : NAME = NAME ( ) for NAME in NAME : NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) # Look for patterns like \"\ud83d\udccb Test 1:\", \"Test 2:\", \"\u2022 Test 3:\" NAME = NAME . NAME ( LIT , NAME , NAME . NAME , ) if NAME : NAME . NAME ( NAME ( NAME . NAME ( LIT ) ) ) if NAME : NAME = f\" { NAME ( NAME ) } tests \" # Pattern 6: Look for any number followed by \"test\" or \"tests\" if NAME == LIT : for NAME in NAME : NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) # Look for patterns like \"5 tests\", \"10 test cases\", \"3 test functions\" NAME = NAME . NAME ( LIT , NAME , NAME . NAME , ) if NAME : NAME = NAME ( NAME . NAME ( LIT ) ) NAME = f\" { NAME } tests \" break # Pattern 7: Look for test completion messages with counts if NAME == LIT : for NAME in NAME : NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) # Look for patterns like \"All X tests passed\", \"X operations completed\" NAME = NAME . NAME ( LIT , NAME , NAME . NAME , ) if NAME : NAME = NAME ( NAME . NAME ( LIT ) ) NAME = f\" { NAME } tests \" break # Pattern 8: Look for \"ALL TESTS PASSED\" with counts if NAME == LIT : for NAME in NAME : if LIT in NAME or LIT in NAME : # Look for nearby lines with test counts for NAME in NAME : if LIT in NAME and NAME . NAME ( LIT ) >= LIT : try : NAME = NAME ( NAME . NAME ( LIT ) [ LIT ] . NAME ( ) [ LIT ] ) NAME = f\" { NAME } tests \" break except ( NAME , NAME ) : continue if NAME != LIT : break # Define failure indicators (be more specific to avoid false positives) NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] # Also check output for failure indicators if NAME and NAME . NAME : # Only mark as failed if we find actual failure indicators # Exclude lines that are just showing \"Failed: 0\" (which means 0 failures) NAME = NAME . NAME . NAME ( LIT ) for NAME in NAME : for NAME in NAME : if NAME in NAME and not ( LIT in NAME or LIT in NAME ) : NAME = False break if not NAME : break NAME = LIT if NAME else LIT # Show concise summary with test count and quality score NAME = LIT if NAME : NAME = NAME . NAME NAME = NAME ( NAME . NAME ) if NAME . NAME else LIT if NAME < LIT : NAME = f\" | Quality: { NAME : .1f } /100 \u26a0\ufe0f ( { NAME } issues) \" elif NAME < LIT : NAME = f\" | Quality: { NAME : .1f } /100 \ud83d\udcca ( { NAME } issues) \" else : NAME = f\" | Quality: { NAME : .1f } /100 \u2705 \" NAME ( f\" { NAME } | Duration: { NAME : .2f } s | { NAME } { NAME } \" ) # Show quality violation details for failed quality checks if NAME and NAME . NAME < LIT and NAME . NAME : NAME ( LIT ) # Group violations by type for better readability NAME = { } for NAME in NAME . NAME [ : LIT ] : # Show first 5 if LIT in NAME : NAME . NAME ( LIT , [ ] ) . NAME ( NAME ) elif LIT in NAME : NAME . NAME ( LIT , [ ] ) . NAME ( NAME ) elif LIT in NAME : NAME . NAME ( LIT , [ ] ) . NAME ( NAME ) else : NAME . NAME ( LIT , [ ] ) . NAME ( NAME ) for NAME , NAME in NAME . NAME ( ) : NAME ( f\" { NAME } : { NAME ( NAME ) } issue(s) \" ) for NAME in NAME [ : LIT ] : # Show first 2 of each type # Extract function name for brevity if LIT in NAME and LIT in NAME : NAME = NAME . NAME ( LIT ) [ LIT ] . NAME ( LIT ) [ LIT ] NAME = NAME . NAME ( LIT ) [ LIT ] if LIT in NAME else NAME NAME ( f\" \u2022 { NAME } : { NAME } \" ) else : NAME ( f\" \u2022 { NAME } \" ) if NAME ( NAME . NAME ) > LIT : NAME ( f\" ... and { NAME ( NAME . NAME ) - LIT } more issues \" ) # Extract numeric test count for summary NAME = LIT if NAME != LIT : try : # Extract number from formats like \"8 tests\", \"24 tests\", \"5+ tests\" import NAME # Extract number from formats like \"8 tests\", \"24 tests\", \"5+ tests\" NAME = NAME . NAME ( LIT , NAME ) if NAME : NAME = NAME ( NAME . NAME ( LIT ) ) except ( NAME , NAME ) : NAME = LIT if not NAME : NAME ( LIT ) if NAME . NAME : NAME = NAME . NAME . NAME ( ) . NAME ( LIT ) for NAME in NAME [ - LIT : ] : # Show last 3 error lines NAME ( f\" { NAME } \" ) if NAME . NAME and NAME ( NAME in NAME . NAME for NAME in NAME ) : NAME = NAME . NAME . NAME ( ) . NAME ( LIT ) NAME = [ NAME for NAME in NAME if NAME ( NAME in NAME for NAME in NAME ) ] for NAME in NAME [ - LIT : ] : # Show last 2 failure lines NAME ( f\" { NAME } \" ) # Create performance metrics if monitoring was enabled if NAME : NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME . NAME ( LIT , LIT ) , NAME = NAME . NAME ( LIT , LIT ) , NAME = NAME , NAME = NAME , NAME = NAME . NAME if not NAME and NAME . NAME else None , NAME = NAME ) return NAME , NAME , NAME except NAME as NAME : NAME ( f\" \u274c FAILED | Error: { NAME } \" ) NAME = None if NAME : NAME = NAME ( NAME = NAME , NAME = LIT , NAME = False , NAME = LIT , NAME = LIT , NAME = LIT , NAME = NAME . NAME ( ) . NAME ( ) , NAME = NAME . NAME ( ) . NAME ( ) , NAME = NAME ( NAME ) ) return False , LIT , NAME"
    },
    {
      "module_path": "run_all_tests.py",
      "qualname": "run_tests_parallel",
      "lineno": 787,
      "end_lineno": 824,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 38,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(modules_with_descriptions, enable_monitoring, coverage)",
      "fingerprint": "4419fab717b51cfa08cdae918e09fef44ad55eda",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME = False , NAME : NAME = False ) -> NAME [ NAME [ NAME ] , NAME , NAME ] : LIT NAME = [ ] NAME = LIT NAME = LIT # Determine optimal number of workers (don't exceed CPU count) NAME = NAME . NAME ( ) or LIT # Fallback to 1 if cpu_count() returns None NAME = NAME ( NAME ( NAME ) , NAME ) with NAME . NAME . NAME ( NAME = NAME ) as NAME : # Submit all test jobs NAME = { NAME . NAME ( NAME , NAME , NAME , NAME , NAME ) : ( NAME , NAME ) for NAME , NAME in NAME } # Process results as they complete for NAME , NAME in NAME ( NAME . NAME . NAME ( NAME ) , LIT ) : NAME , NAME = NAME [ NAME ] try : NAME , NAME , NAME = NAME . NAME ( ) if NAME : NAME += LIT NAME += NAME if NAME : NAME . NAME ( NAME ) NAME ( f\" \ud83e\uddea [ { NAME : 2d } / { NAME ( NAME ) } ] Testing: { NAME } \" ) if NAME : NAME ( f\" \ud83d\udcdd { NAME } \" ) except NAME as NAME : NAME ( f\" \ud83e\uddea [ { NAME : 2d } / { NAME ( NAME ) } ] Testing: { NAME } \" ) NAME ( f\" \u274c FAILED | Error: { NAME } \" ) return NAME , NAME , NAME"
    },
    {
      "module_path": "run_all_tests.py",
      "qualname": "save_performance_metrics",
      "lineno": 827,
      "end_lineno": 860,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 8,
      "loc": 34,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "json",
        "size:medium"
      ],
      "signature": "(metrics, suite_performance)",
      "fingerprint": "31da0ae55b4166c6c78ba133ac68f81845967b2d",
      "simhash64": 7488180022980031547,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME ) : LIT try : NAME = NAME ( LIT ) # Load existing metrics if file exists NAME = [ ] if NAME . NAME ( ) : try : with NAME . NAME ( ) as NAME : NAME = NAME . NAME ( NAME ) except ( NAME . NAME , NAME ) : NAME = [ ] # Add new metrics NAME = { LIT : NAME . NAME ( ) . NAME ( ) , LIT : NAME ( NAME ) , LIT : [ NAME ( NAME ) for NAME in NAME ] } NAME . NAME ( NAME ) # Keep only last 50 runs to prevent file from growing too large if NAME ( NAME ) > LIT : NAME = NAME [ - LIT : ] # Save updated metrics with NAME . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME , NAME = LIT ) NAME ( f\" \ud83d\udcca Performance metrics saved to { NAME } \" ) except NAME as NAME : NAME ( f\" \u26a0\ufe0f  Failed to save performance metrics: { NAME } \" )"
    },
    {
      "module_path": "run_all_tests.py",
      "qualname": "analyze_performance_trends",
      "lineno": 863,
      "end_lineno": 892,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 10,
      "loc": 30,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(metrics)",
      "fingerprint": "2b60dd8054983df8eff9da8a2d1cc27268753eac",
      "simhash64": 7488109654302962707,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME [ NAME ] : LIT NAME = [ ] if not NAME : return NAME # Analyze slow tests NAME = [ NAME for NAME in NAME if NAME . NAME > LIT ] # Tests taking more than 10 seconds if NAME : NAME . NAME ( NAME = lambda NAME : NAME . NAME , NAME = True ) NAME . NAME ( f\" \ud83d\udc0c { NAME ( NAME ) } slow tests detected (>10s). Slowest: { NAME [ LIT ] . NAME } ( { NAME [ LIT ] . NAME : .1f } s) \" ) # Analyze memory usage NAME = [ NAME for NAME in NAME if NAME . NAME > LIT ] # Tests using more than 100MB if NAME : NAME . NAME ( NAME = lambda NAME : NAME . NAME , NAME = True ) NAME . NAME ( f\" \ud83e\udde0 { NAME ( NAME ) } memory-intensive tests detected (>100MB). Highest: { NAME [ LIT ] . NAME } ( { NAME [ LIT ] . NAME : .1f } MB) \" ) # Analyze CPU usage NAME = [ NAME for NAME in NAME if NAME . NAME > LIT ] # Tests using more than 50% CPU if NAME : NAME . NAME ( f\" \u26a1 { NAME ( NAME ) } CPU-intensive tests detected (>50% CPU) \" ) # Suggest parallel execution if not already used NAME = NAME ( NAME . NAME for NAME in NAME ) if NAME > LIT : # If total time > 1 minute NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "run_all_tests.py",
      "qualname": "main",
      "lineno": 895,
      "end_lineno": 1099,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 54,
      "loc": 205,
      "tags": [
        "impure",
        "logging",
        "time",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "2fb08a91cd27dd426f6ecd81a82f883370bc4b6d",
      "simhash64": 7488109654235845691,
      "normalized": "def NAME ( ) -> NAME : LIT # Parse command line arguments NAME = LIT in NAME . NAME NAME = LIT in NAME . NAME NAME = NAME or NAME NAME ( LIT ) if NAME : NAME ( LIT ) if NAME : NAME ( LIT ) NAME ( LIT * LIT ) NAME ( ) # Blank line # Run linter first for hygiene; fail fast only on safe subset if not NAME ( ) : return False # Run quality checks for Python best practices if not NAME ( ) : NAME ( LIT ) # Auto-discover all test modules with the standardized test function NAME = NAME ( ) if not NAME : NAME ( LIT ) return False # Extract descriptions from module docstrings for enhanced reporting NAME = { } NAME = LIT for NAME in NAME : NAME = NAME ( NAME ) if NAME : NAME [ NAME ] = NAME NAME += LIT NAME = NAME . NAME ( ) NAME ( f\" \ud83d\udcca Found { NAME ( NAME ) } test modules ( { NAME } with enhanced descriptions) \" ) NAME ( f\" \\n { LIT * LIT } \" ) NAME ( LIT ) NAME ( f\" { LIT * LIT } \" ) # Prepare modules with descriptions NAME = [ ( NAME , NAME . NAME ( NAME , LIT ) ) for NAME in NAME ] # Run tests with appropriate method if NAME : NAME ( LIT ) NAME , NAME , NAME = NAME ( NAME , NAME ) NAME = [ ( NAME . NAME , NAME . NAME ( NAME . NAME , LIT ) , NAME . NAME ) for NAME in NAME ] else : NAME ( LIT ) NAME = [ ] NAME = [ ] NAME = LIT NAME = LIT for NAME , ( NAME , NAME ) in NAME ( NAME , LIT ) : NAME ( f\" \\n\ud83e\uddea [ { NAME : 2d } / { NAME ( NAME ) } ] Testing: { NAME } \" ) NAME , NAME , NAME = NAME ( NAME , NAME , NAME , NAME = NAME ) NAME += NAME if NAME : NAME += LIT if NAME : NAME . NAME ( NAME ) NAME . NAME ( ( NAME , NAME or f\" Tests for { NAME } \" , NAME ) ) # Print comprehensive summary with performance metrics NAME = NAME . NAME ( ) - NAME if not NAME : # Recalculate for sequential mode NAME = NAME ( LIT for NAME , NAME , NAME in NAME if NAME ) NAME = NAME ( NAME ) - NAME NAME = ( NAME / NAME ( NAME ) ) * LIT if NAME else LIT NAME ( f\" \\n { LIT * LIT } \" ) NAME ( LIT ) NAME ( f\" { LIT * LIT } \" ) NAME ( f\" \u23f0 Duration: { NAME : .1f } s \" ) NAME ( f\" \ud83e\uddea Total Tests Run: { NAME } \" ) NAME ( f\" \u2705 Passed: { NAME } \" ) NAME ( f\" \u274c Failed: { NAME } \" ) NAME ( f\" \ud83d\udcc8 Success Rate: { NAME : .1f } % \" ) # Quality summary with detailed breakdown if NAME and NAME ( NAME . NAME for NAME in NAME ) : NAME = [ NAME . NAME . NAME for NAME in NAME if NAME . NAME ] if NAME : NAME = NAME ( NAME ) / NAME ( NAME ) NAME = NAME ( LIT for NAME in NAME if NAME < LIT ) NAME = NAME ( LIT for NAME in NAME if LIT <= NAME < LIT ) NAME = NAME ( LIT for NAME in NAME if NAME >= LIT ) NAME ( f\" \ud83d\udd0d Quality Score: { NAME : .1f } /100 avg \" ) NAME ( f\" \u2705 Above 95%: { NAME } modules \" ) NAME ( f\" \ud83d\udcca 70-95%: { NAME } modules \" ) NAME ( f\" \u26a0\ufe0f  Below 70%: { NAME } modules \" ) # Show most common violation types NAME = [ ] for NAME in NAME : if NAME . NAME and NAME . NAME . NAME : NAME . NAME ( NAME . NAME . NAME ) if NAME : NAME = { } for NAME in NAME : if LIT in NAME : NAME [ LIT ] = NAME . NAME ( LIT , LIT ) + LIT elif LIT in NAME : NAME [ LIT ] = NAME . NAME ( LIT , LIT ) + LIT elif LIT in NAME : NAME [ LIT ] = NAME . NAME ( LIT , LIT ) + LIT else : NAME [ LIT ] = NAME . NAME ( LIT , LIT ) + LIT NAME ( LIT ) for NAME , NAME in NAME ( NAME . NAME ( ) , NAME = lambda NAME : NAME [ LIT ] , NAME = True ) : NAME ( f\" { NAME } : { NAME } violations \" ) # Performance metrics and analysis if NAME and NAME : NAME = NAME ( NAME . NAME for NAME in NAME ) / NAME ( NAME ) NAME = NAME ( NAME . NAME for NAME in NAME ) NAME = NAME ( NAME . NAME for NAME in NAME ) / NAME ( NAME ) NAME = NAME ( NAME . NAME for NAME in NAME ) # Calculate parallel efficiency NAME = NAME ( NAME . NAME for NAME in NAME ) NAME = ( NAME / NAME ) if NAME > LIT else LIT NAME ( LIT ) NAME ( f\" \ud83d\udcbe Memory Usage: { NAME : .1f } MB avg, { NAME : .1f } MB peak \" ) NAME ( f\" \u26a1 CPU Usage: { NAME : .1f } % avg, { NAME : .1f } % peak \" ) if NAME : NAME ( f\" \ud83d\ude80 Parallel Efficiency: { NAME : .1f } x speedup \" ) # Create suite performance metrics NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ( NAME ) ) # Show optimization suggestions if NAME . NAME : NAME ( LIT ) for NAME in NAME . NAME : NAME ( f\" { NAME } \" ) # Save metrics for trend analysis if NAME : NAME ( NAME , NAME ) # Show failed modules first if any if NAME > LIT : NAME ( LIT ) for NAME , NAME , NAME in NAME : if not NAME : NAME ( f\" \u2022 { NAME } \" ) # Show summary by category NAME = NAME ( LIT for NAME , NAME , NAME in NAME if NAME and NAME in NAME ) NAME = NAME ( LIT for NAME , NAME , NAME in NAME if not NAME and NAME in NAME ) NAME ( LIT ) NAME ( f\" Enhanced Modules: { NAME } passed, { NAME } failed \" ) NAME ( f\" Standard Modules: { NAME - NAME } passed, { NAME - NAME } failed \" ) if NAME == LIT : NAME ( f\" \\n\ud83c\udf89 ALL { NAME ( NAME ) } MODULES PASSED! \" ) NAME ( f\" Professional testing framework with { NAME ( NAME ) } standardized modules complete.\\n \" ) else : NAME ( f\" \\n\u26a0\ufe0f { NAME } module(s) failed. \" ) NAME ( LIT ) return NAME == LIT"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "SecurityManager.__init__",
      "lineno": 110,
      "end_lineno": 113,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "impure",
        "filesystem",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, app_name)",
      "fingerprint": "cf85a313e4303851d1aa26f2046a0f6b4e84377e",
      "simhash64": 7488109655376704531,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) : NAME . NAME = NAME NAME . NAME = NAME ( LIT ) NAME . NAME = None"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "SecurityManager._get_master_key",
      "lineno": 115,
      "end_lineno": 129,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 15,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "7fb4dc38921ed1a078283b644f93a7f15ad77d54",
      "simhash64": 7487652261693666355,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : # Try to get existing key from system keyring NAME = NAME . NAME ( NAME . NAME , LIT ) if NAME : return NAME . NAME ( NAME . NAME ( ) ) except NAME as NAME : NAME . NAME ( f\" Could not retrieve master key from keyring: { NAME } \" ) # Generate new key if none exists return NAME . NAME ( )"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "SecurityManager._generate_new_master_key",
      "lineno": 131,
      "end_lineno": 147,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "randomness",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "f2f0198abd0e1d3a54303de3bc64b82fa7666e85",
      "simhash64": 7487617073026610195,
      "normalized": "def NAME ( NAME ) -> NAME : LIT # Generate a secure random key NAME = NAME . NAME ( ) try : # Store in system keyring NAME = NAME . NAME ( NAME ) . NAME ( ) NAME . NAME ( NAME . NAME , LIT , NAME ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Failed to store master key in keyring: { NAME } \" ) NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "SecurityManager._get_fernet",
      "lineno": 149,
      "end_lineno": 154,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "63903c56f79857c9f80d7c560bb6eaf29532f24b",
      "simhash64": 8641031158842696723,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if NAME . NAME is None : NAME = NAME . NAME ( ) NAME . NAME = NAME ( NAME ) return NAME . NAME"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "SecurityManager.encrypt_credentials",
      "lineno": 156,
      "end_lineno": 186,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 31,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:medium"
      ],
      "signature": "(self, credentials)",
      "fingerprint": "6358ab15e2852d431688905c3d1f41ce92d133d4",
      "simhash64": 7488215207352120339,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT try : NAME = NAME . NAME ( ) # Serialize and encrypt credentials NAME = NAME . NAME ( NAME ) . NAME ( ) NAME = NAME . NAME ( NAME ) # Write to encrypted file from NAME import NAME with NAME . NAME . NAME ( LIT ) as NAME : NAME . NAME ( NAME ) # Set restrictive file permissions NAME ( NAME . NAME ) . NAME ( LIT ) NAME . NAME ( f\" Encrypted { NAME ( NAME ) } credentials successfully \" ) return True except NAME as NAME : NAME . NAME ( f\" Failed to encrypt credentials: { NAME } \" ) return False"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "SecurityManager.decrypt_credentials",
      "lineno": 188,
      "end_lineno": 214,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 27,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "5f8edd30c7c8e1b4f015870d632e0d0d33689d51",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME . NAME . NAME ( ) : NAME . NAME ( LIT ) return None try : NAME = NAME . NAME ( ) # Read and decrypt file with NAME . NAME . NAME ( LIT ) as NAME : NAME = NAME . NAME ( ) NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( NAME . NAME ( ) ) NAME . NAME ( f\" Decrypted { NAME ( NAME ) } credentials successfully \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Failed to decrypt credentials: { NAME } \" ) return None"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "SecurityManager.migrate_env_credentials",
      "lineno": 216,
      "end_lineno": 301,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 14,
      "loc": 86,
      "tags": [
        "impure",
        "filesystem",
        "size:medium"
      ],
      "signature": "(self, env_file_path)",
      "fingerprint": "bad579d1537d4e039bf94b68aab2bf0156239e1c",
      "simhash64": 8641101527586878483,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) -> NAME : LIT NAME = NAME ( NAME ) if not NAME . NAME ( ) : NAME . NAME ( f\" Environment file { NAME } not found \" ) return False NAME = { } NAME = [ LIT , LIT , LIT , LIT , ] try : # Read .env file and extract sensitive credentials with NAME ( NAME ) . NAME ( ) as NAME : for NAME in NAME : NAME = NAME . NAME ( ) if LIT in NAME and not NAME . NAME ( LIT ) : NAME , NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) . NAME ( LIT ) if NAME in NAME and NAME : NAME [ NAME ] = NAME if not NAME : NAME . NAME ( LIT ) return True # Check if encrypted credentials already exist and can be decrypted NAME = NAME . NAME ( ) if NAME is not None : NAME . NAME ( f\" Found { NAME ( NAME ) } existing encrypted credentials \" ) # Merge with new credentials from .env NAME . NAME ( NAME ) NAME = NAME NAME . NAME ( f\" Merged credentials, total: { NAME ( NAME ) } \" ) elif NAME . NAME . NAME ( ) : # Encrypted file exists but can't be decrypted (key mismatch) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) # Backup the old encrypted file NAME = NAME ( f\" { NAME . NAME } .backup \" ) if NAME . NAME ( ) : NAME . NAME ( ) # Remove old backup NAME . NAME . NAME ( NAME ) NAME . NAME ( f\" Backed up old encrypted file to { NAME } \" ) # Encrypt and store credentials (this will create a new file) if not NAME . NAME ( NAME ) : return False # Create backup of original .env file NAME = NAME . NAME ( LIT ) NAME . NAME ( NAME ) NAME . NAME ( f\" Backed up original .env file to { NAME } \" ) # Create new .env file with credentials removed NAME . NAME ( NAME , NAME , NAME ) NAME . NAME ( f\" Successfully migrated { NAME ( NAME ) } credentials to encrypted storage \" ) return True except NAME as NAME : NAME . NAME ( f\" Failed to migrate credentials: { NAME } \" ) return False"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "SecurityManager._create_secure_env_file",
      "lineno": 303,
      "end_lineno": 320,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 18,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, env_path, backup_path, sensitive_keys)",
      "fingerprint": "f173efd84925c46a33b91d64d05700b3e8ec39a0",
      "simhash64": 7487617073026610235,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME ) : LIT with NAME ( NAME ) . NAME ( ) as NAME , NAME ( NAME ) . NAME ( LIT ) as NAME : NAME . NAME ( LIT ) NAME . NAME ( LIT ) for NAME in NAME : NAME = NAME . NAME ( ) # Skip sensitive credential lines if NAME ( NAME . NAME ( NAME + LIT ) for NAME in NAME ) : # Add placeholder comment NAME = NAME . NAME ( LIT ) [ LIT ] NAME . NAME ( f\" # { NAME } =<stored_in_encrypted_storage>\\n \" ) else : NAME . NAME ( NAME )"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "SecurityManager.get_credential",
      "lineno": 322,
      "end_lineno": 335,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self, key)",
      "fingerprint": "6909c168cf423ed68e2c6a611a8ab871226ec5ad",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT NAME = NAME . NAME ( ) if NAME : return NAME . NAME ( NAME ) return None"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "SecurityManager.prompt_for_credentials",
      "lineno": 337,
      "end_lineno": 372,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 36,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "5a10b6562833171ab7e9e6eb7768d9b9932828d8",
      "simhash64": 7488180023047140355,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME ( LIT ) NAME ( LIT ) NAME = { } # Ancestry credentials NAME = NAME ( LIT ) . NAME ( ) if NAME : NAME [ LIT ] = NAME NAME = NAME . NAME ( LIT ) . NAME ( ) if NAME : NAME [ LIT ] = NAME # AI API keys NAME = ( NAME ( LIT ) . NAME ( ) or LIT ) if NAME . NAME ( ) == LIT : NAME = NAME . NAME ( LIT ) . NAME ( ) if NAME : NAME [ LIT ] = NAME elif NAME . NAME ( ) == LIT : NAME = NAME . NAME ( LIT ) . NAME ( ) if NAME : NAME [ LIT ] = NAME return NAME"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "SecurityManager.setup_secure_credentials",
      "lineno": 374,
      "end_lineno": 405,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 5,
      "loc": 32,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "b4107252636c870a2f7fc43b3ba907285d843e4b",
      "simhash64": 7487652257465799723,
      "normalized": "def NAME ( NAME ) -> NAME : LIT # Check if credentials already exist NAME = NAME . NAME ( ) if NAME : NAME ( LIT ) NAME = NAME ( LIT ) . NAME ( ) . NAME ( ) if NAME != LIT : return True # Get credentials from user NAME = NAME . NAME ( ) if not NAME : NAME ( LIT ) return False # Encrypt and store if NAME . NAME ( NAME ) : NAME ( f\" \\n\u2713 Successfully encrypted and stored { NAME ( NAME ) } credentials \" ) NAME ( LIT ) return True NAME ( LIT ) return False"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "SecurityManager.delete_credentials",
      "lineno": 407,
      "end_lineno": 430,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "587c5a92b6d2e591ed88e192e2cf471cd50c7d04",
      "simhash64": 7487652257465807875,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : if NAME . NAME . NAME ( ) : NAME . NAME . NAME ( ) NAME . NAME ( LIT ) # Also try to remove from keyring try : NAME . NAME ( NAME . NAME , LIT ) NAME . NAME ( LIT ) except NAME : pass # Key might not exist return True except NAME as NAME : NAME . NAME ( f\" Failed to delete credentials: { NAME } \" ) return False"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "SecurityManager.validate_credentials",
      "lineno": 432,
      "end_lineno": 449,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self, credentials)",
      "fingerprint": "fe6d5cd2e11594e22a95fae8a503a30801b6f37b",
      "simhash64": 7488180022980023347,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = [ LIT , LIT ] for NAME in NAME : if not NAME . NAME ( NAME ) : NAME . NAME ( f\" Missing required credential: { NAME } \" ) return False return True"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 452,
      "end_lineno": 937,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 18,
      "loc": 486,
      "tags": [
        "impure",
        "network",
        "time",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "1689125e7083243a472efa86561514004749055f",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( ) -> NAME : LIT NAME . NAME ( LIT ) # Quick basic test first try : # Test basic instantiation NAME = NAME ( LIT ) assert NAME . NAME == LIT NAME . NAME ( LIT ) # Test encryption/decryption with credentials NAME = { LIT : LIT , LIT : LIT } NAME = NAME . NAME ( NAME ) assert NAME is True NAME . NAME ( LIT ) # Test credential retrieval NAME = NAME . NAME ( ) assert NAME is not None assert NAME [ LIT ] == LIT NAME . NAME ( LIT ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" \u274c Basic SecurityManager tests failed: { NAME } \" ) return False with NAME ( ) : NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # SecurityManager instantiation and basic setup def NAME ( ) : NAME = NAME ( LIT ) assert NAME . NAME == LIT assert NAME . NAME . NAME == LIT assert NAME . NAME is None # Test data with 12345 identifier NAME = LIT assert ( LIT in NAME ) , LIT # Master key generation and retrieval def NAME ( ) : NAME = NAME ( LIT ) try : # Test key generation NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT # Fernet generates 44-byte base64-encoded keys assert NAME ( NAME ) in [ LIT , LIT , ] , f\" Fernet key should be 32 or 44 bytes, got { NAME ( NAME ) } \" # Test key consistency NAME = NAME . NAME ( ) assert NAME == NAME , LIT # Test Fernet instance creation NAME = NAME . NAME ( ) assert NAME is not None , LIT finally : NAME . NAME ( ) # Credential encryption and decryption def NAME ( ) : NAME = NAME ( LIT ) NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } try : # Test encryption NAME = NAME . NAME ( NAME ) assert NAME is True , LIT # Verify file exists assert NAME . NAME . NAME ( ) , LIT # Test decryption NAME = NAME . NAME ( ) assert NAME is not None , LIT assert ( NAME == NAME ) , LIT finally : NAME . NAME ( ) # Individual credential retrieval def NAME ( ) : NAME = NAME ( LIT ) NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } try : NAME . NAME ( NAME ) # Test getting existing credentials NAME = NAME . NAME ( LIT ) assert ( NAME == LIT ) , LIT NAME = NAME . NAME ( LIT ) assert NAME == LIT , LIT # Test getting non-existent credential NAME = NAME . NAME ( LIT ) assert NAME is None , LIT finally : NAME . NAME ( ) # Credential validation def NAME ( ) : NAME = NAME ( LIT ) # Test valid credentials NAME = { LIT : LIT , LIT : LIT , } assert ( NAME . NAME ( NAME ) is True ) , LIT # Test missing username NAME = { LIT : LIT } with NAME ( ) : # EXPECTED: Suppresses intentional validation error assert ( NAME . NAME ( NAME ) is False ) , LIT # Test missing password NAME = { LIT : LIT } with NAME ( ) : # EXPECTED: Suppresses intentional validation error assert ( NAME . NAME ( NAME ) is False ) , LIT # Test empty values NAME = { LIT : LIT , LIT : LIT , } with NAME ( ) : # EXPECTED: Suppresses intentional validation error assert ( NAME . NAME ( NAME ) is False ) , LIT # Error handling and edge cases def NAME ( ) : NAME = NAME ( LIT ) # Test decryption with no file NAME = NAME . NAME ( ) assert NAME is None , LIT # Test get_credential with no encrypted file NAME = NAME . NAME ( LIT ) assert NAME is None , LIT # Test data with 12345 identifier NAME = LIT assert ( LIT in NAME ) , LIT # Test encryption with edge case data try : # This should handle gracefully NAME = NAME . NAME ( { LIT : LIT } ) # Should either succeed or fail gracefully assert NAME ( NAME , NAME ) except NAME : # If it raises an exception, that's also acceptable for this edge case pass # File permissions and security def NAME ( ) : import NAME NAME = NAME ( LIT ) NAME = { LIT : LIT } try : NAME . NAME ( NAME ) if NAME . NAME . NAME ( ) : # Check file permissions (on Unix-like systems) NAME = NAME . NAME . NAME ( ) NAME . NAME ( NAME . NAME ) # File should be readable/writable by owner only # This test is best-effort since Windows permissions work differently if NAME ( NAME , LIT ) : NAME = NAME . NAME ( NAME . NAME ) # On Unix: should be 0o600 (owner read/write only) # On Windows: this test may not be meaningful # Log permissions for visibility NAME . NAME ( f\" File permissions: { NAME ( NAME ) } \" ) finally : NAME . NAME ( ) # Credential deletion and cleanup def NAME ( ) : NAME = NAME ( LIT ) NAME = { LIT : LIT } # Create credentials file NAME . NAME ( NAME ) assert ( NAME . NAME . NAME ( ) ) , LIT # Test deletion NAME = NAME . NAME ( ) assert NAME is True , LIT assert ( not NAME . NAME . NAME ( ) ) , LIT # Test deletion when file doesn't exist NAME = NAME . NAME ( ) assert NAME is True , LIT # Multiple SecurityManager instances def NAME ( ) : NAME = NAME ( LIT ) NAME = NAME ( LIT ) # Same app name NAME = { LIT : LIT } NAME = { LIT : LIT } try : # Same app name means they share the same master key # so the second encryption will overwrite the first # Encrypt credentials with first manager NAME = NAME . NAME ( NAME ) assert NAME is True , LIT # Verify first manager can read its own data NAME = NAME . NAME ( ) assert ( NAME == NAME ) , LIT # Encrypt credentials with second manager (will overwrite) NAME = NAME . NAME ( NAME ) assert NAME is True , LIT # Both managers will read the same file (last written) NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) # They should both read the same data (from manager2) assert NAME == NAME , LIT assert NAME == NAME , LIT finally : NAME . NAME ( ) NAME . NAME ( ) # Integration test - full workflow def NAME ( ) : NAME = NAME ( LIT ) # Simulate full setup workflow NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } try : # Step 1: Encrypt credentials assert ( NAME . NAME ( NAME ) is True ) , LIT # Step 2: Validate stored credentials NAME = NAME . NAME ( ) assert NAME is not None , LIT assert ( NAME . NAME ( NAME ) is True ) , LIT # Step 3: Retrieve individual credentials NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) assert ( NAME == LIT ) , LIT assert NAME == LIT , LIT assert NAME == LIT , LIT # Step 4: Test with missing optional credential NAME = NAME . NAME ( LIT ) assert NAME is None finally : NAME . NAME ( ) # Run tests organized by standard categories with NAME ( ) : # Initialization Tests NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Core Functionality Tests NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Edge Cases Tests NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Integration Tests NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Performance Tests def NAME ( ) : LIT import NAME NAME = NAME ( LIT ) # Create larger credential set NAME = { f\" KEY_ { NAME } _12345 \" : f\" value_ { NAME } _ { LIT * LIT } _12345 \" for NAME in NAME ( LIT ) } try : # Test encryption performance NAME = NAME . NAME ( ) NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( ) - NAME assert NAME is True , LIT assert ( NAME < LIT ) , f\" Encryption took too long: { NAME : .2f } s \" # Test decryption performance NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) - NAME assert ( NAME == NAME ) , LIT assert ( NAME < LIT ) , f\" Decryption took too long: { NAME : .2f } s \" finally : NAME . NAME ( ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Error Handling Tests NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "test_security_manager_instantiation",
      "lineno": 526,
      "end_lineno": 536,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "e9bc65f21a314a69fbe9d821cd8d65ee42f72ad6",
      "simhash64": 7452151225961068083,
      "normalized": "def NAME ( ) : NAME = NAME ( LIT ) assert NAME . NAME == LIT assert NAME . NAME . NAME == LIT assert NAME . NAME is None # Test data with 12345 identifier NAME = LIT assert ( LIT in NAME ) , LIT"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "test_master_key_operations",
      "lineno": 539,
      "end_lineno": 559,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c0fbeca80fffaf65f0007177e0803fe9273311ff",
      "simhash64": 7452291968818648103,
      "normalized": "def NAME ( ) : NAME = NAME ( LIT ) try : # Test key generation NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT # Fernet generates 44-byte base64-encoded keys assert NAME ( NAME ) in [ LIT , LIT , ] , f\" Fernet key should be 32 or 44 bytes, got { NAME ( NAME ) } \" # Test key consistency NAME = NAME . NAME ( ) assert NAME == NAME , LIT # Test Fernet instance creation NAME = NAME . NAME ( ) assert NAME is not None , LIT finally : NAME . NAME ( )"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "test_credential_encryption_decryption",
      "lineno": 562,
      "end_lineno": 587,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "684d72a605d6730b988d01d96ceac7dae2830f4c",
      "simhash64": 7452854880117364271,
      "normalized": "def NAME ( ) : NAME = NAME ( LIT ) NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } try : # Test encryption NAME = NAME . NAME ( NAME ) assert NAME is True , LIT # Verify file exists assert NAME . NAME . NAME ( ) , LIT # Test decryption NAME = NAME . NAME ( ) assert NAME is not None , LIT assert ( NAME == NAME ) , LIT finally : NAME . NAME ( )"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "test_individual_credential_retrieval",
      "lineno": 590,
      "end_lineno": 615,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "fd211d3a1aca6e66aee6d942c4a82cea0492b814",
      "simhash64": 7451729014569735723,
      "normalized": "def NAME ( ) : NAME = NAME ( LIT ) NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } try : NAME . NAME ( NAME ) # Test getting existing credentials NAME = NAME . NAME ( LIT ) assert ( NAME == LIT ) , LIT NAME = NAME . NAME ( LIT ) assert NAME == LIT , LIT # Test getting non-existent credential NAME = NAME . NAME ( LIT ) assert NAME is None , LIT finally : NAME . NAME ( )"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "test_credential_validation",
      "lineno": 618,
      "end_lineno": 652,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 35,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "3dc9b44e24f883c1453083fa0cf5ad46f4911025",
      "simhash64": 7452890064490501679,
      "normalized": "def NAME ( ) : NAME = NAME ( LIT ) # Test valid credentials NAME = { LIT : LIT , LIT : LIT , } assert ( NAME . NAME ( NAME ) is True ) , LIT # Test missing username NAME = { LIT : LIT } with NAME ( ) : # EXPECTED: Suppresses intentional validation error assert ( NAME . NAME ( NAME ) is False ) , LIT # Test missing password NAME = { LIT : LIT } with NAME ( ) : # EXPECTED: Suppresses intentional validation error assert ( NAME . NAME ( NAME ) is False ) , LIT # Test empty values NAME = { LIT : LIT , LIT : LIT , } with NAME ( ) : # EXPECTED: Suppresses intentional validation error assert ( NAME . NAME ( NAME ) is False ) , LIT"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "test_error_handling",
      "lineno": 655,
      "end_lineno": 680,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9b5f2e213ad9c3ff1ab45728d46c7def8085b376",
      "simhash64": 8641277416154502691,
      "normalized": "def NAME ( ) : NAME = NAME ( LIT ) # Test decryption with no file NAME = NAME . NAME ( ) assert NAME is None , LIT # Test get_credential with no encrypted file NAME = NAME . NAME ( LIT ) assert NAME is None , LIT # Test data with 12345 identifier NAME = LIT assert ( LIT in NAME ) , LIT # Test encryption with edge case data try : # This should handle gracefully NAME = NAME . NAME ( { LIT : LIT } ) # Should either succeed or fail gracefully assert NAME ( NAME , NAME ) except NAME : # If it raises an exception, that's also acceptable for this edge case pass"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "test_file_security",
      "lineno": 683,
      "end_lineno": 707,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 25,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ca11504318d339aab176c16df625bf0008a35eba",
      "simhash64": 8641066343281898547,
      "normalized": "def NAME ( ) : import NAME NAME = NAME ( LIT ) NAME = { LIT : LIT } try : NAME . NAME ( NAME ) if NAME . NAME . NAME ( ) : # Check file permissions (on Unix-like systems) NAME = NAME . NAME . NAME ( ) NAME . NAME ( NAME . NAME ) # File should be readable/writable by owner only # This test is best-effort since Windows permissions work differently if NAME ( NAME , LIT ) : NAME = NAME . NAME ( NAME . NAME ) # On Unix: should be 0o600 (owner read/write only) # On Windows: this test may not be meaningful # Log permissions for visibility NAME . NAME ( f\" File permissions: { NAME ( NAME ) } \" ) finally : NAME . NAME ( )"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "test_credential_deletion",
      "lineno": 710,
      "end_lineno": 729,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "41d383922b47274287a71538174a5eff42bf00fb",
      "simhash64": 8640573763079279619,
      "normalized": "def NAME ( ) : NAME = NAME ( LIT ) NAME = { LIT : LIT } # Create credentials file NAME . NAME ( NAME ) assert ( NAME . NAME . NAME ( ) ) , LIT # Test deletion NAME = NAME . NAME ( ) assert NAME is True , LIT assert ( not NAME . NAME . NAME ( ) ) , LIT # Test deletion when file doesn't exist NAME = NAME . NAME ( ) assert NAME is True , LIT"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "test_multiple_instances",
      "lineno": 732,
      "end_lineno": 767,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 36,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "4534b106a8d8529a194e716ed2642c14eb51906f",
      "simhash64": 7488355944840467507,
      "normalized": "def NAME ( ) : NAME = NAME ( LIT ) NAME = NAME ( LIT ) # Same app name NAME = { LIT : LIT } NAME = { LIT : LIT } try : # Same app name means they share the same master key # so the second encryption will overwrite the first # Encrypt credentials with first manager NAME = NAME . NAME ( NAME ) assert NAME is True , LIT # Verify first manager can read its own data NAME = NAME . NAME ( ) assert ( NAME == NAME ) , LIT # Encrypt credentials with second manager (will overwrite) NAME = NAME . NAME ( NAME ) assert NAME is True , LIT # Both managers will read the same file (last written) NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) # They should both read the same data (from manager2) assert NAME == NAME , LIT assert NAME == NAME , LIT finally : NAME . NAME ( ) NAME . NAME ( )"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "test_full_workflow",
      "lineno": 770,
      "end_lineno": 809,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 40,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "4aaae3ab2b9f0add5c896e5042d3274150b33f3d",
      "simhash64": 7451728980277105707,
      "normalized": "def NAME ( ) : NAME = NAME ( LIT ) # Simulate full setup workflow NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } try : # Step 1: Encrypt credentials assert ( NAME . NAME ( NAME ) is True ) , LIT # Step 2: Validate stored credentials NAME = NAME . NAME ( ) assert NAME is not None , LIT assert ( NAME . NAME ( NAME ) is True ) , LIT # Step 3: Retrieve individual credentials NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) assert ( NAME == LIT ) , LIT assert NAME == LIT , LIT assert NAME == LIT , LIT # Step 4: Test with missing optional credential NAME = NAME . NAME ( LIT ) assert NAME is None finally : NAME . NAME ( )"
    },
    {
      "module_path": "security_manager.py",
      "qualname": "test_performance",
      "lineno": 885,
      "end_lineno": 918,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 34,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "6f8a080855b2af1897f2175c0df18704d9c9e744",
      "simhash64": 7452186411407938587,
      "normalized": "def NAME ( ) : LIT import NAME NAME = NAME ( LIT ) # Create larger credential set NAME = { f\" KEY_ { NAME } _12345 \" : f\" value_ { NAME } _ { LIT * LIT } _12345 \" for NAME in NAME ( LIT ) } try : # Test encryption performance NAME = NAME . NAME ( ) NAME = NAME . NAME ( NAME ) NAME = NAME . NAME ( ) - NAME assert NAME is True , LIT assert ( NAME < LIT ) , f\" Encryption took too long: { NAME : .2f } s \" # Test decryption performance NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) - NAME assert ( NAME == NAME ) , LIT assert ( NAME < LIT ) , f\" Decryption took too long: { NAME : .2f } s \" finally : NAME . NAME ( )"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "force_user_agent",
      "lineno": 37,
      "end_lineno": 49,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(driver, user_agent)",
      "fingerprint": "2c618b483321a95389fa106189c9349e99e974d5",
      "simhash64": 7488180022980023347,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME ) : LIT if not NAME : NAME . NAME ( LIT ) return False # Use execute_script to modify the user agent NAME . NAME ( LIT , NAME ) NAME . NAME ( f\" Set user agent to: { NAME } \" ) return True"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "extract_text",
      "lineno": 53,
      "end_lineno": 57,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(element)",
      "fingerprint": "481d54937a0fc9c1ed4252889cbbb92aeb868286",
      "simhash64": 7492182245305127939,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME : return LIT return NAME . NAME or LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "extract_attribute",
      "lineno": 61,
      "end_lineno": 65,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(element, attribute)",
      "fingerprint": "dfd8305cc1d1512e59d4c30e03fe75c903357c64",
      "simhash64": 7487757810514957347,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT if not NAME : return LIT return NAME . NAME ( NAME ) or LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "is_elem_there",
      "lineno": 69,
      "end_lineno": 74,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(driver, selector, by)",
      "fingerprint": "0b10cb33b4c4c88010987d6ef4219796ff305a15",
      "simhash64": 7488109654235841539,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME = NAME . NAME ) -> NAME : LIT if not NAME : return False NAME . NAME ( NAME , NAME ) return True"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "is_browser_open",
      "lineno": 78,
      "end_lineno": 84,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "impure",
        "filesystem",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(driver)",
      "fingerprint": "6a4f8c296ffca8c529b98902f284eba81451436a",
      "simhash64": 5182258398752060499,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME : return False # Access current_url - will raise exception if browser is closed NAME = NAME . NAME return True"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "close_tabs",
      "lineno": 88,
      "end_lineno": 105,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(driver, keep_first)",
      "fingerprint": "705b21f54b69c5a2b171c0e1785970a4e0ca2c08",
      "simhash64": 7487617073093719043,
      "normalized": "def NAME ( NAME , NAME : NAME = True ) : LIT if not NAME : return NAME = NAME . NAME if NAME and NAME ( NAME ) > LIT : # Close all but first tab for NAME in NAME [ LIT : ] : NAME . NAME . NAME ( NAME ) NAME . NAME ( ) # Switch back to first tab NAME . NAME . NAME ( NAME [ LIT ] ) elif not NAME : # Close all tabs for NAME in NAME : NAME . NAME . NAME ( NAME ) NAME . NAME ( )"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "get_driver_cookies",
      "lineno": 109,
      "end_lineno": 113,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(driver)",
      "fingerprint": "6a56286a0a30d2010853fffab1ec590c8922f5b7",
      "simhash64": 7488180572736369699,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME : return [ ] return NAME . NAME ( )"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "export_cookies",
      "lineno": 117,
      "end_lineno": 126,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 10,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:small"
      ],
      "signature": "(driver, filepath)",
      "fingerprint": "aac9d03e00786b66ed2871a647c55b91dd36aa9e",
      "simhash64": 7488109654235841579,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT if not NAME : return False NAME = NAME ( NAME ) from NAME import NAME with NAME ( NAME ) . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME , NAME = LIT ) return True"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "scroll_to_element",
      "lineno": 130,
      "end_lineno": 136,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 7,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(driver, element)",
      "fingerprint": "6df077fa69b105e47af2076353732e5e4ca43b61",
      "simhash64": 7487749015495672867,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT if not NAME or not NAME : return NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT ) # Brief pause for scroll completion"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "wait_for_element",
      "lineno": 140,
      "end_lineno": 148,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(driver, selector, timeout, by)",
      "fingerprint": "9eea5c541383b6666face3e4bb816b8e3b91027b",
      "simhash64": 7488109654235841539,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME = LIT , NAME : NAME = NAME . NAME ) -> NAME : LIT if not NAME : return None NAME = NAME ( NAME , NAME ) return NAME . NAME ( NAME . NAME ( ( NAME , NAME ) ) )"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "safe_click",
      "lineno": 152,
      "end_lineno": 161,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(driver, element)",
      "fingerprint": "1d65180ba6ae1916a189b580bb3293f4f8a7c3b5",
      "simhash64": 7488109654236365859,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT if not NAME or not NAME : return False # Scroll to element first NAME ( NAME , NAME ) # Try to click NAME . NAME ( ) return True"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "get_element_text",
      "lineno": 165,
      "end_lineno": 169,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(element)",
      "fingerprint": "481d54937a0fc9c1ed4252889cbbb92aeb868286",
      "simhash64": 7492182245305127939,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME : return LIT return NAME . NAME or LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "is_element_visible",
      "lineno": 173,
      "end_lineno": 177,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(element)",
      "fingerprint": "3da578084877bb46cde62080fa96a409ecb19b22",
      "simhash64": 7492147610688853027,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME : return False return NAME . NAME ( )"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "selenium_module_tests",
      "lineno": 180,
      "end_lineno": 247,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 68,
      "tags": [
        "impure",
        "network",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "7ed3f2cbb5bb9e6e992b6f033dc2978678497c83",
      "simhash64": 7487757781525500971,
      "normalized": "def NAME ( ) -> None : LIT import NAME from NAME . NAME import NAME NAME = [ ] # Test 1: Function availability def NAME ( ) : NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME in NAME ( ) , f\" Function { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] ) , f\" Function { NAME } should be callable \" NAME . NAME ( ( LIT , NAME ) ) # Test 2: Force user agent functionality def NAME ( ) : NAME = NAME ( ) NAME = NAME ( NAME , LIT ) NAME . NAME . NAME ( ) assert NAME , LIT NAME . NAME ( ( LIT , NAME ) ) # Test 3: Safe execution with None def NAME ( ) : assert NAME ( None ) == LIT , LIT assert ( NAME ( None , LIT ) == LIT ) , LIT assert ( not NAME ( None , LIT ) ) , LIT NAME . NAME ( ( LIT , NAME ) ) # Test 4: Element text extraction def NAME ( ) : NAME = NAME ( ) NAME . NAME = LIT NAME = NAME ( NAME ) assert NAME == LIT , LIT NAME . NAME ( ( LIT , NAME ) ) # Test 5: Performance validation def NAME ( ) : NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : # Reduced for faster testing NAME ( None ) NAME ( None , LIT ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Operations should be fast, took { NAME : .3f } s \" NAME . NAME ( ( LIT , NAME ) ) return NAME"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_function_availability",
      "lineno": 188,
      "end_lineno": 202,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6fff5b9aa49c30c41d0335856fd9d9887bc18fe2",
      "simhash64": 7451728984500769835,
      "normalized": "def NAME ( ) : NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME in NAME ( ) , f\" Function { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] ) , f\" Function { NAME } should be callable \""
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_force_user_agent",
      "lineno": 207,
      "end_lineno": 211,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "8d1328175220a0aa8563eaa1fb5812db165e11a4",
      "simhash64": 7487652228407657515,
      "normalized": "def NAME ( ) : NAME = NAME ( ) NAME = NAME ( NAME , LIT ) NAME . NAME . NAME ( ) assert NAME , LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_safe_execution",
      "lineno": 216,
      "end_lineno": 223,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d3f29ed738e40c36f1fa370d185c0b0b9bb2441c",
      "simhash64": 6297672784398947883,
      "normalized": "def NAME ( ) : assert NAME ( None ) == LIT , LIT assert ( NAME ( None , LIT ) == LIT ) , LIT assert ( not NAME ( None , LIT ) ) , LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_element_text",
      "lineno": 228,
      "end_lineno": 232,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "7056bad8eeedec2dc322a4e005c2ba4740373a96",
      "simhash64": 7488180024053761051,
      "normalized": "def NAME ( ) : NAME = NAME ( ) NAME . NAME = LIT NAME = NAME ( NAME ) assert NAME == LIT , LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_performance",
      "lineno": 237,
      "end_lineno": 243,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "7287845071635503d0ba470d6c8f0521a1e2d12f",
      "simhash64": 8641136682968978491,
      "normalized": "def NAME ( ) : NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : # Reduced for faster testing NAME ( None ) NAME ( None , LIT ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Operations should be fast, took { NAME : .3f } s \""
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 250,
      "end_lineno": 556,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 307,
      "tags": [
        "impure",
        "network",
        "logging",
        "time",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "d19f3503bae260a2603a4293bcc12424ee888967",
      "simhash64": 7451728984506012715,
      "normalized": "def NAME ( ) -> NAME : LIT import NAME from NAME . NAME import NAME from NAME import NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) def NAME ( ) : LIT NAME = [ ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME in NAME : # Test function existence NAME = NAME in NAME ( ) # Test function callability NAME = False if NAME : try : NAME = NAME ( NAME ( ) [ NAME ] ) except NAME : NAME = False # Test function type NAME = NAME ( NAME ( ) . NAME ( NAME , None ) ) . NAME NAME = LIT if NAME and NAME else LIT NAME ( f\" { NAME } { NAME } : { NAME } \" ) NAME ( f\" Exists: { NAME } , Callable: { NAME } , Type: { NAME } \" ) NAME = NAME and NAME NAME . NAME ( NAME ) assert NAME , f\" Function { NAME } should be available \" assert NAME , f\" Function { NAME } should be callable \" NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } selenium utility functions available \" ) def NAME ( ) : NAME = NAME ( ) NAME = NAME ( NAME , LIT ) NAME . NAME . NAME ( ) assert NAME , LIT def NAME ( ) : # Test safe extraction with None elements assert NAME ( None ) == LIT , LIT assert ( NAME ( None , LIT ) == LIT ) , LIT # Test with mock element NAME = NAME ( ) NAME . NAME = LIT NAME . NAME . NAME = LIT assert ( NAME ( NAME ) == LIT ) , LIT assert ( NAME ( NAME , LIT ) == LIT ) , LIT def NAME ( ) : # Test with None driver assert ( not NAME ( None , LIT ) ) , LIT # Test with mock driver - element found NAME = NAME ( ) NAME . NAME . NAME = NAME ( ) NAME = NAME ( NAME , LIT ) assert NAME , LIT # Test with mock driver - element not found NAME . NAME . NAME = NAME ( ) NAME = NAME ( NAME , LIT ) assert ( not NAME ) , LIT def NAME ( ) : # Test with None driver assert ( not NAME ( None ) ) , LIT # Test with valid mock driver NAME = NAME ( ) NAME . NAME = LIT NAME = NAME ( NAME ) assert NAME , LIT # Test with invalid session - use spec-based mock with property descriptor from NAME . NAME . NAME . NAME import NAME NAME = NAME ( NAME = NAME ) # Define property that raises exception def NAME ( NAME ) : raise NAME ( ) # Set the property on the mock's type NAME ( NAME ) . NAME = NAME ( NAME ) NAME = NAME ( NAME ) assert ( not NAME ) , LIT def NAME ( ) : NAME = NAME ( ) NAME . NAME = [ LIT , LIT , LIT ] # Test closing tabs while keeping first NAME ( NAME , NAME = True ) assert ( NAME . NAME . NAME . NAME >= LIT ) , LIT # Test closing all tabs NAME ( NAME , NAME = False ) assert NAME . NAME . NAME , LIT def NAME ( ) : NAME = NAME ( ) NAME = [ { LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT } , ] NAME . NAME . NAME = NAME # Test getting cookies NAME = NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME ) == LIT , LIT # Test with None driver NAME = NAME ( None ) assert ( NAME == [ ] ) , LIT def NAME ( ) : # Test safe_click with None element NAME = NAME ( None , None ) assert not NAME , LIT # Test with mock element NAME = NAME ( ) NAME = NAME ( ) NAME = NAME ( NAME , NAME ) NAME . NAME . NAME ( ) assert NAME , LIT def NAME ( ) : # Test get_element_text with None assert ( NAME ( None ) == LIT ) , LIT # Test is_element_visible with None assert ( not NAME ( None ) ) , LIT # Test with mock elements NAME = NAME ( ) NAME . NAME = LIT NAME . NAME . NAME = True assert ( NAME ( NAME ) == LIT ) , LIT assert ( NAME ( NAME ) ) , LIT def NAME ( ) : # Test that operations complete within reasonable time NAME = NAME . NAME ( ) # Run multiple operations for NAME in NAME ( LIT ) : NAME ( None ) NAME ( None , LIT ) NAME ( None , LIT ) NAME ( None ) NAME ( None ) NAME ( None ) NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" Performance test should complete quickly, took { NAME : .3f } s \" # Run all tests NAME ( LIT ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Generate summary report and return result return NAME . NAME ( )"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_function_availability",
      "lineno": 260,
      "end_lineno": 308,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 49,
      "tags": [
        "impure",
        "network",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "3f71357cd27a03626f13388834c84df875f9b85c",
      "simhash64": 7433714585996530731,
      "normalized": "def NAME ( ) : LIT NAME = [ ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ] NAME ( LIT ) NAME = [ ] for NAME , NAME in NAME : # Test function existence NAME = NAME in NAME ( ) # Test function callability NAME = False if NAME : try : NAME = NAME ( NAME ( ) [ NAME ] ) except NAME : NAME = False # Test function type NAME = NAME ( NAME ( ) . NAME ( NAME , None ) ) . NAME NAME = LIT if NAME and NAME else LIT NAME ( f\" { NAME } { NAME } : { NAME } \" ) NAME ( f\" Exists: { NAME } , Callable: { NAME } , Type: { NAME } \" ) NAME = NAME and NAME NAME . NAME ( NAME ) assert NAME , f\" Function { NAME } should be available \" assert NAME , f\" Function { NAME } should be callable \" NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } selenium utility functions available \" )"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_force_user_agent",
      "lineno": 310,
      "end_lineno": 314,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "8d1328175220a0aa8563eaa1fb5812db165e11a4",
      "simhash64": 7487652228407657515,
      "normalized": "def NAME ( ) : NAME = NAME ( ) NAME = NAME ( NAME , LIT ) NAME . NAME . NAME ( ) assert NAME , LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_safe_text_extraction",
      "lineno": 316,
      "end_lineno": 333,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "8e80cad8768030fcc25188cac127814c0b7fa051",
      "simhash64": 5145885975292843051,
      "normalized": "def NAME ( ) : # Test safe extraction with None elements assert NAME ( None ) == LIT , LIT assert ( NAME ( None , LIT ) == LIT ) , LIT # Test with mock element NAME = NAME ( ) NAME . NAME = LIT NAME . NAME . NAME = LIT assert ( NAME ( NAME ) == LIT ) , LIT assert ( NAME ( NAME , LIT ) == LIT ) , LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_element_detection",
      "lineno": 335,
      "end_lineno": 352,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "645d449fd3fbac27a3be4844153deb5cc17bc232",
      "simhash64": 7487792965896016903,
      "normalized": "def NAME ( ) : # Test with None driver assert ( not NAME ( None , LIT ) ) , LIT # Test with mock driver - element found NAME = NAME ( ) NAME . NAME . NAME = NAME ( ) NAME = NAME ( NAME , LIT ) assert NAME , LIT # Test with mock driver - element not found NAME . NAME . NAME = NAME ( ) NAME = NAME ( NAME , LIT ) assert ( not NAME ) , LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_browser_status",
      "lineno": 354,
      "end_lineno": 381,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 28,
      "tags": [
        "impure",
        "network",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "919321246163cc4498ea4c6eb85e2fb9cf19ea43",
      "simhash64": 8641136681894196263,
      "normalized": "def NAME ( ) : # Test with None driver assert ( not NAME ( None ) ) , LIT # Test with valid mock driver NAME = NAME ( ) NAME . NAME = LIT NAME = NAME ( NAME ) assert NAME , LIT # Test with invalid session - use spec-based mock with property descriptor from NAME . NAME . NAME . NAME import NAME NAME = NAME ( NAME = NAME ) # Define property that raises exception def NAME ( NAME ) : raise NAME ( ) # Set the property on the mock's type NAME ( NAME ) . NAME = NAME ( NAME ) NAME = NAME ( NAME ) assert ( not NAME ) , LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "current_url_getter",
      "lineno": 372,
      "end_lineno": 373,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "1461537cdbbc1e1540bc1911ba366af5e1d4a257",
      "simhash64": 8640574283308762235,
      "normalized": "def NAME ( NAME ) : raise NAME ( )"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_tab_management",
      "lineno": 383,
      "end_lineno": 395,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3792860d216bd2d49589cb24a13c1be24a1d6e79",
      "simhash64": 7452151231396877315,
      "normalized": "def NAME ( ) : NAME = NAME ( ) NAME . NAME = [ LIT , LIT , LIT ] # Test closing tabs while keeping first NAME ( NAME , NAME = True ) assert ( NAME . NAME . NAME . NAME >= LIT ) , LIT # Test closing all tabs NAME ( NAME , NAME = False ) assert NAME . NAME . NAME , LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_cookie_operations",
      "lineno": 397,
      "end_lineno": 414,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ee8f3e0b74a6f02d30a11fb680b950176e228a0c",
      "simhash64": 5145885970997351471,
      "normalized": "def NAME ( ) : NAME = NAME ( ) NAME = [ { LIT : LIT , LIT : LIT } , { LIT : LIT , LIT : LIT } , ] NAME . NAME . NAME = NAME # Test getting cookies NAME = NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT assert NAME ( NAME ) == LIT , LIT # Test with None driver NAME = NAME ( None ) assert ( NAME == [ ] ) , LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_safe_interaction",
      "lineno": 416,
      "end_lineno": 426,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "58fcacf8a4860c0d4d78d61618831fbfb554033e",
      "simhash64": 7488355915851011107,
      "normalized": "def NAME ( ) : # Test safe_click with None element NAME = NAME ( None , None ) assert not NAME , LIT # Test with mock element NAME = NAME ( ) NAME = NAME ( ) NAME = NAME ( NAME , NAME ) NAME . NAME . NAME ( ) assert NAME , LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_element_text_helpers",
      "lineno": 428,
      "end_lineno": 449,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "261d3dc5b5c21a44242eaab081e3f8047894b06f",
      "simhash64": 8640714471041307691,
      "normalized": "def NAME ( ) : # Test get_element_text with None assert ( NAME ( None ) == LIT ) , LIT # Test is_element_visible with None assert ( not NAME ( None ) ) , LIT # Test with mock elements NAME = NAME ( ) NAME . NAME = LIT NAME . NAME . NAME = True assert ( NAME ( NAME ) == LIT ) , LIT assert ( NAME ( NAME ) ) , LIT"
    },
    {
      "module_path": "selenium_utils.py",
      "qualname": "test_performance_validation",
      "lineno": 451,
      "end_lineno": 467,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "8976be318dce5da88e195f3596bcc62b97d6b541",
      "simhash64": 8640714471041307691,
      "normalized": "def NAME ( ) : # Test that operations complete within reasonable time NAME = NAME . NAME ( ) # Run multiple operations for NAME in NAME ( LIT ) : NAME ( None ) NAME ( None , LIT ) NAME ( None , LIT ) NAME ( None ) NAME ( None ) NAME ( None ) NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" Performance test should complete quickly, took { NAME : .3f } s \""
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "get_standard_logger",
      "lineno": 54,
      "end_lineno": 56,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(module_name)",
      "fingerprint": "f05f4fa35186ff41c3dafb99e72a48f8706f7aae",
      "simhash64": 7488215208425858147,
      "normalized": "def NAME ( NAME : NAME ) -> NAME . NAME : LIT return NAME ( NAME )"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "setup_module",
      "lineno": 60,
      "end_lineno": 100,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 41,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(module_globals, module_name)",
      "fingerprint": "9724b5f9789527b85d77d34a5ff65b5d9fd6715b",
      "simhash64": 7488144838608466995,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME . NAME : LIT try : # Step 1: Standardize imports first NAME ( ) # Step 2: Auto-register module functions NAME ( NAME , NAME ) # Step 3: Return configured logger return NAME ( NAME ) except NAME as NAME : # Fallback to basic logger if optimization fails NAME ( f\" Warning: setup_module failed for { NAME } , using fallback: { NAME } \" ) return NAME ( NAME )"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "safe_import",
      "lineno": 104,
      "end_lineno": 111,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(module_name, fallback)",
      "fingerprint": "d160402c8c120f75d9b5eedf37c01470c8273260",
      "simhash64": 7488250357364470787,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME = None ) -> NAME : LIT try : import NAME return NAME . NAME ( NAME ) except NAME : return NAME"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "safe_import_from",
      "lineno": 114,
      "end_lineno": 122,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(module_name, item_name, fallback)",
      "fingerprint": "76e346a169108d6160267f49314b9cf81075a3e6",
      "simhash64": 7488109619876103171,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME = None ) -> NAME : LIT try : import NAME NAME = NAME . NAME ( NAME ) return NAME ( NAME , NAME , NAME ) except ( NAME , NAME ) : return NAME"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "get_unified_test_framework",
      "lineno": 126,
      "end_lineno": 135,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "017c399c0233dfd1d047fc948d6e8cb6e3133c32",
      "simhash64": 5146371387663225939,
      "normalized": "def NAME ( ) -> NAME : LIT # Using modern test_framework.py instead of deprecated test_framework_unified try : from NAME import NAME return NAME except NAME : # Fallback to legacy test framework return None"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 251,
      "end_lineno": 474,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 9,
      "loc": 224,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "45a658e522c4b385ba44c4fc0743a2103f32492d",
      "simhash64": 5145885970996827179,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME NAME ( LIT ) # Quick basic test first try : # Test basic module setup NAME = NAME ( NAME ( ) , NAME ) assert NAME is not None NAME ( LIT ) # Test function registration def NAME ( ) -> NAME : return LIT NAME ( LIT , NAME ) assert NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) except NAME as NAME : NAME ( f\" \u274c Basic Standard Imports tests failed: { NAME } \" ) return False with NAME ( ) : NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # Module setup and initialization def NAME ( ) -> None : # Test setup_module function NAME = { } NAME = NAME ( NAME , LIT ) assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT # Logger functionality def NAME ( ) -> None : NAME = NAME ( LIT ) assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT # Function registration def NAME ( ) : def NAME ( ) -> NAME : return LIT # Test registration NAME ( LIT , NAME ) assert NAME ( LIT ) , LIT # Test retrieval NAME = NAME ( LIT ) assert NAME is not None , LIT assert NAME ( ) == LIT , LIT # Safe imports def NAME ( ) : # Test successful import NAME = NAME ( LIT ) assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT # Test failed import with fallback NAME = NAME ( LIT , LIT ) assert NAME == LIT , LIT # Test safe_import_from NAME = NAME ( LIT , LIT ) assert NAME is not None , LIT # Test safe_import_from with fallback NAME = NAME ( LIT , LIT , LIT ) assert NAME == LIT , LIT # Import standardization def NAME ( ) : # Test that standardize_module_imports doesn't crash try : NAME ( ) NAME = True except NAME : NAME = False assert NAME , LIT # Core imports availability def NAME ( ) : NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME in NAME ( ) , f\" Function { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] ) , f\" Function { NAME } should be callable \" # Standard library imports availability def NAME ( ) : NAME = [ LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME ( ) , f\" Module { NAME } should be imported \" # Module cleanup def NAME ( ) : # Test that we can clean up registered functions def NAME ( ) -> NAME : return LIT NAME ( LIT , NAME ) assert NAME ( LIT ) , LIT # Test cleanup if available try : NAME ( ) # After cleanup, function might or might not be available depending on implementation # This is more of a smoke test except NAME : pass # Cleanup might not be implemented or might fail gracefully # Performance test def NAME ( ) : import NAME NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( f\" test_module_ { NAME } \" ) NAME ( f\" test_func_ { NAME } \" , lambda : NAME ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Module operations should be fast, took { NAME : .3f } s \" # Run all tests with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "test_func",
      "lineno": 268,
      "end_lineno": 269,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "4ff6433adac1c61a1c491c1fbf35dfa2a3834dff",
      "simhash64": 5186445305669653539,
      "normalized": "def NAME ( ) -> NAME : return LIT"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "test_module_setup",
      "lineno": 285,
      "end_lineno": 291,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "f80352d158745326f2bb42ffac44c2af237549da",
      "simhash64": 5147574820858139691,
      "normalized": "def NAME ( ) -> None : # Test setup_module function NAME = { } NAME = NAME ( NAME , LIT ) assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "test_logger_creation",
      "lineno": 294,
      "end_lineno": 298,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "4e8891c2406cc50b77c509dddf560e9a0aeb9b6a",
      "simhash64": 5147011870904718379,
      "normalized": "def NAME ( ) -> None : NAME = NAME ( LIT ) assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "test_function_registration",
      "lineno": 301,
      "end_lineno": 314,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "72750372500d8a0676db6e0d364ea7c3a276f4fb",
      "simhash64": 5145885970997875755,
      "normalized": "def NAME ( ) : def NAME ( ) -> NAME : return LIT # Test registration NAME ( LIT , NAME ) assert NAME ( LIT ) , LIT # Test retrieval NAME = NAME ( LIT ) assert NAME is not None , LIT assert NAME ( ) == LIT , LIT"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "sample_function",
      "lineno": 302,
      "end_lineno": 303,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "4ff6433adac1c61a1c491c1fbf35dfa2a3834dff",
      "simhash64": 5186445305669653539,
      "normalized": "def NAME ( ) -> NAME : return LIT"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "test_safe_imports",
      "lineno": 317,
      "end_lineno": 333,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 17,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2d16b0923730615169b9902124e45bfadce9299b",
      "simhash64": 5145885962402698795,
      "normalized": "def NAME ( ) : # Test successful import NAME = NAME ( LIT ) assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT # Test failed import with fallback NAME = NAME ( LIT , LIT ) assert NAME == LIT , LIT # Test safe_import_from NAME = NAME ( LIT , LIT ) assert NAME is not None , LIT # Test safe_import_from with fallback NAME = NAME ( LIT , LIT , LIT ) assert NAME == LIT , LIT"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "test_import_standardization",
      "lineno": 336,
      "end_lineno": 343,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "ed1a711e602b5842d86ce0ad10d3c9e22df89a95",
      "simhash64": 8642403303250368111,
      "normalized": "def NAME ( ) : # Test that standardize_module_imports doesn't crash try : NAME ( ) NAME = True except NAME : NAME = False assert NAME , LIT"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "test_core_imports_availability",
      "lineno": 346,
      "end_lineno": 361,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6fff5b9aa49c30c41d0335856fd9d9887bc18fe2",
      "simhash64": 7451728984500769835,
      "normalized": "def NAME ( ) : NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME in NAME ( ) , f\" Function { NAME } should be available \" assert NAME ( NAME ( ) [ NAME ] ) , f\" Function { NAME } should be callable \""
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "test_standard_library_availability",
      "lineno": 364,
      "end_lineno": 367,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "3b41ae893a4e6b1fa0ece193846278195000d7b6",
      "simhash64": 7452291964523156539,
      "normalized": "def NAME ( ) : NAME = [ LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME in NAME ( ) , f\" Module { NAME } should be imported \""
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "test_module_cleanup",
      "lineno": 370,
      "end_lineno": 386,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7319010afb0bc00853152e4a9c02ac6c7f34606c",
      "simhash64": 8646898100544116009,
      "normalized": "def NAME ( ) : # Test that we can clean up registered functions def NAME ( ) -> NAME : return LIT NAME ( LIT , NAME ) assert NAME ( LIT ) , LIT # Test cleanup if available try : NAME ( ) # After cleanup, function might or might not be available depending on implementation # This is more of a smoke test except NAME : pass # Cleanup might not be implemented or might fail gracefully"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "temp_function",
      "lineno": 372,
      "end_lineno": 373,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "4ff6433adac1c61a1c491c1fbf35dfa2a3834dff",
      "simhash64": 5186445305669653539,
      "normalized": "def NAME ( ) -> NAME : return LIT"
    },
    {
      "module_path": "standard_imports.py",
      "qualname": "test_performance",
      "lineno": 389,
      "end_lineno": 398,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "71921fe64281174ced2bd848d5d1b49cce0de064",
      "simhash64": 7488215208426902587,
      "normalized": "def NAME ( ) : import NAME NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( f\" test_module_ { NAME } \" ) NAME ( f\" test_func_ { NAME } \" , lambda : NAME ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Module operations should be fast, took { NAME : .3f } s \""
    },
    {
      "module_path": "test_framework.py",
      "qualname": "Colors.green",
      "lineno": 69,
      "end_lineno": 71,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(text)",
      "fingerprint": "6f157d3714b0ff565aad62007c6d681d26d8be98",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return f\" { NAME . NAME } { NAME } { NAME . NAME } \""
    },
    {
      "module_path": "test_framework.py",
      "qualname": "Colors.red",
      "lineno": 74,
      "end_lineno": 76,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(text)",
      "fingerprint": "6f157d3714b0ff565aad62007c6d681d26d8be98",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return f\" { NAME . NAME } { NAME } { NAME . NAME } \""
    },
    {
      "module_path": "test_framework.py",
      "qualname": "Colors.yellow",
      "lineno": 79,
      "end_lineno": 81,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(text)",
      "fingerprint": "6f157d3714b0ff565aad62007c6d681d26d8be98",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return f\" { NAME . NAME } { NAME } { NAME . NAME } \""
    },
    {
      "module_path": "test_framework.py",
      "qualname": "Colors.blue",
      "lineno": 84,
      "end_lineno": 86,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(text)",
      "fingerprint": "6f157d3714b0ff565aad62007c6d681d26d8be98",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return f\" { NAME . NAME } { NAME } { NAME . NAME } \""
    },
    {
      "module_path": "test_framework.py",
      "qualname": "Colors.magenta",
      "lineno": 89,
      "end_lineno": 91,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(text)",
      "fingerprint": "6f157d3714b0ff565aad62007c6d681d26d8be98",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return f\" { NAME . NAME } { NAME } { NAME . NAME } \""
    },
    {
      "module_path": "test_framework.py",
      "qualname": "Colors.cyan",
      "lineno": 94,
      "end_lineno": 96,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(text)",
      "fingerprint": "6f157d3714b0ff565aad62007c6d681d26d8be98",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return f\" { NAME . NAME } { NAME } { NAME . NAME } \""
    },
    {
      "module_path": "test_framework.py",
      "qualname": "Colors.white",
      "lineno": 99,
      "end_lineno": 101,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(text)",
      "fingerprint": "6f157d3714b0ff565aad62007c6d681d26d8be98",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return f\" { NAME . NAME } { NAME } { NAME . NAME } \""
    },
    {
      "module_path": "test_framework.py",
      "qualname": "Colors.gray",
      "lineno": 104,
      "end_lineno": 106,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(text)",
      "fingerprint": "6f157d3714b0ff565aad62007c6d681d26d8be98",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return f\" { NAME . NAME } { NAME } { NAME . NAME } \""
    },
    {
      "module_path": "test_framework.py",
      "qualname": "Colors.bold",
      "lineno": 109,
      "end_lineno": 111,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(text)",
      "fingerprint": "6f157d3714b0ff565aad62007c6d681d26d8be98",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return f\" { NAME . NAME } { NAME } { NAME . NAME } \""
    },
    {
      "module_path": "test_framework.py",
      "qualname": "Colors.underline",
      "lineno": 114,
      "end_lineno": 116,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(text)",
      "fingerprint": "6f157d3714b0ff565aad62007c6d681d26d8be98",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return f\" { NAME . NAME } { NAME } { NAME . NAME } \""
    },
    {
      "module_path": "test_framework.py",
      "qualname": "has_ansi_codes",
      "lineno": 119,
      "end_lineno": 121,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(text)",
      "fingerprint": "eafbc8ca81a18b6a32c98f456ac07bdcea6982f1",
      "simhash64": 7492824361170015339,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return LIT in NAME ( NAME )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "strip_ansi_codes",
      "lineno": 124,
      "end_lineno": 128,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "regex",
        "size:tiny"
      ],
      "signature": "(text)",
      "fingerprint": "07d9ce250767edfde8cfeb354f2f9ff5546c03a6",
      "simhash64": 7488180024053769251,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT import NAME NAME = NAME . NAME ( LIT ) return NAME . NAME ( LIT , NAME )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "TestSuite.__init__",
      "lineno": 147,
      "end_lineno": 155,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, suite_name, module_name)",
      "fingerprint": "b887cf04168720467dbf7daa67182ed772b4b30e",
      "simhash64": 7452080857283998739,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> None : NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = None NAME . NAME = LIT NAME . NAME = LIT NAME . NAME = LIT NAME . NAME = LIT NAME . NAME : NAME [ NAME [ NAME , NAME ] ] = [ ]"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "TestSuite.start_suite",
      "lineno": 157,
      "end_lineno": 165,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "a899422d6a1c78a9db31dd2a87956fa05d34d8a5",
      "simhash64": 7435192358597465107,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = NAME . NAME ( ) NAME ( f\" \\n { NAME . NAME } { NAME . NAME } { LIT * LIT } { NAME . NAME } \" ) NAME ( f\" { NAME . NAME } { NAME . NAME } { NAME . NAME } Testing: { NAME . NAME } { NAME . NAME } \" ) NAME ( f\" { NAME . NAME } Module: { NAME . NAME } { NAME . NAME } \" ) NAME ( f\" { NAME . NAME } { LIT * LIT } { NAME . NAME } \\n \" )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "TestSuite.run_test",
      "lineno": 167,
      "end_lineno": 268,
      "is_method": true,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 102,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "(self, test_name, test_func, expected_behavior, test_description, method_description)",
      "fingerprint": "5297af7b448f29a64d27ab753a92d1ec328e5062",
      "simhash64": 7452080858291672091,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT , ) -> NAME : LIT NAME . NAME += LIT NAME = NAME . NAME ( ) NAME ( f\" { NAME . NAME } { NAME . NAME } Test { NAME . NAME } : { NAME } { NAME . NAME } \" ) if NAME : NAME ( f\" Test: { NAME } \" ) if NAME : NAME ( f\" Method: { NAME } \" ) if NAME : NAME ( f\" Expected: { NAME } \" ) try : NAME = LIT NAME ( ) NAME = NAME . NAME ( ) - NAME NAME = ( LIT ) NAME ( f\" Outcome: { NAME } \" ) NAME ( f\" Duration: { NAME : .3f } s \" ) NAME ( f\" Conclusion: { NAME . NAME } { NAME . NAME } PASSED { NAME . NAME } \" ) NAME ( ) # Add blank line between tests NAME . NAME += LIT NAME . NAME . NAME ( { LIT : NAME , LIT : LIT , LIT : NAME , LIT : NAME , LIT : NAME , } ) return True except NAME as NAME : import NAME NAME = NAME . NAME ( ) - NAME NAME = f\" Assertion failed: { NAME ! NAME } \" NAME ( f\" Outcome: { NAME } \" ) NAME . NAME ( ) NAME ( f\" Duration: { NAME : .3f } s \" ) NAME ( f\" Conclusion: { NAME . NAME } { NAME . NAME } FAILED { NAME . NAME } \" ) NAME ( ) # Add blank line between tests NAME . NAME += LIT NAME . NAME . NAME ( { LIT : NAME , LIT : LIT , LIT : NAME , LIT : NAME ( NAME ) , LIT : NAME , LIT : NAME , } ) return False except NAME as NAME : NAME = NAME . NAME ( ) - NAME NAME = f\" Exception occurred: { NAME ( NAME ) . NAME } : { NAME ! NAME } \" NAME ( f\" Outcome: { NAME } \" ) NAME ( f\" Duration: { NAME : .3f } s \" ) NAME ( f\" Conclusion: { NAME . NAME } { NAME . NAME } FAILED { NAME . NAME } \" ) NAME ( ) # Add blank line between tests NAME . NAME += LIT NAME . NAME . NAME ( { LIT : NAME , LIT : LIT , LIT : NAME , LIT : f\" { NAME ( NAME ) . NAME } : { NAME ! NAME } \" , LIT : NAME , LIT : NAME , } ) return False"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "TestSuite.add_warning",
      "lineno": 270,
      "end_lineno": 273,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "impure",
        "logging",
        "size:tiny"
      ],
      "signature": "(self, message)",
      "fingerprint": "23cb22f7c92390ffb8056f6b1b65720c6da78b14",
      "simhash64": 7452080858290631699,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT NAME . NAME += LIT NAME ( f\" { NAME . NAME } { NAME . NAME } WARNING: { NAME } { NAME . NAME } \" )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "TestSuite.finish_suite",
      "lineno": 275,
      "end_lineno": 323,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 49,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "8729da7e9e88f782d3bb01ca09be54cd054025c9",
      "simhash64": 7434066458707407891,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) - NAME . NAME if NAME . NAME else LIT NAME ( f\" \\n { NAME . NAME } { LIT * LIT } { NAME . NAME } \" ) NAME ( f\" { NAME . NAME } { NAME . NAME } { NAME . NAME } Test Summary: { NAME . NAME } { NAME . NAME } \" ) NAME ( f\" { NAME . NAME } { LIT * LIT } { NAME . NAME } \" ) # Overall results if NAME . NAME == LIT : NAME = NAME . NAME NAME = NAME . NAME NAME = LIT else : NAME = NAME . NAME NAME = NAME . NAME NAME = LIT NAME ( f\" { NAME } { NAME . NAME } Duration: { NAME : .3f } s { NAME . NAME } \" ) NAME ( f\" { NAME } { NAME } Status: { NAME } { NAME . NAME } \" ) NAME ( f\" { NAME . NAME } { NAME . NAME } Passed: { NAME . NAME } { NAME . NAME } \" ) NAME ( f\" { NAME . NAME } { NAME . NAME } Failed: { NAME . NAME } { NAME . NAME } \" ) if NAME . NAME > LIT : NAME ( f\" { NAME . NAME } { NAME . NAME } Warnings: { NAME . NAME } { NAME . NAME } \" ) # Detailed results for failed tests NAME = [ NAME for NAME in NAME . NAME if NAME [ LIT ] in [ LIT , LIT ] ] if NAME : NAME ( f\" \\n { NAME . NAME } { NAME . NAME } Failed Test Details: { NAME . NAME } \" ) for NAME in NAME : NAME ( f\" { NAME . NAME } \u2022 { NAME [ LIT ] } { NAME . NAME } \" ) if LIT in NAME : NAME ( f\" { NAME . NAME } { NAME [ LIT ] } { NAME . NAME } \" ) if NAME . NAME ( LIT ) : NAME ( f\" { NAME . NAME } Expected: { NAME [ LIT ] } { NAME . NAME } \" ) NAME ( f\" { NAME . NAME } { LIT * LIT } { NAME . NAME } \\n \" ) return NAME . NAME == LIT"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "suppress_logging",
      "lineno": 327,
      "end_lineno": 333,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 1,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "40b8942a9d80a78d78d1963227fb89c581e01b13",
      "simhash64": 8641136712026076193,
      "normalized": "def NAME ( ) -> NAME [ None ] : LIT NAME . NAME ( NAME . NAME ) try : yield finally : NAME . NAME ( NAME . NAME )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "create_mock_data",
      "lineno": 336,
      "end_lineno": 349,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "a5141be17d47dfe96f423a5a72778fa82522fc5e",
      "simhash64": 5727967426797016619,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME ( ) , LIT : NAME ( ) , LIT : NAME ( ) , LIT : LIT , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } , }"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "create_standardized_test_data",
      "lineno": 352,
      "end_lineno": 376,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 25,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2e7335ef926986c93a077610c162e9f5324cef45",
      "simhash64": 1115152207779894831,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME ( ) , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , } , LIT : { LIT : False , # Default to mock data for safety LIT : True , # Skip external API calls in tests LIT : True , # Use caching for performance } }"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "get_test_mode",
      "lineno": 379,
      "end_lineno": 383,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "cbc59d5909308a0b0642474a3741a3278a408097",
      "simhash64": 14351102907085394987,
      "normalized": "def NAME ( ) -> NAME : LIT import NAME # Check environment variable or config to determine test mode return NAME . NAME ( LIT , LIT ) . NAME ( ) in [ LIT , LIT ]"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "create_test_data_factory",
      "lineno": 386,
      "end_lineno": 410,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 25,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(use_real_data)",
      "fingerprint": "b7785ead28ea65e7223d0cdc29c312a2480103cf",
      "simhash64": 5145745267934794795,
      "normalized": "def NAME ( NAME : NAME [ NAME ] = None ) -> NAME [ NAME , NAME ] : LIT if NAME is None : NAME = NAME ( ) NAME = NAME ( ) NAME [ LIT ] [ LIT ] = NAME if NAME : # For real data tests, load from environment variables import NAME from NAME import NAME NAME ( ) NAME [ LIT ] = { LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME ( NAME . NAME ( LIT , LIT ) ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) } NAME [ LIT ] [ LIT ] = False return NAME"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "assert_valid_function",
      "lineno": 413,
      "end_lineno": 416,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(func, func_name)",
      "fingerprint": "22e28e1e2cfdb32181fdaec5f33f2363d7635019",
      "simhash64": 2841731811642872947,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT assert NAME is not None , f\" Function { NAME } should exist \" assert NAME ( NAME ) , f\" Function { NAME } should be callable \""
    },
    {
      "module_path": "test_framework.py",
      "qualname": "standardized_test_wrapper",
      "lineno": 419,
      "end_lineno": 451,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 33,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(test_func, test_name, cleanup_func)",
      "fingerprint": "4dcfb5c777d4f12a203138ccb9e1ad95569b0f5a",
      "simhash64": 7452151191602377779,
      "normalized": "def NAME ( NAME : NAME [ [ NAME [ NAME , NAME ] ] , NAME ] , NAME : NAME , NAME : NAME [ NAME [ [ ] , None ] ] = None ) -> NAME [ [ ] , NAME ] : LIT def NAME ( ) -> NAME : NAME = NAME ( ) try : # Setup phase if NAME [ LIT ] [ LIT ] : NAME ( f\" \ud83d\udd0d { NAME } : Using real data \" ) else : NAME ( f\" \ud83e\uddea { NAME } : Using mock data \" ) # Execute test with standardized data NAME = NAME ( NAME ) # Validation phase if NAME is None : NAME = True # Assume success if no explicit return return NAME except NAME as NAME : NAME ( f\" \u274c { NAME } failed: { NAME } \" ) raise finally : # Cleanup phase if NAME : try : NAME ( ) except NAME as NAME : NAME ( f\" \u26a0\ufe0f Cleanup failed for { NAME } : { NAME } \" ) return NAME"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "wrapper",
      "lineno": 421,
      "end_lineno": 449,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 29,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "079c2469d7f90c884178787c7c88353f084e005d",
      "simhash64": 8642192208754546235,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME ( ) try : # Setup phase if NAME [ LIT ] [ LIT ] : NAME ( f\" \ud83d\udd0d { NAME } : Using real data \" ) else : NAME ( f\" \ud83e\uddea { NAME } : Using mock data \" ) # Execute test with standardized data NAME = NAME ( NAME ) # Validation phase if NAME is None : NAME = True # Assume success if no explicit return return NAME except NAME as NAME : NAME ( f\" \u274c { NAME } failed: { NAME } \" ) raise finally : # Cleanup phase if NAME : try : NAME ( ) except NAME as NAME : NAME ( f\" \u26a0\ufe0f Cleanup failed for { NAME } : { NAME } \" )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "create_isolated_test_environment",
      "lineno": 454,
      "end_lineno": 461,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "9949ea988fef7c816d8d0ffa0e370a7f709d2c8f",
      "simhash64": 5128707199236214831,
      "normalized": "def NAME ( ) -> NAME [ NAME , NAME ] : LIT return { LIT : [ ] , LIT : [ ] , LIT : { } , LIT : [ ] }"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "cleanup_test_environment",
      "lineno": 464,
      "end_lineno": 487,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 8,
      "loc": 24,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "(env)",
      "fingerprint": "68f284edcf801d565c5b7cf14ba9ddaccd1b23f7",
      "simhash64": 7488179988687402003,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> None : LIT # Clean up temporary files from NAME import NAME for NAME in NAME . NAME ( LIT , [ ] ) : try : NAME = NAME ( NAME ) if NAME . NAME ( ) : NAME . NAME ( NAME = True ) except NAME : pass # Restore environment variables import NAME for NAME , NAME in NAME . NAME ( LIT , { } ) . NAME ( ) : if NAME is None : NAME . NAME . NAME ( NAME , None ) else : NAME . NAME [ NAME ] = NAME # Run cleanup functions for NAME in NAME . NAME ( LIT , [ ] ) : with NAME ( NAME ) : NAME ( )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "assert_valid_config",
      "lineno": 490,
      "end_lineno": 493,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(config, required_attrs)",
      "fingerprint": "465a48b630fdf4ef32ea7910b765d68b35925471",
      "simhash64": 7488180024054813811,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] ) -> None : LIT for NAME in NAME : assert NAME ( NAME , NAME ) , f\" Config should have attribute { NAME } \""
    },
    {
      "module_path": "test_framework.py",
      "qualname": "test_framework_module_tests",
      "lineno": 496,
      "end_lineno": 595,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 100,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "ba278c957100cf59153e7dccc40d145da17cd99a",
      "simhash64": 7451588276007646243,
      "normalized": "def NAME ( ) -> NAME : LIT NAME ( f\" { NAME . NAME } Running comprehensive tests for test_framework.py... \" ) NAME = NAME ( LIT , LIT ) NAME . NAME ( ) def NAME ( ) -> None : LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT # Test both naming conventions def NAME ( ) -> None : LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT def NAME ( NAME : NAME ) -> None : LIT NAME = NAME [ LIT ] assert NAME ( NAME , NAME ) assert LIT in NAME assert LIT in NAME assert NAME [ LIT ] [ LIT ] == LIT assert NAME ( NAME [ LIT ] , NAME ) return True def NAME ( NAME : NAME ) -> None : LIT assert LIT in NAME assert LIT in NAME assert NAME [ LIT ] [ LIT ] in [ LIT , LIT ] # Allow both mock and real assert NAME ( NAME [ LIT ] [ LIT ] , NAME ) return True def NAME ( ) -> None : LIT NAME = NAME ( LIT , LIT ) assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME is None def NAME ( ) -> None : LIT with NAME ( ) : NAME . NAME ( LIT ) # Test that it doesn't raise an exception from NAME import NAME # Should work fine assert NAME ( ) . NAME ( ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME ( NAME , LIT ) , LIT , ) NAME . NAME ( LIT , NAME ( NAME , LIT ) , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) NAME . NAME ( LIT , NAME , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "test_colors",
      "lineno": 506,
      "end_lineno": 519,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ea24cda281064dfb98fcf89a0988492584cf1c96",
      "simhash64": 7452151226497939027,
      "normalized": "def NAME ( ) -> None : LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT # Test both naming conventions"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "test_icons",
      "lineno": 521,
      "end_lineno": 531,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c75e00fe05b7442f42e8721cc80f13629639f647",
      "simhash64": 7453277126404781587,
      "normalized": "def NAME ( ) -> None : LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "test_mock_data",
      "lineno": 533,
      "end_lineno": 541,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(test_data)",
      "fingerprint": "379a3c11791b4fc25503d4fd7f1c4f591e94f9d8",
      "simhash64": 7452151226028176499,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT NAME = NAME [ LIT ] assert NAME ( NAME , NAME ) assert LIT in NAME assert LIT in NAME assert NAME [ LIT ] [ LIT ] == LIT assert NAME ( NAME [ LIT ] , NAME ) return True"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "test_standardized_data_factory",
      "lineno": 543,
      "end_lineno": 549,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(test_data)",
      "fingerprint": "4ef0d9b51d4efaff558f57efbf42d75f34424258",
      "simhash64": 5146308345931928611,
      "normalized": "def NAME ( NAME : NAME ) -> None : LIT assert LIT in NAME assert LIT in NAME assert NAME [ LIT ] [ LIT ] in [ LIT , LIT ] # Allow both mock and real assert NAME ( NAME [ LIT ] [ LIT ] , NAME ) return True"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "test_test_suite_creation",
      "lineno": 551,
      "end_lineno": 556,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "4a885922d37c10281bda91c30dc8b4fa0a86ecc7",
      "simhash64": 7453417863356265491,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( LIT , LIT ) assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME is None"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "test_context_managers",
      "lineno": 558,
      "end_lineno": 566,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "668e1d5283db0524f5c6464cea305f0e87d967a8",
      "simhash64": 8641136682969502827,
      "normalized": "def NAME ( ) -> None : LIT with NAME ( ) : NAME . NAME ( LIT ) # Test that it doesn't raise an exception from NAME import NAME # Should work fine assert NAME ( ) . NAME ( )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 598,
      "end_lineno": 600,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "demo_tests",
      "lineno": 605,
      "end_lineno": 636,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 32,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "deae1f6671ee4539c77c5e95d1b69ba305195c0d",
      "simhash64": 7451588276007646243,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME ( LIT , LIT ) NAME . NAME ( ) def NAME ( ) -> None : assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT def NAME ( ) -> None : assert NAME . NAME == LIT assert NAME . NAME == LIT def NAME ( ) -> None : NAME = NAME ( ) assert LIT in NAME assert NAME [ LIT ] [ LIT ] == LIT NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT ) NAME . NAME ( LIT , NAME , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "test_colors",
      "lineno": 609,
      "end_lineno": 613,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "1b3558c12e0b35a8b089c14569828599144f9eac",
      "simhash64": 7453277126404781075,
      "normalized": "def NAME ( ) -> None : assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME == LIT"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "test_icons",
      "lineno": 615,
      "end_lineno": 617,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "ccec5788c6312269ae29479f8c9844cb30f02681",
      "simhash64": 7453277126404781075,
      "normalized": "def NAME ( ) -> None : assert NAME . NAME == LIT assert NAME . NAME == LIT"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "test_mock_data",
      "lineno": 619,
      "end_lineno": 622,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "3463ad35aa4714449753e8191e93c691c7649cef",
      "simhash64": 5146448946786645555,
      "normalized": "def NAME ( ) -> None : NAME = NAME ( ) assert LIT in NAME assert NAME [ LIT ] [ LIT ] == LIT"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "MockLogger.__init__",
      "lineno": 650,
      "end_lineno": 658,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "495aa49083efcd99dd40a33a3a4a2e27ce4bb3f4",
      "simhash64": 5129557121725009957,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME = [ ] NAME . NAME = { LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : [ ] , }"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "MockLogger.debug",
      "lineno": 660,
      "end_lineno": 662,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, msg, **kwargs)",
      "fingerprint": "4a0c6bc4de8e06fbf002167ae8695cb17f97d729",
      "simhash64": 7488180022980027459,
      "normalized": "def NAME ( NAME , NAME : NAME , ** NAME : NAME ) -> None : NAME . NAME . NAME ( NAME ) NAME . NAME [ LIT ] . NAME ( NAME )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "MockLogger.info",
      "lineno": 664,
      "end_lineno": 666,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, msg, **kwargs)",
      "fingerprint": "4a0c6bc4de8e06fbf002167ae8695cb17f97d729",
      "simhash64": 7488180022980027459,
      "normalized": "def NAME ( NAME , NAME : NAME , ** NAME : NAME ) -> None : NAME . NAME . NAME ( NAME ) NAME . NAME [ LIT ] . NAME ( NAME )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "MockLogger.warning",
      "lineno": 668,
      "end_lineno": 670,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, msg, **kwargs)",
      "fingerprint": "4a0c6bc4de8e06fbf002167ae8695cb17f97d729",
      "simhash64": 7488180022980027459,
      "normalized": "def NAME ( NAME , NAME : NAME , ** NAME : NAME ) -> None : NAME . NAME . NAME ( NAME ) NAME . NAME [ LIT ] . NAME ( NAME )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "MockLogger.error",
      "lineno": 672,
      "end_lineno": 674,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, msg, **kwargs)",
      "fingerprint": "4a0c6bc4de8e06fbf002167ae8695cb17f97d729",
      "simhash64": 7488180022980027459,
      "normalized": "def NAME ( NAME , NAME : NAME , ** NAME : NAME ) -> None : NAME . NAME . NAME ( NAME ) NAME . NAME [ LIT ] . NAME ( NAME )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "MockLogger.critical",
      "lineno": 676,
      "end_lineno": 678,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, msg, **kwargs)",
      "fingerprint": "4a0c6bc4de8e06fbf002167ae8695cb17f97d729",
      "simhash64": 7488180022980027459,
      "normalized": "def NAME ( NAME , NAME : NAME , ** NAME : NAME ) -> None : NAME . NAME . NAME ( NAME ) NAME . NAME [ LIT ] . NAME ( NAME )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "MockLogger.get_messages",
      "lineno": 680,
      "end_lineno": 684,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self, level)",
      "fingerprint": "af844d4f3afea28e0053d1844d59992881b8a8de",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) -> NAME [ NAME ] : LIT if NAME : return NAME . NAME . NAME ( NAME , [ ] ) return NAME . NAME"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "MockLogger.clear",
      "lineno": 686,
      "end_lineno": 690,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "c6e75e98aa2b1522e878bf8fe2df65d38b73f042",
      "simhash64": 8640574316660302851,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME . NAME ( ) for NAME in NAME . NAME . NAME ( ) : NAME . NAME ( )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "mock_logger_context",
      "lineno": 694,
      "end_lineno": 710,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 1,
      "complexity": 3,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(module_globals, logger_name)",
      "fingerprint": "314658186dfaf3602ebfa0d9d0b874944eca97f6",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME = LIT ) -> NAME [ NAME ] : LIT NAME = NAME . NAME ( NAME ) NAME = NAME ( ) NAME [ NAME ] = NAME try : yield NAME finally : if NAME : NAME [ NAME ] = NAME"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "format_test_section_header",
      "lineno": 717,
      "end_lineno": 732,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 16,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(title, emoji)",
      "fingerprint": "ebb1880e37bd07ee503f8ac13e502f2e78568d9c",
      "simhash64": 7452080857216889875,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME = LIT ) -> NAME : LIT NAME = LIT * LIT NAME = f\" \\n { NAME . NAME } { NAME } { NAME . NAME } \" NAME += f\" \\n { NAME . NAME } { NAME . NAME } { NAME } { NAME . NAME ( ) } { NAME . NAME } \" NAME += f\" \\n { NAME . NAME } { NAME } { NAME . NAME } \" return NAME"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "format_score_breakdown_table",
      "lineno": 735,
      "end_lineno": 772,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 38,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "(field_scores, total_score)",
      "fingerprint": "d132b9cba099963bba5c4528f697d5af622c32e1",
      "simhash64": 7451658645825558075,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME : LIT NAME = f\" \\n { NAME . NAME } { NAME . NAME } \ud83d\udcca Scoring Breakdown: { NAME . NAME } \\n \" NAME += f\" { NAME . NAME } { LIT : <12 } { LIT : <6 } { LIT : <30 } { NAME . NAME } \\n \" NAME += f\" { NAME . NAME } { LIT * LIT } { NAME . NAME } \\n \" # Field descriptions for readability NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } for NAME , NAME in NAME . NAME ( ) : NAME = NAME . NAME ( NAME , NAME . NAME ( ) . NAME ( LIT , LIT ) ) if NAME > LIT : NAME = NAME . NAME elif NAME == LIT : NAME = NAME . NAME else : NAME = NAME . NAME NAME += f\" { NAME . NAME } { NAME : <12 } { NAME } { NAME : <6 } { NAME . NAME } { NAME : <30 } \\n \" NAME += f\" { NAME . NAME } { LIT * LIT } { NAME . NAME } \\n \" NAME += f\" { NAME . NAME } { NAME . NAME } { LIT : <12 } { NAME : <6 } Final Match Score { NAME . NAME } \\n \" return NAME"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "format_search_criteria",
      "lineno": 775,
      "end_lineno": 790,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(criteria)",
      "fingerprint": "7df488d4752ceacc4993906442b6939cf791e1c0",
      "simhash64": 7452080857216889875,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = f\" { NAME . NAME } { NAME . NAME } \ud83d\udd0d Search Criteria: { NAME . NAME } \\n \" for NAME , NAME in NAME . NAME ( ) : NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) NAME += f\" { NAME . NAME } \u2022 { NAME . NAME } { NAME } : { NAME . NAME } { NAME } { NAME . NAME } \\n \" return NAME"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "format_test_result",
      "lineno": 793,
      "end_lineno": 818,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 26,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "(test_name, success, duration)",
      "fingerprint": "9a0a56537fa4060a3e07417c159ec87644136eb6",
      "simhash64": 7452080857216889875,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT if NAME : NAME = NAME . NAME NAME = NAME . NAME NAME = LIT else : NAME = NAME . NAME NAME = NAME . NAME NAME = LIT NAME = f\" { NAME } { NAME } { NAME } : { NAME } { NAME . NAME } \" if NAME : NAME += f\" { NAME . NAME } ( { NAME : .3f } s) { NAME . NAME } \" return NAME"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "suppress_debug_logging",
      "lineno": 821,
      "end_lineno": 824,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "c53b55245ef52f1f9fa024e7d0228d1df23d4d8b",
      "simhash64": 8641136717864543267,
      "normalized": "def NAME ( ) -> None : LIT import NAME NAME . NAME ( ) . NAME ( NAME . NAME )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "restore_debug_logging",
      "lineno": 827,
      "end_lineno": 830,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "c53b55245ef52f1f9fa024e7d0228d1df23d4d8b",
      "simhash64": 8641136717864543267,
      "normalized": "def NAME ( ) -> None : LIT import NAME NAME . NAME ( ) . NAME ( NAME . NAME )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "clean_test_output",
      "lineno": 833,
      "end_lineno": 852,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 1,
      "complexity": 2,
      "loc": 20,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "69c1f6fc877fe6a91f09a92b7796c899d27f0c5e",
      "simhash64": 8641127882581509163,
      "normalized": "def NAME ( ) -> NAME [ None ] : LIT from NAME import NAME @ NAME def NAME ( ) -> NAME : NAME ( ) try : yield finally : NAME ( ) return NAME ( )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "_clean_output",
      "lineno": 845,
      "end_lineno": 850,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 1,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "6a8d982d0a917a6ba8c35187c7644ad3682fb089",
      "simhash64": 8640705674478523945,
      "normalized": "def NAME ( ) -> NAME : NAME ( ) try : yield finally : NAME ( )"
    },
    {
      "module_path": "test_framework.py",
      "qualname": "test_function_availability",
      "lineno": 855,
      "end_lineno": 904,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 50,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(required_functions, globals_dict, module_name)",
      "fingerprint": "f6950e82fdb4a0442c9368ac2c411075b557cfc3",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME = LIT ) -> NAME [ NAME ] : LIT NAME = [ ] NAME ( f\" \\n\ud83d\udd0d Testing { NAME } Function Availability: \" ) for NAME in NAME : try : # Check if function exists in globals if NAME not in NAME : NAME ( f\" \u274c { NAME } : Not found in globals \" ) NAME . NAME ( False ) continue # Check if it's callable NAME = NAME [ NAME ] if not NAME ( NAME ) : NAME ( f\" \u274c { NAME } : Found but not callable \" ) NAME . NAME ( False ) continue # Function exists and is callable NAME ( f\" \u2705 { NAME } : Available and callable \" ) NAME . NAME ( True ) except NAME as NAME : NAME ( f\" \u274c { NAME } : Error during test - { NAME } \" ) NAME . NAME ( False ) # Summary NAME = NAME ( NAME ) NAME = NAME ( NAME ) NAME ( f\" \\n\ud83d\udcca Function Availability Summary: { NAME } / { NAME } functions available \" ) # Assert all functions are available for NAME , ( NAME , NAME ) in NAME ( NAME ( NAME , NAME ) ) : assert NAME , f\" Required function ' { NAME } ' is not available \" return NAME"
    },
    {
      "module_path": "universal_scoring.py",
      "qualname": "apply_universal_scoring",
      "lineno": 26,
      "end_lineno": 116,
      "is_method": false,
      "is_async": false,
      "args_count": 6,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 9,
      "loc": 91,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(candidates, search_criteria, scoring_weights, date_flexibility, max_results, performance_timeout)",
      "fingerprint": "ad90f1422c9dd0623fdba8913fd75813172de402",
      "simhash64": 7488180022980031515,
      "normalized": "def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME = LIT , NAME : NAME = LIT ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : from NAME import NAME from NAME import NAME # Use default weights if not provided if NAME is None : NAME = NAME ( NAME , LIT , { } ) # Use default date flexibility if not provided if NAME is None : NAME = { LIT : LIT } NAME = [ ] NAME = NAME . NAME ( ) NAME . NAME ( f\" Scoring { NAME ( NAME ) } candidates with universal scoring \" ) for NAME , NAME in NAME ( NAME ) : # Performance timeout check if ( NAME . NAME ( ) - NAME ) > NAME : NAME . NAME ( f\" Universal scoring timeout after { NAME } candidates \" ) break # Early termination if we have enough high-quality results if NAME ( NAME ) >= NAME and NAME [ - LIT ] . NAME ( LIT , LIT ) > LIT : NAME . NAME ( f\" Early termination with { NAME ( NAME ) } high-quality results \" ) break try : # Calculate score using universal algorithm NAME , NAME , NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) # Create standardized result format NAME = NAME . NAME ( ) NAME . NAME ( { LIT : NAME ( NAME ) , LIT : NAME , LIT : NAME , LIT : f\" { NAME . NAME ( LIT , LIT ) } { NAME . NAME ( LIT , LIT ) } \" . NAME ( ) , LIT : NAME ( NAME ) } ) NAME . NAME ( NAME ) except NAME as NAME : NAME = NAME . NAME ( LIT , NAME . NAME ( LIT , LIT ) ) NAME . NAME ( f\" Error scoring candidate { NAME } : { NAME } \" ) continue # Sort by score (descending) and return top results NAME . NAME ( NAME = lambda NAME : NAME . NAME ( LIT , LIT ) , NAME = True ) NAME = NAME [ : NAME ] NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Universal scoring completed: { NAME ( NAME ) } results in { NAME : .3f } s \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Universal scoring failed: { NAME } \" ) return [ ]"
    },
    {
      "module_path": "universal_scoring.py",
      "qualname": "_get_confidence_level",
      "lineno": 119,
      "end_lineno": 129,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(score)",
      "fingerprint": "15c674a78039200c966424ef556e4b827b1785c4",
      "simhash64": 5726842651100485163,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if NAME >= LIT : return LIT if NAME >= LIT : return LIT if NAME >= LIT : return LIT if NAME >= LIT : return LIT return LIT"
    },
    {
      "module_path": "universal_scoring.py",
      "qualname": "format_scoring_breakdown",
      "lineno": 132,
      "end_lineno": 191,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 60,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "(result, search_criteria, title)",
      "fingerprint": "7ab0e3ee0981b63b079309c0f55f26c9caeeaa0b",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME = LIT ) -> NAME : LIT try : NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , [ ] ) NAME = [ f\" \\n { NAME . NAME ( f' \ud83d\udcca { NAME } : ' ) } \" ] NAME . NAME ( LIT ) NAME . NAME ( LIT ) # Standard field mapping for consistent display NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } # Display field scores for NAME , NAME in NAME . NAME ( ) : NAME = NAME . NAME ( NAME , NAME . NAME ( ) ) NAME . NAME ( f\" { NAME : <12 } { NAME : >5 } { NAME ( NAME , NAME ) } \" ) NAME . NAME ( LIT ) NAME . NAME ( f\" { LIT : <12 } { NAME : >5 } { NAME ( NAME ) . NAME ( LIT , LIT ) . NAME ( ) } \" ) # Add reasons if available if NAME : NAME . NAME ( f\" \\n { NAME . NAME ( LIT ) } \" ) for NAME in NAME [ : LIT ] : # Limit to top 5 reasons NAME . NAME ( f\" \u2022 { NAME } \" ) return LIT . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error formatting scoring breakdown: { NAME } \" ) return f\" Scoring breakdown unavailable: { NAME } \""
    },
    {
      "module_path": "universal_scoring.py",
      "qualname": "_get_field_description",
      "lineno": 194,
      "end_lineno": 204,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(field_key, score)",
      "fingerprint": "88871a91d1867bb6d964ada82a5dc84a73e1abee",
      "simhash64": 5726841552662599211,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : LIT if NAME >= LIT : return LIT if NAME >= LIT : return LIT if NAME >= LIT : return LIT if NAME > LIT : return LIT return LIT"
    },
    {
      "module_path": "universal_scoring.py",
      "qualname": "validate_search_criteria",
      "lineno": 207,
      "end_lineno": 249,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 12,
      "loc": 43,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(criteria)",
      "fingerprint": "4859adef175206eb2ebfec72a91b6d86b1f42279",
      "simhash64": 7452151226028176435,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT NAME = { } # Normalize names to lowercase if LIT in NAME : NAME [ LIT ] = NAME ( NAME [ LIT ] ) . NAME ( ) . NAME ( ) if LIT in NAME : NAME [ LIT ] = NAME ( NAME [ LIT ] ) . NAME ( ) . NAME ( ) # Normalize numeric fields for NAME in [ LIT , LIT ] : if NAME in NAME and NAME [ NAME ] is not None : try : NAME [ NAME ] = NAME ( NAME [ NAME ] ) except ( NAME , NAME ) : NAME . NAME ( f\" Invalid { NAME } : { NAME [ NAME ] } \" ) NAME [ NAME ] = None # Normalize gender if LIT in NAME : NAME = NAME ( NAME [ LIT ] ) . NAME ( ) . NAME ( ) if NAME in [ LIT , LIT , LIT ] : NAME [ LIT ] = LIT elif NAME in [ LIT , LIT , LIT ] : NAME [ LIT ] = LIT else : NAME [ LIT ] = NAME # Copy other fields as-is for NAME , NAME in NAME . NAME ( ) : if NAME not in NAME : NAME [ NAME ] = NAME return NAME"
    },
    {
      "module_path": "universal_scoring.py",
      "qualname": "test_universal_scoring",
      "lineno": 253,
      "end_lineno": 288,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 36,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "cabe4bfe9db60ead1983e5837e7ba783f9fa39ba",
      "simhash64": 5145886005414762027,
      "normalized": "def NAME ( ) -> NAME : LIT try : # Mock candidate data NAME = [ { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ] NAME = { LIT : LIT , LIT : LIT , LIT : LIT } # This would normally call the real scoring function # For testing, we'll just validate the structure NAME = NAME ( NAME , NAME , NAME = LIT ) # Validate result structure assert NAME ( NAME , NAME ) if NAME : # Only check if we got results NAME = NAME [ LIT ] assert LIT in NAME assert LIT in NAME assert LIT in NAME return True except NAME as NAME : NAME . NAME ( f\" Universal scoring test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "universal_scoring.py",
      "qualname": "test_criteria_validation",
      "lineno": 291,
      "end_lineno": 311,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2dc235597e5a95a6602dbeccb7d8bdc24e753144",
      "simhash64": 5145878308841756203,
      "normalized": "def NAME ( ) -> NAME : LIT try : NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME ( NAME ) assert NAME [ LIT ] == LIT assert NAME [ LIT ] == LIT assert NAME [ LIT ] == LIT assert NAME [ LIT ] == LIT return True except NAME as NAME : NAME . NAME ( f\" Criteria validation test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "universal_scoring.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 314,
      "end_lineno": 321,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "7df204c088b3bb3d84aada8c79501a4f212d250e",
      "simhash64": 9221670026945140267,
      "normalized": "def NAME ( ) -> NAME : LIT try : NAME ( ) NAME ( ) return True except NAME : return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "get_configured_concurrency",
      "lineno": 70,
      "end_lineno": 177,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 8,
      "yield_count": 0,
      "complexity": 20,
      "loc": 108,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "purpose:getter",
        "size:large"
      ],
      "signature": "(default, workload_size, operation_type)",
      "fingerprint": "554f7f496bb1f7d52a2e00ccffcd9b154b4c0462",
      "simhash64": 5182477752395535403,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME [ NAME ] = None , NAME : NAME = LIT ) -> NAME : LIT import NAME import NAME # Check environment variables first (highest priority) NAME = NAME . NAME ( LIT ) if NAME : try : return NAME ( LIT , NAME ( NAME ) ) except NAME : pass NAME = NAME . NAME ( LIT ) if NAME : try : return NAME ( LIT , NAME ( NAME ) ) except NAME : pass # PHASE 2 ENHANCEMENT: Adaptive concurrency calculation try : # Get system capabilities NAME = NAME . NAME ( NAME = True ) or LIT NAME . NAME ( ) . NAME / ( LIT ** LIT ) NAME = NAME . NAME ( NAME = LIT ) NAME = NAME . NAME ( ) . NAME # Base concurrency on CPU count and operation type NAME = { LIT : LIT , # API calls can be more concurrent (I/O bound) LIT : LIT , # Database operations moderate concurrency LIT : LIT , # File operations conservative concurrency LIT : LIT # General operations moderate concurrency } NAME = NAME ( NAME * NAME . NAME ( NAME , LIT ) ) # Adjust based on current system load NAME = LIT if NAME > LIT : NAME = LIT # Reduce concurrency if CPU is heavily loaded elif NAME > LIT : NAME = LIT # Moderate reduction elif NAME < LIT : NAME = LIT # Increase if CPU is underutilized if NAME > LIT : NAME *= LIT # Further reduce if memory is constrained elif NAME > LIT : NAME *= LIT # Adjust based on workload size if NAME : if NAME < LIT : NAME = LIT # Small workloads don't need high concurrency elif NAME > LIT : NAME = LIT # Large workloads benefit from higher concurrency else : NAME = LIT else : NAME = LIT # Calculate final concurrency NAME = NAME ( NAME * NAME * NAME ) # Apply bounds NAME = LIT NAME = NAME ( NAME * LIT , LIT ) # Cap at 3x CPU count or 20 NAME = NAME ( NAME , NAME ( NAME , NAME ) ) # Use default if calculation fails or seems unreasonable if NAME < LIT or NAME > LIT : return NAME return NAME except NAME : # Fallback to default if adaptive calculation fails return NAME # Try config schema as fallback try : from NAME import NAME NAME = NAME ( NAME ( NAME , LIT , None ) , LIT , None ) if NAME is not None : return NAME ( LIT , NAME ) NAME = NAME ( NAME ( NAME , LIT , None ) , LIT , None ) if NAME is not None : return NAME ( LIT , NAME ) except NAME : pass return NAME ( LIT , NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "fast_json_loads",
      "lineno": 287,
      "end_lineno": 303,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "json",
        "size:small"
      ],
      "signature": "(json_str)",
      "fingerprint": "2613188a9d0485c2b3c645e5b1c83dc2886a4edd",
      "simhash64": 8641136677600801827,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT try : # Dynamic import to handle missing orjson gracefully NAME = NAME ( LIT ) return NAME . NAME ( NAME ) except ( NAME , NAME ) : return NAME . NAME ( NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "fast_json_dumps",
      "lineno": 305,
      "end_lineno": 330,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 26,
      "tags": [
        "pure-ish",
        "json",
        "size:small"
      ],
      "signature": "(obj, indent, ensure_ascii)",
      "fingerprint": "3b4a54ee841602cedc588654cf3de13b98a7e174",
      "simhash64": 7488320726110221315,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] = None , NAME : NAME = False ) -> NAME : LIT try : # Dynamic import to handle missing orjson gracefully NAME = NAME ( LIT ) if NAME : # orjson doesn't support indent, fall back to json for pretty printing return NAME . NAME ( NAME , NAME = NAME , NAME = NAME ) # Fast compact serialization return NAME . NAME ( NAME ) . NAME ( LIT ) except ( NAME , NAME ) : if NAME : return NAME . NAME ( NAME , NAME = NAME , NAME = NAME ) # Optimized compact serialization return NAME . NAME ( NAME , NAME = ( LIT , LIT ) , NAME = NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "parse_cookie",
      "lineno": 336,
      "end_lineno": 381,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 46,
      "tags": [
        "impure",
        "size:medium"
      ],
      "signature": "(cookie_string)",
      "fingerprint": "bc1ff64c8dd8d149ab9f8a0a6631e36f6620c45b",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME , NAME ] : LIT NAME : NAME [ NAME , NAME ] = { } if not NAME ( NAME , NAME ) : NAME . NAME ( LIT ) return NAME # End of if NAME = NAME . NAME ( LIT ) for NAME in NAME : NAME = NAME . NAME ( ) if not NAME : continue # End of if if LIT in NAME : NAME , NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) NAME [ NAME ] = NAME else : NAME . NAME ( f\" Skipping cookie part without '=': ' { NAME } ' \" ) # End of if/else # End of for return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "ordinal_case",
      "lineno": 385,
      "end_lineno": 442,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 12,
      "loc": 58,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(text)",
      "fingerprint": "372db379892e41b3d6fbc365445b862b41262320",
      "simhash64": 5182477752395535403,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : LIT if not NAME and NAME != LIT : return NAME ( NAME ) if NAME is not None else LIT # End of if try : NAME = NAME ( NAME ) if LIT <= ( NAME % LIT ) <= LIT : NAME = LIT else : NAME = NAME % LIT if NAME == LIT : NAME = LIT elif NAME == LIT : NAME = LIT elif NAME == LIT : NAME = LIT else : NAME = LIT # End of if/elif/else # End of if/else return NAME ( NAME ) + NAME except ( NAME , NAME ) : if NAME ( NAME , NAME ) : NAME = NAME . NAME ( ) . NAME ( ) NAME = { LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT } for NAME , NAME in NAME ( NAME ) : if NAME > LIT and NAME in NAME : NAME [ NAME ] = NAME . NAME ( ) # End of if # End of for return LIT . NAME ( NAME ) return NAME ( NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "format_name",
      "lineno": 448,
      "end_lineno": 620,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 31,
      "loc": 173,
      "tags": [
        "impure",
        "regex",
        "purpose:formatting",
        "size:large"
      ],
      "signature": "(name)",
      "fingerprint": "d6390a3f79db3e5873f5d6b6aae9998d2ca361c7",
      "simhash64": 7488180023047140387,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME : LIT if not NAME or not NAME ( NAME , NAME ) : return LIT # End of if if NAME . NAME ( ) or NAME . NAME ( LIT , NAME ) : NAME . NAME ( f\" Formatting name: Input ' { NAME } ' appears non-alphabetic, returning as is. \" ) NAME = NAME . NAME ( ) return NAME if NAME else LIT # End of if try : NAME = NAME . NAME ( ) # Handle GEDCOM slashes more robustly NAME = NAME . NAME ( LIT , LIT , NAME ) # Middle NAME = NAME . NAME ( LIT , LIT , NAME ) # Start NAME = NAME . NAME ( LIT , LIT , NAME ) # End NAME = NAME . NAME ( LIT , LIT , NAME ) # Only NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) NAME = { LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , } NAME = { LIT , LIT , LIT , LIT , LIT } NAME = NAME . NAME ( ) NAME = [ ] NAME = LIT while NAME < NAME ( NAME ) : NAME = NAME [ NAME ] NAME = NAME . NAME ( ) if NAME > LIT and NAME in NAME : NAME . NAME ( NAME ) NAME += LIT continue # End of if if NAME . NAME ( ) in NAME : NAME . NAME ( NAME . NAME ( ) ) NAME += LIT continue # End of if # *** NEW/MODIFIED LOGIC FOR QUOTED NICKNAMES AND APOSTROPHES *** if NAME . NAME ( LIT ) and NAME . NAME ( LIT ) and NAME ( NAME ) > LIT : # Handles parts like 'Betty' or 'bo' # Capitalize the content within the quotes NAME = NAME [ LIT : - LIT ] NAME . NAME ( LIT + NAME . NAME ( ) + LIT ) NAME += LIT continue # End of if if LIT in NAME : NAME = [ ] NAME = NAME . NAME ( LIT ) for NAME , NAME in NAME ( NAME ) : if NAME > LIT and NAME . NAME ( ) in NAME : NAME . NAME ( NAME . NAME ( ) ) elif NAME : # Ensure sub_part is not empty NAME . NAME ( NAME . NAME ( ) ) # End of if/elif # End of for NAME . NAME ( LIT . NAME ( NAME ( None , NAME ) ) ) NAME += LIT continue # End of if # Handle names like O'Malley, D'Angelo if ( LIT in NAME and NAME ( NAME ) > LIT and not ( NAME . NAME ( LIT ) or NAME . NAME ( LIT ) ) ) : # This condition targets internal apostrophes like in O'Malley # It avoids single-quoted parts like 'Betty' which are handled above. NAME = NAME . NAME ( LIT ) # Capitalize the first letter of each piece around the apostrophe NAME = LIT . NAME ( NAME . NAME ( ) for NAME in NAME ) NAME . NAME ( NAME ) NAME += LIT continue # End of if if NAME . NAME ( LIT ) and NAME ( NAME ) > LIT : NAME . NAME ( LIT + NAME [ LIT : ] . NAME ( ) ) NAME += LIT continue # End of if if NAME . NAME ( LIT ) and NAME ( NAME ) > LIT : if NAME == LIT : # Handle \"Mac\" itself NAME . NAME ( LIT ) else : NAME . NAME ( LIT + NAME [ LIT : ] . NAME ( ) ) # End of if/else NAME += LIT continue # End of if if ( NAME ( NAME ) == LIT and NAME . NAME ( LIT ) and NAME [ LIT ] . NAME ( ) ) : # Initials like J. NAME . NAME ( NAME [ LIT ] . NAME ( ) + LIT ) NAME += LIT continue # End of if if ( NAME ( NAME ) == LIT and NAME . NAME ( ) ) : # Single letter initials without period NAME . NAME ( NAME . NAME ( ) ) NAME += LIT continue # End of if # Default: capitalize the part NAME . NAME ( NAME . NAME ( ) ) NAME += LIT # End of while NAME = LIT . NAME ( NAME ) NAME = NAME . NAME ( LIT , LIT , NAME ) . NAME ( ) # Consolidate multiple spaces return NAME if NAME else LIT except NAME as NAME : NAME . NAME ( f\" Error formatting name ' { NAME } ': { NAME } \" , NAME = False ) try : return NAME . NAME ( ) if NAME ( NAME , NAME ) else LIT except NAME : return LIT"
    },
    {
      "module_path": "utils.py",
      "qualname": "retry",
      "lineno": 630,
      "end_lineno": 706,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 13,
      "loc": 77,
      "tags": [
        "pure-ish",
        "randomness",
        "time",
        "size:medium"
      ],
      "signature": "(max_retries, backoff_factor, max_delay, **kwargs)",
      "fingerprint": "5f83a152b6b2fcafa574f44f70b87a032c54878f",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , ** NAME : NAME , ) : LIT # Map legacy UPPERCASE kwargs to lowercase if not explicitly provided if NAME is None and LIT in NAME : try : NAME = NAME ( NAME [ LIT ] ) # type: ignore[arg-type] except NAME : NAME = None if NAME is None and LIT in NAME : try : NAME = NAME ( NAME [ LIT ] ) # type: ignore[arg-type] except NAME : NAME = None if NAME is None and LIT in NAME : try : NAME = NAME ( NAME [ LIT ] ) # type: ignore[arg-type] except NAME : NAME = None def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : NAME = NAME # Use new config system NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) for NAME in NAME ( NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : if NAME == NAME - LIT : NAME . NAME ( f\" Function ' { NAME . NAME } ' failed after { NAME } retries. Final Exception: { NAME } \" , NAME = False , # Keep simple log for retry failure ) raise # Re-raise the final exception # End of if NAME = NAME ( NAME * ( LIT ** NAME ) , NAME ) + NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" Retry { NAME + LIT } / { NAME } for { NAME . NAME } after exception: { NAME ( NAME ) . NAME } . Sleeping { NAME : .2f } s. \" ) NAME . NAME ( NAME ) # End of try/except # End of for # This part should ideally not be reached if raise is used above NAME . NAME ( f\" Function ' { NAME . NAME } ' failed after all { NAME } retries (exited loop unexpectedly). \" ) raise NAME ( f\" Function { NAME . NAME } failed after all retries. \" ) # End of wrapper return NAME # End of decorator return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "decorator",
      "lineno": 659,
      "end_lineno": 703,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 45,
      "tags": [
        "pure-ish",
        "randomness",
        "time",
        "size:medium"
      ],
      "signature": "(func)",
      "fingerprint": "2c5f1f15c69c62f151a1b942f9fae6e17d83bdbe",
      "simhash64": 7488180022980023323,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : NAME = NAME # Use new config system NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) for NAME in NAME ( NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : if NAME == NAME - LIT : NAME . NAME ( f\" Function ' { NAME . NAME } ' failed after { NAME } retries. Final Exception: { NAME } \" , NAME = False , # Keep simple log for retry failure ) raise # Re-raise the final exception # End of if NAME = NAME ( NAME * ( LIT ** NAME ) , NAME ) + NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" Retry { NAME + LIT } / { NAME } for { NAME . NAME } after exception: { NAME ( NAME ) . NAME } . Sleeping { NAME : .2f } s. \" ) NAME . NAME ( NAME ) # End of try/except # End of for # This part should ideally not be reached if raise is used above NAME . NAME ( f\" Function ' { NAME . NAME } ' failed after all { NAME } retries (exited loop unexpectedly). \" ) raise NAME ( f\" Function { NAME . NAME } failed after all retries. \" ) # End of wrapper return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "wrapper",
      "lineno": 661,
      "end_lineno": 700,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 40,
      "tags": [
        "pure-ish",
        "randomness",
        "time",
        "size:medium"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "27b67d1ad02fb8a635767f15d38de422610afcb0",
      "simhash64": 7488180022980023323,
      "normalized": "def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : NAME = NAME # Use new config system NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) for NAME in NAME ( NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : if NAME == NAME - LIT : NAME . NAME ( f\" Function ' { NAME . NAME } ' failed after { NAME } retries. Final Exception: { NAME } \" , NAME = False , # Keep simple log for retry failure ) raise # Re-raise the final exception # End of if NAME = NAME ( NAME * ( LIT ** NAME ) , NAME ) + NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" Retry { NAME + LIT } / { NAME } for { NAME . NAME } after exception: { NAME ( NAME ) . NAME } . Sleeping { NAME : .2f } s. \" ) NAME . NAME ( NAME ) # End of try/except # End of for # This part should ideally not be reached if raise is used above NAME . NAME ( f\" Function ' { NAME . NAME } ' failed after all { NAME } retries (exited loop unexpectedly). \" ) raise NAME ( f\" Function { NAME . NAME } failed after all retries. \" )"
    },
    {
      "module_path": "utils.py",
      "qualname": "retry_api",
      "lineno": 710,
      "end_lineno": 852,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 10,
      "loc": 143,
      "tags": [
        "impure",
        "network",
        "randomness",
        "time",
        "size:large"
      ],
      "signature": "(max_retries, initial_delay, backoff_factor, retry_on_exceptions, retry_on_status_codes)",
      "fingerprint": "58a9e0b6eb535e491b9b0d7b628c9c5df8119b51",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME [ NAME ] , ... ] = ( NAME . NAME . NAME , # type: ignore # Assume imported NAME , NAME , ) , NAME : NAME [ NAME [ NAME ] ] = None , ) -> NAME [ [ NAME [ ... , NAME ] ] , NAME [ ... , NAME ] ] : LIT def NAME ( NAME : NAME [ ... , NAME ] ) -> NAME [ ... , NAME ] : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : NAME = NAME # Use new config system NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = NAME ( NAME if NAME is not None else NAME ( NAME , LIT , [ LIT , LIT , LIT , LIT , LIT ] ) ) NAME = NAME ( NAME , LIT , LIT ) NAME = NAME NAME = NAME NAME = LIT NAME : NAME [ NAME ] = None NAME : NAME = None while NAME > LIT : NAME += LIT try : NAME = NAME ( * NAME , ** NAME ) NAME = NAME NAME : NAME [ NAME ] = None if NAME ( NAME , NAME . NAME ) : # type: ignore # Assume imported NAME = NAME . NAME # End of if NAME = False if NAME is not None and NAME in NAME : NAME = True NAME = NAME . NAME . NAME ( # type: ignore f\" { NAME } Error \" , NAME = NAME ) # End of if if NAME : NAME -= LIT if NAME <= LIT : NAME . NAME ( f\" API Call failed after { NAME } retries for ' { NAME . NAME } ' (Final Status { NAME } ). \" ) # Return the response object on final failure return NAME # End of if NAME = NAME ( NAME * ( NAME ** ( NAME - LIT ) ) , NAME ) + NAME . NAME ( LIT , LIT ) NAME = NAME ( LIT , NAME ) NAME . NAME ( f\" API Call status { NAME } (Attempt { NAME } / { NAME } ) for ' { NAME . NAME } '. Retrying in { NAME : .2f } s... \" ) NAME . NAME ( NAME ) NAME *= NAME continue # Success or non-retryable error, return the response return NAME # End of if/else except NAME as NAME : NAME = NAME NAME -= LIT if NAME <= LIT : NAME . NAME ( f\" API Call failed after { NAME } retries for ' { NAME . NAME } '. Final Exception: { NAME ( NAME ) . NAME } - { NAME } \" , NAME = False , ) # Raise the exception on final retry failure raise NAME # End of if NAME = NAME ( NAME * ( NAME ** ( NAME - LIT ) ) , NAME ) + NAME . NAME ( LIT , LIT ) NAME = NAME ( LIT , NAME ) NAME . NAME ( f\" API Call exception ' { NAME ( NAME ) . NAME } ' (Attempt { NAME } / { NAME } ) for ' { NAME . NAME } ', retrying in { NAME : .2f } s... \" ) NAME . NAME ( NAME ) NAME *= NAME continue except NAME as NAME : # Non-retryable exception occurred NAME . NAME ( f\" Unexpected error during API call attempt { NAME } for ' { NAME . NAME } ': { NAME } \" , NAME = True , ) raise NAME # Re-raise immediately # End of try/except # End of while # Should only be reached if the loop completes unexpectedly (e.g., condition error) # Or if the last attempt resulted in a retryable error but retries hit 0 NAME . NAME ( f\" Exited retry loop for ' { NAME . NAME } '. Last status: { NAME ( NAME , LIT , LIT ) } , Last exception: { NAME } \" ) if NAME : raise NAME # Re-raise the last exception if one occurred # This case implies a retryable status on the last attempt return ( NAME if NAME is not None else NAME ( f\" { NAME . NAME } failed after all retries. \" ) ) # End of if/else # End of wrapper return NAME # End of decorator return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "decorator",
      "lineno": 735,
      "end_lineno": 849,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 10,
      "loc": 115,
      "tags": [
        "impure",
        "network",
        "randomness",
        "time",
        "size:large"
      ],
      "signature": "(func)",
      "fingerprint": "54fa63b0a9793ed092e21de9f62e7c09b2389147",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME : NAME [ ... , NAME ] ) -> NAME [ ... , NAME ] : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : NAME = NAME # Use new config system NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = NAME ( NAME if NAME is not None else NAME ( NAME , LIT , [ LIT , LIT , LIT , LIT , LIT ] ) ) NAME = NAME ( NAME , LIT , LIT ) NAME = NAME NAME = NAME NAME = LIT NAME : NAME [ NAME ] = None NAME : NAME = None while NAME > LIT : NAME += LIT try : NAME = NAME ( * NAME , ** NAME ) NAME = NAME NAME : NAME [ NAME ] = None if NAME ( NAME , NAME . NAME ) : # type: ignore # Assume imported NAME = NAME . NAME # End of if NAME = False if NAME is not None and NAME in NAME : NAME = True NAME = NAME . NAME . NAME ( # type: ignore f\" { NAME } Error \" , NAME = NAME ) # End of if if NAME : NAME -= LIT if NAME <= LIT : NAME . NAME ( f\" API Call failed after { NAME } retries for ' { NAME . NAME } ' (Final Status { NAME } ). \" ) # Return the response object on final failure return NAME # End of if NAME = NAME ( NAME * ( NAME ** ( NAME - LIT ) ) , NAME ) + NAME . NAME ( LIT , LIT ) NAME = NAME ( LIT , NAME ) NAME . NAME ( f\" API Call status { NAME } (Attempt { NAME } / { NAME } ) for ' { NAME . NAME } '. Retrying in { NAME : .2f } s... \" ) NAME . NAME ( NAME ) NAME *= NAME continue # Success or non-retryable error, return the response return NAME # End of if/else except NAME as NAME : NAME = NAME NAME -= LIT if NAME <= LIT : NAME . NAME ( f\" API Call failed after { NAME } retries for ' { NAME . NAME } '. Final Exception: { NAME ( NAME ) . NAME } - { NAME } \" , NAME = False , ) # Raise the exception on final retry failure raise NAME # End of if NAME = NAME ( NAME * ( NAME ** ( NAME - LIT ) ) , NAME ) + NAME . NAME ( LIT , LIT ) NAME = NAME ( LIT , NAME ) NAME . NAME ( f\" API Call exception ' { NAME ( NAME ) . NAME } ' (Attempt { NAME } / { NAME } ) for ' { NAME . NAME } ', retrying in { NAME : .2f } s... \" ) NAME . NAME ( NAME ) NAME *= NAME continue except NAME as NAME : # Non-retryable exception occurred NAME . NAME ( f\" Unexpected error during API call attempt { NAME } for ' { NAME . NAME } ': { NAME } \" , NAME = True , ) raise NAME # Re-raise immediately # End of try/except # End of while # Should only be reached if the loop completes unexpectedly (e.g., condition error) # Or if the last attempt resulted in a retryable error but retries hit 0 NAME . NAME ( f\" Exited retry loop for ' { NAME . NAME } '. Last status: { NAME ( NAME , LIT , LIT ) } , Last exception: { NAME } \" ) if NAME : raise NAME # Re-raise the last exception if one occurred # This case implies a retryable status on the last attempt return ( NAME if NAME is not None else NAME ( f\" { NAME . NAME } failed after all retries. \" ) ) # End of if/else # End of wrapper return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "wrapper",
      "lineno": 737,
      "end_lineno": 845,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 10,
      "loc": 109,
      "tags": [
        "impure",
        "network",
        "randomness",
        "time",
        "size:large"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "74b8080fda50f03b56fff7dfe197344d8f96f273",
      "simhash64": 7488109654235845659,
      "normalized": "def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : NAME = NAME # Use new config system NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = ( NAME if NAME is not None else NAME ( NAME , LIT , LIT ) ) NAME = NAME ( NAME if NAME is not None else NAME ( NAME , LIT , [ LIT , LIT , LIT , LIT , LIT ] ) ) NAME = NAME ( NAME , LIT , LIT ) NAME = NAME NAME = NAME NAME = LIT NAME : NAME [ NAME ] = None NAME : NAME = None while NAME > LIT : NAME += LIT try : NAME = NAME ( * NAME , ** NAME ) NAME = NAME NAME : NAME [ NAME ] = None if NAME ( NAME , NAME . NAME ) : # type: ignore # Assume imported NAME = NAME . NAME # End of if NAME = False if NAME is not None and NAME in NAME : NAME = True NAME = NAME . NAME . NAME ( # type: ignore f\" { NAME } Error \" , NAME = NAME ) # End of if if NAME : NAME -= LIT if NAME <= LIT : NAME . NAME ( f\" API Call failed after { NAME } retries for ' { NAME . NAME } ' (Final Status { NAME } ). \" ) # Return the response object on final failure return NAME # End of if NAME = NAME ( NAME * ( NAME ** ( NAME - LIT ) ) , NAME ) + NAME . NAME ( LIT , LIT ) NAME = NAME ( LIT , NAME ) NAME . NAME ( f\" API Call status { NAME } (Attempt { NAME } / { NAME } ) for ' { NAME . NAME } '. Retrying in { NAME : .2f } s... \" ) NAME . NAME ( NAME ) NAME *= NAME continue # Success or non-retryable error, return the response return NAME # End of if/else except NAME as NAME : NAME = NAME NAME -= LIT if NAME <= LIT : NAME . NAME ( f\" API Call failed after { NAME } retries for ' { NAME . NAME } '. Final Exception: { NAME ( NAME ) . NAME } - { NAME } \" , NAME = False , ) # Raise the exception on final retry failure raise NAME # End of if NAME = NAME ( NAME * ( NAME ** ( NAME - LIT ) ) , NAME ) + NAME . NAME ( LIT , LIT ) NAME = NAME ( LIT , NAME ) NAME . NAME ( f\" API Call exception ' { NAME ( NAME ) . NAME } ' (Attempt { NAME } / { NAME } ) for ' { NAME . NAME } ', retrying in { NAME : .2f } s... \" ) NAME . NAME ( NAME ) NAME *= NAME continue except NAME as NAME : # Non-retryable exception occurred NAME . NAME ( f\" Unexpected error during API call attempt { NAME } for ' { NAME . NAME } ': { NAME } \" , NAME = True , ) raise NAME # Re-raise immediately # End of try/except # End of while # Should only be reached if the loop completes unexpectedly (e.g., condition error) # Or if the last attempt resulted in a retryable error but retries hit 0 NAME . NAME ( f\" Exited retry loop for ' { NAME . NAME } '. Last status: { NAME ( NAME , LIT , LIT ) } , Last exception: { NAME } \" ) if NAME : raise NAME # Re-raise the last exception if one occurred # This case implies a retryable status on the last attempt return ( NAME if NAME is not None else NAME ( f\" { NAME . NAME } failed after all retries. \" ) )"
    },
    {
      "module_path": "utils.py",
      "qualname": "ensure_browser_open",
      "lineno": 856,
      "end_lineno": 903,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 10,
      "loc": 48,
      "tags": [
        "impure",
        "filesystem",
        "size:medium"
      ],
      "signature": "(func)",
      "fingerprint": "b0e0374d2553cba475231178a8ba04441d66c138",
      "simhash64": 5182337563590308919,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : NAME : NAME = None NAME : NAME = None # Logic to find WebDriver instance (simplified) if NAME : if NAME ( NAME [ LIT ] , NAME ) : # type: ignore # Assume SessionManager available NAME = NAME [ LIT ] NAME = NAME . NAME elif NAME ( NAME [ LIT ] , NAME ) : # type: ignore # Assume WebDriver available NAME = NAME [ LIT ] # End of if/elif # End of if if not NAME and LIT in NAME and NAME ( NAME [ LIT ] , NAME ) : # type: ignore NAME = NAME [ LIT ] # End of if # End of if if ( not NAME and LIT in NAME and NAME ( NAME [ LIT ] , NAME ) # type: ignore ) : NAME = NAME [ LIT ] NAME = NAME . NAME # End of if # End of if # Final check and raise error if no driver found if not NAME : raise NAME ( f\" Function ' { NAME . NAME } ' decorated with @ensure_browser_open requires a WebDriver instance. \" ) # End of if # Check if browser is open using utility function if not NAME ( NAME ) : raise NAME ( # type: ignore f\" Browser session invalid/closed when calling function ' { NAME . NAME } ' \" ) # End of if return NAME ( * NAME , ** NAME ) # End of wrapper return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "wrapper",
      "lineno": 860,
      "end_lineno": 900,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 10,
      "loc": 41,
      "tags": [
        "impure",
        "filesystem",
        "size:medium"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "23e4bde2987a41ac4202479fd78935d1a0eb0db7",
      "simhash64": 5182337563590308919,
      "normalized": "def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : NAME : NAME = None NAME : NAME = None # Logic to find WebDriver instance (simplified) if NAME : if NAME ( NAME [ LIT ] , NAME ) : # type: ignore # Assume SessionManager available NAME = NAME [ LIT ] NAME = NAME . NAME elif NAME ( NAME [ LIT ] , NAME ) : # type: ignore # Assume WebDriver available NAME = NAME [ LIT ] # End of if/elif # End of if if not NAME and LIT in NAME and NAME ( NAME [ LIT ] , NAME ) : # type: ignore NAME = NAME [ LIT ] # End of if # End of if if ( not NAME and LIT in NAME and NAME ( NAME [ LIT ] , NAME ) # type: ignore ) : NAME = NAME [ LIT ] NAME = NAME . NAME # End of if # End of if # Final check and raise error if no driver found if not NAME : raise NAME ( f\" Function ' { NAME . NAME } ' decorated with @ensure_browser_open requires a WebDriver instance. \" ) # End of if # Check if browser is open using utility function if not NAME ( NAME ) : raise NAME ( # type: ignore f\" Browser session invalid/closed when calling function ' { NAME . NAME } ' \" ) # End of if return NAME ( * NAME , ** NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "time_wait",
      "lineno": 907,
      "end_lineno": 936,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 30,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(wait_description)",
      "fingerprint": "67a0796481fa65746db37bc0e57032cdd129a6f7",
      "simhash64": 7488144838607934515,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : NAME = NAME . NAME ( ) try : return NAME ( * NAME , ** NAME ) except NAME as NAME : # type: ignore # Assume imported NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Wait ' { NAME } ' timed out after { NAME : .3f } seconds. \" , NAME = False , # Don't need full trace for timeout ) raise NAME # Re-raise TimeoutException except NAME as NAME : NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Error during wait ' { NAME } ' after { NAME : .3f } seconds: { NAME } \" , NAME = True , # Log full trace for other errors ) raise NAME # Re-raise other exceptions # End of try/except # End of wrapper return NAME # End of decorator return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "decorator",
      "lineno": 910,
      "end_lineno": 933,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 24,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(func)",
      "fingerprint": "686c37902cea30f28468e7d9598b110915088172",
      "simhash64": 7488144838608983091,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : NAME = NAME . NAME ( ) try : return NAME ( * NAME , ** NAME ) except NAME as NAME : # type: ignore # Assume imported NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Wait ' { NAME } ' timed out after { NAME : .3f } seconds. \" , NAME = False , # Don't need full trace for timeout ) raise NAME # Re-raise TimeoutException except NAME as NAME : NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Error during wait ' { NAME } ' after { NAME : .3f } seconds: { NAME } \" , NAME = True , # Log full trace for other errors ) raise NAME # Re-raise other exceptions # End of try/except # End of wrapper return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "wrapper",
      "lineno": 912,
      "end_lineno": 929,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 18,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "2805c5ff2ab883ee6f4d932e728524518724e620",
      "simhash64": 7452116041590019135,
      "normalized": "def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : NAME = NAME . NAME ( ) try : return NAME ( * NAME , ** NAME ) except NAME as NAME : # type: ignore # Assume imported NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Wait ' { NAME } ' timed out after { NAME : .3f } seconds. \" , NAME = False , # Don't need full trace for timeout ) raise NAME # Re-raise TimeoutException except NAME as NAME : NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Error during wait ' { NAME } ' after { NAME : .3f } seconds: { NAME } \" , NAME = True , # Log full trace for other errors ) raise NAME # Re-raise other exceptions"
    },
    {
      "module_path": "utils.py",
      "qualname": "ObjectPool.__init__",
      "lineno": 956,
      "end_lineno": 960,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, factory, max_size)",
      "fingerprint": "5dd90eeba5bf3bc093000b751dbf9f3b62a6ce28",
      "simhash64": 7488180022980031511,
      "normalized": "def NAME ( NAME , NAME : NAME [ [ ] , NAME ] , NAME : NAME = LIT ) : NAME . NAME = NAME NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME = NAME ( LIT , NAME ( NAME ) ) NAME . NAME = NAME . NAME ( )"
    },
    {
      "module_path": "utils.py",
      "qualname": "ObjectPool.acquire",
      "lineno": 962,
      "end_lineno": 967,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "db818695cc590723ae00fa28a37e7732885b3348",
      "simhash64": 7488145388363755523,
      "normalized": "def NAME ( NAME ) -> NAME : with NAME . NAME : if NAME . NAME : return NAME . NAME . NAME ( ) # Create outside of lock to avoid holding during factory work return NAME . NAME ( )"
    },
    {
      "module_path": "utils.py",
      "qualname": "ObjectPool.release",
      "lineno": 969,
      "end_lineno": 972,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, obj)",
      "fingerprint": "63051b2f2aba19222f3f56b4dd226b55bafc2f05",
      "simhash64": 8641136711958963203,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : with NAME . NAME : if NAME ( NAME . NAME ) < NAME . NAME : NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "LazyProperty.__init__",
      "lineno": 990,
      "end_lineno": 993,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, func)",
      "fingerprint": "f2e9d5b3a42327f1faa26d49a4bee515e68b4f53",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME [ [ NAME ] , NAME ] ) : NAME ( NAME ) ( NAME ) NAME . NAME = NAME NAME . NAME = NAME . NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "LazyProperty.__get__",
      "lineno": 995,
      "end_lineno": 1002,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self, obj, objtype)",
      "fingerprint": "0b03b9ef0736935bc6b499aa7d90af239c338776",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME , NAME , NAME = None ) -> NAME : if NAME is None : return NAME # access via class if NAME . NAME in NAME . NAME : return NAME . NAME [ NAME . NAME ] NAME = NAME . NAME ( NAME ) NAME . NAME [ NAME . NAME ] = NAME return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "DynamicRateLimiter.__init__",
      "lineno": 1013,
      "end_lineno": 1069,
      "is_method": true,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 57,
      "tags": [
        "pure-ish",
        "time",
        "purpose:initialization",
        "size:medium"
      ],
      "signature": "(self, initial_delay, max_delay, backoff_factor, decrease_factor, token_capacity, token_fill_rate)",
      "fingerprint": "cfe7bf18e7edd86e72918f25808c63ba97c2c040",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , ) -> None : NAME = NAME # Use new config system NAME = NAME ( NAME , LIT , None ) # Use APIConfig-backed values to ensure .env is respected # OPTIMIZATION: Improved default values for better Action 6 performance NAME . NAME = ( NAME if NAME is not None else ( NAME ( NAME , LIT , LIT ) if NAME else LIT ) # Reduced from 2.0 ) NAME . NAME = ( NAME if NAME is not None else ( NAME ( NAME , LIT , LIT ) if NAME else LIT ) # Reduced from 60.0 ) NAME . NAME = ( NAME if NAME is not None else ( NAME ( NAME , LIT , LIT ) if NAME else LIT ) # Reduced from 4.0 ) NAME . NAME = ( NAME if NAME is not None else LIT ) NAME . NAME = NAME . NAME NAME . NAME = False # Token Bucket parameters (capacity=burst_limit, fill_rate=requests_per_second) # OPTIMIZATION: Increased bucket capacity and refill rate for better throughput NAME . NAME = NAME ( NAME if NAME is not None else ( NAME ( NAME , LIT , LIT ) if NAME else LIT ) # Increased from 2.0 to 3.0 ) NAME . NAME = NAME ( NAME if NAME is not None else ( NAME ( NAME , LIT , LIT ) if NAME else LIT ) # Increased from 0.5 ) NAME . NAME = NAME . NAME ( ) if NAME . NAME <= LIT : NAME . NAME ( f\" Token fill rate ( { NAME . NAME } ) must be positive. Setting to 1.0. \" ) NAME . NAME = LIT # End of if NAME . NAME = NAME ( NAME . NAME ) NAME . NAME = NAME . NAME ( ) NAME . NAME ( f\" RateLimiter Init: Capacity= { NAME . NAME : .1f } , FillRate= { NAME . NAME : .1f } /s, InitialDelay= { NAME . NAME : .2f } s, MaxDelay= { NAME . NAME : .1f } s, Backoff= { NAME . NAME : .2f } , Decrease= { NAME . NAME : .2f } \" )"
    },
    {
      "module_path": "utils.py",
      "qualname": "DynamicRateLimiter._refill_tokens",
      "lineno": 1073,
      "end_lineno": 1078,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "f94066b9db033250a29e4e5bd4d433858fa102ea",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME ) -> None : NAME = NAME . NAME ( ) NAME = NAME ( LIT , NAME - NAME . NAME ) NAME = NAME * NAME . NAME NAME . NAME = NAME ( NAME . NAME , NAME . NAME + NAME ) NAME . NAME = NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "DynamicRateLimiter.wait",
      "lineno": 1082,
      "end_lineno": 1122,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 7,
      "loc": 41,
      "tags": [
        "pure-ish",
        "logging",
        "randomness",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "855012dc923f3018e99ecb1e9cc646cbeb96d10b",
      "simhash64": 7452080857216889875,
      "normalized": "def NAME ( NAME ) -> NAME : # Serialize token accounting to ensure correctness under concurrency with NAME . NAME : NAME . NAME ( ) NAME = LIT if NAME . NAME >= LIT : NAME . NAME -= LIT # Apply base delay even if token is available NAME = NAME . NAME ( LIT , LIT ) NAME = NAME . NAME NAME = NAME ( NAME * NAME , NAME . NAME ) NAME = NAME ( LIT , NAME ) # Ensure minimum sleep # OPTIMIZATION: Reduce logging verbosity - only log significant delays if NAME > LIT : # Only log delays over 2 seconds NAME . NAME ( f\" Token available ( { NAME . NAME : .2f } left). Applying base delay: { NAME : .3f } s (CurrentDelay: { NAME . NAME : .2f } s) \" ) else : # Token bucket empty, wait for a token to generate NAME = ( LIT - NAME . NAME ) / NAME . NAME NAME = NAME . NAME ( LIT , LIT ) # Small extra jitter NAME = NAME + NAME NAME = NAME ( NAME , NAME . NAME ) # Cap wait time NAME = NAME ( LIT , NAME ) # Ensure minimum sleep # OPTIMIZATION: Reduce token bucket logging verbosity if NAME > LIT : # Only log very significant waits (increased from 3.0s) NAME . NAME ( f\" Token bucket empty ( { NAME . NAME : .2f } ). Waiting for token: { NAME : .3f } s \" ) # End of with # Perform the sleep outside the lock if NAME > LIT : NAME . NAME ( NAME ) # After sleeping, do a quick refill under lock to update state with NAME . NAME : NAME . NAME ( ) return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "DynamicRateLimiter.reset_delay",
      "lineno": 1126,
      "end_lineno": 1133,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "e99105603232217e598bee96fe9902035819843f",
      "simhash64": 7452116591344792659,
      "normalized": "def NAME ( NAME ) -> None : if NAME . NAME != NAME . NAME : NAME . NAME ( f\" Rate limiter base delay reset from { NAME . NAME : .2f } s to initial: { NAME . NAME : .2f } s \" ) NAME . NAME = NAME . NAME # End of if NAME . NAME = False"
    },
    {
      "module_path": "utils.py",
      "qualname": "DynamicRateLimiter.decrease_delay",
      "lineno": 1137,
      "end_lineno": 1151,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "3c6195f0ede52e9bc8a2b3dc7b046db29842fc5c",
      "simhash64": 7488144838607938579,
      "normalized": "def NAME ( NAME ) -> None : if not NAME . NAME and NAME . NAME > NAME . NAME : NAME = NAME . NAME NAME . NAME = NAME ( NAME . NAME * NAME . NAME , NAME . NAME ) if ( NAME ( NAME - NAME . NAME ) > LIT ) : # Log only significant changes NAME . NAME ( f\" Decreased base delay component to { NAME . NAME : .2f } s \" ) # End of if # End of if NAME . NAME = False # Reset flag after successful operation"
    },
    {
      "module_path": "utils.py",
      "qualname": "DynamicRateLimiter.increase_delay",
      "lineno": 1155,
      "end_lineno": 1171,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "00f278ddf7bfc4e51d746dac573a9955c5b08993",
      "simhash64": 7452116041588974611,
      "normalized": "def NAME ( NAME ) -> None : NAME = NAME . NAME NAME . NAME = NAME ( NAME . NAME * NAME . NAME , NAME . NAME ) if ( NAME ( NAME - NAME . NAME ) > LIT ) : # Log only significant changes NAME . NAME ( f\" Rate limit feedback received. Increased base delay from { NAME : .2f } s to { NAME . NAME : .2f } s \" ) else : NAME . NAME ( f\" Rate limit feedback received, but delay already at max ( { NAME . NAME : .2f } s) or increase too small. \" ) # End of if/else NAME . NAME = True"
    },
    {
      "module_path": "utils.py",
      "qualname": "DynamicRateLimiter.is_throttled",
      "lineno": 1175,
      "end_lineno": 1176,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "c535505b83302f749df69716dfd6a90687463628",
      "simhash64": 7488145388363752531,
      "normalized": "def NAME ( NAME ) -> NAME : return NAME . NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "_prepare_base_headers",
      "lineno": 1196,
      "end_lineno": 1245,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 50,
      "tags": [
        "pure-ish",
        "json",
        "size:medium"
      ],
      "signature": "(method, api_description, referer_url, headers)",
      "fingerprint": "86a9ee784596ca180ba225e6d6f326742b5fbdc5",
      "simhash64": 7452151225962107923,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME [ NAME , NAME ] ] = None , ) -> NAME [ NAME , NAME ] : LIT NAME = NAME # Use new config system # Create base headers NAME : NAME [ NAME , NAME ] = { LIT : LIT , LIT : NAME or NAME . NAME . NAME , LIT : LIT , LIT : LIT , LIT : NAME . NAME ( ) , # Internal key for _prepare_api_headers } # Apply contextual headers from config NAME = NAME ( NAME . NAME , LIT , { } ) . NAME ( NAME , { } ) if NAME ( NAME , NAME ) : NAME . NAME ( { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None } ) else : NAME . NAME ( f\" [ { NAME } ] Expected dict for contextual headers, got { NAME ( NAME ) } \" ) # Apply explicit overrides if NAME : NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None } NAME . NAME ( NAME ) # End of if # End of if return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "_prepare_api_headers",
      "lineno": 1249,
      "end_lineno": 1368,
      "is_method": false,
      "is_async": false,
      "args_count": 10,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 22,
      "loc": 120,
      "tags": [
        "impure",
        "network",
        "randomness",
        "json",
        "size:large"
      ],
      "signature": "(session_manager, driver, api_description, base_headers, use_csrf_token, add_default_origin, use_enhanced_headers, tree_id, person_id, referer_url)",
      "fingerprint": "3d4c29bd018d9de8f266768c3494298df442934b",
      "simhash64": 7452151226028176403,
      "normalized": "def NAME ( NAME : NAME , # Assume available NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME , NAME : NAME , NAME : NAME = False , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME ( ) NAME = NAME # Use new config system NAME = False # Get User-Agent from browser if possible (skip session validation to prevent recursion) if NAME and NAME . NAME : # Simple driver check without session validation try : NAME = NAME . NAME ( LIT ) if NAME and NAME ( NAME , NAME ) : NAME [ LIT ] = NAME NAME = True # End of if except NAME : # type: ignore NAME . NAME ( f\" [ { NAME } ] WebDriver error getting User-Agent, using default. \" ) except NAME as NAME : NAME . NAME ( f\" [ { NAME } ] Error getting User-Agent: { NAME } , using default. \" ) # End of try/except # End of if # Fallback User-Agent if driver failed or wasn't available/valid if not NAME : NAME [ LIT ] = NAME . NAME ( NAME . NAME . NAME ) NAME . NAME ( f\" [ { NAME } ] Using default User-Agent: { NAME [ LIT ] } \" ) # End of if # Add Origin header for relevant methods NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) if NAME and NAME not in [ LIT , LIT , LIT ] : try : NAME = NAME ( NAME . NAME . NAME ) NAME = f\" { NAME . NAME } :// { NAME . NAME } \" NAME [ LIT ] = NAME except NAME as NAME : NAME . NAME ( f\" [ { NAME } ] Could not parse BASE_URL for Origin header: { NAME } \" ) # End of try/except # End of if # Skip dynamic header generation to prevent recursion during API requests # These headers are not essential for basic API functionality # Add CSRF token if requested and available if NAME : NAME = NAME . NAME if NAME : NAME = NAME # Handle potential JSON structure in token (legacy?) if NAME ( NAME , NAME ) and NAME . NAME ( ) . NAME ( LIT ) : try : NAME = NAME ( NAME ) NAME = NAME . NAME ( LIT , NAME ) except NAME . NAME : NAME . NAME ( f\" [ { NAME } ] CSRF token looks like JSON but failed to parse, using raw value. \" ) # End of try/except # End of if NAME [ LIT ] = NAME ( NAME ) # CRITICAL FIX: Use lowercase header name else : NAME . NAME ( f\" [ { NAME } ] CSRF token requested but not found in SessionManager. \" ) # End of if/else # End of if # Add User ID header (conditionally) NAME = { # Use set for faster lookup LIT , LIT , LIT , } if NAME . NAME and NAME not in NAME : NAME [ LIT ] = NAME . NAME . NAME ( ) elif NAME in NAME and NAME . NAME : NAME . NAME ( f\" [ { NAME } ] Omitting 'ancestry-userid' header as configured. \" ) # End of if/elif # Apply enhanced browser headers if requested if NAME : try : NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) NAME . NAME ( f\" [ { NAME } ] Applied enhanced browser headers \" ) except NAME as NAME : NAME . NAME ( f\" [ { NAME } ] Failed to apply enhanced headers: { NAME } \" ) # Remove any headers with None values (e.g., if dynamic generation failed) NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME is not None } # Remove internal _method key NAME . NAME ( LIT , None ) return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "_sync_cookies_for_request",
      "lineno": 1372,
      "end_lineno": 1413,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 7,
      "loc": 42,
      "tags": [
        "impure",
        "network",
        "size:medium"
      ],
      "signature": "(session_manager, driver, api_description, attempt)",
      "fingerprint": "63ffa7bb344e624e7bc48588bca6d96235eedb94",
      "simhash64": 7488316362421867571,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME = LIT , ) -> NAME : LIT # Check driver validity for dynamic headers/cookies (avoid is_sess_valid() to prevent recursion) NAME = NAME and NAME . NAME if not NAME : if NAME == LIT : # Only log on first attempt NAME . NAME ( f\" [ { NAME } ] Browser session invalid or driver None (Attempt { NAME } ). Dynamic headers might be incomplete/stale. \" ) return False # Use smart cookie syncing that only syncs once per session try : # Check if cookies are already synced for this session if NAME ( NAME , LIT ) and NAME . NAME : # Cookies already synced, no need to sync again return True # Use the session manager's smart sync method NAME . NAME ( ) return True except NAME as NAME : NAME . NAME ( f\" [ { NAME } ] Exception during cookie sync (Attempt { NAME } ): { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "_apply_rate_limiting",
      "lineno": 1417,
      "end_lineno": 1489,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 12,
      "loc": 73,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(session_manager, api_description, attempt)",
      "fingerprint": "25bda3fe5d16941fcff775ac83eef5b5b779e158",
      "simhash64": 7452221594706293779,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME = LIT , ) -> NAME : LIT import NAME # OPTIMIZATION: Cache rate limit calculations to reduce per-request overhead NAME = f\" { NAME } _ { NAME } \" NAME = NAME . NAME ( ) # Initialize cache if it doesn't exist if not NAME ( NAME , LIT ) : NAME . NAME = { } NAME . NAME = NAME # Check if we have a cached result within the last 0.5 seconds NAME = NAME . NAME . NAME ( NAME ) if NAME and ( NAME - NAME [ LIT ] ) < LIT : return NAME [ LIT ] # Clean up old cache entries periodically if ( NAME - NAME . NAME ) > LIT : NAME = NAME - LIT # Keep entries from last 5 seconds NAME . NAME = { NAME : NAME for NAME , NAME in NAME . NAME . NAME ( ) if NAME [ LIT ] > NAME } NAME . NAME = NAME # Use both rate limiters - take the maximum delay for safety NAME = NAME . NAME . NAME ( ) if NAME . NAME else LIT NAME = LIT # Use adaptive rate limiter if available (with error handling for performance) if NAME ( NAME , LIT ) and NAME . NAME : try : NAME = NAME . NAME . NAME ( ) except NAME : # Silently ignore adaptive rate limiter errors to improve performance NAME = LIT # Take the maximum wait time from both systems for safety NAME = NAME ( NAME , NAME ) # Cache the result NAME . NAME [ NAME ] = { LIT : NAME , LIT : NAME } # OPTIMIZATION: Reduce rate limit logging verbosity - only log significant waits if NAME > LIT : # Only log waits over 2 seconds (increased from 0.1s) NAME . NAME ( f\" [ { NAME } ] Rate limit wait: { NAME : .2f } s (Dynamic: { NAME : .2f } s, Adaptive: { NAME : .2f } s) (Attempt { NAME } ) \" ) elif NAME > LIT and NAME < NAME and NAME > LIT : # Only log optimization when wait is significant (reduced log spam) NAME . NAME ( f\" \u26a1 Adaptive rate limiter optimizing: { NAME : .2f } s vs { NAME : .2f } s \" ) return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "_record_adaptive_response",
      "lineno": 1493,
      "end_lineno": 1532,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 9,
      "loc": 40,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(session_manager, success, response_time, status_code, error_type)",
      "fingerprint": "e4231c59f3ff50deaab72219a06ad66a11fd9784",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None ) -> None : LIT if NAME ( NAME , LIT ) and NAME . NAME : try : NAME . NAME . NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) except NAME as NAME : NAME . NAME ( f\" Failed to record adaptive response: { NAME } \" ) # === HEALTH MONITORING: Record API response time === if NAME ( NAME , LIT ) and NAME . NAME : try : NAME . NAME . NAME ( NAME ) # Record errors if request failed if not NAME : NAME = NAME or LIT NAME . NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Health monitoring API tracking: { NAME } \" )"
    },
    {
      "module_path": "utils.py",
      "qualname": "_log_request_details",
      "lineno": 1536,
      "end_lineno": 1580,
      "is_method": false,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 45,
      "tags": [
        "pure-ish",
        "logging",
        "size:medium"
      ],
      "signature": "(api_description, attempt, http_method, url, headers, data, _json_data)",
      "fingerprint": "e65cca64c61266b8f7f62d611f320a2ee747cd9e",
      "simhash64": 7452291964524205075,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , ) -> None : LIT # Mask sensitive headers for logging NAME = { } NAME = { LIT , LIT , LIT , LIT , LIT , LIT , LIT , } for NAME , NAME in NAME . NAME ( ) : # Ensure value is string for processing NAME = NAME ( NAME ) if NAME . NAME ( ) in NAME and NAME and NAME ( NAME ) > LIT : NAME [ NAME ] = NAME [ : LIT ] + LIT + NAME [ - LIT : ] else : NAME [ NAME ] = NAME # End of if/else # End of for # Minimal request logging to reduce noise if NAME > LIT : # Only log retries NAME . NAME ( f\" \ud83c\udf10 { NAME } : { NAME } { NAME } (attempt { NAME } ) \" )"
    },
    {
      "module_path": "utils.py",
      "qualname": "_generate_ancestry_context_ube",
      "lineno": 1584,
      "end_lineno": 1628,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 45,
      "tags": [
        "pure-ish",
        "logging",
        "json",
        "size:medium"
      ],
      "signature": "(session_manager, tree_id, person_id)",
      "fingerprint": "e4d3518ec9ab98dad045dc8bbf339dc32d750a54",
      "simhash64": 7451729014570783787,
      "normalized": "def NAME ( NAME : LIT , NAME : NAME , NAME : NAME ) -> NAME [ NAME ] : LIT try : # Generate a session ID if we don't have one NAME = NAME ( NAME , LIT , None ) if not NAME : NAME = NAME ( NAME . NAME ( ) ) # Create context data structure similar to the browser NAME = { LIT : LIT , LIT : NAME ( NAME . NAME ( ) ) , LIT : NAME , LIT : LIT , LIT : f\" ancestry uk : family-tree : person : tree : { NAME } : person : { NAME } : facts \" , LIT : LIT , LIT : LIT , LIT : NAME . NAME ( { LIT : { LIT : LIT , LIT : LIT } } ) } # Convert to JSON and encode NAME = NAME . NAME ( NAME ) return NAME . NAME ( NAME . NAME ( LIT ) ) . NAME ( LIT ) # Consolidated logging - reduced verbosity except NAME as NAME : NAME . NAME ( f\" Failed to generate ancestry context: { NAME } \" ) return None"
    },
    {
      "module_path": "utils.py",
      "qualname": "_add_enhanced_browser_headers",
      "lineno": 1632,
      "end_lineno": 1722,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 10,
      "loc": 91,
      "tags": [
        "pure-ish",
        "time",
        "json",
        "size:medium"
      ],
      "signature": "(headers, session_manager, tree_id, person_id, referer_url)",
      "fingerprint": "8aae1a1318130cdd4412c83cef0fea71e603f9fc",
      "simhash64": 7451729014636844075,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : LIT , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME ( ) try : # Add comprehensive browser headers NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } ) # Add referer if provided if NAME : NAME [ LIT ] = NAME # Add ancestry context if tree_id and person_id are available if NAME and NAME : try : NAME = NAME ( NAME , NAME , NAME ) if NAME : NAME [ LIT ] = NAME except NAME as NAME : NAME . NAME ( f\" Could not generate ancestry context: { NAME } \" ) # Add tracing headers for better compatibility try : NAME = NAME ( NAME . NAME ( ) ) . NAME ( LIT , LIT ) NAME = NAME ( NAME . NAME ( ) ) . NAME ( LIT , LIT ) [ : LIT ] NAME [ LIT ] = f\" 00- { NAME } - { NAME } -01 \" NAME [ LIT ] = f\" 2611750@nr=0-1-1690570-1588686754- { NAME } ---- { NAME ( NAME . NAME ( ) . NAME ( ) * LIT ) } \" except NAME as NAME : NAME . NAME ( f\" Could not generate tracing headers: { NAME } \" ) # Add NewRelic header for better compatibility try : NAME = { LIT : [ LIT , LIT ] , LIT : { LIT : LIT , LIT : LIT , LIT : LIT , LIT : NAME , LIT : NAME , LIT : NAME ( NAME . NAME ( ) . NAME ( ) * LIT ) , LIT : LIT } } NAME = NAME . NAME ( NAME . NAME ( NAME ) . NAME ( LIT ) ) . NAME ( LIT ) NAME [ LIT ] = NAME except NAME as NAME : NAME . NAME ( f\" Could not generate NewRelic header: { NAME } \" ) # Reduced verbosity: Only log header enhancement at INFO level for important calls if NAME ( NAME ) - NAME ( NAME ) > LIT : # Only log when significant enhancement NAME . NAME ( f\" Enhanced headers with { NAME ( NAME ) - NAME ( NAME ) } additional browser-like headers \" ) except NAME as NAME : NAME . NAME ( f\" Failed to add enhanced browser headers: { NAME } \" ) return NAME # Return original headers if enhancement fails return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "_prepare_api_request",
      "lineno": 1726,
      "end_lineno": 1856,
      "is_method": false,
      "is_async": false,
      "args_count": 16,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 131,
      "tags": [
        "impure",
        "network",
        "json",
        "size:large"
      ],
      "signature": "(session_manager, driver, url, method, api_description, attempt, headers, referer_url, use_csrf_token, add_default_origin, timeout, cookie_jar, allow_redirects, data, json_data, json)",
      "fingerprint": "c209feb6ffc2baa83d950f131d5f50a004e25af3",
      "simhash64": 7488250391724200979,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME [ NAME ] = None , NAME : NAME = True , NAME : NAME = True , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , # type: ignore NAME : NAME = True , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME # Use new config system # Prepare base headers NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) # Prepare request details NAME = NAME if NAME is not None else NAME . NAME NAME = NAME . NAME NAME = NAME if NAME is not None else NAME . NAME NAME = NAME . NAME ( ) # Handle specific API quirks (e.g., allow_redirects) NAME = NAME # Note: Match List API should allow redirects (as it did in working version from 2 months ago) # Sync cookies NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) # Check for enhanced headers flags in the headers parameter NAME = False NAME = None NAME = None NAME = NAME if NAME : NAME = NAME . NAME ( LIT ) == LIT NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) # Remove internal flags from headers NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if not NAME . NAME ( LIT ) } NAME . NAME ( NAME ) # Generate final headers NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) # Apply rate limiting NAME ( NAME = NAME , NAME = NAME , NAME = NAME , ) # Use json parameter if provided, otherwise use json_data NAME = NAME if NAME is not None else NAME # Log request details NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) # Return all prepared request parameters return { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , # Use 'json' for requests.request, not 'json_data' LIT : NAME , LIT : True , # Standard verification LIT : NAME , LIT : NAME , }"
    },
    {
      "module_path": "utils.py",
      "qualname": "_execute_api_request",
      "lineno": 1860,
      "end_lineno": 1905,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 46,
      "tags": [
        "impure",
        "network",
        "size:medium"
      ],
      "signature": "(session_manager, api_description, request_params, attempt)",
      "fingerprint": "ee3eea14a26316467ed1fe834dfeda4b167fbef8",
      "simhash64": 7488250391725257747,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME = LIT , ) -> NAME : LIT NAME = NAME . NAME try : # Execute the request NAME = NAME . NAME ( ** NAME ) # OPTIMIZATION: Log consolidated response details only for non-success or slow requests NAME = NAME . NAME NAME = NAME . NAME # Only log if not successful (non-2xx) to reduce log noise if NAME < LIT or NAME >= LIT : NAME . NAME ( f\" \ud83c\udf10 { NAME } request completed: { NAME } { NAME } \" ) # Success responses are logged at INFO level in _process_response if needed return NAME except NAME as NAME : # type: ignore NAME . NAME ( f\" [_api_req Attempt { NAME } ' { NAME } '] RequestException: { NAME ( NAME ) . NAME } - { NAME } \" ) return None except NAME as NAME : NAME . NAME ( f\" { NAME } : CRITICAL Unexpected error during request attempt { NAME } : { NAME } \" , NAME = True , ) return None"
    },
    {
      "module_path": "utils.py",
      "qualname": "_process_api_response",
      "lineno": 1909,
      "end_lineno": 1974,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 9,
      "loc": 66,
      "tags": [
        "pure-ish",
        "json",
        "size:medium"
      ],
      "signature": "(response, api_description, force_text_response)",
      "fingerprint": "bcec6ba606d8436ec9c0f2a9079fefa1cee0b19d",
      "simhash64": 7452186410334196755,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME = False , ) -> NAME : LIT if NAME is None : return None # Get status code and reason NAME = NAME . NAME # Handle successful responses (2xx) if NAME . NAME : # Force text response if requested if NAME : NAME . NAME ( f\" { NAME } : Force text response requested. \" ) return NAME . NAME # Process based on content type NAME = NAME . NAME . NAME ( LIT , LIT ) . NAME ( ) if LIT in NAME : try : # Handle empty response body for JSON return NAME . NAME ( ) if NAME . NAME else None except NAME as NAME : # type: ignore NAME . NAME ( f\" { NAME } : OK ( { NAME } ), but JSON decode FAILED: { NAME } \" ) with NAME . NAME ( NAME ) : NAME . NAME ( f\" << Response Text (JSON Error): { NAME . NAME [ : LIT ] } ... \" ) # End of try/except # Return None because caller expected JSON but didn't get it return None # End of try/except elif NAME == LIT and LIT in NAME : NAME = NAME . NAME . NAME ( ) NAME . NAME ( f\" { NAME } : Received text/plain as expected for CSRF. \" ) return NAME if NAME else None else : NAME . NAME ( f\" { NAME } : OK ( { NAME } ), Content-Type ' { NAME } '. Returning raw TEXT. \" ) return NAME . NAME # End of if/elif/else content_type # End of if response.ok # For non-successful responses, return the response object itself # This allows the caller to handle specific error cases return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "_api_req",
      "lineno": 1978,
      "end_lineno": 2321,
      "is_method": false,
      "is_async": false,
      "args_count": 17,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 13,
      "yield_count": 0,
      "complexity": 36,
      "loc": 344,
      "tags": [
        "impure",
        "network",
        "logging",
        "randomness",
        "time",
        "json",
        "size:large"
      ],
      "signature": "(url, driver, session_manager, method, data, json_data, json, use_csrf_token, headers, referer_url, api_description, timeout, cookie_jar, allow_redirects, force_text_response, add_default_origin, redirect_count)",
      "fingerprint": "40d91cce7414f831702591881ac7d9ee40ca3285",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME , # type: ignore NAME : NAME = LIT , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME = True , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME [ NAME ] = None , NAME : NAME = LIT , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , # type: ignore NAME : NAME = True , NAME : NAME = False , NAME : NAME = True , NAME : NAME = LIT , ) -> NAME [ NAME , NAME ] : LIT # --- Step 1: Validate prerequisites --- if not NAME or not NAME . NAME : NAME . NAME ( f\" { NAME } : Aborting - SessionManager or internal requests_session missing. \" ) return None # End of if if not NAME : NAME . NAME ( f\" { NAME } : Aborting - Config schema not loaded. \" ) return None # End of if NAME = NAME . NAME # --- Step 2: Get Retry Configuration --- NAME = NAME . NAME NAME = NAME . NAME NAME = NAME . NAME NAME = NAME . NAME NAME = NAME ( NAME . NAME ) # --- Step 3: Execute Request with Retry Loop --- NAME = NAME NAME : NAME [ NAME ] = None NAME : NAME = None NAME = NAME while NAME > LIT : NAME = NAME - NAME + LIT try : # --- Step 3.1: Prepare the request --- NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , # Pass the json parameter if provided ) # --- Step 3.2: Execute the request --- NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ) # If request failed with an exception, response will be None if NAME is None : NAME -= LIT if NAME <= LIT : NAME . NAME ( f\" { NAME } : Request failed after { NAME } attempts. \" ) return None NAME = NAME ( NAME * ( NAME ** ( NAME - LIT ) ) , NAME ) + NAME . NAME ( LIT , LIT ) NAME = NAME ( LIT , NAME ) NAME . NAME ( f\" { NAME } : Request error (Attempt { NAME } / { NAME } ). Retrying in { NAME : .2f } s... \" ) NAME . NAME ( NAME ) NAME *= NAME continue # Go to next iteration of the while loop # End of if/else retries_left # End of if response is None # --- Step 3.3: Check for retryable status codes --- NAME = NAME . NAME NAME = NAME . NAME if NAME in NAME : NAME -= LIT NAME . NAME ( f\" [_api_req Attempt { NAME } ' { NAME } '] Received retryable status: { NAME } { NAME } \" ) NAME = NAME ( f\" { NAME } Error \" , NAME = NAME ) # type: ignore if NAME <= LIT : NAME . NAME ( f\" { NAME } : Failed after { NAME } attempts (Final Status { NAME } ). Returning Response object. \" ) with NAME . NAME ( NAME ) : NAME . NAME ( f\" << Final Response Text (Retry Fail): { NAME . NAME [ : LIT ] } ... \" ) # End of try/except return NAME NAME = NAME ( NAME * ( NAME ** ( NAME - LIT ) ) , NAME ) + NAME . NAME ( LIT , LIT ) NAME = NAME ( LIT , NAME ) # Handle rate limiting feedback if NAME == LIT : # Too Many Requests if NAME . NAME : NAME . NAME . NAME ( ) # Record rate limit error for adaptive learning NAME ( NAME = NAME , NAME = False , NAME = LIT , # Approximate - we know it was slow NAME = NAME , NAME = LIT ) else : # Record other failure types for adaptive learning NAME ( NAME = NAME , NAME = False , NAME = LIT , # Approximate response time NAME = NAME , NAME = f\" http_error_ { NAME } \" ) # End of if/else status == 429 NAME . NAME ( f\" { NAME } : Status { NAME } (Attempt { NAME } / { NAME } ). Retrying in { NAME : .2f } s... \" ) with NAME . NAME ( NAME ) : NAME . NAME ( f\" << Response Text (Retry): { NAME . NAME [ : LIT ] } ... \" ) # End of try/except NAME . NAME ( NAME ) NAME *= NAME continue # Go to next iteration of the while loop # End of if/else retries_left # End of if status in retry_status_codes # --- Step 3.4: Handle redirects --- # Handle redirects if allow_redirects is False if LIT <= NAME < LIT and not NAME [ LIT ] : NAME . NAME ( f\" { NAME } : Status { NAME } { NAME } (Redirects Disabled). Returning Response object. \" ) NAME . NAME ( f\" << Redirect Location: { NAME . NAME . NAME ( LIT ) } \" ) return NAME # End of if # Generalized manual redirect handling for all 3xx codes if LIT <= NAME < LIT and NAME [ LIT ] : NAME = NAME . NAME . NAME ( LIT ) NAME = NAME ( NAME , LIT , LIT ) if NAME and NAME < LIT : NAME . NAME ( f\" { NAME } : Received { NAME } { NAME } . Following redirect to { NAME } . (Redirect { NAME + LIT } /5) \" ) # Switch to GET for 301, 302, 303 if original method is POST/PUT NAME = NAME if NAME in [ LIT , LIT , LIT ] and NAME . NAME ( ) in [ LIT , LIT ] : NAME = LIT NAME . NAME ( f\" Switching method to GET for redirect status { NAME } . \" ) # Preserve headers/cookies NAME = NAME ( NAME ) if NAME else None # Add diagnostics for redirect chain/history NAME . NAME ( f\" Redirect chain: { NAME } -> { NAME } \" ) # Pass redirect_count to prevent infinite loop return NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = None if NAME == LIT else NAME , NAME = None if NAME == LIT else NAME , NAME = None if NAME == LIT else NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME + f\" (redirected { NAME + LIT } ) \" , NAME = NAME , NAME = NAME , NAME = False , # Prevent further recursion NAME = NAME , NAME = NAME , # Custom param to track redirect count NAME = NAME + LIT , ) NAME . NAME ( f\" { NAME } : Unexpected final status { NAME } { NAME } (Redirects Enabled). Returning Response object. \" ) NAME . NAME ( f\" << Redirect Location: { NAME } \" ) return NAME # End of if # --- Step 3.5: Handle non-retryable error status codes --- if not NAME . NAME : # For login verification API, use debug level for 401/403 errors if ( NAME == LIT and NAME in [ LIT , LIT ] ) : NAME . NAME ( f\" [_api_req Attempt { NAME } ' { NAME } '] Received expected status: { NAME } { NAME } \" ) else : NAME . NAME ( f\" [_api_req Attempt { NAME } ' { NAME } '] Received NON-retryable error status: { NAME } { NAME } \" ) if NAME in [ LIT , LIT ] : # For login verification API, don't log a warning as this is expected when not logged in if NAME == LIT : NAME . NAME ( f\" { NAME } : API call returned { NAME } { NAME } . User not logged in. \" ) else : NAME . NAME ( f\" { NAME } : API call failed { NAME } { NAME } . Session expired/invalid? \" ) NAME . NAME = False # Mark session as not ready else : NAME . NAME ( f\" { NAME } : Non-retryable error: { NAME } { NAME } . \" ) # Log error response only for non-auth errors and if response has useful content if NAME not in [ LIT , LIT , LIT ] and NAME ( NAME , LIT ) : try : NAME = NAME . NAME [ : LIT ] if NAME . NAME ( ) and not NAME . NAME ( LIT ) : # Skip HTML error pages NAME . NAME ( f\" << Error Response: { NAME } ... \" ) except NAME : pass return NAME # Return the Response object for the caller to handle # End of if not response.ok # --- Step 3.6: Process successful response --- if NAME . NAME : # Update DynamicRateLimiter (existing system) if NAME . NAME : NAME . NAME . NAME ( ) # Success, decrease future delay # Record success for adaptive learning NAME ( NAME = NAME , NAME = True , NAME = LIT , # Approximate - successful responses are generally fast NAME = NAME . NAME ) # Process the response return NAME ( NAME = NAME , NAME = NAME , NAME = NAME , ) # End of if response.ok # --- Handle exceptions during the request attempt --- except NAME as NAME : # type: ignore NAME . NAME ( f\" [_api_req Attempt { NAME } ' { NAME } '] RequestException: { NAME ( NAME ) . NAME } - { NAME } \" ) NAME -= LIT NAME = NAME if NAME <= LIT : NAME . NAME ( f\" { NAME } : Request failed after { NAME } attempts. Final Error: { NAME } \" , NAME = False , ) return None # Return None after all retries fail for network errors NAME = NAME ( NAME * ( NAME ** ( NAME - LIT ) ) , NAME ) + NAME . NAME ( LIT , LIT ) NAME = NAME ( LIT , NAME ) NAME . NAME ( f\" { NAME } : { NAME ( NAME ) . NAME } (Attempt { NAME } / { NAME } ). Retrying in { NAME : .2f } s... Error: { NAME } \" ) NAME . NAME ( NAME ) NAME *= NAME continue # Go to next attempt # End of if/else retries_left except NAME as NAME : NAME . NAME ( f\" { NAME } : CRITICAL Unexpected error during request attempt { NAME } : { NAME } \" , NAME = True , ) return None # Return None on unexpected errors within the loop # End of try/except block for request attempt # If we get here, the request was successful and processed break # Exit the retry loop # End of while retries_left > 0 # --- Diagnostic Log: Function Exit --- NAME . NAME ( f\" [_api_req EXIT] api_description: ' { NAME } ', attempts: { NAME - NAME + LIT } / { NAME } \" ) # --- Should only be reached if loop completes without success (e.g., retries exhausted) --- if NAME is None : NAME . NAME ( f\" { NAME } : Exited retry loop. Last Exception: { NAME } . \" ) return None # End of if # Return the last response (this should be a non-retryable error response) NAME . NAME ( f\" [_api_req ' { NAME } '] Returning last Response object (Status: { NAME . NAME } ). \" ) return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "make_ube",
      "lineno": 2325,
      "end_lineno": 2396,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 8,
      "yield_count": 0,
      "complexity": 11,
      "loc": 72,
      "tags": [
        "pure-ish",
        "json",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(driver)",
      "fingerprint": "e1eef203df40d4ea4a9ee564d8e5acc279bd38f2",
      "simhash64": 7488320760469427227,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : if not NAME : return None # End of if try : NAME = NAME . NAME # Quick check for session validity except NAME as NAME : # type: ignore NAME . NAME ( f\" Cannot generate UBE header: Session invalid/unresponsive ( { NAME ( NAME ) . NAME } ). \" ) return None # End of try/except NAME : NAME [ NAME ] = None try : # Try fetching specific cookie first NAME = NAME . NAME ( LIT ) if NAME and NAME ( NAME , NAME ) and LIT in NAME : NAME = NAME [ LIT ] elif NAME is None : # Fallback to getting all cookies if specific fails NAME = { NAME [ LIT ] : NAME [ LIT ] for NAME in NAME . NAME ( ) if NAME ( NAME , NAME ) and LIT in NAME } NAME = NAME . NAME ( LIT ) # End of if/elif if not NAME : NAME . NAME ( LIT ) return None # End of if except ( NAME , NAME ) as NAME : # type: ignore NAME . NAME ( f\" Error getting ANCSESSIONID cookie for UBE header: { NAME } \" ) return None except NAME as NAME : NAME . NAME ( f\" Unexpected error getting ANCSESSIONID for UBE: { NAME } \" , NAME = True ) return None # End of try/except # Construct UBE data payload NAME = ( LIT # Typically zero GUID for this header ) NAME = NAME ( NAME . NAME ( ) ) # Unique ID for this interaction NAME = ( LIT # Example ) NAME = LIT # Example NAME = LIT # Example consent string NAME = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : LIT , # Example LIT : LIT , # Usually empty JSON string } # Encode the payload try : NAME = NAME ( NAME ) . NAME ( LIT ) return NAME . NAME ( NAME ) . NAME ( LIT ) except ( NAME . NAME , NAME , NAME . NAME ) as NAME : NAME . NAME ( f\" Error encoding UBE header data: { NAME } \" , NAME = True ) return None except NAME as NAME : NAME . NAME ( f\" Unexpected error encoding UBE header: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "utils.py",
      "qualname": "make_newrelic",
      "lineno": 2401,
      "end_lineno": 2432,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 32,
      "tags": [
        "pure-ish",
        "time",
        "json",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(_driver)",
      "fingerprint": "3f207bbb3f6633f16494a6df7a6f3bd4a7b4e277",
      "simhash64": 7452291963516523567,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : # This function generates a plausible NewRelic header structure. # Exact values might vary, but the format is generally consistent. # The driver argument is kept for potential future use but isn't strictly needed now. try : NAME = NAME . NAME ( ) . NAME [ : LIT ] # Shorter trace ID part NAME = NAME . NAME ( ) . NAME [ : LIT ] # Span ID # These IDs seem static or tied to Ancestry's NewRelic account/app NAME = LIT NAME = LIT NAME = LIT # Obfuscated/partial license key part NAME = { LIT : [ LIT , LIT ] , # Version info LIT : { LIT : LIT , # Type LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME ( NAME . NAME ( ) * LIT ) , # Timestamp in ms LIT : NAME , } , } NAME = NAME ( NAME ) . NAME ( LIT ) return NAME . NAME ( NAME ) . NAME ( LIT ) except ( NAME . NAME , NAME , NAME . NAME ) as NAME : NAME . NAME ( f\" Error generating NewRelic header: { NAME } \" , NAME = True ) return None except NAME as NAME : NAME . NAME ( f\" Unexpected error generating NewRelic header: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "utils.py",
      "qualname": "make_traceparent",
      "lineno": 2437,
      "end_lineno": 2448,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(_driver)",
      "fingerprint": "f71c11169d506624348724905ab26bf1582120c4",
      "simhash64": 7452080857217938451,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : # Generates a W3C Trace Context traceparent header. # Driver argument kept for consistency, not currently used. try : NAME = LIT # Standard version NAME = NAME . NAME ( ) . NAME # Full 32-char trace ID NAME = NAME . NAME ( ) . NAME [ : LIT ] # 16-char parent/span ID NAME = LIT # Sampled flag (usually 01) return f\" { NAME } - { NAME } - { NAME } - { NAME } \" except NAME as NAME : NAME . NAME ( f\" Error generating traceparent header: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "utils.py",
      "qualname": "make_tracestate",
      "lineno": 2453,
      "end_lineno": 2468,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(_driver)",
      "fingerprint": "95479bfee7d6262eeb698ac50d71964a45fa1406",
      "simhash64": 7452221594706285619,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : # Generates a tracestate header, often including NewRelic state. # Driver argument kept for consistency, not currently used. try : # NewRelic specific part of tracestate NAME = LIT # Corresponds to license key part in newrelic header NAME = LIT NAME = LIT NAME = NAME . NAME ( ) . NAME [ : LIT ] # Another span ID NAME = NAME ( NAME . NAME ( ) * LIT ) # Format follows NewRelic's tracestate structure return f\" { NAME } @nr=0-1- { NAME } - { NAME } - { NAME } ---- { NAME } \" # Other vendors could potentially be added, comma-separated except NAME as NAME : NAME . NAME ( f\" Error generating tracestate header: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "utils.py",
      "qualname": "handle_twofa",
      "lineno": 2479,
      "end_lineno": 2661,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 9,
      "yield_count": 0,
      "complexity": 14,
      "loc": 183,
      "tags": [
        "impure",
        "network",
        "logging",
        "time",
        "size:large"
      ],
      "signature": "(session_manager)",
      "fingerprint": "6025e403a058b3cab0da5099d99632a37f8264dc",
      "simhash64": 7488215207890039863,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : # type: ignore if NAME . NAME is None : NAME . NAME ( LIT ) return False # End of if NAME = NAME . NAME NAME = NAME ( NAME , NAME . NAME . NAME ) NAME ( NAME , NAME . NAME . NAME ) NAME = NAME ( NAME , NAME . NAME . NAME ) try : NAME ( LIT ) NAME . NAME ( LIT ) try : NAME . NAME ( f\" Waiting for 2FA page header using selector: ' { NAME } ' \" ) NAME . NAME ( NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME . NAME ( LIT ) except NAME : # type: ignore NAME . NAME ( LIT ) if ( NAME ( NAME , NAME = True ) is True ) : # API check only for speed NAME . NAME ( LIT ) return True # End of if NAME . NAME ( LIT ) return False # Return False if 2FA page wasn't detected and not logged in except NAME as NAME : # type: ignore NAME . NAME ( f\" WebDriverException waiting for 2FA header: { NAME } \" ) return False # End of try/except # Try clicking SMS button try : NAME . NAME ( f\" Waiting for 2FA 'Send Code' (SMS) button: ' { NAME } ' \" ) # type: ignore NAME = NAME . NAME ( NAME . NAME ( ( NAME . NAME , NAME ) ) # type: ignore ) if NAME : NAME . NAME ( LIT ) try : NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT ) # Wait briefly for code input field to potentially appear try : NAME . NAME ( f\" Waiting for 2FA code input field: ' { NAME } ' \" ) # type: ignore NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME . NAME ( LIT ) except NAME : # type: ignore NAME . NAME ( LIT ) except NAME as NAME : # type: ignore NAME . NAME ( f\" Error waiting for 2FA code input field: { NAME } . Check selector: { NAME } \" ) # type: ignore # End of inner try/except except NAME as NAME : # type: ignore NAME . NAME ( f\" Error clicking 'Send Code' button via JS: { NAME } \" ) # Don't return False yet, proceed to wait for manual entry # End of try/except else : # This case should be rare if element_to_be_clickable succeeded NAME . NAME ( LIT ) # Proceed to wait for manual entry anyway # End of if/else sms_button_clickable except NAME : # type: ignore NAME . NAME ( LIT ) # Proceed to wait for manual entry except NAME : # type: ignore NAME . NAME ( LIT ) # Proceed to wait for manual entry except NAME as NAME : # type: ignore NAME . NAME ( f\" WebDriverException interacting with 2FA 'Send Code' button: { NAME } \" , NAME = False , ) # Proceed to wait for manual entry except NAME as NAME : NAME . NAME ( f\" Unexpected error clicking 2FA 'Send Code' button: { NAME } \" , NAME = True ) # Proceed to wait for manual entry # End of try/except block for clicking SMS button # Wait for user action (manual code entry and submission) NAME = NAME . NAME . NAME NAME . NAME ( f\" Waiting up to { NAME } s for user to manually enter 2FA code and submit... \" ) NAME = NAME . NAME ( ) NAME = False while NAME . NAME ( ) - NAME < NAME : try : # Check if the 2FA header is GONE (indicates page change/submission) NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME . NAME ( LIT ) NAME = True break # Exit wait loop except NAME : # type: ignore # Header still present, continue waiting NAME . NAME ( LIT ) # Check every 2 seconds except NAME : # type: ignore # Header element gone, assume submitted NAME . NAME ( LIT ) NAME = True break # Exit wait loop except NAME as NAME : # type: ignore # Handle potential errors during the check NAME . NAME ( f\" WebDriver error checking for 2FA header during wait: { NAME } \" ) # If session dies here, login_status check later will fail break # Exit wait loop on error except NAME as NAME : NAME . NAME ( f\" Unexpected error checking for 2FA header during wait: { NAME } \" ) break # Exit wait loop on error # End of try/except # End of while loop # Final check after waiting if NAME : NAME . NAME ( LIT ) NAME . NAME ( LIT ) # Allow page to settle NAME = NAME ( NAME , NAME = False ) # Use UI fallback for reliability if NAME is True : NAME . NAME ( LIT ) return True NAME . NAME ( LIT ) return False # End of if/else NAME . NAME ( f\" Timed out ( { NAME } s) waiting for user 2FA action (page did not change). \" ) return False # End of if/else user_action_detected except NAME as NAME : # type: ignore NAME . NAME ( f\" WebDriverException during 2FA handling: { NAME } \" ) if not NAME ( NAME ) : NAME . NAME ( LIT ) # End of if return False except NAME as NAME : NAME . NAME ( f\" Unexpected error during 2FA handling: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "enter_creds",
      "lineno": 2669,
      "end_lineno": 2845,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 9,
      "yield_count": 0,
      "complexity": 15,
      "loc": 177,
      "tags": [
        "impure",
        "network",
        "randomness",
        "time",
        "size:large"
      ],
      "signature": "(driver)",
      "fingerprint": "79f97b384de0a4980d23aea2857270a9666560a4",
      "simhash64": 7488215207888991291,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : # type: ignore NAME = NAME ( NAME , NAME . NAME . NAME ) NAME = NAME ( NAME , LIT ) # Short wait for quick checks NAME . NAME ( NAME . NAME ( LIT , LIT ) ) # Small random wait try : NAME . NAME ( LIT ) # --- Username --- NAME . NAME ( f\" Waiting for username input: ' { NAME } '... \" ) # type: ignore NAME = NAME . NAME ( NAME . NAME ( ( NAME . NAME , NAME ) ) # type: ignore ) NAME . NAME ( LIT ) try : # Attempt to clear field robustly NAME . NAME ( ) NAME . NAME ( LIT ) NAME . NAME ( ) NAME . NAME ( LIT ) # JS clear as fallback/additional measure NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT ) except ( NAME , NAME ) as NAME : # type: ignore NAME . NAME ( f\" Issue clicking/clearing username field ( { NAME ( NAME ) . NAME } ). Proceeding cautiously. \" ) except NAME as NAME : # type: ignore NAME . NAME ( f\" WebDriverException clicking/clearing username: { NAME } . Aborting. \" ) return False # End of try/except # Check config value exists NAME = NAME . NAME . NAME if not NAME : raise NAME ( LIT ) # End of if NAME . NAME ( LIT ) NAME . NAME ( NAME ) NAME . NAME ( LIT ) NAME . NAME ( NAME . NAME ( LIT , LIT ) ) # --- Password --- NAME . NAME ( f\" Waiting for password input: ' { NAME } '... \" ) # type: ignore NAME = NAME . NAME ( NAME . NAME ( ( NAME . NAME , NAME ) ) # type: ignore ) NAME . NAME ( LIT ) try : # Attempt to clear field robustly NAME . NAME ( ) NAME . NAME ( LIT ) NAME . NAME ( ) NAME . NAME ( LIT ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT ) except ( NAME , NAME ) as NAME : # type: ignore NAME . NAME ( f\" Issue clicking/clearing password field ( { NAME ( NAME ) . NAME } ). Proceeding cautiously. \" ) except NAME as NAME : # type: ignore NAME . NAME ( f\" WebDriverException clicking/clearing password: { NAME } . Aborting. \" ) return False # End of try/except # Check config value exists NAME = NAME . NAME . NAME if not NAME : raise NAME ( LIT ) # End of if NAME . NAME ( LIT ) NAME . NAME ( NAME ) NAME . NAME ( LIT ) NAME . NAME ( NAME . NAME ( LIT , LIT ) ) # --- Sign In Button --- NAME = None try : NAME . NAME ( f\" Waiting for sign in button presence: ' { NAME } '... \" ) # type: ignore NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( ( NAME . NAME , NAME ) ) # type: ignore ) NAME . NAME ( LIT ) NAME = NAME . NAME ( NAME . NAME ( ( NAME . NAME , NAME ) ) # type: ignore ) NAME . NAME ( LIT ) except NAME : # type: ignore NAME . NAME ( LIT ) NAME . NAME ( LIT ) try : NAME . NAME ( NAME . NAME ) NAME . NAME ( LIT ) return True # Assume submission worked except ( NAME , NAME ) as NAME : # type: ignore NAME . NAME ( f\" Failed to send RETURN key: { NAME } \" ) return False # Fallback also failed # End of try/except except NAME as NAME : # type: ignore NAME . NAME ( f\" Unexpected WebDriver error finding sign in button: { NAME } \" ) return False # End of try/except # Click button using multiple methods if needed NAME = False if NAME : # Attempt 1: Standard click try : NAME . NAME ( LIT ) NAME . NAME ( ) NAME . NAME ( LIT ) NAME = True except ( NAME , NAME , NAME ) as NAME : # type: ignore NAME . NAME ( f\" Standard click failed ( { NAME ( NAME ) . NAME } ). Trying JS click... \" ) except NAME as NAME : # type: ignore NAME . NAME ( f\" WebDriver error during standard click: { NAME } . Trying JS click... \" ) # End of try/except standard click # Attempt 2: JavaScript click (if standard failed) if not NAME : try : NAME . NAME ( LIT ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT ) NAME = True except NAME as NAME : # type: ignore NAME . NAME ( f\" Error during JavaScript click: { NAME } \" ) # End of try/except JS click # End of if not click_successful # Attempt 3: Send RETURN key (if clicks failed) if not NAME : NAME . NAME ( LIT ) try : # Send to password field as it likely still has focus NAME . NAME ( NAME . NAME ) NAME . NAME ( LIT ) NAME = True except ( NAME , NAME ) as NAME : # type: ignore NAME . NAME ( f\" Failed to send RETURN key as final fallback: { NAME } \" ) # End of try/except RETURN key # End of if not click_successful (after JS) # End of if sign_in_button return NAME # Return True if any click/submit method seemed to work except ( NAME , NAME ) as NAME : # type: ignore NAME . NAME ( f\" Timeout or Element not found finding username/password field: { NAME } \" ) return False except NAME as NAME : # Catch missing config NAME . NAME ( f\" Configuration Error: { NAME } \" ) # Re-raise config error as it's critical raise NAME except NAME as NAME : # type: ignore NAME . NAME ( f\" WebDriver error entering credentials: { NAME } \" ) if not NAME ( NAME ) : NAME . NAME ( LIT ) # End of if return False except NAME as NAME : NAME . NAME ( f\" Unexpected error entering credentials: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "consent",
      "lineno": 2851,
      "end_lineno": 2999,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 9,
      "yield_count": 0,
      "complexity": 10,
      "loc": 149,
      "tags": [
        "pure-ish",
        "time",
        "size:large"
      ],
      "signature": "(driver)",
      "fingerprint": "16e17ad4b9e770d3bc9913a673c82db8187402cf",
      "simhash64": 7488144843440829491,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : # type: ignore LIT if not NAME : NAME . NAME ( LIT ) return False # End of if NAME . NAME ( f\" Checking for cookie consent overlay: ' { NAME } ' \" ) # type: ignore NAME = None try : # Use a short wait to find the banner NAME = NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( ( NAME . NAME , NAME ) ) # type: ignore ) NAME . NAME ( LIT ) except NAME : # type: ignore NAME . NAME ( LIT ) return True # No banner, proceed except NAME as NAME : # Catch errors finding element # type: ignore NAME . NAME ( f\" Error checking for consent banner: { NAME } \" ) return False # Indicate failure if check fails # End of try/except # If overlay detected, try to handle it NAME = False if NAME : # Attempt 1: Try removing the element directly with JS try : NAME . NAME ( LIT ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT ) # Allow DOM to update # Verify removal try : NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME . NAME ( LIT ) NAME = True return True # Success except NAME : # type: ignore NAME . NAME ( LIT ) except NAME as NAME : # type: ignore NAME . NAME ( f\" Error verifying overlay removal after JS: { NAME } \" ) # End of try/except verification except NAME as NAME : # type: ignore NAME . NAME ( f\" Error removing consent overlay via JS: { NAME } . Trying button click... \" ) except NAME as NAME : # Catch other unexpected errors during JS removal NAME . NAME ( f\" Unexpected error during JS removal of consent: { NAME } . Trying button click... \" ) # End of try/except JS removal # End of if overlay_element # Attempt 2: Try clicking the specific accept button if JS removal failed/skipped if not NAME : NAME . NAME ( f\" JS removal failed/skipped. Trying specific accept button: ' { NAME } ' \" ) try : # Wait for the button to be clickable NAME = NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME . NAME ( LIT ) # Try standard click first try : NAME . NAME ( ) NAME . NAME ( LIT ) # Verify removal NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME . NAME ( LIT ) return True # Success except NAME : # type: ignore NAME . NAME ( LIT ) # Fall through to JS click attempt except ( NAME , NAME , ) : # If overlay gone after click # type: ignore NAME . NAME ( LIT ) return True except NAME as NAME : # type: ignore NAME . NAME ( f\" Error during standard click on accept button: { NAME } . Trying JS click... \" ) # End of try/except standard click # Try JS click as fallback try : NAME . NAME ( LIT ) NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT ) # Verify removal NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME . NAME ( LIT ) return True # Success except ( NAME , NAME , ) : # If overlay gone after JS click # type: ignore NAME . NAME ( LIT ) return True except NAME as NAME : # type: ignore NAME . NAME ( f\" Failed JS click for accept button: { NAME } \" ) # End of try/except JS click except NAME : # type: ignore NAME . NAME ( f\" Specific accept button ' { NAME } ' not found or not clickable. \" ) except ( NAME ) as NAME : # Catch errors finding/interacting # type: ignore NAME . NAME ( f\" Error finding/clicking specific accept button: { NAME } \" ) except NAME as NAME : # Catch other unexpected errors NAME . NAME ( f\" Unexpected error handling consent button: { NAME } \" , NAME = True ) # End of try/except button click block # End of if not removed_via_js # If both JS removal and button click failed NAME . NAME ( LIT ) return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "_check_initial_login_status",
      "lineno": 3004,
      "end_lineno": 3028,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 25,
      "tags": [
        "impure",
        "logging",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "007e41da986cb0601cee17fbbe2b490df6e4d837",
      "simhash64": 5182477715889886211,
      "normalized": "def NAME ( NAME : NAME ) -> NAME [ NAME ] : LIT NAME = NAME ( NAME , NAME = True ) # API check only for speed if NAME is True : NAME ( LIT ) return LIT return None"
    },
    {
      "module_path": "utils.py",
      "qualname": "_navigate_to_signin_page",
      "lineno": 3031,
      "end_lineno": 3074,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 44,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(driver, session_manager)",
      "fingerprint": "0085c18fcc9fdc8a6f7c8ff0d0331020fd799461",
      "simhash64": 7487617073093706787,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : # type: ignore LIT NAME = NAME ( NAME . NAME . NAME , LIT ) # Wait for username input as indication of page load if not NAME ( NAME , NAME , NAME , NAME # type: ignore ) : # Navigation failed or redirected. Check if already logged in. NAME . NAME ( LIT ) NAME = NAME ( NAME , NAME = True ) # API check only for speed if NAME is True : NAME . NAME ( LIT ) return LIT NAME . NAME ( LIT ) return LIT NAME . NAME ( LIT ) return LIT"
    },
    {
      "module_path": "utils.py",
      "qualname": "_handle_credential_entry",
      "lineno": 3077,
      "end_lineno": 3150,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 5,
      "loc": 74,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(driver)",
      "fingerprint": "5ce70e7422c53113732c42ab81f05315887b08b0",
      "simhash64": 7487722630975763519,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : # type: ignore LIT if not NAME ( NAME ) : NAME . NAME ( LIT ) # Check for specific error messages on the page try : # Check for specific 'invalid credentials' message NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME . NAME ( LIT ) return LIT except NAME : # type: ignore # Check for any generic alert box NAME = LIT # Example try : NAME = NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME = ( NAME . NAME if NAME and NAME . NAME else LIT ) NAME . NAME ( f\" Login failed: Generic alert found: ' { NAME } '. \" ) return LIT except NAME : # type: ignore NAME . NAME ( LIT ) return LIT # Credential entry itself failed except ( NAME ) as NAME : # Handle errors checking for alerts # type: ignore NAME . NAME ( f\" Error checking for generic login error message: { NAME } \" ) return LIT # Assume cred entry failed except ( NAME ) as NAME : # Handle errors checking for specific alert # type: ignore NAME . NAME ( f\" Error checking for specific login error message: { NAME } \" ) return LIT return LIT"
    },
    {
      "module_path": "utils.py",
      "qualname": "_check_for_2fa",
      "lineno": 3153,
      "end_lineno": 3180,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 4,
      "loc": 28,
      "tags": [
        "pure-ish",
        "randomness",
        "time",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(driver, session_manager)",
      "fingerprint": "63cdc2ec7d0d7e5a5db380c1624540b0043a7f68",
      "simhash64": 7488215207957140519,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : # type: ignore LIT NAME . NAME ( LIT ) NAME . NAME ( NAME . NAME ( LIT , LIT ) ) # Allow time for redirect or 2FA page load try : # Check if the 2FA header is now visible NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME . NAME ( LIT ) return True except NAME : # type: ignore NAME . NAME ( LIT ) return False except NAME as NAME : # type: ignore NAME . NAME ( f\" WebDriver error checking for 2FA page: { NAME } \" ) # If error checking, verify login status as fallback NAME = NAME ( NAME , NAME = True ) # API check only for speed if NAME is True : return LIT if NAME is False : return LIT # Error + not logged in return LIT # Critical status check error"
    },
    {
      "module_path": "utils.py",
      "qualname": "_handle_2fa_verification",
      "lineno": 3183,
      "end_lineno": 3196,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "(session_manager)",
      "fingerprint": "1663bb6b01e4bf6298447752bbd3d18490ff4baa",
      "simhash64": 7487652257465799723,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT if NAME ( NAME ) : NAME . NAME ( LIT ) # Re-verify login status after 2FA if NAME ( NAME ) is True : NAME ( LIT ) return LIT NAME . NAME ( LIT ) return LIT NAME . NAME ( LIT ) return LIT"
    },
    {
      "module_path": "utils.py",
      "qualname": "_handle_no_2fa_verification",
      "lineno": 3199,
      "end_lineno": 3280,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 9,
      "yield_count": 0,
      "complexity": 7,
      "loc": 82,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "(driver, session_manager)",
      "fingerprint": "d57e0abe6acb2e95e5938cf757ccfac82f33a6db",
      "simhash64": 7487652257466856491,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : # type: ignore LIT NAME = NAME ( NAME . NAME . NAME , LIT ) # No 2FA detected, check login status directly NAME . NAME ( LIT ) NAME = NAME ( NAME , NAME = False ) # Use UI fallback for reliability if NAME is True : NAME ( LIT ) return LIT if NAME is False : # Verify why it failed if no 2FA was shown NAME ( LIT ) NAME . NAME ( LIT ) try : # Check specific error again NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME . NAME ( LIT ) return LIT except NAME : # type: ignore # Check generic error again NAME = LIT try : NAME = NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME = ( NAME . NAME if NAME else LIT ) NAME . NAME ( f\" Login failed: Generic alert found (post-check): ' { NAME } '. \" ) return LIT except NAME : # type: ignore # Still on login page? try : if NAME . NAME . NAME ( NAME ) : NAME . NAME ( LIT ) return LIT NAME . NAME ( LIT ) return LIT except NAME : # type: ignore NAME . NAME ( LIT ) return LIT # Session likely dead except ( NAME ) as NAME : # Error checking generic alert # type: ignore NAME . NAME ( f\" Login failed: Error checking for generic alert (post-check): { NAME } \" ) return LIT except ( NAME ) as NAME : # Error checking specific alert # type: ignore NAME . NAME ( f\" Login failed: Error checking for specific alert (post-check): { NAME } \" ) return LIT else : # login_status returned None NAME . NAME ( LIT ) return LIT"
    },
    {
      "module_path": "utils.py",
      "qualname": "_handle_2fa_and_verification",
      "lineno": 3283,
      "end_lineno": 3295,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(driver, session_manager)",
      "fingerprint": "6653a051020c667a5f30496e82aae89b749bb3ee",
      "simhash64": 5182407380364076067,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : # type: ignore LIT NAME = NAME ( NAME , NAME ) # If 2FA check returned a login result, return it if NAME ( NAME , NAME ) : return NAME # Handle 2FA or direct verification based on detection if NAME : # 2FA present return NAME ( NAME ) # No 2FA detected return NAME ( NAME , NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "log_in",
      "lineno": 3298,
      "end_lineno": 3347,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 8,
      "yield_count": 0,
      "complexity": 8,
      "loc": 50,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(session_manager)",
      "fingerprint": "a7262fa8f5bc3136cbb9f9d704c0dff2ab5c3dee",
      "simhash64": 7488250391724200979,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : # type: ignore LIT NAME = NAME . NAME if not NAME : NAME . NAME ( LIT ) return LIT # First check if already logged in before attempting navigation NAME = NAME ( NAME ) if NAME : return NAME try : # --- Step 1: Navigate to Sign-in Page --- NAME = NAME ( NAME , NAME ) if NAME != LIT : return NAME # --- Step 2: Handle Consent Banner --- if not NAME ( NAME ) : NAME . NAME ( LIT ) # Continue anyway, maybe it wasn't essential # --- Step 3: Enter Credentials --- NAME = NAME ( NAME ) if NAME != LIT : return NAME # --- Step 4: Handle 2FA and Final Verification --- return NAME ( NAME , NAME ) # --- Catch errors during the overall login process --- except NAME as NAME : # type: ignore NAME . NAME ( f\" Timeout during login process: { NAME } \" , NAME = False ) return LIT except NAME as NAME : # type: ignore NAME . NAME ( f\" WebDriverException during login: { NAME } \" , NAME = False ) if not NAME ( NAME ) : NAME . NAME ( LIT ) # End of if return LIT except NAME as NAME : NAME . NAME ( f\" An unexpected error occurred during login: { NAME } \" , NAME = True ) return LIT"
    },
    {
      "module_path": "utils.py",
      "qualname": "login_status",
      "lineno": 3354,
      "end_lineno": 3500,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 13,
      "yield_count": 0,
      "complexity": 20,
      "loc": 147,
      "tags": [
        "pure-ish",
        "time",
        "size:large"
      ],
      "signature": "(session_manager, disable_ui_fallback)",
      "fingerprint": "99feca5d50d5ea52829bf75a60e8cbd6bae26bac",
      "simhash64": 7488180572802946099,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME = False ) -> NAME [ NAME ] : # type: ignore LIT # --- Validate arguments and session state --- # Check if session_manager has the expected attributes instead of isinstance check if not NAME ( NAME , LIT ) or not NAME ( NAME , LIT ) : NAME . NAME ( f\" Invalid argument: Expected SessionManager-like object, got { NAME ( NAME ) } . \" ) return None # Critical argument error # End of if if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False # Cannot be logged in if session is invalid # End of if NAME = NAME . NAME if NAME is None : NAME . NAME ( LIT ) return None # Critical state error # End of if # --- Primary Check: API Verification --- NAME . NAME ( LIT ) try : # Sync cookies before API check to ensure latest state NAME . NAME ( ) # Perform API check NAME = NAME . NAME . NAME ( ) # If API check is definitive, return its result if NAME is True : NAME . NAME ( LIT ) return True if NAME is False : NAME . NAME ( LIT ) return False # End of if/elif NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Exception during API login check: { NAME } \" , NAME = True ) NAME = None # Ensure we continue to UI fallback # End of try/except # If API check is ambiguous (None) and UI fallback is disabled, return None if NAME is None and NAME : NAME . NAME ( LIT ) return None # End of if # --- Secondary Check: UI Verification (Fallback) --- NAME . NAME ( LIT ) try : # Check 1: Presence of a known logged-in element (most reliable indicator) NAME = NAME # type: ignore # Assumes defined in my_selectors NAME . NAME ( f\" Checking for logged-in indicator: ' { NAME } ' \" ) # Use helper function is_elem_there for robust check NAME = NAME ( NAME , NAME . NAME , NAME , NAME = LIT ) # type: ignore if NAME : NAME . NAME ( LIT ) return True # End of if # Check 2: Presence of login button (if present, definitely not logged in) NAME = NAME # type: ignore # Assumes defined in my_selectors NAME . NAME ( f\" Checking for login button: ' { NAME } ' \" ) # Use helper function is_elem_there for robust check NAME = NAME ( NAME , NAME . NAME , NAME , NAME = LIT ) # type: ignore if NAME : NAME . NAME ( LIT ) return False # End of if # Check 3: Navigate to base URL and check again if both checks were inconclusive if not NAME and not NAME : NAME . NAME ( LIT ) try : NAME = NAME . NAME NAME = NAME . NAME . NAME # Only navigate if not already on base URL if not NAME . NAME ( NAME ) : NAME . NAME ( NAME ) NAME . NAME ( LIT ) # Allow page to load # Check again after navigation NAME = NAME ( NAME , NAME . NAME , NAME , NAME = LIT ) # type: ignore if NAME : NAME . NAME ( LIT ) return True # End of if NAME = NAME ( NAME , NAME . NAME , NAME , NAME = LIT ) # type: ignore if NAME : NAME . NAME ( LIT ) return False # End of if # End of if except NAME as NAME : NAME . NAME ( f\" Error during navigation for secondary UI check: { NAME } \" ) # Continue to default return # End of try/except # End of if # Default to False in ambiguous cases for security reasons NAME . NAME ( LIT ) return False except NAME as NAME : # type: ignore NAME . NAME ( f\" WebDriverException during UI login_status check: { NAME } \" ) if not NAME ( NAME ) : NAME . NAME ( LIT ) NAME . NAME ( ) # Close the dead session # End of if return None # Return None on critical WebDriver error during check except NAME as NAME : # Catch other unexpected errors NAME . NAME ( f\" Unexpected error during UI login_status check: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "utils.py",
      "qualname": "_url_base_matches",
      "lineno": 3508,
      "end_lineno": 3514,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 7,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(target_url_base, landed_url_base)",
      "fingerprint": "b1596f829df063d926975628d7ff58fbee8ff157",
      "simhash64": 7487652257398690819,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> NAME : try : NAME = ( NAME or LIT ) . NAME ( LIT ) NAME = ( NAME or LIT ) . NAME ( LIT ) return NAME == NAME or NAME . NAME ( NAME + LIT ) except NAME : return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "nav_to_page",
      "lineno": 3519,
      "end_lineno": 3901,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 17,
      "yield_count": 0,
      "complexity": 40,
      "loc": 383,
      "tags": [
        "impure",
        "network",
        "randomness",
        "time",
        "regex",
        "size:large"
      ],
      "signature": "(driver, url, selector, session_manager)",
      "fingerprint": "3c0bc5c60cec31ed93e3c61b578af2bd6b186364",
      "simhash64": 7488180022981080115,
      "normalized": "def NAME ( NAME : NAME , # type: ignore NAME : NAME , NAME : NAME = LIT , # CSS selector to wait for as indication of page load success NAME : NAME = None , # Pass SessionManager for context/restart ) -> NAME : LIT if not NAME : NAME . NAME ( LIT ) return False # End of if if not NAME or not NAME ( NAME , NAME ) : NAME . NAME ( f\" Navigation failed: Target URL ' { NAME } ' is invalid. \" ) return False # End of if NAME = NAME . NAME . NAME NAME = NAME . NAME . NAME NAME = NAME . NAME . NAME # Normalize target URL base (scheme, netloc, path) for comparison try : NAME = NAME ( NAME ) NAME = NAME ( ( NAME . NAME , NAME . NAME , NAME . NAME . NAME ( LIT ) , LIT , LIT , LIT , ) ) . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Failed to parse target URL ' { NAME } ': { NAME } \" ) return False # End of try/except # Define common problematic URLs/selectors NAME = NAME ( NAME . NAME . NAME , LIT ) . NAME ( LIT ) NAME ( NAME . NAME . NAME , LIT ) . NAME ( LIT ) # Selectors for known 'unavailable' pages NAME = { NAME : ( LIT , LIT ) , # type: ignore # Selector : (action, wait_seconds) NAME : ( LIT , LIT ) , # type: ignore # Add other known error page selectors here } for NAME in NAME ( LIT , NAME + LIT ) : NAME . NAME ( f\" Navigation Attempt { NAME } / { NAME } to: { NAME } \" ) NAME = LIT NAME = LIT try : # --- Pre-Navigation Checks --- if not NAME ( NAME ) : NAME . NAME ( f\" Navigation failed (Attempt { NAME } ): Browser session invalid before nav. \" ) if NAME : NAME . NAME ( LIT ) if NAME . NAME ( ) : NAME . NAME ( LIT ) # Get the new driver instance with type assertion NAME = NAME . NAME if NAME is not None : NAME = NAME # Only assign if not None if not NAME : # Check if restart actually provided a driver NAME . NAME ( LIT ) return False # End of if continue # Retry navigation with new driver NAME . NAME ( LIT ) return False # Unrecoverable # End of if/else restart NAME . NAME ( LIT ) return False # Unrecoverable # End of if/else session_manager # End of if not is_browser_open # --- Navigation Execution --- NAME . NAME ( f\" Executing driver.get(' { NAME } ')... \" ) NAME . NAME ( NAME ) # Wait for document ready state (basic page load signal) NAME ( NAME , NAME ) . NAME ( # type: ignore lambda NAME : NAME . NAME ( LIT ) in [ LIT , LIT ] ) # Small pause allowing JS/redirects to potentially trigger NAME . NAME ( NAME . NAME ( LIT , LIT ) ) # --- Post-Navigation Checks --- try : NAME = NAME . NAME NAME = NAME ( NAME ) NAME = NAME ( ( NAME . NAME , NAME . NAME , NAME . NAME . NAME ( LIT ) , LIT , LIT , LIT , ) ) . NAME ( LIT ) NAME . NAME ( f\" Landed on URL base: { NAME } \" ) except NAME as NAME : # type: ignore NAME . NAME ( f\" Failed to get current URL after get() (Attempt { NAME } ): { NAME } . Retrying. \" ) continue # Retry the navigation attempt # End of try/except # Check for MFA page NAME = False try : # Use short wait, presence is enough NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME = True except ( NAME , NAME ) : # type: ignore pass # Expected if not on MFA page except NAME as NAME : # type: ignore NAME . NAME ( f\" WebDriverException checking for MFA header: { NAME } \" ) # End of try/except if NAME : NAME . NAME ( LIT ) # Should not attempt re-login here, indicates a prior login state issue return False # Fail navigation # End of if # Check for Login page (only if *not* intentionally navigating there) NAME = False if ( NAME != NAME ) : # Don't check if login is the target try : # Check if username input exists (strong indicator of login page) NAME ( NAME , LIT ) . NAME ( # type: ignore NAME . NAME ( # type: ignore ( NAME . NAME , NAME ) # type: ignore ) ) NAME = True except ( NAME , NAME ) : # type: ignore pass # Expected if not on login page except NAME as NAME : # type: ignore NAME . NAME ( f\" WebDriverException checking for Login username input: { NAME } \" ) # End of try/except # End of if target_url_base != signin_page_url_base if NAME : NAME . NAME ( LIT ) if NAME : # First check if we're already logged in (API might say yes even if UI shows login page) NAME = NAME ( NAME , NAME = True ) # API check only for speed if NAME is True : NAME . NAME ( LIT ) continue # Retry original nav_to_page call # Attempt automated login NAME . NAME ( LIT ) NAME = NAME ( NAME ) if NAME == LIT : NAME . NAME ( LIT ) continue # Retry original nav_to_page call NAME . NAME ( f\" Re-login attempt failed ( { NAME } ). Cannot complete navigation. \" ) return False # Fail navigation if re-login fails # End of if/else login_result_str # End of if/else login_stat NAME . NAME ( LIT ) return False # Fail navigation # End of if/else session_manager # End of if is_on_login_page # Check if landed on an unexpected URL (and not login/mfa) # Allow for slight variations (e.g., trailing slash) via base comparison if not NAME ( NAME , NAME ) : # Check if it's a known redirect (e.g., signin page redirecting to base URL after successful login) NAME = ( NAME == NAME and NAME == NAME ( NAME . NAME . NAME ) . NAME . NAME ( LIT ) ) if NAME : NAME . NAME ( LIT ) NAME . NAME ( LIT ) # Allow settling if ( NAME and NAME ( NAME , NAME = True ) is True ) : # API check only for speed NAME . NAME ( LIT ) return True # Treat as success if login was the goal and we are now logged in # End of if # End of if is_signin_to_base_redirect # If not the known redirect, check for unavailability messages NAME . NAME ( f\" Navigation landed on unexpected URL base: ' { NAME } ' (Expected: ' { NAME } ') \" ) NAME , NAME = NAME ( NAME , NAME ) if NAME == LIT : NAME . NAME ( LIT ) return False # Fail navigation if NAME == LIT : NAME . NAME ( f\" Temporary unavailability message found. Waiting { NAME } s and retrying... \" ) NAME . NAME ( NAME ) continue # Retry navigation attempt # Wrong URL, no specific message, likely a redirect issue NAME . NAME ( LIT ) continue # Retry navigation attempt # End of if/elif/else action # End of if landed_url_base != target_url_base # --- Final Check: Element on Page --- # If we reached here, we are on the correct URL base (or handled redirects) NAME = ( NAME if NAME else LIT ) # Default to body if no selector provided NAME . NAME ( f\" On correct URL base. Waiting up to { NAME } s for selector: ' { NAME } ' \" ) try : NAME ( NAME , NAME ) . NAME ( # type: ignore NAME . NAME ( ( NAME . NAME , NAME ) ) # type: ignore ) NAME . NAME ( f\" Navigation successful and element ' { NAME } ' found on: { NAME } \" ) return True # Success! except NAME : # type: ignore # Correct URL, but target element didn't appear NAME = LIT with NAME . NAME ( NAME ) : NAME = NAME . NAME # End of try/except NAME . NAME ( f\" Timeout waiting for selector ' { NAME } ' at { NAME } (URL base was correct). \" ) # Check again for unavailability messages that might have appeared late NAME , NAME = NAME ( NAME , NAME ) if NAME == LIT : return False if NAME == LIT : NAME . NAME ( NAME ) continue # Retry navigation # End of if/elif NAME . NAME ( LIT ) continue # Retry navigation attempt except ( NAME ) as NAME : # Catch errors during element wait # type: ignore NAME . NAME ( f\" WebDriverException waiting for selector ' { NAME } ': { NAME } \" ) continue # Retry navigation # End of try/except for final check # --- Handle Exceptions During Navigation Attempt --- except NAME as NAME : # type: ignore NAME = LIT try : NAME = NAME . NAME # type: ignore except NAME : pass # End of try/except NAME . NAME ( f\" Unexpected alert detected (Attempt { NAME } ): { NAME } \" ) try : NAME . NAME . NAME . NAME ( ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Failed to accept unexpected alert: { NAME } \" ) return False # Fail if alert cannot be handled # End of try/except continue # Retry navigation after handling alert except NAME as NAME : # type: ignore NAME . NAME ( f\" WebDriverException during navigation (Attempt { NAME } ): { NAME } \" , NAME = False , ) if NAME and not NAME ( NAME ) : NAME . NAME ( LIT ) if NAME . NAME ( ) : NAME . NAME ( LIT ) # Get the new driver instance with type assertion NAME = NAME . NAME if NAME is not None : NAME = NAME # Only assign if not None if not NAME : return False # Fail if restart didn't provide driver # End of if continue # Retry navigation NAME . NAME ( LIT ) return False # Unrecoverable # End of if/else restart NAME . NAME ( LIT ) NAME . NAME ( NAME . NAME ( LIT , LIT ) ) continue # Retry navigation attempt # End of if/else session_manager except NAME as NAME : # Catch other unexpected errors NAME . NAME ( f\" Unexpected error during navigation (Attempt { NAME } ): { NAME } \" , NAME = True , ) NAME . NAME ( NAME . NAME ( LIT , LIT ) ) # Wait before retry continue # Retry navigation attempt # End of try/except block for navigation attempt # --- Failed After All Attempts --- NAME . NAME ( f\" Navigation to ' { NAME } ' failed permanently after { NAME } attempts. \" ) try : NAME . NAME ( f\" Final URL after failure: { NAME . NAME } \" ) except NAME : NAME . NAME ( LIT ) # End of try/except return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "_check_for_unavailability",
      "lineno": 3905,
      "end_lineno": 3927,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 23,
      "tags": [
        "pure-ish",
        "time",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(driver, selectors)",
      "fingerprint": "01ac45206185cbd3dddcac48cdf641884aa352ac",
      "simhash64": 5182477751255741495,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME , NAME [ NAME , NAME ] ] # type: ignore ) -> NAME [ NAME [ NAME ] , NAME ] : LIT # Check if driver is usable if not NAME ( NAME ) : NAME . NAME ( LIT ) return None , LIT # End of if for NAME , ( NAME , NAME ) in NAME . NAME ( ) : # Use selenium_utils helper 'is_elem_there' with a very short wait # Assume is_elem_there is imported if NAME ( NAME , NAME . NAME , NAME , NAME = LIT ) : # type: ignore NAME . NAME ( f\" Unavailability message found matching selector: ' { NAME } '. Action: { NAME } , Wait: { NAME } s \" ) return NAME , NAME # Return action (refresh/skip) and wait time # End of if # End of for # Return default (no action, zero wait) if no matching selectors found return None , LIT"
    },
    {
      "module_path": "utils.py",
      "qualname": "main",
      "lineno": 3931,
      "end_lineno": 3943,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "e86034eec922a6481fcadb33ab2d5fefa4f66da6",
      "simhash64": 210526254888048623,
      "normalized": "def NAME ( ) -> None : LIT # --- Standard library imports needed for main --- # --- Local imports needed for main --- # Imports are assumed successful due to strict checks at top level pass # main function placeholder, test logic removed"
    },
    {
      "module_path": "utils.py",
      "qualname": "test_parse_cookie",
      "lineno": 3945,
      "end_lineno": 3974,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "664d12d2b90d47e1b10def73013aafb175425fdc",
      "simhash64": 5151233993462421035,
      "normalized": "def NAME ( ) : LIT try : NAME = [ ( LIT , { LIT : LIT , LIT : LIT , LIT : LIT } , LIT , ) , ( LIT , { } , LIT ) , ( LIT , { LIT : LIT } , LIT ) , ( LIT , { LIT : LIT , LIT : LIT , LIT : LIT } , LIT , ) , ( LIT , { LIT : LIT } , LIT , ) , ] for NAME , NAME , NAME in NAME : NAME = NAME ( NAME ) if NAME != NAME : return False return True except NAME : return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "test_ordinal_case",
      "lineno": 3977,
      "end_lineno": 3993,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 17,
      "tags": [
        "impure",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "cfac22849ec7f5f22ad43040703de37e52733560",
      "simhash64": 5125619777032590379,
      "normalized": "def NAME ( ) : LIT try : NAME = [ ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ] for NAME , NAME in NAME : NAME = NAME ( NAME ) if NAME != NAME : return False return True except NAME : return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "test_format_name",
      "lineno": 3996,
      "end_lineno": 4018,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 23,
      "tags": [
        "impure",
        "purpose:formatting",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "48c9109c1c3ee8a50c9995e2c5a0edb2ec81a375",
      "simhash64": 5125619777032590379,
      "normalized": "def NAME ( ) : LIT try : NAME = [ ( LIT , LIT ) , ( None , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ] for NAME , NAME in NAME : NAME = NAME ( NAME ) if NAME != NAME : return False return True except NAME : return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "test_decorators",
      "lineno": 4020,
      "end_lineno": 4038,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "14ad8f4c4e5d15a394ca3a905335d5acc307d7ed",
      "simhash64": 5181949952387355691,
      "normalized": "def NAME ( ) : LIT try : # Test retry decorator availability assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT # Basic decorator functionality test @ NAME ( NAME = LIT , NAME = LIT ) def NAME ( ) : return LIT NAME = NAME ( ) assert NAME == LIT , LIT return True except NAME : return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "test_func",
      "lineno": 4031,
      "end_lineno": 4032,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "88196c13a4ec3b7a1dbe2535ac0e0e678a85a55d",
      "simhash64": 5760372770364887083,
      "normalized": "def NAME ( ) : return LIT"
    },
    {
      "module_path": "utils.py",
      "qualname": "test_rate_limiter",
      "lineno": 4041,
      "end_lineno": 4058,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 18,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "77f67910f1a0a8f3c8d1c25636cb48b5335dce27",
      "simhash64": 7487757777228960811,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME ( NAME = LIT , NAME = LIT ) assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT # Test basic wait functionality import NAME NAME = NAME . NAME ( ) NAME . NAME ( ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , LIT return True except NAME : return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "test_session_manager",
      "lineno": 4061,
      "end_lineno": 4079,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d155a4af03d0286d31bbaa838eff16f5519eb4ed",
      "simhash64": 7451729013495993379,
      "normalized": "def NAME ( ) : LIT try : # Import SessionManager directly to avoid circular import issues from NAME . NAME import NAME NAME = NAME ( ) assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT # Test initial state assert not NAME . NAME , LIT assert not NAME . NAME , LIT return True except NAME : return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "test_api_request_function",
      "lineno": 4082,
      "end_lineno": 4093,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2eeb2331a647a79a7e1cd9356badb83eb6ef36a5",
      "simhash64": 7488179988620284963,
      "normalized": "def NAME ( ) : LIT try : assert NAME ( NAME ) , LIT # Test function signature (should not raise errors) import NAME as NAME NAME = NAME . NAME ( NAME ) assert NAME ( NAME . NAME ) >= LIT , LIT return True except NAME : return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "test_login_status_function",
      "lineno": 4096,
      "end_lineno": 4107,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c238e97c7abe568d26824df9b6637a0fb72482d7",
      "simhash64": 7488320760468386859,
      "normalized": "def NAME ( ) : LIT try : assert NAME ( NAME ) , LIT # Test function signature import NAME as NAME NAME = NAME . NAME ( NAME ) assert LIT in NAME . NAME , LIT return True except NAME : return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "test_module_registration",
      "lineno": 4110,
      "end_lineno": 4123,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "8e40f2b7912424a749250b66d23a55de62221d43",
      "simhash64": 7487757777228961323,
      "normalized": "def NAME ( ) : LIT try : assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT # Test that core classes are available assert LIT in NAME ( ) , LIT assert LIT in NAME ( ) , LIT assert LIT in NAME ( ) , LIT return True except NAME : return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "test_performance_validation",
      "lineno": 4126,
      "end_lineno": 4177,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 52,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "c90d45cfa7deabdb34e1a8933c7557af9092766e",
      "simhash64": 7488179989694026811,
      "normalized": "def NAME ( ) : LIT try : import NAME NAME = NAME . NAME ( ) # Format name performance for NAME in NAME ( LIT ) : NAME ( f\" test name { NAME } \" ) # Ordinal case performance for NAME in NAME ( LIT , LIT ) : NAME ( NAME ) NAME = NAME . NAME ( ) - NAME assert NAME < LIT , f\" Performance test should complete quickly, took { NAME : .3f } s \" # New test ensuring that nav_to_page accepts subpath under the target base def NAME ( ) : class NAME : def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME def NAME ( NAME , NAME : NAME ) -> NAME : return LIT # Target is /discoveryui-matches/list/ while landed has /list/<UUID> NAME = LIT NAME = NAME + LIT NAME = NAME ( NAME ) # Monkey-patch is_browser_open to True from NAME import NAME as NAME try : def NAME ( NAME : NAME ) -> NAME : return True NAME ( ) [ LIT ] = NAME assert NAME ( NAME . NAME ( LIT ) , NAME . NAME ( LIT ) ) finally : NAME ( ) [ LIT ] = NAME return True NAME . NAME ( NAME = LIT , NAME = NAME , NAME = LIT , NAME = LIT , NAME = LIT , ) return True except NAME : return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "test_nav_to_list_accepts_uuid_subpath",
      "lineno": 4144,
      "end_lineno": 4165,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "a311e08489437dadcd4f054998c9737d3a967233",
      "simhash64": 7488109620949845011,
      "normalized": "def NAME ( ) : class NAME : def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME def NAME ( NAME , NAME : NAME ) -> NAME : return LIT # Target is /discoveryui-matches/list/ while landed has /list/<UUID> NAME = LIT NAME = NAME + LIT NAME = NAME ( NAME ) # Monkey-patch is_browser_open to True from NAME import NAME as NAME try : def NAME ( NAME : NAME ) -> NAME : return True NAME ( ) [ LIT ] = NAME assert NAME ( NAME . NAME ( LIT ) , NAME . NAME ( LIT ) ) finally : NAME ( ) [ LIT ] = NAME return True"
    },
    {
      "module_path": "utils.py",
      "qualname": "MockDriver.__init__",
      "lineno": 4146,
      "end_lineno": 4147,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, current_url)",
      "fingerprint": "0f70e91530b827d64534e5f608ec2fe7441857ef",
      "simhash64": 7488109620949853267,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "MockDriver.get",
      "lineno": 4148,
      "end_lineno": 4149,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, url)",
      "fingerprint": "0f70e91530b827d64534e5f608ec2fe7441857ef",
      "simhash64": 7488109620949853267,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "MockDriver.execute_script",
      "lineno": 4150,
      "end_lineno": 4151,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self, script)",
      "fingerprint": "ab3fc6cd3287ce3a1c38d9db7d77625d31986260",
      "simhash64": 7488320761542644835,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : return LIT"
    },
    {
      "module_path": "utils.py",
      "qualname": "is_open_mock",
      "lineno": 4159,
      "end_lineno": 4160,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(driver)",
      "fingerprint": "37181bb9c8b7d24d409f60787a4834fcbd7ef37e",
      "simhash64": 7488277296473605219,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : return True"
    },
    {
      "module_path": "utils.py",
      "qualname": "utils_module_tests",
      "lineno": 4191,
      "end_lineno": 4283,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 93,
      "tags": [
        "impure",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "70e275d5e1975d4d5147fcbf2f53aca693198b25",
      "simhash64": 5127871611137332267,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( LIT , LIT ) NAME . NAME ( ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "utils.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 4286,
      "end_lineno": 4288,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "utils.py",
      "qualname": "safe_file_operation",
      "lineno": 4301,
      "end_lineno": 4347,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 1,
      "complexity": 6,
      "loc": 47,
      "tags": [
        "impure",
        "filesystem",
        "size:medium"
      ],
      "signature": "(file_path, mode, encoding)",
      "fingerprint": "ed1d773393dd271b320d7cb1272cc314ea295566",
      "simhash64": 7452151225961067547,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME = LIT , NAME : NAME = LIT ) -> NAME [ NAME [ NAME ] , None , None ] : LIT NAME = NAME ( NAME ) NAME = None try : with NAME . NAME ( NAME , NAME = NAME ) as NAME : yield NAME except NAME as NAME : NAME . NAME ( f\" File not found: { NAME } \" ) raise NAME ( f\" Cannot access file: { NAME } \" ) from NAME except NAME as NAME : NAME . NAME ( f\" Permission denied accessing file: { NAME } \" ) raise NAME ( f\" Access denied to file: { NAME } \" ) from NAME except NAME as NAME : NAME . NAME ( f\" Encoding error reading file { NAME } : { NAME } \" ) raise NAME ( NAME . NAME , NAME . NAME , NAME . NAME , NAME . NAME , f\" Encoding error in file { NAME } : { NAME . NAME } \" ) from NAME except NAME as NAME : NAME . NAME ( f\" Unexpected error with file { NAME } : { NAME } \" ) raise NAME ( f\" Unexpected error accessing file { NAME } \" ) from NAME finally : if NAME and not NAME . NAME : try : NAME . NAME ( ) NAME . NAME ( f\" File closed successfully: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Error closing file { NAME } : { NAME } \" )"
    },
    {
      "module_path": "utils.py",
      "qualname": "api_session_context",
      "lineno": 4351,
      "end_lineno": 4402,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 1,
      "complexity": 8,
      "loc": 52,
      "tags": [
        "impure",
        "network",
        "json",
        "size:medium"
      ],
      "signature": "(session_manager)",
      "fingerprint": "a89114a5d09be914b297414d6a3bf1f42e2c572f",
      "simhash64": 7488180023047132195,
      "normalized": "def NAME ( NAME : NAME [ LIT ] = None ) -> NAME [ NAME . NAME , None , None ] : LIT NAME = None try : if NAME and NAME ( NAME , LIT ) and NAME . NAME : # Use existing session from SessionManager NAME = NAME . NAME NAME . NAME ( LIT ) else : # Create new session NAME = NAME . NAME ( ) # Note: requests.Session doesn't have a timeout attribute # Timeout should be passed to individual request methods NAME . NAME ( LIT ) # Configure session headers NAME . NAME . NAME ( { LIT : LIT , LIT : LIT , LIT : LIT , } ) yield NAME except NAME as NAME : NAME . NAME ( f\" Error in API session context: { NAME } \" ) raise finally : # Only close session if we created it (not from SessionManager) if NAME and ( not NAME or not NAME ( NAME , LIT ) or NAME != NAME . NAME ) : try : NAME . NAME ( ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error closing API session: { NAME } \" )"
    },
    {
      "module_path": "utils.py",
      "qualname": "async_api_session_context",
      "lineno": 4408,
      "end_lineno": 4461,
      "is_method": false,
      "is_async": true,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 1,
      "complexity": 8,
      "loc": 54,
      "tags": [
        "async",
        "impure",
        "network",
        "json",
        "size:medium"
      ],
      "signature": "(session_manager)",
      "fingerprint": "73c4d6770a91ac85523f22017f37c24e06c13d6f",
      "simhash64": 7452151225961059379,
      "normalized": "async def NAME ( NAME : NAME [ LIT ] = None ) : LIT if not NAME or NAME is None : raise NAME ( LIT ) NAME = NAME . NAME ( NAME = LIT ) # Default timeout NAME = NAME . NAME ( NAME = LIT , NAME = LIT ) # Connection pooling # Configure headers NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } # Extract cookies from session manager if available NAME = None if NAME and NAME ( NAME , LIT ) and NAME . NAME : try : # Convert requests cookies to aiohttp format NAME = { } for NAME in NAME . NAME . NAME : NAME [ NAME . NAME ] = NAME . NAME NAME . NAME ( f\" Transferred { NAME ( NAME ) } cookies from SessionManager \" ) except NAME as NAME : NAME . NAME ( f\" Failed to transfer cookies from SessionManager: { NAME } \" ) async with NAME . NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) as NAME : NAME . NAME ( LIT ) try : yield NAME finally : NAME . NAME ( LIT )"
    },
    {
      "module_path": "utils.py",
      "qualname": "async_api_request",
      "lineno": 4464,
      "end_lineno": 4572,
      "is_method": false,
      "is_async": true,
      "args_count": 10,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 8,
      "yield_count": 0,
      "complexity": 15,
      "loc": 109,
      "tags": [
        "async",
        "impure",
        "network",
        "logging",
        "json",
        "size:large"
      ],
      "signature": "(url, method, session_manager, headers, data, json_data, timeout, api_description, max_retries, backoff_factor)",
      "fingerprint": "c3efe72fb20f61a39f406b9a38d7dfcd1640a92c",
      "simhash64": 7452080857216889875,
      "normalized": "async def NAME ( NAME : NAME , NAME : NAME = LIT , NAME : NAME [ LIT ] = None , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME : NAME . NAME ( f\" [ { NAME } ] aiohttp not available - falling back to synchronous request \" ) # Could implement fallback to requests here if needed return None async with NAME ( NAME ) as NAME : # Merge headers NAME = { } if NAME : NAME . NAME ( NAME ) # Add CSRF token if available if NAME and NAME ( NAME , LIT ) and NAME . NAME : NAME [ LIT ] = NAME . NAME # CRITICAL FIX: Use lowercase header name # Set timeout NAME = NAME . NAME ( NAME = NAME or LIT ) if NAME else None for NAME in NAME ( LIT , NAME + LIT ) : try : NAME . NAME ( f\" [ { NAME } ] Async attempt { NAME } / { NAME } : { NAME } { NAME } \" ) async with NAME . NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME ) as NAME : NAME . NAME ( f\" [ { NAME } ] Response: { NAME . NAME } { NAME . NAME } \" ) if NAME . NAME == LIT : try : NAME = await NAME . NAME ( ) NAME . NAME ( f\" [ { NAME } ] Successful async request (attempt { NAME } ) \" ) return NAME except NAME : # Try to get text response NAME = await NAME . NAME ( ) NAME . NAME ( f\" [ { NAME } ] Non-JSON response: { NAME [ : LIT ] } \" ) return { LIT : NAME } elif NAME . NAME == LIT : # Rate limit NAME . NAME ( f\" [ { NAME } ] Rate limited (429), attempt { NAME } / { NAME } \" ) if NAME < NAME : await NAME . NAME ( NAME * ( LIT ** NAME ) ) continue NAME . NAME ( f\" [ { NAME } ] Rate limit exceeded after { NAME } attempts \" ) return None else : NAME . NAME ( f\" [ { NAME } ] HTTP { NAME . NAME } : { NAME . NAME } \" ) if NAME < NAME : await NAME . NAME ( NAME * NAME ) continue return None except NAME . NAME : NAME . NAME ( f\" [ { NAME } ] Timeout on attempt { NAME } / { NAME } \" ) if NAME < NAME : await NAME . NAME ( NAME * NAME ) continue NAME . NAME ( f\" [ { NAME } ] Timeout after { NAME } attempts \" ) return None except NAME as NAME : NAME . NAME ( f\" [ { NAME } ] Error on attempt { NAME } / { NAME } : { NAME } \" ) if NAME < NAME : await NAME . NAME ( NAME * NAME ) continue NAME . NAME ( f\" [ { NAME } ] Failed after { NAME } attempts \" ) return None return None"
    },
    {
      "module_path": "utils.py",
      "qualname": "async_batch_api_requests",
      "lineno": 4575,
      "end_lineno": 4636,
      "is_method": false,
      "is_async": true,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 9,
      "loc": 62,
      "tags": [
        "async",
        "impure",
        "network",
        "size:medium"
      ],
      "signature": "(requests, session_manager, max_concurrent, progress_callback)",
      "fingerprint": "44d5d35edb5c8fb0da0a25f4f13188569195058d",
      "simhash64": 7488180022980031571,
      "normalized": "async def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ LIT ] = None , NAME : NAME [ NAME ] = None , # PHASE 1: Allow None to use configured value NAME : NAME [ NAME [ [ NAME , NAME ] , None ] ] = None ) -> NAME [ NAME [ NAME [ NAME , NAME ] ] ] : LIT # PHASE 1: Use configured concurrency if not explicitly provided if NAME is None : NAME = NAME ( NAME = LIT ) NAME = NAME . NAME ( NAME ) async def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME [ NAME , NAME [ NAME [ NAME , NAME ] ] ] : async with NAME : NAME = await NAME ( NAME = NAME , ** NAME ) if NAME : NAME ( NAME + LIT , NAME ( NAME ) ) return NAME , NAME # Create tasks for all requests NAME = [ NAME ( NAME , NAME ) for NAME , NAME in NAME ( NAME ) ] # Execute all tasks concurrently NAME . NAME ( f\" Starting { NAME ( NAME ) } async API requests with max_concurrent= { NAME } \" ) NAME = await NAME . NAME ( * NAME , NAME = True ) # Sort results by original index and extract values NAME : NAME [ NAME [ NAME [ NAME , NAME ] ] ] = [ None ] * NAME ( NAME ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME . NAME ( f\" Async batch request failed: { NAME } \" ) continue if NAME ( NAME , NAME ) and NAME ( NAME ) == LIT : NAME , NAME = NAME NAME [ NAME ] = NAME NAME = NAME ( LIT for NAME in NAME if NAME is not None ) NAME . NAME ( f\" Completed async batch: { NAME } / { NAME ( NAME ) } successful \" ) return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "bounded_request",
      "lineno": 4606,
      "end_lineno": 4611,
      "is_method": false,
      "is_async": true,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "async",
        "impure",
        "network",
        "size:tiny"
      ],
      "signature": "(request_data, index)",
      "fingerprint": "bdd4f0f9b1b7ada1498a5a7fae05cd4f88e06e75",
      "simhash64": 7488180022980031571,
      "normalized": "async def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME [ NAME , NAME [ NAME [ NAME , NAME ] ] ] : async with NAME : NAME = await NAME ( NAME = NAME , ** NAME ) if NAME : NAME ( NAME + LIT , NAME ( NAME ) ) return NAME , NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "async_file_context",
      "lineno": 4650,
      "end_lineno": 4719,
      "is_method": false,
      "is_async": true,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 6,
      "yield_count": 2,
      "complexity": 4,
      "loc": 70,
      "tags": [
        "async",
        "impure",
        "filesystem",
        "json",
        "size:medium"
      ],
      "signature": "(file_path, mode, encoding, **kwargs)",
      "fingerprint": "0fdb9fc7696e1c8bcc22d25cf6e608b832e86f14",
      "simhash64": 7488109654235853843,
      "normalized": "async def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME = LIT , NAME : NAME = LIT , ** NAME ) : LIT NAME = NAME ( NAME ) if NAME and NAME is not None : # Use aiofiles for true async file I/O async with NAME . NAME ( NAME , NAME = NAME , NAME = NAME , ** NAME ) as NAME : # type: ignore NAME . NAME ( f\" Async file opened with aiofiles: { NAME } (mode: { NAME } ) \" ) yield NAME else : # Fallback to thread pool execution NAME = NAME . NAME ( ) def NAME ( ) -> NAME [ NAME ] : return NAME ( NAME ) . NAME ( NAME = NAME , NAME = NAME , ** NAME ) NAME = await NAME . NAME ( None , NAME ) try : NAME . NAME ( f\" Async file opened with thread pool: { NAME } (mode: { NAME } ) \" ) # Create async wrapper for file operations class NAME : def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME ) -> None : NAME . NAME = NAME NAME . NAME = NAME async def NAME ( NAME , NAME = - LIT ) : return await NAME . NAME . NAME ( None , NAME . NAME . NAME , NAME ) async def NAME ( NAME , NAME ) : return await NAME . NAME . NAME ( None , NAME . NAME . NAME , NAME ) async def NAME ( NAME ) : return await NAME . NAME . NAME ( None , NAME . NAME . NAME ) async def NAME ( NAME ) : return await NAME . NAME . NAME ( None , NAME . NAME . NAME ) def NAME ( NAME , NAME : NAME ) -> NAME : # Delegate other attributes to the underlying file return NAME ( NAME . NAME , NAME ) yield NAME ( NAME , NAME ) finally : await NAME . NAME ( None , NAME . NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "_open_file",
      "lineno": 4686,
      "end_lineno": 4687,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "impure",
        "filesystem",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "fa9e6e9a2f845696d29e612ac70121c62199d013",
      "simhash64": 7488109654236374099,
      "normalized": "def NAME ( ) -> NAME [ NAME ] : return NAME ( NAME ) . NAME ( NAME = NAME , NAME = NAME , ** NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "AsyncFileWrapper.__init__",
      "lineno": 4696,
      "end_lineno": 4698,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, file_handle, loop)",
      "fingerprint": "d3b96adf34c47a9141c9d921550477e4dabf44c7",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME ) -> None : NAME . NAME = NAME NAME . NAME = NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "AsyncFileWrapper.read",
      "lineno": 4700,
      "end_lineno": 4701,
      "is_method": true,
      "is_async": true,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "async",
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self, size)",
      "fingerprint": "e764260a91decb367e10ac75fcf864732c852650",
      "simhash64": 7487617078395319299,
      "normalized": "async def NAME ( NAME , NAME = - LIT ) : return await NAME . NAME . NAME ( None , NAME . NAME . NAME , NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "AsyncFileWrapper.write",
      "lineno": 4703,
      "end_lineno": 4704,
      "is_method": true,
      "is_async": true,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "async",
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self, data)",
      "fingerprint": "8d40446019d50b6ddc5a412be182cffaa8fa11cf",
      "simhash64": 7487617077321573379,
      "normalized": "async def NAME ( NAME , NAME ) : return await NAME . NAME . NAME ( None , NAME . NAME . NAME , NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "AsyncFileWrapper.readline",
      "lineno": 4706,
      "end_lineno": 4707,
      "is_method": true,
      "is_async": true,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "async",
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "812fa9c6f7dc5624d991a65a4d6d84e83b0044d9",
      "simhash64": 7487617077858444291,
      "normalized": "async def NAME ( NAME ) : return await NAME . NAME . NAME ( None , NAME . NAME . NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "AsyncFileWrapper.readlines",
      "lineno": 4709,
      "end_lineno": 4710,
      "is_method": true,
      "is_async": true,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "async",
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "812fa9c6f7dc5624d991a65a4d6d84e83b0044d9",
      "simhash64": 7487617077858444291,
      "normalized": "async def NAME ( NAME ) : return await NAME . NAME . NAME ( None , NAME . NAME . NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "AsyncFileWrapper.__getattr__",
      "lineno": 4712,
      "end_lineno": 4714,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self, name)",
      "fingerprint": "541819413370e53f09dc264172673a55ebe7aa4b",
      "simhash64": 7488250374544340083,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : # Delegate other attributes to the underlying file return NAME ( NAME . NAME , NAME )"
    },
    {
      "module_path": "utils.py",
      "qualname": "async_read_json_file",
      "lineno": 4722,
      "end_lineno": 4749,
      "is_method": false,
      "is_async": true,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 2,
      "loc": 28,
      "tags": [
        "async",
        "impure",
        "filesystem",
        "logging",
        "json",
        "size:small"
      ],
      "signature": "(file_path)",
      "fingerprint": "7b31a7d4f2450625b2b6642dd351c4cea965b130",
      "simhash64": 7452151225961067539,
      "normalized": "async def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME [ NAME , NAME ] ] : LIT try : async with NAME ( NAME , LIT ) as NAME : NAME = await NAME . NAME ( ) return NAME ( NAME ) except NAME : NAME . NAME ( f\" JSON file not found: { NAME } \" ) return None except NAME . NAME as NAME : NAME . NAME ( f\" Invalid JSON in file { NAME } : { NAME } \" ) return None except NAME as NAME : NAME . NAME ( f\" Error reading JSON file { NAME } : { NAME } \" ) return None"
    },
    {
      "module_path": "utils.py",
      "qualname": "async_write_json_file",
      "lineno": 4752,
      "end_lineno": 4791,
      "is_method": false,
      "is_async": true,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 40,
      "tags": [
        "async",
        "impure",
        "filesystem",
        "json",
        "size:medium"
      ],
      "signature": "(file_path, data, indent, ensure_ascii)",
      "fingerprint": "a2324a8d485e04d577329de55eab4742666b9ddf",
      "simhash64": 7488109654235853907,
      "normalized": "async def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] , NAME : NAME = LIT , NAME : NAME = False ) -> NAME : LIT try : # Create parent directory if it doesn't exist NAME = NAME ( NAME ) NAME . NAME . NAME ( NAME = True , NAME = True ) # Serialize JSON NAME = NAME ( NAME , NAME = NAME , NAME = NAME ) async with NAME ( NAME , LIT ) as NAME : await NAME . NAME ( NAME ) NAME . NAME ( f\" Successfully wrote JSON file: { NAME } \" ) return True except NAME as NAME : NAME . NAME ( f\" Error writing JSON file { NAME } : { NAME } \" ) return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "async_read_text_file",
      "lineno": 4794,
      "end_lineno": 4809,
      "is_method": false,
      "is_async": true,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "async",
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "(file_path)",
      "fingerprint": "35d7ef46c166f155eaa57d7535cf8258a7ec15be",
      "simhash64": 7452151225961067571,
      "normalized": "async def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME ] : LIT try : async with NAME ( NAME , LIT ) as NAME : return await NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" Error reading text file { NAME } : { NAME } \" ) return None"
    },
    {
      "module_path": "utils.py",
      "qualname": "async_write_text_file",
      "lineno": 4812,
      "end_lineno": 4835,
      "is_method": false,
      "is_async": true,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 24,
      "tags": [
        "async",
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "(file_path, content)",
      "fingerprint": "53bba0f18ef785dd66340c7efe6f8dfbe3b01467",
      "simhash64": 7488180022980031507,
      "normalized": "async def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME : LIT try : NAME = NAME ( NAME ) NAME . NAME . NAME ( NAME = True , NAME = True ) async with NAME ( NAME , LIT ) as NAME : await NAME . NAME ( NAME ) NAME . NAME ( f\" Successfully wrote text file: { NAME } \" ) return True except NAME as NAME : NAME . NAME ( f\" Error writing text file { NAME } : { NAME } \" ) return False"
    },
    {
      "module_path": "utils.py",
      "qualname": "async_batch_file_operations",
      "lineno": 4838,
      "end_lineno": 4919,
      "is_method": false,
      "is_async": true,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 13,
      "loc": 82,
      "tags": [
        "async",
        "pure-ish",
        "json",
        "size:medium"
      ],
      "signature": "(operations, max_concurrent, progress_callback)",
      "fingerprint": "b3740e405f9c40f2c60f1cb9862c1cd753bc838d",
      "simhash64": 7488180022981080083,
      "normalized": "async def NAME ( NAME : NAME [ NAME [ NAME , NAME ] ] , NAME : NAME [ NAME ] = None , # PHASE 1: Allow None to use configured value NAME : NAME [ NAME [ [ NAME , NAME ] , None ] ] = None ) -> NAME [ NAME ] : LIT # PHASE 1: Use configured concurrency if not explicitly provided if NAME is None : NAME = NAME ( NAME = LIT ) NAME = NAME . NAME ( NAME ) async def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME [ NAME , NAME ] : async with NAME : try : NAME = NAME [ LIT ] NAME = NAME [ LIT ] if NAME == LIT : NAME = await NAME ( NAME ) NAME = NAME is not None elif NAME == LIT : NAME = await NAME ( NAME , NAME [ LIT ] ) elif NAME == LIT : NAME = await NAME ( NAME ) NAME = NAME is not None elif NAME == LIT : NAME = await NAME ( NAME , NAME [ LIT ] ) else : NAME . NAME ( f\" Unknown operation type: { NAME } \" ) NAME = False if NAME : NAME ( NAME + LIT , NAME ( NAME ) ) return NAME , NAME except NAME as NAME : NAME . NAME ( f\" File operation { NAME } failed: { NAME } \" ) return NAME , False # Create tasks for all operations NAME = [ NAME ( NAME , NAME ) for NAME , NAME in NAME ( NAME ) ] # Execute all tasks concurrently NAME . NAME ( f\" Starting { NAME ( NAME ) } async file operations with max_concurrent= { NAME } \" ) NAME = await NAME . NAME ( * NAME , NAME = True ) # Sort results by original index and extract success values NAME = [ False ] * NAME ( NAME ) for NAME in NAME : if NAME ( NAME , NAME ) : NAME . NAME ( f\" Async file operation failed: { NAME } \" ) continue if NAME ( NAME , NAME ) and NAME ( NAME ) == LIT : NAME , NAME = NAME NAME [ NAME ] = NAME NAME = NAME ( NAME ) NAME . NAME ( f\" Completed async file operations: { NAME } / { NAME ( NAME ) } successful \" ) return NAME"
    },
    {
      "module_path": "utils.py",
      "qualname": "bounded_operation",
      "lineno": 4867,
      "end_lineno": 4894,
      "is_method": false,
      "is_async": true,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 7,
      "loc": 28,
      "tags": [
        "async",
        "pure-ish",
        "size:small"
      ],
      "signature": "(operation, index)",
      "fingerprint": "4f88ae1c7da43006e36f3abadbdd759ce6cd85f8",
      "simhash64": 7488180022980031507,
      "normalized": "async def NAME ( NAME : NAME [ NAME , NAME ] , NAME : NAME ) -> NAME [ NAME , NAME ] : async with NAME : try : NAME = NAME [ LIT ] NAME = NAME [ LIT ] if NAME == LIT : NAME = await NAME ( NAME ) NAME = NAME is not None elif NAME == LIT : NAME = await NAME ( NAME , NAME [ LIT ] ) elif NAME == LIT : NAME = await NAME ( NAME ) NAME = NAME is not None elif NAME == LIT : NAME = await NAME ( NAME , NAME [ LIT ] ) else : NAME . NAME ( f\" Unknown operation type: { NAME } \" ) NAME = False if NAME : NAME ( NAME + LIT , NAME ( NAME ) ) return NAME , NAME except NAME as NAME : NAME . NAME ( f\" File operation { NAME } failed: { NAME } \" ) return NAME , False"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.__init__",
      "lineno": 96,
      "end_lineno": 123,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 28,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self, config_file, environment, auto_load)",
      "fingerprint": "0140fbbd52cd79ecde6db97719cecea80d163e11",
      "simhash64": 7452151226028176407,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME [ NAME ] = None , NAME : NAME = True , ) : LIT # Load .env file if available if NAME : NAME ( ) NAME . NAME = NAME ( NAME ) if NAME else None NAME . NAME = NAME or NAME . NAME ( LIT , LIT ) NAME . NAME : NAME [ NAME ] = None NAME . NAME : NAME [ NAME ] = None # Supported file formats NAME . NAME = { LIT , LIT , LIT , LIT } if NAME : NAME . NAME ( )"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.load_config",
      "lineno": 125,
      "end_lineno": 177,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 53,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "54c0c5914bdcf1a44e648c88eb0efe5dc32a0870",
      "simhash64": 7488144838607942675,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME . NAME ( f\" Loading configuration for environment: { NAME . NAME } \" ) # Start with default configuration NAME = NAME . NAME ( ) # Load from configuration file if specified if NAME . NAME and NAME . NAME . NAME ( ) : NAME = NAME . NAME ( ) NAME = NAME . NAME ( NAME , NAME ) # Override with environment variables NAME = NAME . NAME ( ) NAME = NAME . NAME ( NAME , NAME ) # Create and validate configuration schema try : NAME = NAME . NAME ( NAME ) # Validate configuration NAME = NAME . NAME ( ) if NAME : raise NAME ( f\" Configuration validation failed: { NAME } \" ) # Cache the configuration NAME . NAME = NAME if NAME . NAME : NAME . NAME = NAME . NAME . NAME ( ) . NAME NAME . NAME ( f\" Configuration loaded successfully for environment: { NAME . NAME } \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Failed to load configuration: { NAME } \" ) raise NAME ( f\" Configuration loading failed: { NAME } \" )"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.get_config",
      "lineno": 179,
      "end_lineno": 198,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 20,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self, reload_if_changed)",
      "fingerprint": "1bf3797e31183914df0b3f1fc97b4363275885dd",
      "simhash64": 8641136711958959107,
      "normalized": "def NAME ( NAME , NAME : NAME = True ) -> NAME : LIT # Check if configuration file has changed if NAME and NAME . NAME ( ) : NAME . NAME ( LIT ) return NAME . NAME ( ) # Return cached configuration or load if not cached if NAME . NAME is None : return NAME . NAME ( ) return NAME . NAME"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.reload_config",
      "lineno": 200,
      "end_lineno": 209,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "66df6b7676ec1dec05f8f47a9f51871d183639ef",
      "simhash64": 8641031712893481987,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME . NAME = None NAME . NAME = None return NAME . NAME ( )"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.validate_config",
      "lineno": 211,
      "end_lineno": 234,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 5,
      "loc": 24,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self, config_data)",
      "fingerprint": "aa132f1325dd1a025b3759e118107727e09a1c54",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None ) -> NAME [ NAME ] : LIT if NAME is None : if NAME . NAME is None : NAME . NAME ( ) if NAME . NAME is not None : return NAME . NAME . NAME ( ) return [ LIT ] try : NAME = NAME . NAME ( NAME ) return NAME . NAME ( ) except NAME as NAME : return [ f\" Configuration validation error: { NAME } \" ]"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.get_environment_config",
      "lineno": 236,
      "end_lineno": 254,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self, env_name)",
      "fingerprint": "b830c4f4d5ef8192f05602684f4792c447cf6e47",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME NAME . NAME = NAME try : NAME = NAME . NAME ( ) return NAME . NAME ( ) finally : NAME . NAME = NAME NAME . NAME = None # Clear cache to avoid confusion"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.export_config",
      "lineno": 256,
      "end_lineno": 287,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 32,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:medium"
      ],
      "signature": "(self, output_file, format)",
      "fingerprint": "66d0835b91350401d4c3d7b62561393f79754134",
      "simhash64": 7488180022980023323,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME = LIT ) -> NAME : LIT try : NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) NAME = NAME ( NAME ) if NAME . NAME ( ) == LIT : with NAME . NAME ( LIT , NAME = LIT ) as NAME : NAME . NAME ( NAME , NAME , NAME = LIT , NAME = NAME ) else : NAME . NAME ( f\" Unsupported export format: { NAME } \" ) return False NAME . NAME ( f\" Configuration exported to { NAME } \" ) return True except NAME as NAME : NAME . NAME ( f\" Failed to export configuration: { NAME } \" ) return False"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager._get_default_config",
      "lineno": 289,
      "end_lineno": 313,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 25,
      "tags": [
        "impure",
        "network",
        "logging",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "d80435798fc2f08c6cd17dd9832c6c6d12fe2834",
      "simhash64": 7452854880176608815,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT # PHASE 2 ENHANCEMENT: Auto-detect optimal settings (simplified for now) NAME = { LIT : NAME . NAME , LIT : NAME . NAME == LIT , LIT : LIT , LIT : LIT , LIT : { } , LIT : { } , LIT : { } , LIT : { } , LIT : { } , LIT : { } , } # Add basic auto-detected batch size try : import NAME NAME = NAME . NAME ( NAME = True ) or LIT NAME [ LIT ] = NAME ( NAME * LIT , LIT ) # Adaptive batch size except NAME : pass return NAME"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager._auto_detect_optimal_settings",
      "lineno": 315,
      "end_lineno": 410,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 96,
      "tags": [
        "impure",
        "network",
        "logging",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "875cdfdbe1c299dd1c68f12c9b6ce98cca24087e",
      "simhash64": 5145886005414762027,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT try : import NAME # System capabilities NAME = NAME . NAME ( NAME = True ) or LIT NAME = NAME . NAME ( ) . NAME / ( LIT ** LIT ) NAME = NAME . NAME ( LIT ) . NAME / ( LIT ** LIT ) # Auto-detect API settings NAME = { LIT : NAME ( NAME * LIT , LIT ) , # 2x CPU cores, max 16 LIT : NAME ( NAME * LIT , LIT ) , # Conservative for stability LIT : LIT if NAME >= LIT else LIT , # Shorter timeout for high-memory systems LIT : LIT , LIT : LIT , } # Auto-detect cache settings NAME = NAME ( NAME ( NAME * LIT * LIT ) , LIT ) # 10% of RAM, max 1GB NAME = NAME ( NAME ( NAME * LIT * LIT ) , LIT ) # 5% of free disk, max 2GB NAME = { LIT : NAME , LIT : NAME , LIT : LIT , # 1 hour LIT : LIT , # 24 hours LIT : True , } # Auto-detect database settings NAME = NAME ( NAME + LIT , LIT ) # CPU cores + 2, max 10 NAME = { LIT : NAME , LIT : NAME ( LIT , NAME ( NAME * LIT ) ) , LIT : LIT , LIT : NAME ( NAME ( NAME * LIT * LIT ) , LIT ) , # 5% of RAM for DB cache, max 512MB } # Auto-detect Selenium settings based on system performance NAME = { LIT : True , # Default to headless for better performance LIT : LIT , LIT : LIT if NAME >= LIT else LIT , LIT : LIT , LIT : NAME < LIT , # Disable images on low-memory systems } # Auto-detect logging level based on environment and system if NAME . NAME == LIT : NAME = LIT elif NAME . NAME == LIT : NAME = LIT else : NAME = LIT NAME = { LIT : NAME , LIT : True , LIT : NAME ( NAME ( NAME * LIT * LIT ) , LIT ) , # 1% of free disk, max 100MB LIT : LIT , } # Auto-detect security settings NAME = { LIT : True , LIT : True , LIT : LIT , LIT : True , LIT : True , } NAME = { LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME , LIT : NAME ( NAME * LIT , LIT ) , # Adaptive batch size LIT : NAME ( NAME * LIT , LIT ) , # Scale with CPU } NAME . NAME ( f\" Auto-detected configuration: CPU= { NAME } , RAM= { NAME : .1f } GB, Disk= { NAME : .1f } GB \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Auto-detection failed, using defaults: { NAME } \" ) return { }"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.validate_system_requirements",
      "lineno": 412,
      "end_lineno": 497,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 12,
      "loc": 86,
      "tags": [
        "impure",
        "network",
        "db",
        "filesystem",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "0b26a4871e673eaf53cd9dc85481b4272a315da9",
      "simhash64": 7452151227101910059,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT try : import NAME import NAME NAME = { LIT : True , LIT : [ ] , LIT : [ ] , LIT : [ ] , LIT : { } } # Check system resources NAME = NAME . NAME ( NAME = True ) or LIT NAME = NAME . NAME ( ) . NAME / ( LIT ** LIT ) NAME = NAME . NAME ( LIT ) . NAME / ( LIT ** LIT ) NAME [ LIT ] = { LIT : NAME , LIT : NAME ( NAME , LIT ) , LIT : NAME ( NAME , LIT ) } # Validate minimum requirements if NAME < LIT : NAME [ LIT ] . NAME ( f\" Low CPU count ( { NAME } ). Recommend at least 2 cores for optimal performance. \" ) if NAME < LIT : NAME [ LIT ] . NAME ( f\" Insufficient memory ( { NAME : .1f } GB). Minimum 4GB required. \" ) NAME [ LIT ] = False if NAME < LIT : NAME [ LIT ] . NAME ( f\" Insufficient disk space ( { NAME : .1f } GB). Minimum 1GB free space required. \" ) NAME [ LIT ] = False # Check for optimal performance if NAME >= LIT : NAME [ LIT ] . NAME ( LIT ) if NAME >= LIT : NAME [ LIT ] . NAME ( LIT ) # Check Python dependencies try : from NAME . NAME import NAME NAME = [ LIT , LIT , LIT ] NAME [ LIT ] = NAME ( NAME ( NAME ) is not None for NAME in NAME ) except NAME as NAME : NAME [ LIT ] . NAME ( f\" Missing required dependency: { NAME } \" ) NAME [ LIT ] = False # Check Chrome/ChromeDriver availability NAME = NAME . NAME ( LIT ) or NAME . NAME ( LIT ) or NAME . NAME ( LIT ) if not NAME : NAME [ LIT ] . NAME ( LIT ) return NAME except NAME as NAME : return { LIT : False , LIT : [ f\" System validation failed: { NAME } \" ] , LIT : [ ] , LIT : [ ] , LIT : { } }"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.run_setup_wizard",
      "lineno": 499,
      "end_lineno": 569,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 12,
      "loc": 71,
      "tags": [
        "impure",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(self, interactive)",
      "fingerprint": "282c3932478129f02d5a0e8a463cdea8334ffc6a",
      "simhash64": 7469637859962950699,
      "normalized": "def NAME ( NAME , NAME : NAME = True ) -> NAME : LIT try : NAME ( LIT ) NAME ( LIT * LIT ) # Validate system requirements NAME = NAME . NAME ( ) NAME ( LIT ) NAME = NAME . NAME ( LIT , { } ) NAME ( f\" CPU Cores: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" Memory: { NAME . NAME ( LIT , LIT ) } GB \" ) NAME ( f\" Free Disk: { NAME . NAME ( LIT , LIT ) } GB \" ) # Show validation results if NAME . NAME ( LIT ) : NAME ( LIT ) for NAME in NAME [ LIT ] : NAME ( f\" \u2022 { NAME } \" ) if NAME . NAME ( LIT ) : NAME ( LIT ) for NAME in NAME [ LIT ] : NAME ( f\" \u2022 { NAME } \" ) if NAME . NAME ( LIT ) : NAME ( LIT ) for NAME in NAME [ LIT ] : NAME ( f\" \u2022 { NAME } \" ) if not NAME . NAME ( LIT ) : NAME ( LIT ) return False NAME ( LIT ) # Auto-detect and show optimal settings NAME = NAME . NAME ( ) NAME ( LIT ) NAME = NAME . NAME ( LIT , { } ) NAME ( f\" Concurrency: { NAME . NAME ( LIT , LIT ) } \" ) NAME ( f\" Thread Pool: { NAME . NAME ( LIT , LIT ) } \" ) NAME = NAME . NAME ( LIT , { } ) NAME ( f\" Memory Cache: { NAME . NAME ( LIT , LIT ) } MB \" ) NAME ( f\" Disk Cache: { NAME . NAME ( LIT , LIT ) } MB \" ) if NAME : NAME = NAME ( LIT ) . NAME ( ) . NAME ( ) if NAME and NAME not in { LIT , LIT } : NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) return True except NAME as NAME : NAME ( f\" \\n\u274c Setup wizard failed: { NAME } \" ) return False"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager._load_config_file",
      "lineno": 571,
      "end_lineno": 587,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 17,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "a3fdc5b07c13d1bb18b57d1619f2dd448fd449a5",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT if not NAME . NAME or not NAME . NAME . NAME ( ) : return { } try : NAME = NAME . NAME . NAME . NAME ( ) if NAME == LIT : with NAME . NAME . NAME ( NAME = LIT ) as NAME : return NAME . NAME ( NAME ) else : NAME . NAME ( f\" Unsupported config file format: { NAME } \" ) return { } except NAME as NAME : NAME . NAME ( f\" Failed to load config file { NAME . NAME } : { NAME } \" ) return { }"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager._load_environment_variables",
      "lineno": 589,
      "end_lineno": 935,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 84,
      "loc": 347,
      "tags": [
        "impure",
        "network",
        "filesystem",
        "logging",
        "size:large"
      ],
      "signature": "(self)",
      "fingerprint": "bfd7746d8bc208bc723b9832fcce6c07e6c70dd7",
      "simhash64": 7488180023047140379,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = { } # Load main configuration NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME . NAME ( ) in ( LIT , LIT , LIT , ) NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME # Load reference person configuration NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME # Load user configuration NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME # Load testing configuration NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME # Load application mode NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME # Load AI configuration NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid AI_CONTEXT_MESSAGES_COUNT: { NAME } \" ) NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid AI_CONTEXT_MESSAGE_MAX_WORDS: { NAME } \" ) NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid AI_CONTEXT_WINDOW_MESSAGES: { NAME } \" ) # Proactive refresh cooldown (seconds) NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid PROACTIVE_REFRESH_COOLDOWN: { NAME } \" ) # Proactive refresh interval (seconds) NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid PROACTIVE_REFRESH_INTERVAL: { NAME } \" ) # Action 6 coord timeout (seconds) NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid ACTION6_COORD_TIMEOUT: { NAME } \" ) # Load API configuration NAME = { } # DeepSeek API configuration NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME # Google API configuration NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME if NAME : NAME [ LIT ] = NAME # Load database configuration NAME = { } NAME = NAME . NAME ( LIT ) if NAME : # Enforce canonical project-relative DB path when a relative ancestry.db is provided NAME = NAME ( NAME ) if not NAME . NAME ( ) and NAME . NAME . NAME ( ) == LIT : # Normalize to canonical Data/ancestry.db within project NAME [ LIT ] = NAME ( LIT ) / LIT else : # Respect absolute or custom filenames NAME [ LIT ] = NAME else : # Default to canonical project DB path NAME [ LIT ] = NAME ( LIT ) / LIT NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME ( NAME ) NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid DB_POOL_SIZE value: { NAME } \" ) NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME if NAME : NAME [ LIT ] = NAME # Load Selenium configuration NAME = { } NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME ( NAME ) NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME ( NAME ) NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME ( NAME ) NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME . NAME ( ) in ( LIT , LIT , LIT , ) NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid DEBUG_PORT value: { NAME } \" ) if NAME : NAME [ LIT ] = NAME # Merge additional API configuration with existing api_config if LIT not in NAME : NAME [ LIT ] = { } NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] [ LIT ] = NAME NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] [ LIT ] = NAME NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid REQUEST_TIMEOUT value: { NAME } \" ) NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] [ LIT ] = NAME NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] [ LIT ] = NAME # Load processing limit configuration (Action 6 lessons) NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid MAX_PAGES value: { NAME } \" ) # Load batch size configuration NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid BATCH_SIZE value: { NAME } \" ) # Load matches per page configuration NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid MATCHES_PER_PAGE value: { NAME } \" ) # Load optional concurrency override for Action 6 NAME = NAME . NAME ( LIT ) if NAME : try : # Mirror under API scope since APIConfig owns concurrency affecting API calls if LIT not in NAME : NAME [ LIT ] = { } NAME [ LIT ] [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid MAX_CONCURRENCY value: { NAME } \" ) # Load thread pool workers override for Action 6 NAME = NAME . NAME ( LIT ) if NAME : try : # Store under API scope for consistency with max_concurrency if LIT not in NAME : NAME [ LIT ] = { } NAME [ LIT ] [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid THREAD_POOL_WORKERS value: { NAME } \" ) # Load max productive to process configuration NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid MAX_PRODUCTIVE_TO_PROCESS value: { NAME } \" ) # Load max inbox configuration NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid MAX_INBOX value: { NAME } \" ) # Load logging configuration NAME = { } NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME ( NAME ) NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid MAX_LOG_SIZE_MB value: { NAME } \" ) if NAME : NAME [ LIT ] = NAME # Load cache configuration NAME = { } NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = NAME ( NAME ) NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid MEMORY_CACHE_SIZE value: { NAME } \" ) NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid DISK_CACHE_SIZE_MB value: { NAME } \" ) if NAME : NAME [ LIT ] = NAME # Load security configuration NAME = { } NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = ( NAME . NAME ( ) in ( LIT , LIT , LIT ) ) NAME = NAME . NAME ( LIT ) if NAME : NAME [ LIT ] = ( NAME . NAME ( ) in ( LIT , LIT , LIT ) ) NAME = NAME . NAME ( LIT ) if NAME : try : NAME [ LIT ] = NAME ( NAME ) except NAME : NAME . NAME ( f\" Invalid SESSION_TIMEOUT_MINUTES value: { NAME } \" ) if NAME : NAME [ LIT ] = NAME return NAME"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager._merge_configs",
      "lineno": 937,
      "end_lineno": 962,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, base, override)",
      "fingerprint": "65f98ca4aa5d2e3ab55a7e7924efb2ed5e073451",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME [ NAME , NAME ] ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME ( NAME ) for NAME , NAME in NAME . NAME ( ) : if ( NAME in NAME and NAME ( NAME [ NAME ] , NAME ) and NAME ( NAME , NAME ) ) : NAME [ NAME ] = NAME . NAME ( NAME [ NAME ] , NAME ) else : NAME [ NAME ] = NAME return NAME"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager._should_reload",
      "lineno": 964,
      "end_lineno": 973,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "1cdf95081cae4f5f8e6d7306969f61fafb6c8908",
      "simhash64": 8641031158842696707,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME . NAME or not NAME . NAME . NAME ( ) : return False if NAME . NAME is None : return True NAME = NAME . NAME . NAME ( ) . NAME return NAME > NAME . NAME"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.get_database_config",
      "lineno": 975,
      "end_lineno": 977,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5876a8ab9d8c530886aa6ea2498349a784932952",
      "simhash64": 7487652257398694915,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME ( ) . NAME"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.get_selenium_config",
      "lineno": 979,
      "end_lineno": 981,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "impure",
        "network",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5876a8ab9d8c530886aa6ea2498349a784932952",
      "simhash64": 7487652257398694915,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME ( ) . NAME"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.get_api_config",
      "lineno": 983,
      "end_lineno": 985,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5876a8ab9d8c530886aa6ea2498349a784932952",
      "simhash64": 7487652257398694915,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME ( ) . NAME"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.get_logging_config",
      "lineno": 987,
      "end_lineno": 989,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5876a8ab9d8c530886aa6ea2498349a784932952",
      "simhash64": 7487652257398694915,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME ( ) . NAME"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.get_cache_config",
      "lineno": 991,
      "end_lineno": 993,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5876a8ab9d8c530886aa6ea2498349a784932952",
      "simhash64": 7487652257398694915,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME ( ) . NAME"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "ConfigManager.get_security_config",
      "lineno": 995,
      "end_lineno": 997,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5876a8ab9d8c530886aa6ea2498349a784932952",
      "simhash64": 7487652257398694915,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME ( ) . NAME"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 1000,
      "end_lineno": 1251,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 14,
      "loc": 252,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "json",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "30d9446488cd52db6b8b1b7d944585820db3a02f",
      "simhash64": 5145885970996302891,
      "normalized": "def NAME ( ) -> NAME : LIT import NAME import NAME from NAME import NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) # INITIALIZATION TESTS def NAME ( ) : LIT assert NAME ( NAME ) , LIT # Test basic instantiation try : NAME = NAME ( NAME = False ) assert NAME is not None , LIT assert NAME . NAME in [ LIT , LIT , LIT , ] , LIT except NAME : # May require specific configuration files pass def NAME ( ) : LIT # Test ConfigManager methods exist NAME = NAME ( NAME = False ) assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT # CORE FUNCTIONALITY TESTS def NAME ( ) : LIT NAME = NAME ( NAME = False ) # Test default config loading NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT def NAME ( ) : LIT NAME = NAME ( NAME = False ) # Test getter methods exist assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT # EDGE CASE TESTS def NAME ( ) : LIT # Test with non-existent config file try : NAME = NAME ( NAME = LIT , NAME = False ) assert NAME is not None , LIT except NAME : # Exception handling is acceptable pass def NAME ( ) : LIT NAME = NAME ( NAME = False ) # Test validation with various invalid inputs NAME = [ None , LIT , LIT , [ ] ] for NAME in NAME : try : NAME = NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT except NAME : # Exception handling is acceptable for invalid inputs pass # INTEGRATION TESTS def NAME ( ) : LIT with NAME . NAME ( NAME = LIT , NAME = LIT , NAME = False ) as NAME : NAME = { LIT : LIT , LIT : LIT } import NAME NAME . NAME ( NAME , NAME ) NAME = NAME . NAME try : NAME = NAME ( NAME = NAME , NAME = False ) NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT except NAME : pass finally : from NAME import NAME with NAME . NAME ( NAME ) : NAME ( NAME ) . NAME ( NAME = True ) def NAME ( ) : LIT import NAME # Test environment variable access NAME = LIT NAME = LIT NAME . NAME [ NAME ] = NAME try : NAME = NAME ( NAME = False ) NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT finally : NAME . NAME . NAME ( NAME , None ) # PERFORMANCE TESTS def NAME ( ) : LIT NAME = NAME ( NAME = False ) NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : # Reduced for reliability try : NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT except NAME : pass NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 10 config access operations should be fast, took { NAME : .3f } s \" # ERROR HANDLING TESTS def NAME ( ) : LIT NAME = [ ( LIT , LIT ) , ( LIT , LIT ) , ( None , LIT ) , ] for NAME , NAME in NAME : try : NAME = NAME ( NAME = NAME , NAME = False ) # Should handle gracefully assert NAME is not None or NAME is None except NAME : # Exception handling is acceptable for invalid inputs pass # Run all tests NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "test_config_manager_initialization",
      "lineno": 1014,
      "end_lineno": 1029,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b61c5190b91b8723c2748c99b21100e36e416130",
      "simhash64": 5146448954303353903,
      "normalized": "def NAME ( ) : LIT assert NAME ( NAME ) , LIT # Test basic instantiation try : NAME = NAME ( NAME = False ) assert NAME is not None , LIT assert NAME . NAME in [ LIT , LIT , LIT , ] , LIT except NAME : # May require specific configuration files pass"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "test_config_validation",
      "lineno": 1031,
      "end_lineno": 1037,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "54a7a4cb736f224e8a74a8cb083056f789b3d454",
      "simhash64": 5145885970997875755,
      "normalized": "def NAME ( ) : LIT # Test ConfigManager methods exist NAME = NAME ( NAME = False ) assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "test_config_loading",
      "lineno": 1040,
      "end_lineno": 1048,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "9cb9328400a99029bc49024fc6fb0549b6cdb699",
      "simhash64": 7488320761542120507,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( NAME = False ) # Test default config loading NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT assert LIT in NAME , LIT assert LIT in NAME , LIT"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "test_config_access",
      "lineno": 1050,
      "end_lineno": 1061,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "1672cd9af7524ede15c29023cb914d142a9b6b55",
      "simhash64": 5145885970997875755,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( NAME = False ) # Test getter methods exist assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "test_missing_config_handling",
      "lineno": 1064,
      "end_lineno": 1074,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "json",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f101a07ab304997e01f1b13c282461342ea542fd",
      "simhash64": 6300497424976615039,
      "normalized": "def NAME ( ) : LIT # Test with non-existent config file try : NAME = NAME ( NAME = LIT , NAME = False ) assert NAME is not None , LIT except NAME : # Exception handling is acceptable pass"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "test_invalid_config_data",
      "lineno": 1076,
      "end_lineno": 1091,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ed244d1467a0a8fc0fec3e70a6c72e572efb4302",
      "simhash64": 7488320727251063871,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( NAME = False ) # Test validation with various invalid inputs NAME = [ None , LIT , LIT , [ ] ] for NAME in NAME : try : NAME = NAME . NAME ( NAME ) assert NAME ( NAME , NAME ) , LIT except NAME : # Exception handling is acceptable for invalid inputs pass"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "test_config_file_integration",
      "lineno": 1094,
      "end_lineno": 1113,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 20,
      "tags": [
        "impure",
        "filesystem",
        "json",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "037e826628bf0eb7199acc5e817b83ef76df53da",
      "simhash64": 7488109655309587483,
      "normalized": "def NAME ( ) : LIT with NAME . NAME ( NAME = LIT , NAME = LIT , NAME = False ) as NAME : NAME = { LIT : LIT , LIT : LIT } import NAME NAME . NAME ( NAME , NAME ) NAME = NAME . NAME try : NAME = NAME ( NAME = NAME , NAME = False ) NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT except NAME : pass finally : from NAME import NAME with NAME . NAME ( NAME ) : NAME ( NAME ) . NAME ( NAME = True )"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "test_environment_integration",
      "lineno": 1115,
      "end_lineno": 1132,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 18,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "57a279d70bf323b86f227b9e18748a18061ff843",
      "simhash64": 7452151225961059347,
      "normalized": "def NAME ( ) : LIT import NAME # Test environment variable access NAME = LIT NAME = LIT NAME . NAME [ NAME ] = NAME try : NAME = NAME ( NAME = False ) NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT finally : NAME . NAME . NAME ( NAME , None )"
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "test_config_access_performance",
      "lineno": 1135,
      "end_lineno": 1150,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5aff32d4fe0d6d38b48ea7638b23b3138d67e00f",
      "simhash64": 7488355911554470971,
      "normalized": "def NAME ( ) : LIT NAME = NAME ( NAME = False ) NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : # Reduced for reliability try : NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT except NAME : pass NAME = NAME . NAME ( ) - NAME assert ( NAME < LIT ) , f\" 10 config access operations should be fast, took { NAME : .3f } s \""
    },
    {
      "module_path": "config\\config_manager.py",
      "qualname": "test_config_error_handling",
      "lineno": 1153,
      "end_lineno": 1168,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 16,
      "tags": [
        "pure-ish",
        "json",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6903b786d61ec2df4678b0bd8dc153a577a3c6e7",
      "simhash64": 5183603615796728879,
      "normalized": "def NAME ( ) : LIT NAME = [ ( LIT , LIT ) , ( LIT , LIT ) , ( None , LIT ) , ] for NAME , NAME in NAME : try : NAME = NAME ( NAME = NAME , NAME = False ) # Should handle gracefully assert NAME is not None or NAME is None except NAME : # Exception handling is acceptable for invalid inputs pass"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "ConfigValidator.__init__",
      "lineno": 62,
      "end_lineno": 64,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "73af8679dfbb13818e0f74826b0e0d997cdbac9f",
      "simhash64": 7452151226028176469,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME : NAME [ NAME , NAME [ NAME ] ] = { }"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "ConfigValidator.add_rule",
      "lineno": 66,
      "end_lineno": 68,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, rule)",
      "fingerprint": "c2664991185302329ef95477bb2bd28562c3caf0",
      "simhash64": 7488180024053769219,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "ConfigValidator.add_environment_rule",
      "lineno": 70,
      "end_lineno": 74,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, env, rule)",
      "fingerprint": "e7bb2f3c855b0a7289faaa767c879f5f6eb1a657",
      "simhash64": 7488180022980031571,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> None : LIT if NAME not in NAME . NAME : NAME . NAME [ NAME ] = [ ] NAME . NAME [ NAME ] . NAME ( NAME )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "ConfigValidator.validate",
      "lineno": 76,
      "end_lineno": 111,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 16,
      "loc": 36,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, config, environment)",
      "fingerprint": "8824085886bcd6fc9c31035cfc79f8b274afa581",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME = NAME . NAME ) -> NAME [ NAME ] : LIT NAME = [ ] # Apply general rules for NAME in NAME . NAME : if NAME ( NAME , NAME . NAME ) : NAME = NAME ( NAME , NAME . NAME ) if NAME is None and NAME . NAME : NAME . NAME ( f\" Required field { NAME . NAME } is missing \" ) elif NAME is not None and not NAME . NAME ( NAME ) : NAME . NAME ( NAME . NAME ) elif NAME . NAME : NAME . NAME ( f\" Required field { NAME . NAME } is missing \" ) # Apply environment-specific rules if NAME in NAME . NAME : for NAME in NAME . NAME [ NAME ] : if NAME ( NAME , NAME . NAME ) : NAME = NAME ( NAME , NAME . NAME ) if NAME is None and NAME . NAME : NAME . NAME ( f\" Environment-required field { NAME . NAME } is missing for { NAME . NAME } \" ) elif NAME is not None and not NAME . NAME ( NAME ) : NAME . NAME ( f\" { NAME . NAME } (environment: { NAME . NAME } ) \" ) elif NAME . NAME : NAME . NAME ( f\" Environment-required field { NAME . NAME } is missing for { NAME . NAME } \" ) return NAME"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "validate_path_exists",
      "lineno": 114,
      "end_lineno": 116,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "impure",
        "filesystem",
        "purpose:validation",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(path)",
      "fingerprint": "6e6a12d2b7899921990fe14ea31f7df4a72d1dd2",
      "simhash64": 7488180022980031587,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : LIT return NAME ( NAME ) . NAME ( ) if NAME else False"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "validate_file_extension",
      "lineno": 119,
      "end_lineno": 130,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "impure",
        "filesystem",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(extensions)",
      "fingerprint": "5e7356cc00a46e7c058236b1aff0a4bb5a9aa4c1",
      "simhash64": 7488180022980031571,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , ) -> NAME [ [ NAME [ NAME , NAME ] ] , NAME ] : LIT def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : if not NAME : return True # Allow None/empty values NAME = NAME ( NAME ) return NAME . NAME . NAME ( ) in [ NAME . NAME ( ) for NAME in NAME ] return NAME"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "validator",
      "lineno": 124,
      "end_lineno": 128,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 5,
      "tags": [
        "impure",
        "filesystem",
        "size:tiny"
      ],
      "signature": "(path)",
      "fingerprint": "aace3143be9995090849fc78d310fc6e8e90f0dc",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME [ NAME , NAME ] ) -> NAME : if not NAME : return True # Allow None/empty values NAME = NAME ( NAME ) return NAME . NAME . NAME ( ) in [ NAME . NAME ( ) for NAME in NAME ]"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "validate_port_range",
      "lineno": 133,
      "end_lineno": 135,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(port)",
      "fingerprint": "764c9d4a9ab6b2b0c298b98da743890a5a9e1992",
      "simhash64": 5150943758910915627,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return LIT <= NAME <= LIT"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "validate_positive_integer",
      "lineno": 138,
      "end_lineno": 140,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(value)",
      "fingerprint": "0d6849b0f3c58e2202a709086ee1c12c543fa133",
      "simhash64": 7487617074100339747,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : LIT return NAME ( NAME , NAME ) and NAME > LIT"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "DatabaseConfig.__post_init__",
      "lineno": 180,
      "end_lineno": 205,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 26,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "105274aaa956c06f5d14d92331505ac6be05a95e",
      "simhash64": 7488215207352116243,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME = NAME . NAME ( ) NAME = NAME . NAME ( NAME , NAME . NAME ( ) ) if NAME : NAME = LIT + LIT . NAME ( f\" - { NAME } \" for NAME in NAME ) NAME . NAME ( NAME ) raise NAME ( NAME ) # Convert string paths to Path objects if NAME ( NAME . NAME , NAME ) : NAME . NAME = NAME ( NAME . NAME ) if NAME ( NAME . NAME , NAME ) : NAME . NAME = NAME ( NAME . NAME ) if NAME ( NAME . NAME , NAME ) : NAME . NAME = NAME ( NAME . NAME ) # Create directories if they don't exist NAME . NAME ( ) NAME . NAME ( f\" Database configuration validated successfully for { NAME . NAME ( ) . NAME } environment \" )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "DatabaseConfig._get_validator",
      "lineno": 207,
      "end_lineno": 296,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 90,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "4b7658a5fc4531b38ce2bbffc35338d8f040e9b5",
      "simhash64": 7487617074100868139,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME ( ) # General validation rules NAME . NAME ( NAME ( LIT , NAME , LIT , ) ) NAME . NAME ( NAME ( LIT , lambda NAME : NAME ( NAME , NAME ) and NAME >= LIT , LIT , ) ) NAME . NAME ( NAME ( LIT , lambda NAME : NAME ( NAME , NAME ) and NAME > LIT , LIT , ) ) NAME . NAME ( NAME ( LIT , lambda NAME : NAME in [ LIT , LIT , LIT , LIT , LIT , LIT ] , LIT , ) ) NAME . NAME ( NAME ( LIT , lambda NAME : NAME in [ LIT , LIT , LIT , LIT ] , LIT , ) ) NAME . NAME ( NAME ( LIT , lambda NAME : NAME ( NAME , NAME ) and LIT <= NAME <= LIT , # 1 hour to 1 week LIT , ) ) NAME . NAME ( NAME ( LIT , lambda NAME : NAME ( NAME , NAME ) and LIT <= NAME <= LIT , LIT , ) ) NAME . NAME ( NAME ( LIT , lambda NAME : NAME ( NAME , NAME ) and LIT <= NAME <= LIT , LIT , ) ) # Production-specific rules NAME . NAME ( NAME . NAME , NAME ( LIT , lambda NAME : NAME is not None , LIT , ) , ) NAME . NAME ( NAME . NAME , NAME ( LIT , lambda NAME : NAME is True , LIT , ) , ) return NAME"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "DatabaseConfig._get_environment",
      "lineno": 298,
      "end_lineno": 307,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "6e6b21696d5c06d9f726ef4bfe84ba0399a5ac48",
      "simhash64": 7488180022980023347,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( LIT , LIT ) . NAME ( ) try : return NAME ( NAME ) except NAME : NAME . NAME ( f\" Unknown environment ' { NAME } ', defaulting to development \" ) return NAME . NAME"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "DatabaseConfig._ensure_directories",
      "lineno": 309,
      "end_lineno": 315,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "c8df9e1fc891ca3baa248ac454ae01da25b7a1ca",
      "simhash64": 7489270742876857347,
      "normalized": "def NAME ( NAME ) -> None : LIT if NAME . NAME : NAME . NAME . NAME ( NAME = True , NAME = True ) if NAME . NAME : NAME . NAME . NAME . NAME ( NAME = True , NAME = True )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "DatabaseConfig.get_connection_string",
      "lineno": 317,
      "end_lineno": 336,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 20,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "74ea62bede6effa406087d03140a45adf2eb934d",
      "simhash64": 8641136711958967315,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME . NAME : raise NAME ( LIT ) NAME = [ ] if NAME . NAME != LIT : NAME . NAME ( f\" journal_mode= { NAME . NAME } \" ) if NAME . NAME : NAME . NAME ( LIT ) if NAME . NAME != LIT : NAME . NAME ( f\" synchronous= { NAME . NAME } \" ) NAME = - ( NAME . NAME * LIT ) # Negative value means KB NAME . NAME ( f\" cache_size= { NAME } \" ) NAME . NAME ( f\" page_size= { NAME . NAME } \" ) if NAME : return f\" sqlite:/// { NAME . NAME } ? { LIT . NAME ( NAME ) } \" return f\" sqlite:/// { NAME . NAME } \""
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "SeleniumConfig.__post_init__",
      "lineno": 370,
      "end_lineno": 379,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "4f3384e5f1c3461e376247a931b7f4c6ad543186",
      "simhash64": 8640538577700558379,
      "normalized": "def NAME ( NAME ) -> None : LIT if NAME . NAME <= LIT or NAME . NAME > LIT : raise NAME ( LIT ) if NAME . NAME < LIT : raise NAME ( LIT ) if NAME . NAME < LIT : raise NAME ( LIT ) if not NAME . NAME or LIT not in NAME . NAME : raise NAME ( LIT )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "APIConfig.__post_init__",
      "lineno": 449,
      "end_lineno": 462,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "a480987d83c57321b6b9e931b11e61fcee2951da",
      "simhash64": 8640538583069267499,
      "normalized": "def NAME ( NAME ) -> None : LIT if not NAME . NAME : raise NAME ( LIT ) if not NAME . NAME . NAME ( ( LIT , LIT ) ) : raise NAME ( LIT ) if NAME . NAME <= LIT : raise NAME ( LIT ) if NAME . NAME < LIT : raise NAME ( LIT ) if NAME . NAME < LIT : raise NAME ( LIT ) if NAME . NAME <= LIT : raise NAME ( LIT )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "LoggingConfig.__post_init__",
      "lineno": 489,
      "end_lineno": 501,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "71f6310367bdd9c4bf9f8a11535b77bcc97d8d8e",
      "simhash64": 7488180022980023851,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME = [ LIT , LIT , LIT , LIT , LIT ] if NAME . NAME not in NAME : raise NAME ( f\" log_level must be one of: { NAME } \" ) if NAME . NAME not in NAME : raise NAME ( f\" console_log_level must be one of: { NAME } \" ) if NAME . NAME not in NAME : raise NAME ( f\" file_log_level must be one of: { NAME } \" ) if NAME . NAME <= LIT : raise NAME ( LIT ) if NAME . NAME < LIT : raise NAME ( LIT )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "CacheConfig.__post_init__",
      "lineno": 524,
      "end_lineno": 533,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "cea001aa5eb26066f55f0df40a223590b7643701",
      "simhash64": 6334686772393841707,
      "normalized": "def NAME ( NAME ) -> None : LIT if NAME . NAME <= LIT : raise NAME ( LIT ) if NAME . NAME <= LIT : raise NAME ( LIT ) if NAME . NAME <= LIT : raise NAME ( LIT ) if NAME . NAME <= LIT : raise NAME ( LIT )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "SecurityConfig.__post_init__",
      "lineno": 556,
      "end_lineno": 561,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "6048fadaee46792112a602debe46c054aecf6d15",
      "simhash64": 6334827510955939371,
      "normalized": "def NAME ( NAME ) -> None : LIT if NAME . NAME <= LIT : raise NAME ( LIT ) if NAME . NAME < LIT : raise NAME ( LIT )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "ConfigSchema.__post_init__",
      "lineno": 689,
      "end_lineno": 693,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "fab8dc1337601590b1b6b59eb3f19898f4b0b44b",
      "simhash64": 7488180024053765163,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME = [ LIT , LIT , LIT ] if NAME . NAME not in NAME : raise NAME ( f\" environment must be one of: { NAME } \" )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "ConfigSchema.to_dict",
      "lineno": 695,
      "end_lineno": 711,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "89e2a2bc2320cb26adbc08861f526830c601c003",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = { } # Convert each sub-config to dict for NAME in NAME . NAME : NAME = NAME ( NAME , NAME ) if NAME ( NAME , LIT ) : # Convert dataclass to dict NAME [ NAME ] = { NAME : NAME ( NAME , NAME ) for NAME in NAME . NAME } else : NAME [ NAME ] = NAME return NAME"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "ConfigSchema.from_dict",
      "lineno": 714,
      "end_lineno": 756,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 43,
      "tags": [
        "impure",
        "network",
        "logging",
        "size:medium"
      ],
      "signature": "(cls, data)",
      "fingerprint": "be9b8f3349665bffab0fd10d7d6f58c85288789a",
      "simhash64": 7452080858291672091,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> LIT : LIT # Extract sub-config data NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) NAME = NAME . NAME ( LIT , { } ) # Create sub-configs NAME = NAME ( ** NAME ) NAME = NAME ( ** NAME ) NAME = NAME ( ** NAME ) NAME = NAME ( ** NAME ) NAME = NAME ( ** NAME ) NAME = NAME ( ** NAME ) NAME = NAME ( ** NAME ) # Extract main config data NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME not in [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] } return NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , ** NAME , )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "ConfigSchema.validate",
      "lineno": 758,
      "end_lineno": 784,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 27,
      "tags": [
        "impure",
        "network",
        "logging",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "e8155fd16603268b7bd10577b4a3c3a93dbeb8aa",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME = [ ] try : # Validate each sub-config by triggering __post_init__ NAME ( ** NAME . NAME . NAME ) NAME ( ** NAME . NAME . NAME ) NAME ( ** NAME . NAME . NAME ) NAME ( ** NAME . NAME . NAME ) NAME ( ** NAME . NAME . NAME ) NAME ( ** NAME . NAME . NAME ) # Validate main config NAME . NAME ( ) except NAME as NAME : NAME . NAME ( NAME ( NAME ) ) except NAME as NAME : NAME . NAME ( f\" Unexpected validation error: { NAME } \" ) return NAME"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 787,
      "end_lineno": 1274,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 43,
      "loc": 488,
      "tags": [
        "impure",
        "network",
        "filesystem",
        "logging",
        "time",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "60f7bcd2b686cf2fd12956c4bbee2504af53e3a2",
      "simhash64": 7452186410333148211,
      "normalized": "def NAME ( ) -> NAME : LIT import NAME from NAME import NAME from NAME import ( NAME , NAME , NAME , ) # Initialize test suite NAME = NAME ( LIT , NAME ) NAME . NAME ( ) # Test 1: Database Config Creation and Validation def NAME ( ) : LIT # Test default creation NAME = NAME ( ) assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME is True # Test custom values NAME = NAME ( NAME = LIT , NAME = LIT , NAME = False ) assert NAME . NAME == LIT assert NAME . NAME == LIT # Test validation errors try : NAME ( NAME = - LIT ) raise NAME ( LIT ) except NAME : pass # Expected try : NAME ( NAME = LIT ) raise NAME ( LIT ) except NAME : pass # Expected # Test 2: Selenium Config Creation and Validation def NAME ( ) : LIT with NAME ( ) : # Test default creation NAME = NAME ( ) assert NAME . NAME is False assert NAME . NAME == LIT assert NAME . NAME == LIT # Test custom values NAME = NAME ( NAME = True , NAME = LIT , NAME = LIT ) assert NAME . NAME is True assert NAME . NAME == LIT # Test validation errors try : NAME ( NAME = - LIT ) raise NAME ( LIT ) except NAME : pass # Expected try : NAME ( NAME = LIT ) raise NAME ( LIT ) except NAME : pass # Expected # Test 3: API Config Creation and Validation def NAME ( ) : LIT with NAME ( ) : # Test default creation NAME = NAME ( ) assert NAME . NAME == LIT assert NAME . NAME == LIT # Updated to match our rate limiting fixes assert NAME . NAME is True # Test custom values NAME = NAME ( NAME = LIT , NAME = LIT , # Updated to use higher value for testing NAME = False , ) assert NAME . NAME == LIT assert NAME . NAME == LIT # Updated to match # Test validation errors try : NAME ( NAME = LIT ) raise NAME ( LIT ) except NAME : pass # Expected try : NAME ( NAME = - LIT ) raise NAME ( LIT ) except NAME : pass # Expected # Test 4: Logging Config Creation and Validation def NAME ( ) : LIT with NAME ( ) : # Test default creation NAME = NAME ( ) assert NAME . NAME == LIT assert NAME . NAME is True assert NAME . NAME == LIT # Test custom values NAME = NAME ( NAME = LIT , NAME = False , NAME = LIT ) assert NAME . NAME == LIT assert NAME . NAME is False # Test validation errors try : NAME ( NAME = LIT ) raise NAME ( LIT ) except NAME : pass # Expected try : NAME ( NAME = - LIT ) raise NAME ( LIT ) except NAME : pass # Expected # Test 5: Cache Config Creation and Validation def NAME ( ) : LIT with NAME ( ) : # Test default creation NAME = NAME ( ) assert NAME . NAME == LIT assert NAME . NAME is True assert NAME . NAME is True # Test custom values NAME = NAME ( NAME = LIT , NAME = False , NAME = False , ) assert NAME . NAME == LIT assert NAME . NAME is False # Test validation errors try : NAME ( NAME = - LIT ) raise NAME ( LIT ) except NAME : pass # Expected # Test 6: Security Config Creation and Validation def NAME ( ) : LIT with NAME ( ) : # Test default creation NAME = NAME ( ) assert NAME . NAME is True assert NAME . NAME is True assert NAME . NAME == LIT # Test custom values NAME = NAME ( NAME = False , NAME = LIT ) assert NAME . NAME is False assert NAME . NAME == LIT # Test validation errors try : NAME ( NAME = - LIT ) raise NAME ( LIT ) except NAME : pass # Expected # Test 7: Main Config Schema Creation def NAME ( ) : LIT with NAME ( ) : # Test default creation NAME = NAME ( ) assert NAME . NAME == LIT assert NAME . NAME is False assert NAME . NAME == LIT # Verify sub-configs are created assert NAME ( NAME . NAME , NAME ) assert NAME ( NAME . NAME , NAME ) assert NAME ( NAME . NAME , NAME ) assert NAME ( NAME . NAME , NAME ) assert NAME ( NAME . NAME , NAME ) assert NAME ( NAME . NAME , NAME ) # Test custom environment NAME = NAME ( NAME = LIT , NAME = True ) assert NAME . NAME == LIT assert NAME . NAME is True # Test 8: Config Schema to_dict Conversion def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) NAME = NAME . NAME ( ) # Verify structure assert NAME ( NAME , NAME ) assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME # Verify sub-configs are dicts assert NAME ( NAME [ LIT ] , NAME ) assert NAME ( NAME [ LIT ] , NAME ) # Verify some values assert NAME [ LIT ] == LIT assert NAME [ LIT ] [ LIT ] == LIT # Test 9: Config Schema from_dict Creation def NAME ( ) : LIT with NAME ( ) : # Create a test dictionary NAME = { LIT : LIT , LIT : True , LIT : { LIT : LIT , LIT : LIT } , LIT : { LIT : True , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT , } , } # Create config from dict NAME = NAME . NAME ( NAME ) # Verify main config assert NAME . NAME == LIT assert NAME . NAME is True # Verify sub-configs assert NAME . NAME . NAME == LIT assert NAME . NAME . NAME == LIT assert NAME . NAME . NAME is True assert NAME . NAME . NAME == LIT assert NAME . NAME . NAME == LIT assert NAME . NAME . NAME == LIT # Test 10: Config Schema Validation def NAME ( ) : LIT with NAME ( ) : # Test valid configuration NAME = NAME ( ) NAME = NAME . NAME ( ) assert NAME ( NAME ) == LIT , f\" Valid config should have no errors: { NAME } \" # Test configuration with invalid environment try : NAME ( NAME = LIT ) raise NAME ( LIT ) except NAME : pass # Expected # Test 11: Edge Cases and Error Handling def NAME ( ) : LIT with NAME ( ) : # Test Path handling in configs NAME = NAME ( NAME . NAME ( ) ) / LIT NAME = NAME ( NAME = NAME ) assert NAME . NAME == NAME # Test None values NAME = NAME ( NAME = None ) assert NAME . NAME is None # Test empty strings in API config try : NAME ( NAME = LIT ) raise NAME ( LIT ) except NAME : pass # Expected # Test 12: Integration Testing def NAME ( ) : LIT with NAME ( ) : # Create a full configuration NAME = NAME ( NAME = LIT , NAME = False ) # Modify sub-configs NAME . NAME . NAME = LIT NAME . NAME . NAME = True NAME . NAME . NAME = False # Convert to dict and back NAME = NAME . NAME ( ) NAME = NAME . NAME ( NAME ) # Verify restoration assert NAME . NAME == LIT assert NAME . NAME . NAME == LIT assert NAME . NAME . NAME is True assert NAME . NAME . NAME is False # Test 13: Performance and Memory Usage def NAME ( ) : LIT with NAME ( ) : import NAME NAME = NAME . NAME ( ) # Create multiple configurations NAME = [ ] for NAME in NAME ( LIT ) : NAME = NAME ( NAME = LIT , NAME = NAME % LIT == LIT ) NAME . NAME ( NAME ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Created 100 configs in { NAME : .4f } seconds \" ) # Test serialization performance NAME = NAME . NAME ( ) for NAME in NAME [ : LIT ] : # Test a subset NAME = NAME . NAME ( ) NAME . NAME ( NAME ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Serialized/deserialized 10 configs in { NAME : .4f } seconds \" ) # Test 14: Method Existence and Structure def NAME ( ) : LIT with NAME ( ) : # Test ConfigSchema methods NAME = NAME ( ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) # Test sub-config classes exist and have __post_init__ for NAME in [ NAME , NAME , NAME , NAME , NAME , NAME , ] : NAME = NAME ( ) assert NAME ( NAME , LIT ) NAME ( NAME . NAME , f\" { NAME . NAME } .__post_init__ \" ) # Test 15: Type Definitions and Import Dependencies def NAME ( ) : LIT with NAME ( ) : # Test dataclass functionality from NAME import NAME , NAME assert NAME ( NAME ) assert NAME ( NAME ) # Test typing imports # Test pathlib from NAME import NAME NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) # Test that all config classes are properly defined as dataclasses for NAME in [ NAME , NAME , NAME , NAME , NAME , NAME , NAME , ] : assert NAME ( NAME , LIT ) def NAME ( ) : LIT NAME ( LIT ) NAME = NAME ( ) # Validate conservative settings for API rate limiting compliance NAME = [ ] if NAME . NAME > LIT : NAME . NAME ( f\" requests_per_second too high: { NAME . NAME } \" ) if NAME . NAME > LIT : NAME . NAME ( f\" thread_pool_workers too high: { NAME . NAME } \" ) if NAME . NAME > LIT : NAME . NAME ( f\" max_concurrency too high: { NAME . NAME } \" ) if NAME . NAME > LIT : NAME . NAME ( f\" burst_limit too high: { NAME . NAME } \" ) if NAME . NAME < LIT : NAME . NAME ( f\" max_retries too low: { NAME . NAME } \" ) if NAME . NAME < LIT : NAME . NAME ( f\" retry_backoff_factor too low: { NAME . NAME } \" ) if NAME . NAME < LIT : NAME . NAME ( f\" request_timeout too low: { NAME . NAME } \" ) if NAME . NAME < LIT : NAME . NAME ( f\" max_delay too low: { NAME . NAME } \" ) if NAME : NAME ( LIT ) for NAME in NAME : NAME ( f\" - { NAME } \" ) raise NAME ( f\" Rate limiting configuration issues: { NAME } \" ) NAME ( LIT ) def NAME ( ) : LIT NAME ( LIT ) NAME = NAME ( ) NAME = NAME . NAME NAME ( f\" MAX_PAGES default value: { NAME } \" ) # Validate that max_pages is properly configured assert NAME ( NAME , NAME ) , f\" MAX_PAGES should be integer, got { NAME ( NAME ) } \" assert NAME >= LIT , f\" MAX_PAGES should be non-negative, got { NAME } \" if NAME == LIT : NAME ( LIT ) else : NAME ( f\" \u26a0\ufe0f  MAX_PAGES= { NAME } limits processing (not unlimited) \" ) # Define all tests NAME = [ ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ( LIT , NAME ) , ] # Run each test using TestSuite for NAME , NAME in NAME : NAME . NAME ( NAME , NAME , f\" Test { NAME } \" ) # Finish suite and return result return NAME . NAME ( )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_database_config",
      "lineno": 811,
      "end_lineno": 835,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 25,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "20e80a23d5a7f83e7688b888482b880393e93f91",
      "simhash64": 7452327147888621079,
      "normalized": "def NAME ( ) : LIT # Test default creation NAME = NAME ( ) assert NAME . NAME == LIT assert NAME . NAME == LIT assert NAME . NAME is True # Test custom values NAME = NAME ( NAME = LIT , NAME = LIT , NAME = False ) assert NAME . NAME == LIT assert NAME . NAME == LIT # Test validation errors try : NAME ( NAME = - LIT ) raise NAME ( LIT ) except NAME : pass # Expected try : NAME ( NAME = LIT ) raise NAME ( LIT ) except NAME : pass # Expected"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_selenium_config",
      "lineno": 838,
      "end_lineno": 865,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c8e87e0746d2dcd6af9f47d50eda9faf3ef92679",
      "simhash64": 7452327113461765651,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : # Test default creation NAME = NAME ( ) assert NAME . NAME is False assert NAME . NAME == LIT assert NAME . NAME == LIT # Test custom values NAME = NAME ( NAME = True , NAME = LIT , NAME = LIT ) assert NAME . NAME is True assert NAME . NAME == LIT # Test validation errors try : NAME ( NAME = - LIT ) raise NAME ( LIT ) except NAME : pass # Expected try : NAME ( NAME = LIT ) raise NAME ( LIT ) except NAME : pass # Expected"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_api_config",
      "lineno": 868,
      "end_lineno": 897,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "03f0c645c5fa49e11faf31b8b26f154cd6cb7bbf",
      "simhash64": 7452327113530455603,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : # Test default creation NAME = NAME ( ) assert NAME . NAME == LIT assert NAME . NAME == LIT # Updated to match our rate limiting fixes assert NAME . NAME is True # Test custom values NAME = NAME ( NAME = LIT , NAME = LIT , # Updated to use higher value for testing NAME = False , ) assert NAME . NAME == LIT assert NAME . NAME == LIT # Updated to match # Test validation errors try : NAME ( NAME = LIT ) raise NAME ( LIT ) except NAME : pass # Expected try : NAME ( NAME = - LIT ) raise NAME ( LIT ) except NAME : pass # Expected"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_logging_config",
      "lineno": 900,
      "end_lineno": 927,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "46eb598655ce8ce3dadd57dbae5934af626303df",
      "simhash64": 7452327147821504019,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : # Test default creation NAME = NAME ( ) assert NAME . NAME == LIT assert NAME . NAME is True assert NAME . NAME == LIT # Test custom values NAME = NAME ( NAME = LIT , NAME = False , NAME = LIT ) assert NAME . NAME == LIT assert NAME . NAME is False # Test validation errors try : NAME ( NAME = LIT ) raise NAME ( LIT ) except NAME : pass # Expected try : NAME ( NAME = - LIT ) raise NAME ( LIT ) except NAME : pass # Expected"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_cache_config",
      "lineno": 930,
      "end_lineno": 953,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "2d7f80a1c5b82f7a97f76174667bb552bce3de3d",
      "simhash64": 7452186410333156371,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : # Test default creation NAME = NAME ( ) assert NAME . NAME == LIT assert NAME . NAME is True assert NAME . NAME is True # Test custom values NAME = NAME ( NAME = LIT , NAME = False , NAME = False , ) assert NAME . NAME == LIT assert NAME . NAME is False # Test validation errors try : NAME ( NAME = - LIT ) raise NAME ( LIT ) except NAME : pass # Expected"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_security_config",
      "lineno": 956,
      "end_lineno": 975,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 20,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "60a2ea51083ca374e1ab2f7ec6a24b96ac830885",
      "simhash64": 7488215207352120915,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : # Test default creation NAME = NAME ( ) assert NAME . NAME is True assert NAME . NAME is True assert NAME . NAME == LIT # Test custom values NAME = NAME ( NAME = False , NAME = LIT ) assert NAME . NAME is False assert NAME . NAME == LIT # Test validation errors try : NAME ( NAME = - LIT ) raise NAME ( LIT ) except NAME : pass # Expected"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_config_schema_creation",
      "lineno": 978,
      "end_lineno": 998,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 21,
      "tags": [
        "impure",
        "network",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "778c56c0b8ec397a8c6bd41ba24a6ead28a0af8e",
      "simhash64": 7488215207352116307,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : # Test default creation NAME = NAME ( ) assert NAME . NAME == LIT assert NAME . NAME is False assert NAME . NAME == LIT # Verify sub-configs are created assert NAME ( NAME . NAME , NAME ) assert NAME ( NAME . NAME , NAME ) assert NAME ( NAME . NAME , NAME ) assert NAME ( NAME . NAME , NAME ) assert NAME ( NAME . NAME , NAME ) assert NAME ( NAME . NAME , NAME ) # Test custom environment NAME = NAME ( NAME = LIT , NAME = True ) assert NAME . NAME == LIT assert NAME . NAME is True"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_config_schema_to_dict",
      "lineno": 1001,
      "end_lineno": 1023,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 23,
      "tags": [
        "impure",
        "network",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "19c1f07c27252c65166034f6c284ba7610fe246d",
      "simhash64": 7452152325539804275,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) NAME = NAME . NAME ( ) # Verify structure assert NAME ( NAME , NAME ) assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME # Verify sub-configs are dicts assert NAME ( NAME [ LIT ] , NAME ) assert NAME ( NAME [ LIT ] , NAME ) # Verify some values assert NAME [ LIT ] == LIT assert NAME [ LIT ] [ LIT ] == LIT"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_config_schema_from_dict",
      "lineno": 1026,
      "end_lineno": 1054,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 29,
      "tags": [
        "impure",
        "network",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "390331a06c1f28979221bec1dd11633cf59fc102",
      "simhash64": 7452856012914464299,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : # Create a test dictionary NAME = { LIT : LIT , LIT : True , LIT : { LIT : LIT , LIT : LIT } , LIT : { LIT : True , LIT : LIT } , LIT : { LIT : LIT , LIT : LIT , } , } # Create config from dict NAME = NAME . NAME ( NAME ) # Verify main config assert NAME . NAME == LIT assert NAME . NAME is True # Verify sub-configs assert NAME . NAME . NAME == LIT assert NAME . NAME . NAME == LIT assert NAME . NAME . NAME is True assert NAME . NAME . NAME == LIT assert NAME . NAME . NAME == LIT assert NAME . NAME . NAME == LIT"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_config_schema_validation",
      "lineno": 1057,
      "end_lineno": 1070,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "8e2177edeb84dc1f3cbb6f8d5b7a39a9953d86e9",
      "simhash64": 8641277416162367035,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : # Test valid configuration NAME = NAME ( ) NAME = NAME . NAME ( ) assert NAME ( NAME ) == LIT , f\" Valid config should have no errors: { NAME } \" # Test configuration with invalid environment try : NAME ( NAME = LIT ) raise NAME ( LIT ) except NAME : pass # Expected"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_edge_cases",
      "lineno": 1073,
      "end_lineno": 1091,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 19,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f79222320b72433294d9880285314a69e9670c43",
      "simhash64": 8641136677666853907,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : # Test Path handling in configs NAME = NAME ( NAME . NAME ( ) ) / LIT NAME = NAME ( NAME = NAME ) assert NAME . NAME == NAME # Test None values NAME = NAME ( NAME = None ) assert NAME . NAME is None # Test empty strings in API config try : NAME ( NAME = LIT ) raise NAME ( LIT ) except NAME : pass # Expected"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_integration",
      "lineno": 1094,
      "end_lineno": 1113,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 20,
      "tags": [
        "impure",
        "network",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "4afc306513f914039790eee8c3f1465e4faf0d81",
      "simhash64": 7488144838607938579,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : # Create a full configuration NAME = NAME ( NAME = LIT , NAME = False ) # Modify sub-configs NAME . NAME . NAME = LIT NAME . NAME . NAME = True NAME . NAME . NAME = False # Convert to dict and back NAME = NAME . NAME ( ) NAME = NAME . NAME ( NAME ) # Verify restoration assert NAME . NAME == LIT assert NAME . NAME . NAME == LIT assert NAME . NAME . NAME is True assert NAME . NAME . NAME is False"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_performance",
      "lineno": 1116,
      "end_lineno": 1141,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 26,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "cacfa8f6bed938073e481823213ee100ca71d668",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : import NAME NAME = NAME . NAME ( ) # Create multiple configurations NAME = [ ] for NAME in NAME ( LIT ) : NAME = NAME ( NAME = LIT , NAME = NAME % LIT == LIT ) NAME . NAME ( NAME ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Created 100 configs in { NAME : .4f } seconds \" ) # Test serialization performance NAME = NAME . NAME ( ) for NAME in NAME [ : LIT ] : # Test a subset NAME = NAME . NAME ( ) NAME . NAME ( NAME ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Serialized/deserialized 10 configs in { NAME : .4f } seconds \" )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_function_structure",
      "lineno": 1144,
      "end_lineno": 1166,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "0b942118db2e2264757931c3af587a1be725146f",
      "simhash64": 7487617073026602019,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : # Test ConfigSchema methods NAME = NAME ( ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) # Test sub-config classes exist and have __post_init__ for NAME in [ NAME , NAME , NAME , NAME , NAME , NAME , ] : NAME = NAME ( ) assert NAME ( NAME , LIT ) NAME ( NAME . NAME , f\" { NAME . NAME } .__post_init__ \" )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_import_dependencies",
      "lineno": 1169,
      "end_lineno": 1196,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 28,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "dc357b7e97dca6058aea03f857325120d6cb8335",
      "simhash64": 7488179971441468543,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : # Test dataclass functionality from NAME import NAME , NAME assert NAME ( NAME ) assert NAME ( NAME ) # Test typing imports # Test pathlib from NAME import NAME NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) # Test that all config classes are properly defined as dataclasses for NAME in [ NAME , NAME , NAME , NAME , NAME , NAME , NAME , ] : assert NAME ( NAME , LIT )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_rate_limiting_configuration",
      "lineno": 1198,
      "end_lineno": 1229,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 11,
      "loc": 32,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "7e2ae6a5c39a70220ec78bb61364e459f16054f0",
      "simhash64": 7488215207352120347,
      "normalized": "def NAME ( ) : LIT NAME ( LIT ) NAME = NAME ( ) # Validate conservative settings for API rate limiting compliance NAME = [ ] if NAME . NAME > LIT : NAME . NAME ( f\" requests_per_second too high: { NAME . NAME } \" ) if NAME . NAME > LIT : NAME . NAME ( f\" thread_pool_workers too high: { NAME . NAME } \" ) if NAME . NAME > LIT : NAME . NAME ( f\" max_concurrency too high: { NAME . NAME } \" ) if NAME . NAME > LIT : NAME . NAME ( f\" burst_limit too high: { NAME . NAME } \" ) if NAME . NAME < LIT : NAME . NAME ( f\" max_retries too low: { NAME . NAME } \" ) if NAME . NAME < LIT : NAME . NAME ( f\" retry_backoff_factor too low: { NAME . NAME } \" ) if NAME . NAME < LIT : NAME . NAME ( f\" request_timeout too low: { NAME . NAME } \" ) if NAME . NAME < LIT : NAME . NAME ( f\" max_delay too low: { NAME . NAME } \" ) if NAME : NAME ( LIT ) for NAME in NAME : NAME ( f\" - { NAME } \" ) raise NAME ( f\" Rate limiting configuration issues: { NAME } \" ) NAME ( LIT )"
    },
    {
      "module_path": "config\\config_schema.py",
      "qualname": "test_max_pages_configuration",
      "lineno": 1231,
      "end_lineno": 1246,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "0b58d3f5a966bf5f5e38d03c6a7772bce0c5d31b",
      "simhash64": 8605107914941044283,
      "normalized": "def NAME ( ) : LIT NAME ( LIT ) NAME = NAME ( ) NAME = NAME . NAME NAME ( f\" MAX_PAGES default value: { NAME } \" ) # Validate that max_pages is properly configured assert NAME ( NAME , NAME ) , f\" MAX_PAGES should be integer, got { NAME ( NAME ) } \" assert NAME >= LIT , f\" MAX_PAGES should be non-negative, got { NAME } \" if NAME == LIT : NAME ( LIT ) else : NAME ( f\" \u26a0\ufe0f  MAX_PAGES= { NAME } limits processing (not unlimited) \" )"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager.__init__",
      "lineno": 44,
      "end_lineno": 53,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self, app_name)",
      "fingerprint": "e93a5aabc710049aa9b7de3f622583e68ed7ddf6",
      "simhash64": 7452080857283998739,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) : LIT NAME . NAME = NAME NAME . NAME = None NAME . NAME : NAME [ NAME [ NAME , NAME ] ] = None"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager._get_security_manager",
      "lineno": 55,
      "end_lineno": 66,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "0aa0bfa87bc6676e12bc2e682d0f8d3b1a518621",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME ) : LIT if NAME . NAME is None : try : # Import here to avoid circular imports from NAME import NAME NAME . NAME = NAME ( NAME . NAME ) except NAME as NAME : NAME . NAME ( f\" SecurityManager not available: { NAME } \" ) NAME . NAME = None return NAME . NAME"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager.load_credentials",
      "lineno": 68,
      "end_lineno": 105,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 9,
      "loc": 38,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, force_reload)",
      "fingerprint": "184916bbb910d34b99dfa1be78c0ce8806ccc74f",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME = False ) -> NAME [ NAME , NAME ] : LIT if not NAME and NAME . NAME is not None : return NAME . NAME NAME = { } # Try to load from encrypted storage first NAME = NAME . NAME ( ) if NAME : try : NAME = NAME . NAME ( ) if NAME : NAME . NAME ( NAME ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Failed to load encrypted credentials: { NAME } \" ) # Fallback to environment variables for missing credentials NAME = NAME . NAME ( ) for NAME , NAME in NAME . NAME ( ) : if NAME not in NAME and NAME : NAME [ NAME ] = NAME NAME . NAME ( f\" Loaded { NAME } from environment variable \" ) # Cache the credentials NAME . NAME = NAME NAME . NAME ( f\" Loaded { NAME ( NAME ) } credentials \" ) return NAME"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager.get_credential",
      "lineno": 107,
      "end_lineno": 118,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self, key)",
      "fingerprint": "c7edeba72fea30e830b927775ab1f97c4b7b5fca",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT NAME = NAME . NAME ( ) return NAME . NAME ( NAME )"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager.has_credential",
      "lineno": 120,
      "end_lineno": 130,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, key)",
      "fingerprint": "f683a8c98dffe58399489c368a104a968d95dbdb",
      "simhash64": 7488180022980543491,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT return NAME . NAME ( NAME ) is not None"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager.store_credentials",
      "lineno": 132,
      "end_lineno": 168,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 7,
      "loc": 37,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, credentials, validate)",
      "fingerprint": "2683d5cc0c80ffdeeb0bcd2acd6d6900c8f45a15",
      "simhash64": 7488215207352112131,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] , NAME : NAME = True ) -> NAME : LIT if NAME and not NAME . NAME ( NAME ) : NAME . NAME ( LIT ) return False NAME = NAME . NAME ( ) if NAME : try : # Merge with existing credentials NAME = NAME . NAME ( ) or { } NAME . NAME ( NAME ) if NAME . NAME ( NAME ) : # Clear cache to force reload NAME . NAME = None NAME . NAME ( f\" Stored { NAME ( NAME ) } credentials securely \" ) return True NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" Failed to store credentials: { NAME } \" ) return False else : NAME . NAME ( LIT ) return False"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager.remove_credential",
      "lineno": 170,
      "end_lineno": 202,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 6,
      "loc": 33,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, key)",
      "fingerprint": "e4a34288829511ce7be1b6391c08406776559d86",
      "simhash64": 7488215207352112147,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT NAME = NAME . NAME ( ) if NAME : try : NAME = NAME . NAME ( ) or { } if NAME in NAME : del NAME [ NAME ] if NAME . NAME ( NAME ) : # Clear cache to force reload NAME . NAME = None NAME . NAME ( f\" Removed credential: { NAME } \" ) return True NAME . NAME ( f\" Failed to encrypt credentials after removing { NAME } \" ) return False NAME . NAME ( f\" Credential not found: { NAME } \" ) return False except NAME as NAME : NAME . NAME ( f\" Failed to remove credential { NAME } : { NAME } \" ) return False else : NAME . NAME ( LIT ) return False"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager.validate_credentials",
      "lineno": 204,
      "end_lineno": 222,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self, credentials)",
      "fingerprint": "04ef7525ccae40f3840e8e1ea344de71c8766dc8",
      "simhash64": 7488180022980023331,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME , NAME ] ) -> NAME : LIT NAME = [ LIT , LIT ] for NAME in NAME : if not NAME . NAME ( NAME ) : NAME . NAME ( f\" Missing required credential: { NAME } \" ) return False NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager.migrate_from_environment",
      "lineno": 224,
      "end_lineno": 246,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "032d8fd613377e9da0da4531b4ed707e8fd6aa4f",
      "simhash64": 7487617073026601987,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) # Filter out empty credentials NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME . NAME ( ) } if not NAME : NAME . NAME ( LIT ) return True if NAME . NAME ( NAME ) : NAME . NAME ( f\" Migrated { NAME ( NAME ) } credentials from environment \" ) return True NAME . NAME ( LIT ) return False"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager.get_ancestry_credentials",
      "lineno": 248,
      "end_lineno": 257,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "5804bad75faad15b283d85c5a5d787fa8ede1bbc",
      "simhash64": 7488180022980031571,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME [ NAME ] , NAME [ NAME ] ] : LIT NAME = NAME . NAME ( LIT ) NAME = NAME . NAME ( LIT ) return NAME , NAME"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager.get_api_key",
      "lineno": 259,
      "end_lineno": 270,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self, provider)",
      "fingerprint": "439ad18842fb510752b967f41a2422a18cf73868",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT NAME = f\" { NAME . NAME ( ) } _API_KEY \" return NAME . NAME ( NAME )"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager._load_from_environment",
      "lineno": 272,
      "end_lineno": 293,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 22,
      "tags": [
        "impure",
        "filesystem",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "ffa7c9074a1486deed95cf0f0f02744abed81682",
      "simhash64": 5146448955309462587,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , ] NAME = { } for NAME in NAME : NAME = NAME . NAME ( NAME , LIT ) if NAME : NAME [ NAME ] = NAME return NAME"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager.clear_cache",
      "lineno": 295,
      "end_lineno": 298,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "b9c40616b9938af6898410551967fa9886d9af0a",
      "simhash64": 8641136717394777091,
      "normalized": "def NAME ( NAME ) : LIT NAME . NAME = None NAME . NAME ( LIT )"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager.get_credential_status",
      "lineno": 300,
      "end_lineno": 328,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 29,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "84e0223201a0cd2fa1015cb2ea623088c0edbe73",
      "simhash64": 7488180024053765131,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) NAME = { LIT : NAME ( NAME ) , LIT : NAME . NAME ( NAME ) , LIT : NAME is not None , LIT : False , LIT : NAME ( NAME . NAME ( ) ) , } if NAME : try : NAME = NAME . NAME ( ) NAME [ LIT ] = NAME is not None NAME [ LIT ] = ( NAME ( NAME ) if NAME else LIT ) except NAME : pass return NAME"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "CredentialManager.export_for_backup",
      "lineno": 330,
      "end_lineno": 359,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, include_sensitive)",
      "fingerprint": "e4162772d11464de596414f6d5ef61e7834731d7",
      "simhash64": 7487757811588699179,
      "normalized": "def NAME ( NAME , NAME : NAME = False ) -> NAME [ NAME , NAME ] : LIT NAME = NAME . NAME ( ) if NAME : NAME . NAME ( LIT ) return { LIT : NAME , LIT : NAME ( NAME ) , LIT : NAME . NAME , } return { LIT : NAME ( NAME . NAME ( ) ) , LIT : NAME ( NAME ) , LIT : NAME . NAME , LIT : NAME ( NAME in NAME for NAME in [ LIT , LIT ] ) , }"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 362,
      "end_lineno": 977,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 35,
      "loc": 616,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "time",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "fd7e22dd885f229d8edf22f200d7a18e54c20570",
      "simhash64": 7452151227034801195,
      "normalized": "def NAME ( ) : LIT import NAME # Test framework imports with fallback import NAME from NAME import NAME try : from NAME import ( NAME , # type: ignore NAME , # type: ignore NAME , NAME , # type: ignore ) except NAME : # Fallback implementations # Define minimal fallback classes that match expected interface from NAME import NAME from NAME import NAME , NAME , NAME class NAME : def NAME ( NAME , NAME : NAME , NAME : NAME = None ) : NAME . NAME = NAME NAME . NAME = LIT NAME . NAME = LIT def NAME ( NAME ) -> None : NAME ( f\" Starting { NAME . NAME } tests... \" ) def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME = LIT ) -> None : try : NAME ( ) NAME . NAME += LIT NAME ( f\" \u2713 { NAME } \" ) except NAME as NAME : NAME . NAME += LIT NAME ( f\" \u2717 { NAME } : { NAME } \" ) def NAME ( NAME ) -> NAME : return NAME . NAME == LIT class NAME : def NAME ( NAME ) : return NAME def NAME ( NAME , NAME : NAME [ NAME [ NAME ] ] , NAME : NAME [ NAME ] , NAME : NAME [ NAME ] , ) -> None : pass def NAME ( ) -> NAME : return { } def NAME ( NAME : NAME , NAME : NAME = LIT ) -> None : assert NAME ( NAME ) , f\" { NAME } should be callable \" NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME = { LIT : LIT , LIT : LIT , LIT : [ ] } def NAME ( NAME : NAME , NAME , NAME : NAME = LIT ) -> NAME : LIT try : NAME = NAME [ LIT ] + NAME [ LIT ] + LIT NAME ( f\" \u2699\ufe0f Test { NAME } : { NAME } \" ) if NAME : NAME ( f\" Test: { NAME } \" ) NAME ( ) NAME [ LIT ] += LIT NAME ( LIT ) NAME ( LIT ) return True except NAME as NAME : NAME [ LIT ] += LIT NAME = f\" \u2717 FAILED: { NAME } - { NAME ! NAME } \" NAME [ LIT ] . NAME ( NAME ) NAME ( f\" Outcome: Test failed with error: { NAME ! NAME } \" ) NAME ( LIT ) NAME ( NAME . NAME ( ) ) return False # Test 1: Basic Initialization def NAME ( ) : LIT NAME ( LIT ) with NAME ( ) : NAME = [ ] # Test default initialization NAME ( LIT ) NAME = NAME ( ) NAME = NAME . NAME == LIT NAME = NAME . NAME is None NAME = NAME . NAME is None NAME ( f\" \u2705 Default app name: { NAME . NAME } (Expected: AncestryAutomation) \" ) NAME ( f\" \u2705 Security manager initial state: { NAME . NAME } (Expected: None) \" ) NAME ( f\" \u2705 Credentials cache initial state: { NAME . NAME } (Expected: None) \" ) NAME . NAME ( [ NAME , NAME , NAME ] ) # Test custom app name NAME ( LIT ) NAME = NAME ( LIT ) NAME = NAME . NAME == LIT NAME ( f\" \u2705 Custom app name: { NAME . NAME } (Expected: TestApp) \" ) NAME . NAME ( NAME ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } initialization checks passed \" ) assert NAME ( NAME ) , LIT # Test 2: Environment Variable Loading def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Store original environment NAME = { } NAME = [ LIT , LIT , LIT ] for NAME in NAME : NAME [ NAME ] = NAME . NAME . NAME ( NAME ) try : # Set test environment variables NAME . NAME [ LIT ] = LIT NAME . NAME [ LIT ] = LIT NAME . NAME [ LIT ] = LIT # Load from environment NAME = NAME . NAME ( ) assert LIT in NAME assert NAME [ LIT ] == LIT assert NAME [ LIT ] == LIT assert NAME [ LIT ] == LIT finally : # Restore original environment for NAME , NAME in NAME . NAME ( ) : if NAME is None : NAME . NAME . NAME ( NAME , None ) else : NAME . NAME [ NAME ] = NAME # Test 3: Credential Validation def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Test valid credentials NAME = { LIT : LIT , LIT : LIT , } assert NAME . NAME ( NAME ) is True # Test missing username NAME = { LIT : LIT } assert NAME . NAME ( NAME ) is False # Test missing password NAME = { LIT : LIT } assert NAME . NAME ( NAME ) is False # Test empty values NAME = { LIT : LIT , LIT : LIT } assert NAME . NAME ( NAME ) is False # Test 4: Credential Getting and Checking def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Mock the load_credentials method to return test data NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } NAME . NAME = NAME # Test getting existing credential NAME = NAME . NAME ( LIT ) assert NAME == LIT # Test getting non-existent credential NAME = NAME . NAME ( LIT ) assert NAME is None # Test checking credential existence assert NAME . NAME ( LIT ) is True assert NAME . NAME ( LIT ) is False # Test 5: Ancestry Credentials Helper def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Test with complete credentials NAME = { LIT : LIT , LIT : LIT , } NAME . NAME = NAME NAME , NAME = NAME . NAME ( ) assert NAME == LIT assert NAME == LIT # Test with missing credentials NAME . NAME = { } NAME , NAME = NAME . NAME ( ) assert NAME is None assert NAME is None # Test 6: API Key Retrieval def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } NAME . NAME = NAME # Test various providers assert NAME . NAME ( LIT ) == LIT assert NAME . NAME ( LIT ) == LIT assert NAME . NAME ( LIT ) == LIT # Test case insensitive assert NAME . NAME ( LIT ) == LIT # Test non-existent provider assert NAME . NAME ( LIT ) is None # Test 7: Cache Management def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Set cache NAME = { LIT : LIT } NAME . NAME = NAME # Verify cache is set assert NAME . NAME is not None assert NAME ( NAME . NAME ) == LIT # Clear cache NAME . NAME ( ) assert NAME . NAME is None # Test 8: Credential Status Reporting def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Mock credentials NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } NAME . NAME = NAME NAME = NAME . NAME ( ) # Verify status structure assert NAME ( NAME , NAME ) assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME # Verify values assert NAME [ LIT ] == LIT assert NAME [ LIT ] is True assert NAME ( NAME [ LIT ] , NAME ) assert LIT in NAME [ LIT ] # Test 9: Export Functionality def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( LIT ) NAME = { LIT : LIT , LIT : LIT , } NAME . NAME = NAME # Test export without sensitive data NAME = NAME . NAME ( NAME = False ) assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT not in NAME # Should not contain actual values assert NAME [ LIT ] == LIT assert NAME [ LIT ] == LIT assert NAME [ LIT ] is True # Test export with sensitive data NAME = NAME . NAME ( NAME = True ) assert LIT in NAME assert LIT in NAME assert NAME [ LIT ] [ LIT ] == LIT # Test 10: Security Manager Integration def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Test getting security manager (should handle missing module gracefully) NAME = NAME . NAME ( ) # Should not raise exception, returns None if module not available assert NAME is None or NAME ( NAME , LIT ) # Test 11: Error Handling def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Test with invalid credentials for validation NAME = { LIT : LIT } assert NAME . NAME ( NAME ) is False # Test storage without security manager (should fail gracefully) NAME = NAME . NAME ( { LIT : LIT } ) assert NAME is False # Should fail without security manager # Test removal without security manager (should fail gracefully) NAME = NAME . NAME ( LIT ) assert NAME is False # Should fail without security manager # Test 12: Integration Testing def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( LIT ) # Store original environment NAME = NAME . NAME . NAME ( LIT ) NAME = NAME . NAME . NAME ( LIT ) try : # Set environment variables NAME . NAME [ LIT ] = LIT NAME . NAME [ LIT ] = LIT # Load credentials (should get from environment) NAME = NAME . NAME ( ) # Verify loaded credentials assert LIT in NAME assert NAME [ LIT ] == LIT # Test ancestry helper NAME , NAME = NAME . NAME ( ) assert NAME == LIT assert NAME == LIT # Test status NAME = NAME . NAME ( ) assert NAME [ LIT ] is True finally : # Restore environment if NAME is None : NAME . NAME . NAME ( LIT , None ) else : NAME . NAME [ LIT ] = NAME if NAME is None : NAME . NAME . NAME ( LIT , None ) else : NAME . NAME [ LIT ] = NAME # Test 13: Performance Testing def NAME ( ) : LIT with NAME ( ) : import NAME NAME = NAME ( ) # Test cache performance NAME = { f\" KEY_ { NAME } \" : f\" value_ { NAME } \" for NAME in NAME ( LIT ) } NAME . NAME = NAME NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME . NAME ( f\" KEY_ { NAME } \" ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Retrieved 100 cached credentials in { NAME : .4f } seconds \" ) # Test validation performance NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME . NAME ( { LIT : f\" user_ { NAME } \" , LIT : f\" pass_ { NAME } \" } ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Validated 10 credential sets in { NAME : .4f } seconds \" ) # Test 14: Method Existence and Structure def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Test public methods NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) # Test private methods NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) # Test properties assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Test 15: Import Dependencies and Type Definitions def NAME ( ) : LIT with NAME ( ) : # Test logging import NAME assert NAME ( NAME , LIT ) # Test pathlib from NAME import NAME NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) # Test typing # Test os module import NAME assert NAME ( NAME , LIT ) # Test that the class is properly defined assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Define all tests with descriptions NAME = [ ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ( LIT , NAME , LIT , ) , ] # Run each test for NAME , NAME , NAME in NAME : NAME ( NAME , NAME , NAME ) # Print summary NAME ( NAME ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME ( LIT ) NAME = NAME [ LIT ] == LIT if NAME : NAME ( LIT ) NAME ( f\" \u2705 Passed: { NAME [ LIT ] } \" ) NAME ( f\" \u274c Failed: { NAME [ LIT ] } \" ) else : NAME ( LIT ) NAME ( f\" \u2705 Passed: { NAME [ LIT ] } \" ) NAME ( f\" \u274c Failed: { NAME [ LIT ] } \" ) if NAME [ LIT ] : NAME ( LIT ) for NAME in NAME [ LIT ] : NAME ( f\" { NAME } \" ) NAME ( LIT ) return NAME"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "TestSuite.__init__",
      "lineno": 389,
      "end_lineno": 392,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, name, module)",
      "fingerprint": "11f6e8fc411708131ce065a6bc82ed06c6560896",
      "simhash64": 7452080857216889875,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME = None ) : NAME . NAME = NAME NAME . NAME = LIT NAME . NAME = LIT"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "TestSuite.start_suite",
      "lineno": 394,
      "end_lineno": 395,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "impure",
        "logging",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "7526495331f0eab1b5b4a792fd1a9e437d1cce7b",
      "simhash64": 8623122318819234931,
      "normalized": "def NAME ( NAME ) -> None : NAME ( f\" Starting { NAME . NAME } tests... \" )"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "TestSuite.run_test",
      "lineno": 397,
      "end_lineno": 406,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "impure",
        "logging",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "(self, name, func, description)",
      "fingerprint": "fb3932bc441bc16eabea7f0c2bab0d94a4617e8f",
      "simhash64": 7452151227035849787,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME = LIT ) -> None : try : NAME ( ) NAME . NAME += LIT NAME ( f\" \u2713 { NAME } \" ) except NAME as NAME : NAME . NAME += LIT NAME ( f\" \u2717 { NAME } : { NAME } \" )"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "TestSuite.run_all_tests",
      "lineno": 408,
      "end_lineno": 409,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "d6c6c7f4cd4a70604d5033216f4e7ccc51a6855e",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME ) -> NAME : return NAME . NAME == LIT"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "SuppressLogging.__enter__",
      "lineno": 412,
      "end_lineno": 413,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "86b7f3e3741ab2db274c91d9cb0ebaefec03d49d",
      "simhash64": 7492789730848703603,
      "normalized": "def NAME ( NAME ) : return NAME"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "SuppressLogging.__exit__",
      "lineno": 415,
      "end_lineno": 421,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, exc_type, exc_val, exc_tb)",
      "fingerprint": "22590fe7d0800599ad270a2621b8ce13a2843f44",
      "simhash64": 7452151225961591895,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME [ NAME ] ] , NAME : NAME [ NAME ] , NAME : NAME [ NAME ] , ) -> None : pass"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "create_mock_data",
      "lineno": 423,
      "end_lineno": 424,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "0ac87602901e5b8519f37d9f24ebc5984d2f2d73",
      "simhash64": 8646837101540577851,
      "normalized": "def NAME ( ) -> NAME : return { }"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "assert_valid_function",
      "lineno": 426,
      "end_lineno": 427,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(func, func_name)",
      "fingerprint": "7431042b49363062f553c19ea843d33033ee6c58",
      "simhash64": 8606374519050769467,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME = LIT ) -> None : assert NAME ( NAME ) , f\" { NAME } should be callable \""
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "run_test",
      "lineno": 436,
      "end_lineno": 455,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 20,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "(test_name, test_func, test_description)",
      "fingerprint": "97373dc8c60c24d43a3b5a780e9711ae91288077",
      "simhash64": 7452151225961059379,
      "normalized": "def NAME ( NAME : NAME , NAME , NAME : NAME = LIT ) -> NAME : LIT try : NAME = NAME [ LIT ] + NAME [ LIT ] + LIT NAME ( f\" \u2699\ufe0f Test { NAME } : { NAME } \" ) if NAME : NAME ( f\" Test: { NAME } \" ) NAME ( ) NAME [ LIT ] += LIT NAME ( LIT ) NAME ( LIT ) return True except NAME as NAME : NAME [ LIT ] += LIT NAME = f\" \u2717 FAILED: { NAME } - { NAME ! NAME } \" NAME [ LIT ] . NAME ( NAME ) NAME ( f\" Outcome: Test failed with error: { NAME ! NAME } \" ) NAME ( LIT ) NAME ( NAME . NAME ( ) ) return False"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_initialization",
      "lineno": 458,
      "end_lineno": 499,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 42,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "50d5f38d9fa502cd6a1abb5ace9dd026f7ab9a26",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( ) : LIT NAME ( LIT ) with NAME ( ) : NAME = [ ] # Test default initialization NAME ( LIT ) NAME = NAME ( ) NAME = NAME . NAME == LIT NAME = NAME . NAME is None NAME = NAME . NAME is None NAME ( f\" \u2705 Default app name: { NAME . NAME } (Expected: AncestryAutomation) \" ) NAME ( f\" \u2705 Security manager initial state: { NAME . NAME } (Expected: None) \" ) NAME ( f\" \u2705 Credentials cache initial state: { NAME . NAME } (Expected: None) \" ) NAME . NAME ( [ NAME , NAME , NAME ] ) # Test custom app name NAME ( LIT ) NAME = NAME ( LIT ) NAME = NAME . NAME == LIT NAME ( f\" \u2705 Custom app name: { NAME . NAME } (Expected: TestApp) \" ) NAME . NAME ( NAME ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } initialization checks passed \" ) assert NAME ( NAME ) , LIT"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_environment_loading",
      "lineno": 502,
      "end_lineno": 532,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 31,
      "tags": [
        "impure",
        "filesystem",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "d6159f4ebb37a053f03199c6138747ba58a435ba",
      "simhash64": 7452151226028176407,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Store original environment NAME = { } NAME = [ LIT , LIT , LIT ] for NAME in NAME : NAME [ NAME ] = NAME . NAME . NAME ( NAME ) try : # Set test environment variables NAME . NAME [ LIT ] = LIT NAME . NAME [ LIT ] = LIT NAME . NAME [ LIT ] = LIT # Load from environment NAME = NAME . NAME ( ) assert LIT in NAME assert NAME [ LIT ] == LIT assert NAME [ LIT ] == LIT assert NAME [ LIT ] == LIT finally : # Restore original environment for NAME , NAME in NAME . NAME ( ) : if NAME is None : NAME . NAME . NAME ( NAME , None ) else : NAME . NAME [ NAME ] = NAME"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_credential_validation",
      "lineno": 535,
      "end_lineno": 557,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "fd719c8223650e441ddbdde6ca99133ed90c72f9",
      "simhash64": 7452328214048183851,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Test valid credentials NAME = { LIT : LIT , LIT : LIT , } assert NAME . NAME ( NAME ) is True # Test missing username NAME = { LIT : LIT } assert NAME . NAME ( NAME ) is False # Test missing password NAME = { LIT : LIT } assert NAME . NAME ( NAME ) is False # Test empty values NAME = { LIT : LIT , LIT : LIT } assert NAME . NAME ( NAME ) is False"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_credential_access",
      "lineno": 560,
      "end_lineno": 583,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "4b905869d2d7edbf5f12c87bee7bd1dc5f061780",
      "simhash64": 8604685703548671531,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Mock the load_credentials method to return test data NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } NAME . NAME = NAME # Test getting existing credential NAME = NAME . NAME ( LIT ) assert NAME == LIT # Test getting non-existent credential NAME = NAME . NAME ( LIT ) assert NAME is None # Test checking credential existence assert NAME . NAME ( LIT ) is True assert NAME . NAME ( LIT ) is False"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_ancestry_credentials",
      "lineno": 586,
      "end_lineno": 606,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "966211fa1e85f4e517334c07a04c8e0b21ba504f",
      "simhash64": 7452291929089676307,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Test with complete credentials NAME = { LIT : LIT , LIT : LIT , } NAME . NAME = NAME NAME , NAME = NAME . NAME ( ) assert NAME == LIT assert NAME == LIT # Test with missing credentials NAME . NAME = { } NAME , NAME = NAME . NAME ( ) assert NAME is None assert NAME is None"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_api_key_retrieval",
      "lineno": 609,
      "end_lineno": 630,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c59f98a2d11c00eae1cc5bc0383708adcabd39ac",
      "simhash64": 7451764198941824555,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } NAME . NAME = NAME # Test various providers assert NAME . NAME ( LIT ) == LIT assert NAME . NAME ( LIT ) == LIT assert NAME . NAME ( LIT ) == LIT # Test case insensitive assert NAME . NAME ( LIT ) == LIT # Test non-existent provider assert NAME . NAME ( LIT ) is None"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_cache_management",
      "lineno": 633,
      "end_lineno": 648,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "758ac265c93e0a99540e5a87b1a573027823ee70",
      "simhash64": 8642262612469789715,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Set cache NAME = { LIT : LIT } NAME . NAME = NAME # Verify cache is set assert NAME . NAME is not None assert NAME ( NAME . NAME ) == LIT # Clear cache NAME . NAME ( ) assert NAME . NAME is None"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_credential_status",
      "lineno": 651,
      "end_lineno": 678,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "383e306e30cc0fa10e0e3a7c9a8dfcacc9004d31",
      "simhash64": 7452152325539796539,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Mock credentials NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } NAME . NAME = NAME NAME = NAME . NAME ( ) # Verify status structure assert NAME ( NAME , NAME ) assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME # Verify values assert NAME [ LIT ] == LIT assert NAME [ LIT ] is True assert NAME ( NAME [ LIT ] , NAME ) assert LIT in NAME [ LIT ]"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_export_functionality",
      "lineno": 681,
      "end_lineno": 707,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 27,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "e86a9b14ba97415c46e0f4fdeaea06211e1ddb0e",
      "simhash64": 7452152325531416115,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( LIT ) NAME = { LIT : LIT , LIT : LIT , } NAME . NAME = NAME # Test export without sensitive data NAME = NAME . NAME ( NAME = False ) assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT in NAME assert LIT not in NAME # Should not contain actual values assert NAME [ LIT ] == LIT assert NAME [ LIT ] == LIT assert NAME [ LIT ] is True # Test export with sensitive data NAME = NAME . NAME ( NAME = True ) assert LIT in NAME assert LIT in NAME assert NAME [ LIT ] [ LIT ] == LIT"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_security_manager_integration",
      "lineno": 710,
      "end_lineno": 720,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "747128844371140fce0339594eb088e9130fc235",
      "simhash64": 8641136678674535431,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Test getting security manager (should handle missing module gracefully) NAME = NAME . NAME ( ) # Should not raise exception, returns None if module not available assert NAME is None or NAME ( NAME , LIT )"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_error_handling",
      "lineno": 723,
      "end_lineno": 738,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "00cc74cea7dec663a1ad9f129dad5020189e8904",
      "simhash64": 7488357009992356475,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Test with invalid credentials for validation NAME = { LIT : LIT } assert NAME . NAME ( NAME ) is False # Test storage without security manager (should fail gracefully) NAME = NAME . NAME ( { LIT : LIT } ) assert NAME is False # Should fail without security manager # Test removal without security manager (should fail gracefully) NAME = NAME . NAME ( LIT ) assert NAME is False # Should fail without security manager"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_integration",
      "lineno": 741,
      "end_lineno": 780,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 40,
      "tags": [
        "impure",
        "filesystem",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "4c7654c87bec24ed8e1cb79376c2bf4baa757f46",
      "simhash64": 7452151226028176403,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( LIT ) # Store original environment NAME = NAME . NAME . NAME ( LIT ) NAME = NAME . NAME . NAME ( LIT ) try : # Set environment variables NAME . NAME [ LIT ] = LIT NAME . NAME [ LIT ] = LIT # Load credentials (should get from environment) NAME = NAME . NAME ( ) # Verify loaded credentials assert LIT in NAME assert NAME [ LIT ] == LIT # Test ancestry helper NAME , NAME = NAME . NAME ( ) assert NAME == LIT assert NAME == LIT # Test status NAME = NAME . NAME ( ) assert NAME [ LIT ] is True finally : # Restore environment if NAME is None : NAME . NAME . NAME ( LIT , None ) else : NAME . NAME [ LIT ] = NAME if NAME is None : NAME . NAME . NAME ( LIT , None ) else : NAME . NAME [ LIT ] = NAME"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_performance",
      "lineno": 783,
      "end_lineno": 811,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 5,
      "loc": 29,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c7e88acf3ee6a92f734b390c29e3a78947aba016",
      "simhash64": 8641136713033749531,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : import NAME NAME = NAME ( ) # Test cache performance NAME = { f\" KEY_ { NAME } \" : f\" value_ { NAME } \" for NAME in NAME ( LIT ) } NAME . NAME = NAME NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME . NAME ( f\" KEY_ { NAME } \" ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Retrieved 100 cached credentials in { NAME : .4f } seconds \" ) # Test validation performance NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME . NAME ( { LIT : f\" user_ { NAME } \" , LIT : f\" pass_ { NAME } \" } ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Validated 10 credential sets in { NAME : .4f } seconds \" )"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_function_structure",
      "lineno": 814,
      "end_lineno": 844,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 31,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "a35973dd300a0e98b40ad31f5bad8c98f7aea759",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : NAME = NAME ( ) # Test public methods NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) # Test private methods NAME ( NAME . NAME , LIT ) NAME ( NAME . NAME , LIT ) # Test properties assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT )"
    },
    {
      "module_path": "config\\credential_manager.py",
      "qualname": "test_import_dependencies",
      "lineno": 847,
      "end_lineno": 870,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 24,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f1180f2b5016b03c664fefe783cd41801c1b9fd3",
      "simhash64": 7488355894375658623,
      "normalized": "def NAME ( ) : LIT with NAME ( ) : # Test logging import NAME assert NAME ( NAME , LIT ) # Test pathlib from NAME import NAME NAME = NAME ( LIT ) assert NAME ( NAME , NAME ) # Test typing # Test os module import NAME assert NAME ( NAME , LIT ) # Test that the class is properly defined assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT )"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "APIManager.__init__",
      "lineno": 61,
      "end_lineno": 80,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 20,
      "tags": [
        "impure",
        "network",
        "logging",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "1de6692f6462d77b87727b80aa83d6c483ee3cd7",
      "simhash64": 7452081407039812625,
      "normalized": "def NAME ( NAME ) -> None : LIT # User identifiers NAME . NAME : NAME [ NAME ] = None NAME . NAME : NAME [ NAME ] = None NAME . NAME : NAME [ NAME ] = None NAME . NAME : NAME [ NAME ] = None NAME . NAME : NAME [ NAME ] = None # Logging flags to prevent repeated logging NAME . NAME : NAME = False NAME . NAME : NAME = False NAME . NAME : NAME = False NAME . NAME : NAME = False # Initialize requests session NAME . NAME = NAME . NAME ( ) NAME . NAME ( ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "APIManager._setup_requests_session",
      "lineno": 82,
      "end_lineno": 92,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "impure",
        "network",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "1eb199c41255c26fbe165be3401b21c9d020b4ac",
      "simhash64": 5145886005356041259,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME = NAME ( NAME = LIT , NAME = LIT , NAME = [ LIT , LIT , LIT , LIT , LIT ] ) NAME = NAME ( NAME = LIT , NAME = LIT , NAME = NAME ) NAME . NAME . NAME ( LIT , NAME ) NAME . NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "APIManager.sync_cookies_from_browser",
      "lineno": 94,
      "end_lineno": 136,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 43,
      "tags": [
        "impure",
        "network",
        "size:medium"
      ],
      "signature": "(self, browser_manager)",
      "fingerprint": "feaa02c2d33f5a3220b3ed7063d09d530682a888",
      "simhash64": 7487652257398690819,
      "normalized": "def NAME ( NAME , NAME ) -> NAME : LIT if not NAME or not NAME . NAME ( ) : NAME . NAME ( LIT ) return False try : NAME = NAME . NAME . NAME ( ) NAME . NAME ( f\" Retrieved { NAME ( NAME ) } cookies from browser for API sync. \" ) # Clear existing cookies NAME . NAME . NAME . NAME ( ) # Add each cookie to requests session for NAME in NAME : NAME . NAME . NAME . NAME ( NAME [ LIT ] , NAME [ LIT ] , NAME = NAME . NAME ( LIT ) , NAME = NAME . NAME ( LIT , LIT ) , NAME = NAME . NAME ( LIT , False ) , ) NAME . NAME ( f\" Synced { NAME ( NAME ) } cookies to API requests session. \" ) return True except NAME as NAME : NAME . NAME ( f\" Error syncing cookies from browser to API: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "APIManager.make_api_request",
      "lineno": 138,
      "end_lineno": 225,
      "is_method": true,
      "is_async": false,
      "args_count": 9,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 9,
      "loc": 88,
      "tags": [
        "pure-ish",
        "logging",
        "json",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self, url, method, use_csrf_token, data, json_data, headers, timeout, api_description)",
      "fingerprint": "b915c8a39ed31f9eafa14ecf9bef22b12d3b152c",
      "simhash64": 7452080857216881683,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME = LIT , NAME : NAME = True , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME = LIT , NAME : NAME = LIT , ) -> NAME : LIT try : # Prepare headers NAME = { LIT : LIT , LIT : LIT , LIT : LIT , } if NAME : NAME . NAME ( NAME ) # Add CSRF token if requested and available if NAME and NAME . NAME : NAME [ LIT ] = NAME . NAME # CRITICAL FIX: Use lowercase header NAME . NAME ( f\" Added CSRF token to { NAME } request \" ) elif NAME and not NAME . NAME : NAME . NAME ( f\" CSRF token requested but not available for { NAME } \" ) # Make the request NAME . NAME ( f\" Making { NAME } request to { NAME } ( { NAME } ) \" ) NAME = NAME . NAME . NAME ( NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = True , ) # Check response status NAME . NAME ( ) # Try to parse JSON response try : NAME = NAME . NAME ( ) NAME . NAME ( f\" { NAME } request successful (JSON response) \" ) return NAME except NAME : # Not JSON, return text or response object if NAME . NAME : NAME . NAME ( f\" { NAME } request successful (text response) \" ) return NAME . NAME NAME . NAME ( f\" { NAME } request successful (response object) \" ) return NAME except NAME as NAME : NAME . NAME ( f\" { NAME } request failed: { NAME } \" ) return None except NAME as NAME : NAME . NAME ( f\" Unexpected error in { NAME } request: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "APIManager.get_csrf_token",
      "lineno": 227,
      "end_lineno": 259,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 33,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "02efb711380e6f2394985971ea660bac2ad83aec",
      "simhash64": 7487617073026601987,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME . NAME ( LIT ) NAME = NAME ( NAME . NAME . NAME , NAME ) NAME = NAME . NAME ( NAME = NAME , NAME = LIT , NAME = False , # Don't use CSRF token to get CSRF token NAME = LIT , ) if NAME and NAME ( NAME , NAME ) : # Try multiple possible field names for CSRF token NAME = ( NAME . NAME ( LIT ) or NAME . NAME ( LIT ) or NAME . NAME ( LIT ) ) if NAME : NAME . NAME = NAME NAME . NAME ( LIT ) return NAME NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) return None"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "APIManager.get_profile_id",
      "lineno": 261,
      "end_lineno": 296,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 7,
      "loc": 36,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "e39c41d7f2745d0a94fd90add3061855d1dd1cf7",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME . NAME ( LIT ) NAME = NAME ( NAME . NAME . NAME , NAME ) NAME = NAME . NAME ( NAME = NAME , NAME = LIT , NAME = False , NAME = LIT , ) if NAME and NAME ( NAME , NAME ) : # Check for profile ID in nested data structure if LIT in NAME and NAME ( NAME [ LIT ] , NAME ) : NAME = NAME [ LIT ] . NAME ( NAME ) else : # Fallback: check for profile ID at root level NAME = NAME . NAME ( NAME ) if NAME : NAME . NAME = NAME if not NAME . NAME : NAME . NAME ( f\" My profile ID: { NAME } \" ) NAME . NAME = True return NAME NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) return None"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "APIManager.get_uuid",
      "lineno": 298,
      "end_lineno": 324,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 27,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "5be9a5cae2a741e92b59e511372b7ac5c5584c36",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT NAME . NAME ( LIT ) NAME = NAME ( NAME . NAME . NAME , NAME ) NAME = NAME . NAME ( NAME = NAME , NAME = LIT , NAME = False , NAME = LIT ) if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( NAME ) if NAME : NAME . NAME = NAME if not NAME . NAME : NAME . NAME ( f\" My UUID: { NAME } \" ) NAME . NAME = True return NAME NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) return None"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "APIManager.retrieve_all_identifiers",
      "lineno": 326,
      "end_lineno": 362,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 37,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "896a3b802c49e51ff00d0c5f7f2c748c42b97360",
      "simhash64": 8641136712026076163,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME . NAME ( LIT ) NAME = True # Get Profile ID if not NAME . NAME : NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) NAME = False # Get UUID if not NAME . NAME : NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) NAME = False # Get CSRF token if not NAME . NAME : NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) # Don't mark as failure since some operations might work without it if NAME : NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) return NAME"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "APIManager.verify_api_login_status",
      "lineno": 364,
      "end_lineno": 397,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 34,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, session_manager)",
      "fingerprint": "b9995ef91d32d3619c38420b4e1ff34881293279",
      "simhash64": 7487652261760767011,
      "normalized": "def NAME ( NAME , NAME = None ) -> NAME [ NAME ] : LIT NAME . NAME ( LIT ) # Skip cookie syncing during API verification to prevent recursion # Cookies should already be synced from previous operations NAME . NAME ( LIT ) # Primary check: Try to get profile ID NAME = NAME . NAME ( ) if NAME : NAME . NAME ( LIT ) return True # Fallback check: Try to get UUID as alternative verification NAME . NAME ( LIT ) NAME = NAME . NAME ( ) if NAME : NAME . NAME ( LIT ) return True # Both primary and fallback checks failed NAME . NAME ( LIT ) return False"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "APIManager.reset_logged_flags",
      "lineno": 399,
      "end_lineno": 404,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "bb7eac9a9ab8db6e41c5bf96300a9124f51dc59f",
      "simhash64": 16675489727778305107,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = False NAME . NAME = False NAME . NAME = False NAME . NAME = False"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "APIManager.clear_identifiers",
      "lineno": 406,
      "end_lineno": 414,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "6b623b6217432f819c7716e67492425904f7b8bb",
      "simhash64": 8606199184592647169,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = None NAME . NAME = None NAME . NAME = None NAME . NAME = None NAME . NAME = None NAME . NAME ( ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "APIManager.has_essential_identifiers",
      "lineno": 417,
      "end_lineno": 419,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "06a08ee9f34fc975310d4ad5ac126f7654977736",
      "simhash64": 7488180022980027459,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME ( NAME . NAME and NAME . NAME )"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "APIManager.requests_session",
      "lineno": 422,
      "end_lineno": 424,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "impure",
        "network",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "e00b91a9b08ca1abc091b83b9992f3443703fef6",
      "simhash64": 7488109654235849795,
      "normalized": "def NAME ( NAME ) -> NAME . NAME : LIT return NAME . NAME"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "_test_api_manager_initialization",
      "lineno": 433,
      "end_lineno": 447,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "impure",
        "network",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "399ae7f94e6e8e2de9269fff3ddd98b1ba377968",
      "simhash64": 5145885970996302891,
      "normalized": "def NAME ( ) -> NAME : try : NAME = NAME ( ) assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME ( NAME , LIT ) , LIT assert NAME . NAME is None , LIT assert NAME . NAME is None , LIT assert NAME . NAME is None , LIT return True except NAME : return False"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "_test_identifier_management",
      "lineno": 450,
      "end_lineno": 466,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "38950a29c6b24c9a92a1445a9ba7bb3a3f495e38",
      "simhash64": 7488320760468378627,
      "normalized": "def NAME ( ) -> NAME : try : NAME = NAME ( ) assert NAME ( NAME , LIT ) , LIT NAME = NAME . NAME assert NAME ( NAME , NAME ) , LIT NAME . NAME = LIT NAME . NAME = LIT NAME = NAME . NAME assert ( NAME ) , LIT return True except NAME : return False"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "_test_api_request_methods",
      "lineno": 469,
      "end_lineno": 489,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "510d70db9412502a2532da649db376532ca960bd",
      "simhash64": 7488179989695075371,
      "normalized": "def NAME ( ) -> NAME : try : NAME = NAME ( ) NAME = [ LIT , LIT , LIT , LIT , ] NAME = [ ] for NAME in NAME : if NAME ( NAME , NAME ) : NAME = NAME ( NAME , NAME ) if NAME ( NAME ) : NAME . NAME ( NAME ) assert ( NAME ( NAME ) >= LIT ) , f\" Should have API methods available, found: { NAME } \" return True except NAME : return False"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "_test_invalid_response_handling",
      "lineno": 492,
      "end_lineno": 501,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "968663c4864e686127cbf0f1d7e79c8bc5e79627",
      "simhash64": 8640573731940766755,
      "normalized": "def NAME ( ) -> NAME : try : NAME = NAME ( ) NAME . NAME ( ) assert ( not NAME . NAME ) , LIT return True except NAME : return False"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "_test_config_integration",
      "lineno": 504,
      "end_lineno": 517,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "32329275d6786627dd0ed382d95f11b037f80807",
      "simhash64": 7488180022980023851,
      "normalized": "def NAME ( ) -> NAME : try : assert NAME is not None , LIT NAME = [ LIT , LIT , LIT ] NAME = [ ] for NAME in NAME : if NAME in NAME ( ) : NAME . NAME ( NAME ) assert ( NAME ( NAME ) >= LIT ) , f\" Should have API path constants defined: { NAME } \" return True except NAME : return False"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "_test_session_reuse_efficiency",
      "lineno": 520,
      "end_lineno": 535,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "94487eaad4c3e41738f3464fed0326f7d548d2c9",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( ) -> NAME : try : import NAME NAME = NAME ( ) NAME = NAME . NAME NAME = NAME . NAME assert NAME is NAME , LIT NAME = NAME . NAME ( ) NAME = [ NAME ( ) for NAME in NAME ( LIT ) ] NAME = NAME . NAME ( ) assert ( NAME - NAME ) < LIT , LIT assert NAME ( NAME ) == LIT , LIT return True except NAME : return False"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "_test_connection_error_handling",
      "lineno": 538,
      "end_lineno": 552,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 15,
      "tags": [
        "impure",
        "network",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b85b25ed5c231e3cd13b5d77d3b8e59c338c05f6",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( ) -> NAME : try : NAME = NAME ( ) NAME = NAME . NAME if NAME ( NAME , LIT ) : NAME = NAME ( NAME . NAME ) assert NAME >= LIT , LIT from NAME . NAME import NAME assert NAME is not None , LIT return True except NAME : return False except NAME : return False"
    },
    {
      "module_path": "core\\api_manager.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 555,
      "end_lineno": 614,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 60,
      "tags": [
        "pure-ish",
        "time",
        "purpose:test_runner",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "07515bfbdbf3769edde1e367faedd2261f9012fc",
      "simhash64": 5127871611137332267,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import ( NAME , ) NAME = NAME ( LIT , LIT ) NAME . NAME ( ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "BrowserManager.__init__",
      "lineno": 60,
      "end_lineno": 71,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "9da00fd92bd9ee29872388f625d432b544db6e23",
      "simhash64": 8605108464762926099,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME : NAME = None NAME . NAME : NAME = False NAME . NAME : NAME = False NAME . NAME : NAME [ NAME ] = None # MASTER BROWSER LOCK - Single lock for ALL browser operations # This prevents race conditions between refresh, cookie access, navigation, etc. NAME . NAME = NAME . NAME ( ) # Reentrant lock for nested calls NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "BrowserManager.start_browser",
      "lineno": 73,
      "end_lineno": 146,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 13,
      "loc": 74,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "regex",
        "size:medium"
      ],
      "signature": "(self, action_name)",
      "fingerprint": "5e6e5bc2edb64dfa34e5004618f10f575e59153d",
      "simhash64": 7487652257398699011,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT NAME . NAME ( f\" Starting browser for action: { NAME or LIT } \" ) # Use master browser lock for thread safety with NAME . NAME : try : if NAME . NAME ( ) : NAME . NAME ( LIT ) return True NAME . NAME ( LIT ) NAME . NAME = NAME ( ) if not NAME . NAME : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) # Navigate to base URL to stabilize NAME . NAME ( f\" Navigating to Base URL ( { NAME . NAME . NAME } ) to stabilize... \" ) # Optimization: if already at base URL, skip re-navigation try : NAME = NAME . NAME . NAME or LIT NAME = ( NAME . NAME . NAME or LIT ) . NAME ( LIT ) if NAME . NAME ( NAME ) : NAME . NAME ( LIT ) elif not NAME ( NAME . NAME , NAME . NAME . NAME ) : NAME . NAME ( f\" Failed to navigate to base URL: { NAME . NAME . NAME } \" ) NAME . NAME ( ) return False except NAME : if not NAME ( NAME . NAME , NAME . NAME . NAME ) : NAME . NAME ( f\" Failed to navigate to base URL: { NAME . NAME . NAME } \" ) NAME . NAME ( ) return False if not NAME ( NAME . NAME , NAME . NAME . NAME ) : NAME . NAME ( f\" Failed to navigate to base URL: { NAME . NAME . NAME } \" ) NAME . NAME ( ) return False # Mark as live and set timing NAME . NAME = True NAME . NAME = True NAME . NAME = NAME . NAME ( ) NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" Failed to start browser: { NAME } \" , NAME = True ) NAME . NAME ( ) return False"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "BrowserManager.close_browser",
      "lineno": 148,
      "end_lineno": 176,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 29,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "6f336ae316295fd8aa074d7f6a2ed3ea8df67772",
      "simhash64": 8641136712026076163,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME ( LIT ) # Use master browser lock for thread safety with NAME . NAME : if NAME . NAME : try : # First try to close gracefully NAME . NAME . NAME ( ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error quitting WebDriver gracefully: { NAME } \" ) # Force cleanup if graceful quit failed try : if NAME ( NAME . NAME , LIT ) and NAME . NAME . NAME : NAME . NAME . NAME . NAME ( ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error stopping WebDriver service: { NAME } \" ) # Always reset state regardless of quit success NAME . NAME = None NAME . NAME = False NAME . NAME = False NAME . NAME = None NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "BrowserManager.is_session_valid",
      "lineno": 178,
      "end_lineno": 205,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 5,
      "loc": 28,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "1dd107d13ecfd427ba967369840568286d314599",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME ) -> NAME : LIT # Use master browser lock for thread safety with NAME . NAME : if not NAME . NAME or not NAME . NAME : return False try : # Try a simple operation to check if driver is responsive NAME = NAME . NAME . NAME return True except ( NAME , NAME , NAME , ) as NAME : NAME . NAME ( f\" Browser session invalid: { NAME } \" ) NAME . NAME = False return False except NAME as NAME : NAME . NAME ( f\" Unexpected error checking session validity: { NAME } \" ) NAME . NAME = False return False"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "BrowserManager.ensure_driver_live",
      "lineno": 207,
      "end_lineno": 226,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 20,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "(self, action_name)",
      "fingerprint": "99f882988df22a51425afc7b1583d0011f9dfae1",
      "simhash64": 7488144838608991251,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT if not NAME . NAME : NAME . NAME ( f\" Browser not needed for action: { NAME } \" ) return True if NAME . NAME ( ) : NAME . NAME ( f\" Browser session is valid for action: { NAME } \" ) return True # Removed duplicate logging - start_browser will log the action return NAME . NAME ( NAME )"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "BrowserManager.get_cookies",
      "lineno": 228,
      "end_lineno": 272,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 10,
      "loc": 45,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self, cookie_names, timeout)",
      "fingerprint": "d71ca2f109b45c58b8190507544e4c85f96babcc",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME = LIT ) -> NAME : LIT # Use master browser lock to prevent race conditions with browser refresh with NAME . NAME : if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False try : NAME = NAME . NAME ( ) NAME = { NAME . NAME ( ) for NAME in NAME } while NAME . NAME ( ) - NAME < NAME : if not NAME . NAME : # Additional safety check NAME . NAME ( LIT ) return False NAME = NAME . NAME . NAME ( ) NAME = { NAME [ LIT ] . NAME ( ) for NAME in NAME if NAME ( NAME , NAME ) and LIT in NAME } NAME = NAME - NAME if not NAME : NAME . NAME ( f\" All required cookies found: { NAME } \" ) return True NAME . NAME ( LIT ) NAME . NAME ( f\" Timeout waiting for cookies: { NAME ( NAME ) } \" ) return False except NAME as NAME : NAME . NAME ( f\" Error checking cookies: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "BrowserManager.create_new_tab",
      "lineno": 274,
      "end_lineno": 310,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 7,
      "loc": 37,
      "tags": [
        "impure",
        "filesystem",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "34836d9e173250ba331c86a5290d4181fd021206",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT if not NAME . NAME ( ) or not NAME . NAME : NAME . NAME ( LIT ) return None try : # Store current window handle NAME = NAME . NAME . NAME # Create new tab NAME . NAME . NAME ( LIT ) # Switch to new tab NAME = NAME . NAME . NAME NAME = None for NAME in NAME : if NAME != NAME : NAME = NAME break if NAME : NAME . NAME . NAME . NAME ( NAME ) NAME . NAME ( f\" Created and switched to new tab: { NAME } \" ) return NAME NAME . NAME ( LIT ) return None except NAME as NAME : NAME . NAME ( f\" Error creating new tab: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "_test_browser_manager_initialization",
      "lineno": 314,
      "end_lineno": 323,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3bdfe4ff0bb70fa67e353c6df6ab75aaa4a10717",
      "simhash64": 8642227427493712899,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME ( ) assert NAME is not None , LIT assert not NAME . NAME , LIT assert not NAME . NAME , LIT assert NAME . NAME is None , LIT assert ( NAME . NAME is None ) , LIT return True"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "_test_method_availability",
      "lineno": 326,
      "end_lineno": 340,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6a0e44af73593fb0cf4a34431fa96e01a5db862a",
      "simhash64": 7452291962375672875,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME ( ) NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : NAME = NAME ( NAME , NAME , None ) assert NAME is not None , f\" Method { NAME } should exist \" assert NAME ( NAME ) , f\" Method { NAME } should be callable \" return True"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "_test_session_validation_no_driver",
      "lineno": 343,
      "end_lineno": 347,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "9cbf7cba2808fa1854e09ab8d1c466070ac58e6f",
      "simhash64": 8641066314224272403,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME ( ) NAME = NAME . NAME ( ) assert not NAME , LIT return True"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "_test_ensure_driver_not_needed",
      "lineno": 350,
      "end_lineno": 355,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "82796396ee644bb2869779d87a07c502b3a4bc81",
      "simhash64": 7488144839681676291,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME ( ) NAME . NAME = False NAME = NAME . NAME ( LIT ) assert NAME , LIT return True"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "_test_cookie_check_invalid_session",
      "lineno": 358,
      "end_lineno": 362,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "dfdcc879d1a1a3f76d72f7e92d746b7d5aaf8eb7",
      "simhash64": 7488179989694026755,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME ( ) NAME = NAME . NAME ( [ LIT ] ) assert not NAME , LIT return True"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "_test_close_browser_no_driver",
      "lineno": 365,
      "end_lineno": 370,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "c051de085f9deaf62a919596e6c59539f58ae426",
      "simhash64": 8642227427493712899,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME ( ) NAME . NAME ( ) assert NAME . NAME is None , LIT assert not NAME . NAME , LIT return True"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "_test_state_management",
      "lineno": 373,
      "end_lineno": 379,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "366d18f9394ff8f34bb00e56945a66a7ae690561",
      "simhash64": 7487581888654517251,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME ( ) NAME . NAME = True assert NAME . NAME , LIT NAME . NAME ( ) assert not NAME . NAME , LIT return True"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "_test_configuration_access",
      "lineno": 382,
      "end_lineno": 385,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "bad4187f35fee2d9f381ae7deaa50b9981fa4a65",
      "simhash64": 6336517423737247235,
      "normalized": "def NAME ( ) -> NAME : assert NAME is not None , LIT assert NAME is not None , LIT return True"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "_test_initialization_performance",
      "lineno": 388,
      "end_lineno": 399,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "74311ff360f6d4e2163fd8112f39b26e67872d13",
      "simhash64": 7488215212721865755,
      "normalized": "def NAME ( ) -> NAME : import NAME NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( ) NAME = NAME . NAME ( ) NAME = NAME - NAME assert ( NAME < LIT ) , f\" 100 initializations took { NAME : .3f } s, should be under 1s \" return True"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "_test_exception_handling",
      "lineno": 402,
      "end_lineno": 411,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "29fd703949c99ba1726d005df9c1f87003684f1a",
      "simhash64": 8641136712495830035,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME ( ) try : NAME . NAME ( ) NAME . NAME ( [ LIT ] ) NAME = NAME . NAME ( ) assert NAME is None , LIT except NAME as NAME : raise NAME ( f\" Methods should handle invalid state gracefully: { NAME } \" ) return True"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 414,
      "end_lineno": 561,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 8,
      "loc": 148,
      "tags": [
        "pure-ish",
        "time",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "864c6a0cb8e52e58056530669cd54912a029e3d2",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME with NAME ( ) : NAME = NAME ( LIT , LIT ) NAME . NAME ( ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # === PHASE 4: REAL BROWSER CONCURRENCY TESTS === def NAME ( ) : LIT import NAME from NAME . NAME import NAME , NAME # Test with mock browser to avoid actual browser creation in tests with NAME ( LIT ) as NAME , NAME ( LIT , NAME = True ) : NAME = NAME ( ) NAME . NAME = LIT NAME . NAME . NAME = [ { LIT : LIT , LIT : LIT } ] NAME . NAME . NAME = LIT NAME . NAME = NAME NAME = NAME ( ) # Test concurrent browser operations NAME = [ ] NAME = [ ] def NAME ( NAME ) : try : # Start browser NAME = NAME . NAME ( f\" ConcurrencyTest- { NAME } \" ) if NAME : # Check session validity NAME = NAME . NAME ( ) if NAME : # Get cookies (the originally failing operation) NAME . NAME . NAME ( ) NAME . NAME ( f\" Thread- { NAME } : Success \" ) else : NAME . NAME ( f\" Thread- { NAME } : Invalid session \" ) else : NAME . NAME ( f\" Thread- { NAME } : Failed to start browser \" ) except NAME as NAME : NAME . NAME ( f\" Thread- { NAME } : Exception - { NAME } \" ) # Run 5 concurrent threads NAME = [ ] for NAME in NAME ( LIT ) : NAME = NAME . NAME ( NAME = NAME , NAME = ( NAME , ) ) NAME . NAME ( NAME ) NAME . NAME ( ) # Wait for all threads to complete for NAME in NAME : NAME . NAME ( ) # Verify results assert NAME ( NAME ) == LIT , f\" Concurrency test should have no errors, got: { NAME } \" assert NAME ( NAME ) == LIT , f\" Should have 5 successful operations, got: { NAME ( NAME ) } \" # Clean up NAME . NAME ( ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "test_real_browser_concurrency",
      "lineno": 497,
      "end_lineno": 551,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 55,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "b04b3a4b5dc49c2486ad70114006a4fbf6af3d7a",
      "simhash64": 7488215207352112187,
      "normalized": "def NAME ( ) : LIT import NAME from NAME . NAME import NAME , NAME # Test with mock browser to avoid actual browser creation in tests with NAME ( LIT ) as NAME , NAME ( LIT , NAME = True ) : NAME = NAME ( ) NAME . NAME = LIT NAME . NAME . NAME = [ { LIT : LIT , LIT : LIT } ] NAME . NAME . NAME = LIT NAME . NAME = NAME NAME = NAME ( ) # Test concurrent browser operations NAME = [ ] NAME = [ ] def NAME ( NAME ) : try : # Start browser NAME = NAME . NAME ( f\" ConcurrencyTest- { NAME } \" ) if NAME : # Check session validity NAME = NAME . NAME ( ) if NAME : # Get cookies (the originally failing operation) NAME . NAME . NAME ( ) NAME . NAME ( f\" Thread- { NAME } : Success \" ) else : NAME . NAME ( f\" Thread- { NAME } : Invalid session \" ) else : NAME . NAME ( f\" Thread- { NAME } : Failed to start browser \" ) except NAME as NAME : NAME . NAME ( f\" Thread- { NAME } : Exception - { NAME } \" ) # Run 5 concurrent threads NAME = [ ] for NAME in NAME ( LIT ) : NAME = NAME . NAME ( NAME = NAME , NAME = ( NAME , ) ) NAME . NAME ( NAME ) NAME . NAME ( ) # Wait for all threads to complete for NAME in NAME : NAME . NAME ( ) # Verify results assert NAME ( NAME ) == LIT , f\" Concurrency test should have no errors, got: { NAME } \" assert NAME ( NAME ) == LIT , f\" Should have 5 successful operations, got: { NAME ( NAME ) } \" # Clean up NAME . NAME ( )"
    },
    {
      "module_path": "core\\browser_manager.py",
      "qualname": "concurrent_browser_operation",
      "lineno": 517,
      "end_lineno": 533,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 17,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(thread_id)",
      "fingerprint": "6ad3496c1d5a00901a9ff42f0f39e82a78a0e8ab",
      "simhash64": 8641136711951619259,
      "normalized": "def NAME ( NAME ) : try : # Start browser NAME = NAME . NAME ( f\" ConcurrencyTest- { NAME } \" ) if NAME : # Check session validity NAME = NAME . NAME ( ) if NAME : # Get cookies (the originally failing operation) NAME . NAME . NAME ( ) NAME . NAME ( f\" Thread- { NAME } : Success \" ) else : NAME . NAME ( f\" Thread- { NAME } : Invalid session \" ) else : NAME . NAME ( f\" Thread- { NAME } : Failed to start browser \" ) except NAME as NAME : NAME . NAME ( f\" Thread- { NAME } : Exception - { NAME } \" )"
    },
    {
      "module_path": "core\\cancellation.py",
      "qualname": "request_cancel",
      "lineno": 18,
      "end_lineno": 22,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(scope)",
      "fingerprint": "feb61064b54da0f16f2ff61491ba184d65ae95cf",
      "simhash64": 8642368131763704833,
      "normalized": "def NAME ( NAME : NAME | None = None ) -> None : LIT global NAME NAME = NAME NAME . NAME ( )"
    },
    {
      "module_path": "core\\cancellation.py",
      "qualname": "clear_cancel",
      "lineno": 25,
      "end_lineno": 29,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "35ee3e16aaf3a60918bc2b64038b5d1be1a6aa8e",
      "simhash64": 8642403870724494339,
      "normalized": "def NAME ( ) -> None : LIT global NAME NAME = None NAME . NAME ( )"
    },
    {
      "module_path": "core\\cancellation.py",
      "qualname": "is_cancel_requested",
      "lineno": 32,
      "end_lineno": 34,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d47288f6127502799f806b1d647827a7f4d80a3e",
      "simhash64": 8645218654783181859,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME . NAME ( )"
    },
    {
      "module_path": "core\\cancellation.py",
      "qualname": "cancel_scope",
      "lineno": 37,
      "end_lineno": 39,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "5c13bca27da8f5c4a6dca6ca850e7e14cd3efae7",
      "simhash64": 7488312480904418339,
      "normalized": "def NAME ( ) -> NAME | None : LIT return NAME"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.__init__",
      "lineno": 78,
      "end_lineno": 127,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 50,
      "tags": [
        "impure",
        "filesystem",
        "purpose:initialization",
        "size:medium"
      ],
      "signature": "(self, db_path)",
      "fingerprint": "4c380fe2eff7576c672231d9267034affdf49b98",
      "simhash64": 7452152325539804179,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) : LIT # Database configuration if NAME : NAME . NAME = NAME elif NAME and NAME . NAME . NAME : NAME . NAME = NAME ( NAME . NAME . NAME . NAME ( ) ) else : # Ensure fallback also uses Data folder NAME = NAME ( LIT ) NAME . NAME . NAME ( NAME = True , NAME = True ) NAME . NAME = NAME ( NAME ) # Default fallback to Data folder # SQLAlchemy components NAME . NAME = None NAME . NAME : NAME [ NAME ] = None NAME . NAME : NAME = False NAME . NAME : NAME = False # Phase 7.3.2 Enhancement: Performance monitoring NAME . NAME = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } # Connection health monitoring NAME . NAME = LIT # 80% success rate threshold NAME . NAME = LIT # 1 second threshold for slow queries NAME . NAME = LIT # 1 hour max connection age # Adaptive pool sizing NAME . NAME = True NAME . NAME = LIT NAME . NAME = LIT NAME . NAME = NAME . NAME NAME . NAME ( f\" Enhanced DatabaseManager initialized with path: { NAME . NAME } (Phase 7.3.2) \" )"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager._calculate_optimal_pool_size",
      "lineno": 129,
      "end_lineno": 153,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 7,
      "loc": 25,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, base_size)",
      "fingerprint": "65958fa37682a07809496e78f84b0271dc75bb3c",
      "simhash64": 7451588275999257603,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT if not NAME . NAME : return NAME # Calculate pool efficiency metrics NAME = NAME . NAME [ LIT ] if NAME < LIT : # Not enough data for optimization return NAME NAME = LIT - ( NAME . NAME [ LIT ] / NAME ) NAME = NAME . NAME [ LIT ] / NAME # Adjust pool size based on metrics if NAME < NAME . NAME : # Poor success rate - increase pool size return NAME ( NAME + LIT , NAME . NAME ) if NAME > LIT : # More than 10% overflow # High overflow - increase pool size return NAME ( NAME + LIT , NAME . NAME ) if NAME < LIT and NAME > LIT : # Very low overflow and high success - can reduce pool size return NAME ( NAME - LIT , NAME . NAME ) return NAME"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager._update_connection_stats",
      "lineno": 155,
      "end_lineno": 176,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 8,
      "loc": 22,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, operation, success, query_time)",
      "fingerprint": "d9a6e8cd9197d89dbbf7a3486f0cffd750413bc8",
      "simhash64": 7452151226028176391,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME = True , NAME : NAME = LIT ) : LIT if NAME == LIT : NAME . NAME [ LIT ] += LIT if not NAME : NAME . NAME [ LIT ] += LIT elif NAME == LIT : NAME . NAME [ LIT ] += LIT NAME . NAME [ LIT ] += NAME if NAME > NAME . NAME : NAME . NAME [ LIT ] += LIT # Update average query time if NAME . NAME [ LIT ] > LIT : NAME . NAME [ LIT ] = ( NAME . NAME [ LIT ] / NAME . NAME [ LIT ] ) elif NAME == LIT : NAME . NAME [ LIT ] += LIT elif NAME == LIT : NAME . NAME [ LIT ] += LIT"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.get_performance_stats",
      "lineno": 178,
      "end_lineno": 200,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 23,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "3c1713f2e6444fd4033174e0877d6870ee630f3b",
      "simhash64": 14369680245070935059,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME . NAME ( ) # Calculate derived metrics NAME = NAME [ LIT ] if NAME > LIT : NAME [ LIT ] = LIT - ( NAME [ LIT ] / NAME ) NAME [ LIT ] = NAME [ LIT ] / NAME else : NAME [ LIT ] = LIT NAME [ LIT ] = LIT # Add pool information NAME [ LIT ] = NAME . NAME NAME [ LIT ] = NAME . NAME NAME [ LIT ] = NAME . NAME # Add health indicators NAME [ LIT ] = LIT if NAME [ LIT ] >= NAME . NAME else LIT NAME [ LIT ] = LIT if NAME [ LIT ] < NAME . NAME else LIT return NAME"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.batch_operation_context",
      "lineno": 203,
      "end_lineno": 252,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 1,
      "complexity": 8,
      "loc": 50,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, batch_size)",
      "fingerprint": "dac7289d401bf4e1f20ee899d5bbb4465796a5fe",
      "simhash64": 7488215207353160755,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) : LIT NAME = None NAME = LIT try : NAME = NAME . NAME ( ) if not NAME : raise NAME ( LIT ) NAME . NAME ( f\" Starting batch operation with batch size: { NAME } \" ) def NAME ( ) -> None : nonlocal NAME if NAME > LIT : NAME . NAME ( ) NAME . NAME ( f\" Committed batch of { NAME } operations \" ) NAME = LIT def NAME ( ) -> None : nonlocal NAME NAME += LIT if NAME >= NAME : NAME ( ) # Provide session and batch management functions yield NAME , NAME , NAME # Final commit for remaining operations NAME ( ) except NAME as NAME : if NAME : try : NAME . NAME ( ) NAME . NAME ( f\" Batch operation failed, rolled back: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Failed to rollback batch operation: { NAME } \" ) raise finally : if NAME : NAME . NAME ( NAME )"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.commit_batch",
      "lineno": 223,
      "end_lineno": 228,
      "is_method": true,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "a4064f7291625a81de7879f6734bc85faa2d9a3f",
      "simhash64": 8641136713033750067,
      "normalized": "def NAME ( ) -> None : nonlocal NAME if NAME > LIT : NAME . NAME ( ) NAME . NAME ( f\" Committed batch of { NAME } operations \" ) NAME = LIT"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.add_to_batch",
      "lineno": 230,
      "end_lineno": 234,
      "is_method": true,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "15d83b168a8e91ea3c62242cd93177dc7672f1ac",
      "simhash64": 7488355945915257955,
      "normalized": "def NAME ( ) -> None : nonlocal NAME NAME += LIT if NAME >= NAME : NAME ( )"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.execute_query_with_timing",
      "lineno": 254,
      "end_lineno": 284,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 31,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, session, query, params)",
      "fingerprint": "eadeee490d7a82ab6789a0655de2fd76ac46a3ab",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None ) -> NAME : LIT import NAME NAME = NAME . NAME ( ) try : NAME = NAME . NAME ( NAME , NAME ) if NAME else NAME . NAME ( NAME ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( LIT , NAME = True , NAME = NAME ) if NAME > NAME . NAME : NAME . NAME ( f\" Slow query detected: { NAME : .3f } s \" ) return NAME except NAME as NAME : NAME = NAME . NAME ( ) - NAME NAME . NAME ( LIT , NAME = False , NAME = NAME ) NAME . NAME ( f\" Query failed after { NAME : .3f } s: { NAME } \" ) raise"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.async_session_context",
      "lineno": 289,
      "end_lineno": 333,
      "is_method": true,
      "is_async": true,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 1,
      "complexity": 6,
      "loc": 45,
      "tags": [
        "async",
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "4142f148a5197fdccae1a386330b576e239716df",
      "simhash64": 7488180023047140371,
      "normalized": "async def NAME ( NAME ) -> NAME [ NAME , None ] : LIT NAME = None NAME = NAME . NAME ( ) try : # Get session in thread pool to avoid blocking NAME = await NAME . NAME ( None , NAME . NAME ) if not NAME : raise NAME ( LIT ) NAME . NAME ( LIT ) yield NAME # Commit in thread pool await NAME . NAME ( None , NAME . NAME ) NAME . NAME ( LIT ) except NAME as NAME : if NAME : try : await NAME . NAME ( None , NAME . NAME ) NAME . NAME ( f\" Async database session rolled back due to error: { NAME } \" ) except NAME as NAME : NAME . NAME ( f\" Failed to rollback async session: { NAME } \" ) raise finally : if NAME : await NAME . NAME ( None , NAME . NAME , NAME )"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.async_execute_query",
      "lineno": 335,
      "end_lineno": 387,
      "is_method": true,
      "is_async": true,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 6,
      "loc": 53,
      "tags": [
        "async",
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, session, query, params, fetch_results)",
      "fingerprint": "527e25422a1151698f16df966edcd49eb77d650c",
      "simhash64": 7488180022980031507,
      "normalized": "async def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME = True ) -> NAME [ NAME [ NAME [ NAME , NAME ] ] ] : LIT NAME = NAME . NAME ( ) def NAME ( ) -> NAME : try : # Convert string query to SQLAlchemy text object NAME = NAME ( NAME ) if NAME ( NAME , NAME ) else NAME NAME = NAME . NAME ( NAME , NAME ) if NAME else NAME . NAME ( NAME ) if NAME : # Convert result to list of dictionaries NAME = NAME . NAME ( ) if NAME : NAME = NAME . NAME ( ) return [ NAME ( NAME ( NAME , NAME ) ) for NAME in NAME ] return [ ] return None except NAME as NAME : NAME . NAME ( f\" Async query execution failed: { NAME } \" ) raise try : return await NAME . NAME ( None , NAME ) except NAME as NAME : NAME . NAME ( f\" Async database query failed: { NAME } \" ) return None"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager._execute_query",
      "lineno": 363,
      "end_lineno": 381,
      "is_method": true,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "360d6c741191e900dda2c20a9a9859606e4cecb5",
      "simhash64": 7488109654236898387,
      "normalized": "def NAME ( ) -> NAME : try : # Convert string query to SQLAlchemy text object NAME = NAME ( NAME ) if NAME ( NAME , NAME ) else NAME NAME = NAME . NAME ( NAME , NAME ) if NAME else NAME . NAME ( NAME ) if NAME : # Convert result to list of dictionaries NAME = NAME . NAME ( ) if NAME : NAME = NAME . NAME ( ) return [ NAME ( NAME ( NAME , NAME ) ) for NAME in NAME ] return [ ] return None except NAME as NAME : NAME . NAME ( f\" Async query execution failed: { NAME } \" ) raise"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.ensure_ready",
      "lineno": 389,
      "end_lineno": 411,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 23,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "2bf8bb97d569fd6fc68d03f4a543dbddd49d01c8",
      "simhash64": 7487652257465807875,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME . NAME ( LIT ) if not NAME . NAME or not NAME . NAME : try : NAME . NAME ( ) NAME . NAME = True NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" DB Initialization failed: { NAME } \" ) NAME . NAME = False return False else : NAME . NAME = True NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager._initialize_engine_and_session",
      "lineno": 413,
      "end_lineno": 526,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 12,
      "loc": 114,
      "tags": [
        "impure",
        "db",
        "filesystem",
        "regex",
        "size:large"
      ],
      "signature": "(self)",
      "fingerprint": "24f025884ccd175a0334df0d16c392e444996bfa",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME ) -> None : LIT # Prevent re-initialization if already done if NAME . NAME and NAME . NAME : NAME . NAME ( LIT ) return NAME . NAME ( LIT ) NAME . NAME = True # Dispose existing engine if somehow present but Session is not if NAME . NAME : NAME . NAME ( LIT ) try : NAME . NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" Error disposing existing engine: { NAME } \" ) NAME . NAME = None NAME . NAME = None try : NAME . NAME ( f\" DB Path: { NAME . NAME } \" ) # Phase 7.3.2: Enhanced pool configuration with adaptive sizing NAME = ( NAME . NAME . NAME if NAME and NAME . NAME else NAME . NAME ) if not NAME ( NAME , NAME ) or NAME <= LIT : NAME . NAME ( f\" Invalid DB_POOL_SIZE ' { NAME } '. Using default { NAME . NAME } . \" ) NAME = NAME . NAME # Adaptive pool sizing based on performance metrics NAME = NAME . NAME ( NAME ) NAME = NAME ( NAME , NAME . NAME ) # Cap pool size NAME . NAME = NAME # Enhanced pool configuration NAME = NAME ( LIT , NAME ( NAME * LIT ) ) # Increased overflow capacity NAME = LIT # Increased timeout for better reliability NAME = NAME . NAME # Recycle connections after max age NAME = True # Enable connection health checks NAME = NAME . NAME NAME . NAME ( f\" Enhanced DB Pool Config: Size= { NAME } , MaxOverflow= { NAME } , \" f\" Timeout= { NAME } , Recycle= { NAME } , PrePing= { NAME } \" ) # Create Enhanced Engine with Phase 7.3.2 optimizations NAME . NAME = NAME ( f\" sqlite:/// { NAME . NAME } \" , NAME = False , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = NAME , NAME = { LIT : False , LIT : LIT , # Connection timeout LIT : None , # Autocommit mode for better performance } , NAME = { LIT : False , LIT : { } , # Enable query compilation caching } ) NAME . NAME ( f\" Created SQLAlchemy engine: ID= { NAME ( NAME . NAME ) } \" ) # Attach event listener for PRAGMA settings @ NAME . NAME ( NAME . NAME , LIT ) def NAME ( NAME : NAME , NAME : NAME ) -> None : NAME = NAME . NAME ( ) try : NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) except NAME . NAME as NAME : NAME . NAME ( f\" Failed setting PRAGMA: { NAME } \" ) finally : NAME . NAME ( ) # Create Session Factory NAME . NAME = NAME ( NAME = NAME . NAME , NAME = False ) NAME . NAME ( f\" Created Session factory for Engine ID= { NAME ( NAME . NAME ) } \" ) # Ensure tables are created NAME . NAME ( ) except NAME as NAME : NAME . NAME ( f\" FAILED to initialize SQLAlchemy: { NAME } \" , NAME = True ) if NAME . NAME : NAME . NAME . NAME ( ) NAME . NAME = None NAME . NAME = None NAME . NAME = False raise NAME except NAME as NAME : NAME . NAME ( f\" UNEXPECTED error initializing SQLAlchemy: { NAME } \" , NAME = True ) if NAME . NAME : NAME . NAME . NAME ( ) NAME . NAME = None NAME . NAME = None NAME . NAME = False raise NAME"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.enable_sqlite_settings",
      "lineno": 488,
      "end_lineno": 500,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "impure",
        "db",
        "size:small"
      ],
      "signature": "(dbapi_connection, connection_record)",
      "fingerprint": "0311d2effb74566b63b2f746702e9fe86f5db6fe",
      "simhash64": 8640573762005545987,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : NAME = NAME . NAME ( ) try : NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) NAME . NAME ( LIT ) except NAME . NAME as NAME : NAME . NAME ( f\" Failed setting PRAGMA: { NAME } \" ) finally : NAME . NAME ( )"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager._ensure_tables_created",
      "lineno": 528,
      "end_lineno": 552,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 6,
      "loc": 25,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "c079dd50a7129d9233521635fa2b24f85fcf6d81",
      "simhash64": 8641136711958967299,
      "normalized": "def NAME ( NAME ) -> None : LIT if not NAME . NAME : NAME . NAME ( LIT ) return try : # Check if the database file exists and has tables NAME = NAME ( NAME . NAME ) NAME = NAME . NAME ( ) if NAME : NAME . NAME ( f\" Database already exists with tables: { NAME } \" ) # Create tables only if the database is empty elif NAME and NAME is not None : NAME . NAME . NAME ( NAME . NAME ) NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Non-critical error during DB table check/creation: { NAME } \" )"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.get_session",
      "lineno": 555,
      "end_lineno": 609,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 8,
      "loc": 55,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "e981c9e3d6fcd64811aea02f85bf4aebe0c36fa3",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT import NAME NAME = NAME . NAME ( ) NAME = NAME ( NAME . NAME ) if NAME . NAME else LIT NAME . NAME ( f\" get_session called. Current Engine ID: { NAME } \" ) # Initialize DB if needed if not NAME . NAME or not NAME . NAME or not NAME . NAME : NAME . NAME ( LIT ) try : NAME . NAME ( ) if not NAME . NAME : NAME . NAME ( LIT ) NAME . NAME ( LIT , NAME = False ) return None except NAME as NAME : NAME . NAME ( f\" Exception during lazy initialization: { NAME } \" ) NAME . NAME ( LIT , NAME = False ) return None # Get session from factory try : NAME : NAME = NAME . NAME ( ) NAME . NAME [ LIT ] += LIT # Track connection time NAME = NAME . NAME ( ) - NAME NAME . NAME ( LIT , NAME = True ) NAME . NAME ( f\" Obtained DB session { NAME ( NAME ) } from Engine ID= { NAME ( NAME . NAME ) } \" f\" (connection time: { NAME : .3f } s) \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Error getting DB session from factory: { NAME } \" , NAME = True ) NAME . NAME ( LIT , NAME = False ) # Attempt to recover by disposing engine and resetting flags if NAME . NAME : with NAME . NAME ( NAME ) : NAME . NAME . NAME ( ) NAME . NAME = None NAME . NAME = None NAME . NAME = False return None"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.return_session",
      "lineno": 611,
      "end_lineno": 631,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, session)",
      "fingerprint": "253e94d7691099a1f2b572d65124895c94ecc06f",
      "simhash64": 7452151226028168243,
      "normalized": "def NAME ( NAME , NAME : NAME ) : LIT if NAME : NAME = NAME ( NAME ) try : NAME . NAME ( ) NAME . NAME [ LIT ] = NAME ( LIT , NAME . NAME [ LIT ] - LIT ) NAME . NAME ( f\" DB session { NAME } closed and returned to pool. \" ) except NAME as NAME : NAME . NAME ( f\" Error closing DB session { NAME } : { NAME } \" , NAME = True ) # Track connection leak NAME . NAME [ LIT ] += LIT else : NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.get_session_context",
      "lineno": 634,
      "end_lineno": 711,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 2,
      "complexity": 12,
      "loc": 78,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "4ce88e8df16a6b2f54c2af17f1ee30008a0d4289",
      "simhash64": 7488215207352120347,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME [ NAME ] , None , None ] : LIT NAME : NAME [ NAME ] = None NAME = LIT try : NAME = NAME . NAME ( ) if NAME : NAME = NAME ( NAME ( NAME ) ) NAME . NAME ( f\" DB Context Manager: Acquired session { NAME } . \" ) yield NAME # After the 'with' block finishes: if NAME . NAME : try : NAME . NAME ( ) NAME . NAME ( f\" DB Context Manager: Commit successful for session { NAME } . \" ) except NAME as NAME : NAME . NAME ( f\" DB Context Manager: Commit failed for session { NAME } : { NAME } . Rolling back. \" ) NAME . NAME ( ) raise else : NAME . NAME ( f\" DB Context Manager: Session { NAME } inactive after yield, skipping commit. \" ) else : NAME . NAME ( LIT ) yield None except NAME as NAME : NAME . NAME ( f\" DB Context Manager: SQLAlchemyError ( { NAME ( NAME ) . NAME } ). Rolling back session { NAME } . \" , NAME = True , ) if NAME and NAME . NAME : try : NAME . NAME ( ) NAME . NAME ( f\" DB Context Manager: Rollback successful for session { NAME } . \" ) except NAME as NAME : NAME . NAME ( f\" DB Context Manager: Error during rollback for session { NAME } : { NAME } \" ) raise NAME except NAME as NAME : NAME . NAME ( f\" DB Context Manager: Unexpected Exception ( { NAME ( NAME ) . NAME } ). Rolling back session { NAME } . \" , NAME = True , ) if NAME and NAME . NAME : try : NAME . NAME ( ) NAME . NAME ( f\" DB Context Manager: Rollback successful for session { NAME } . \" ) except NAME as NAME : NAME . NAME ( f\" DB Context Manager: Error during rollback for session { NAME } : { NAME } \" ) raise NAME finally : # Always return the session to the pool if NAME : NAME . NAME ( NAME ) else : NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.close_connections",
      "lineno": 713,
      "end_lineno": 736,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, dispose_engine)",
      "fingerprint": "bb50c87a63fa977fd7b4042b252fe9105bb6919c",
      "simhash64": 7452186410333148187,
      "normalized": "def NAME ( NAME , NAME : NAME = False ) : LIT if NAME and NAME . NAME : NAME = NAME ( NAME . NAME ) NAME . NAME ( f\" Disposing Engine ID: { NAME } \" ) try : NAME . NAME . NAME ( ) NAME . NAME ( f\" Engine ID= { NAME } disposed successfully. \" ) except NAME as NAME : NAME . NAME ( f\" Error disposing SQLAlchemy engine ID= { NAME } : { NAME } \" , NAME = True , ) finally : NAME . NAME = None NAME . NAME = None NAME . NAME = False else : NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.is_ready",
      "lineno": 739,
      "end_lineno": 741,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "2dc4d0a14fc4df6c2456c35e56f4b9341166183a",
      "simhash64": 7489305922886861843,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME and NAME . NAME is not None and NAME . NAME is not None"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "DatabaseManager.get_db_path",
      "lineno": 743,
      "end_lineno": 745,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "7cf791c4ea854fe6df646a3cb215382778b2a514",
      "simhash64": 7488109654235849795,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "database_manager_module_tests",
      "lineno": 753,
      "end_lineno": 839,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 87,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "fdd0b84dfc4d23e9ed64e921e5376a7edbc9b7ab",
      "simhash64": 5127871576777593899,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import ( NAME , NAME , ) with NAME ( ) : NAME = NAME ( LIT , LIT ) # Run all tests NAME ( LIT ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Generate summary report return NAME . NAME ( )"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 842,
      "end_lineno": 844,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "test_database_manager_initialization",
      "lineno": 848,
      "end_lineno": 859,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "a49cd9fe13adfdb4f808a849090eabc851c747c8",
      "simhash64": 8606339369036846115,
      "normalized": "def NAME ( ) -> None : LIT # Test memory database initialization NAME = NAME ( NAME = LIT ) assert ( NAME . NAME == LIT ) , LIT assert NAME . NAME is None , LIT assert NAME . NAME is None , LIT assert ( not NAME . NAME ) , LIT"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "test_engine_session_creation",
      "lineno": 862,
      "end_lineno": 869,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "726472d43986facd227ccbd41d66199395310d29",
      "simhash64": 8642403316136318011,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( NAME = LIT ) try : NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT except NAME : pass # Database creation might fail in test environment"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "test_session_context_management",
      "lineno": 872,
      "end_lineno": 881,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 10,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f85e1f3c479c1b869883f7c287c737e03d27f483",
      "simhash64": 7489473015435924523,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( NAME = LIT ) try : with NAME . NAME ( ) as NAME : assert NAME is None or NAME ( NAME , LIT ) , LIT except NAME : pass # Context manager might fail without proper database setup"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "test_connection_pooling",
      "lineno": 884,
      "end_lineno": 893,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 10,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c383ab233718cf8af24994abae84c566eeddf1ad",
      "simhash64": 8641277416228426787,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( NAME = LIT ) try : NAME = NAME . NAME ( ) if NAME : NAME . NAME ( NAME ) assert True , LIT except NAME : pass # Session operations might fail without proper setup"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "test_database_readiness",
      "lineno": 896,
      "end_lineno": 900,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "2a06cc422902fd52c12c8a1e7511091cd4240d98",
      "simhash64": 7488320727182382139,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( NAME = LIT ) NAME = NAME . NAME assert NAME ( NAME , NAME ) , LIT"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "test_error_handling_recovery",
      "lineno": 903,
      "end_lineno": 910,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "ffb04eeca2b3c3de8332f8bed060babaa147fe47",
      "simhash64": 8641277416229475375,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( NAME = LIT ) try : NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT except NAME : pass # Error handling is acceptable for invalid paths"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "test_session_lifecycle",
      "lineno": 913,
      "end_lineno": 922,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 10,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "52364669a45b064b18a6ea3e9ba1ba3b5aa02584",
      "simhash64": 7488355911622104107,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( NAME = LIT ) try : NAME = NAME . NAME ( ) if NAME : assert NAME ( NAME , LIT ) , LIT NAME . NAME ( NAME ) except NAME : pass # Session lifecycle might fail without proper setup"
    },
    {
      "module_path": "core\\database_manager.py",
      "qualname": "test_transaction_isolation",
      "lineno": 925,
      "end_lineno": 933,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "23be5c7611b9b391bd04ec93ba87881612b04d99",
      "simhash64": 8641840920233153583,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( NAME = LIT ) try : # Test that multiple session contexts don't interfere with NAME . NAME ( ) , NAME . NAME ( ) : assert True , LIT except NAME : pass # Transaction isolation testing might require specific setup"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIContainer.__init__",
      "lineno": 53,
      "end_lineno": 59,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "08cd71607d69e9bc33f4c28483ccc91f5361dc26",
      "simhash64": 7453206757123732503,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME = NAME . NAME ( ) NAME . NAME : NAME [ NAME ] = [ ]"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIContainer.register_singleton",
      "lineno": 61,
      "end_lineno": 87,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 27,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, interface, implementation, name)",
      "fingerprint": "7612b30efaf76b905bef57a4ad5008a1e4daea1f",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME [ NAME ] , NAME ] , NAME : NAME [ NAME ] = None , ) -> None : LIT with NAME . NAME : NAME = NAME or NAME . NAME ( NAME ) if NAME . NAME ( NAME ) : # Store class for lazy instantiation NAME . NAME [ NAME ] = NAME NAME . NAME [ NAME ] = NAME NAME . NAME ( f\" Registered singleton class: { NAME } \" ) else : # Store instance directly NAME . NAME [ NAME ] = NAME NAME . NAME [ NAME ] = NAME ( NAME ) NAME . NAME ( f\" Registered singleton instance: { NAME } \" )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIContainer.register_transient",
      "lineno": 89,
      "end_lineno": 108,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 20,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, interface, implementation, name)",
      "fingerprint": "a34891d0217c4d4f66c7d354b0788012c639f153",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME ] , NAME : NAME [ NAME ] = None ) -> None : LIT with NAME . NAME : NAME = NAME or NAME . NAME ( NAME ) def NAME ( ) -> NAME : return NAME . NAME ( NAME ) NAME . NAME [ NAME ] = NAME NAME . NAME [ NAME ] = NAME NAME . NAME ( f\" Registered transient service: { NAME } \" )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIContainer.factory",
      "lineno": 103,
      "end_lineno": 104,
      "is_method": true,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "2b9a02f274b37e8f038289311ebcf15cc5553f34",
      "simhash64": 8641137267620881507,
      "normalized": "def NAME ( ) -> NAME : return NAME . NAME ( NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIContainer.register_factory",
      "lineno": 110,
      "end_lineno": 124,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 15,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self, interface, factory, name)",
      "fingerprint": "f5d61357a43843775f44e75cffe640c2248a9726",
      "simhash64": 7452151225961067603,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME [ [ ] , NAME ] , NAME : NAME [ NAME ] = None ) -> None : LIT with NAME . NAME : NAME = NAME or NAME . NAME ( NAME ) NAME . NAME [ NAME ] = NAME NAME . NAME ( f\" Registered factory: { NAME } \" )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIContainer.register_instance",
      "lineno": 126,
      "end_lineno": 141,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, interface, instance, name)",
      "fingerprint": "99244c49549401052ed44d7a30fb17ace51ca815",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME , NAME : NAME [ NAME ] = None ) -> None : LIT with NAME . NAME : NAME = NAME or NAME . NAME ( NAME ) NAME . NAME [ NAME ] = NAME NAME . NAME [ NAME ] = NAME ( NAME ) NAME . NAME ( f\" Registered instance: { NAME } \" )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIContainer.resolve",
      "lineno": 143,
      "end_lineno": 187,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 7,
      "loc": 45,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, interface, name)",
      "fingerprint": "72db0722428683928d0a8f4f1bf7e852c488884d",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME [ NAME ] = None ) -> NAME : LIT with NAME . NAME : NAME = NAME or NAME . NAME ( NAME ) # Check if already instantiated as singleton if NAME in NAME . NAME : return NAME . NAME [ NAME ] # Check for factory if NAME in NAME . NAME : NAME = NAME . NAME [ NAME ] ( ) NAME . NAME ( f\" Created instance via factory: { NAME } \" ) return NAME # Check for registered class (singleton) if NAME in NAME . NAME : NAME = NAME . NAME ( NAME . NAME [ NAME ] ) NAME . NAME [ NAME ] = NAME NAME . NAME ( f\" Created singleton instance: { NAME } \" ) return NAME # Try to resolve by interface mapping if NAME in NAME . NAME : NAME = NAME . NAME [ NAME ] NAME = NAME . NAME ( NAME ) NAME . NAME [ NAME ] = NAME NAME . NAME ( f\" Created instance via interface mapping: { NAME } \" ) return NAME raise NAME ( f\" Cannot resolve service: { NAME } ( { NAME } ) \" )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIContainer.is_registered",
      "lineno": 189,
      "end_lineno": 207,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 19,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self, interface, name)",
      "fingerprint": "b39ba19dc481c6f1180ff24c953809c8b4c97772",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT with NAME . NAME : NAME = NAME or NAME . NAME ( NAME ) return ( NAME in NAME . NAME or NAME in NAME . NAME or NAME in NAME . NAME or NAME in NAME . NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIContainer.clear",
      "lineno": 209,
      "end_lineno": 217,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "183aa71f30722fef13ab5396408176ef16d11825",
      "simhash64": 8640573766837380099,
      "normalized": "def NAME ( NAME ) -> None : LIT with NAME . NAME : NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIContainer.get_registration_info",
      "lineno": 219,
      "end_lineno": 238,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 20,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "5ae1a5da8f1ef673dd366c5fdb7a7689c48d9a8c",
      "simhash64": 7487617073026602019,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT with NAME . NAME : return { LIT : NAME ( NAME . NAME . NAME ( ) ) , LIT : NAME ( NAME . NAME . NAME ( ) ) , LIT : NAME ( NAME . NAME . NAME ( ) ) , LIT : { NAME ( NAME ) : NAME ( NAME ) for NAME , NAME in NAME . NAME . NAME ( ) } , LIT : NAME ( NAME . NAME ) + NAME ( NAME . NAME ) + NAME ( NAME . NAME ) , }"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIContainer._get_service_name",
      "lineno": 240,
      "end_lineno": 242,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self, service_type)",
      "fingerprint": "eaf78fde6eca64ff8d0080b43dc11df52734259b",
      "simhash64": 7452080857216889875,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT return f\" { NAME . NAME } . { NAME . NAME } \""
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIContainer._create_instance",
      "lineno": 244,
      "end_lineno": 297,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 8,
      "loc": 54,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:medium"
      ],
      "signature": "(self, implementation)",
      "fingerprint": "8c7ca3cb702589993cdc6c6a72255c5dd8837211",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT try : # Get constructor signature NAME = NAME . NAME ( NAME . NAME ) NAME = NAME . NAME # Skip 'self' parameter NAME = { NAME : NAME for NAME , NAME in NAME . NAME ( ) if NAME != LIT } # Resolve dependencies NAME = { } for NAME , NAME in NAME . NAME ( ) : if NAME . NAME != NAME . NAME . NAME : try : # Try to resolve the parameter type NAME = NAME . NAME ( NAME . NAME ) NAME [ NAME ] = NAME except NAME : # If dependency cannot be resolved and parameter has no default, # let the constructor handle it if NAME . NAME == NAME . NAME . NAME : NAME . NAME ( f\" Cannot resolve dependency { NAME } : { NAME . NAME } \" f\" for { NAME . NAME } \" ) # Create instance NAME = NAME ( ** NAME ) NAME . NAME ( f\" Created instance: { NAME . NAME } with dependencies: { NAME ( NAME . NAME ( ) ) } \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Failed to create instance of { NAME } : { NAME } \" ) # Fallback to parameterless constructor try : return NAME ( ) except NAME as NAME : NAME . NAME ( f\" Fallback creation also failed: { NAME } \" ) raise NAME ( f\" Cannot create instance of { NAME } : { NAME } \" )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "Injectable.__init_subclass__",
      "lineno": 313,
      "end_lineno": 317,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(cls, **kwargs)",
      "fingerprint": "265c563401dee71d286aa57907ab961a83119f90",
      "simhash64": 7487652257399747687,
      "normalized": "def NAME ( NAME , ** NAME : NAME ) -> None : LIT NAME ( ) . NAME ( ** NAME ) # Note: Actual registration happens in the container setup NAME . NAME ( f\" Injectable subclass defined: { NAME . NAME } \" )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "inject",
      "lineno": 320,
      "end_lineno": 347,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(service_type, name)",
      "fingerprint": "afae463b471ce8530cd5bf4c9a62d5f4710d182a",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME [ NAME ] = None ) -> NAME [ [ NAME [ ... , NAME ] ] , NAME [ ... , NAME ] ] : LIT def NAME ( NAME : NAME [ ... , NAME ] ) -> NAME [ ... , NAME ] : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # Get container from global registry NAME = NAME ( ) NAME = NAME . NAME ( NAME , NAME ) # Add service to kwargs NAME = NAME or NAME . NAME . NAME ( ) NAME [ NAME ] = NAME return NAME ( * NAME , ** NAME ) return NAME return NAME"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "decorator",
      "lineno": 332,
      "end_lineno": 345,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(func)",
      "fingerprint": "f1cbf158a0d1ce5d9cefe522ee0a1a1a38f7086a",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME [ ... , NAME ] ) -> NAME [ ... , NAME ] : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # Get container from global registry NAME = NAME ( ) NAME = NAME . NAME ( NAME , NAME ) # Add service to kwargs NAME = NAME or NAME . NAME . NAME ( ) NAME [ NAME ] = NAME return NAME ( * NAME , ** NAME ) return NAME"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "wrapper",
      "lineno": 334,
      "end_lineno": 343,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "787532795e2ebe5851e67a7ecd86ab9134aa7b8b",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : # Get container from global registry NAME = NAME ( ) NAME = NAME . NAME ( NAME , NAME ) # Add service to kwargs NAME = NAME or NAME . NAME . NAME ( ) NAME [ NAME ] = NAME return NAME ( * NAME , ** NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "ServiceRegistry.get_container",
      "lineno": 360,
      "end_lineno": 380,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 21,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(cls, name)",
      "fingerprint": "5f24449c3482c6e7df8b6d31f8f778514d656fff",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) -> NAME : LIT with NAME . NAME : if NAME not in NAME . NAME : NAME . NAME [ NAME ] = NAME ( ) NAME . NAME ( f\" Created DI container: { NAME } \" ) NAME = NAME . NAME [ NAME ] if NAME == LIT and NAME . NAME is None : NAME . NAME = NAME return NAME"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "ServiceRegistry.clear_container",
      "lineno": 383,
      "end_lineno": 395,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(cls, name)",
      "fingerprint": "e61e702a67f0a6fb97c128b0a2e1ee3a1e0be9ff",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) -> None : LIT with NAME . NAME : if NAME in NAME . NAME : NAME . NAME [ NAME ] . NAME ( ) if NAME == LIT : NAME . NAME = None NAME . NAME ( f\" Cleared DI container: { NAME } \" )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "ServiceRegistry.clear_all_containers",
      "lineno": 398,
      "end_lineno": 405,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(cls)",
      "fingerprint": "75edfa80fd28836a2a41abe63f18114d7ba2448d",
      "simhash64": 8641137266076857347,
      "normalized": "def NAME ( NAME ) -> None : LIT with NAME . NAME : for NAME in NAME . NAME . NAME ( ) : NAME . NAME ( ) NAME . NAME . NAME ( ) NAME . NAME = None NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "get_container",
      "lineno": 408,
      "end_lineno": 418,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(name)",
      "fingerprint": "71b31f98f11c4ea6dbaf8395f2de9f58c3e56f07",
      "simhash64": 7488355945914209315,
      "normalized": "def NAME ( NAME : NAME = LIT ) -> NAME : LIT return NAME . NAME ( NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "configure_dependencies",
      "lineno": 421,
      "end_lineno": 475,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 55,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "9ff66ebcfc1f2a87d4b936883eef80da66195365",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( ) -> None : LIT NAME = NAME ( ) # Clear existing registrations NAME . NAME ( ) try : # Register core services from NAME . NAME import NAME from NAME . NAME import NAME from NAME . NAME import NAME from NAME . NAME import NAME from NAME . NAME import NAME # Register managers as singletons NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME , NAME ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Could not register core services: { NAME } \" ) try : # Register configuration services from NAME . NAME import NAME NAME . NAME ( NAME , NAME ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Could not register configuration services: { NAME } \" ) try : # Register security services from NAME import NAME NAME . NAME ( NAME , NAME ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Could not register security services: { NAME } \" ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "get_service",
      "lineno": 478,
      "end_lineno": 490,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(service_type, name)",
      "fingerprint": "b170777f41ef57acd611d23ff6621da2ee86fd3d",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME [ NAME ] = None ) -> NAME : LIT NAME = NAME ( ) return NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIScope.__init__",
      "lineno": 501,
      "end_lineno": 503,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, container_name)",
      "fingerprint": "6106eb558d4a46a450d2c1ff88cf825a62626c59",
      "simhash64": 8606269550115599379,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) -> None : NAME . NAME = NAME NAME . NAME = None"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIScope.__enter__",
      "lineno": 505,
      "end_lineno": 516,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "b05190e7a4b228b51e971553fef3182a4a399cb5",
      "simhash64": 7487617074100352003,
      "normalized": "def NAME ( NAME ) -> NAME : NAME = NAME ( NAME . NAME ) # Save current state NAME . NAME = { LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , LIT : NAME ( NAME . NAME ) , } return NAME"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "DIScope.__exit__",
      "lineno": 518,
      "end_lineno": 526,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, exc_type, exc_val, exc_tb)",
      "fingerprint": "3b464c7d9ce2b80864f9204bbc1ed8dab3fbd026",
      "simhash64": 7452151226028176471,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME [ NAME ] ] , NAME : NAME [ NAME ] , NAME : NAME [ NAME ] ) -> None : if NAME . NAME : NAME = NAME ( NAME . NAME ) # Restore original state NAME . NAME = NAME . NAME [ LIT ] NAME . NAME = NAME . NAME [ LIT ] NAME . NAME = NAME . NAME [ LIT ] NAME . NAME = NAME . NAME [ LIT ]"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.setUp",
      "lineno": 530,
      "end_lineno": 531,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "c16d1511cb50028ea079013a4fcb5de8a92e3c64",
      "simhash64": 8641137232725312515,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME = NAME ( )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_register_singleton",
      "lineno": 533,
      "end_lineno": 540,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "0e5be308984c4ef813cadcfba4834df22a3ab3b5",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME ) : class NAME : pass NAME . NAME . NAME ( NAME , NAME ) NAME = NAME . NAME . NAME ( NAME ) NAME = NAME . NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_register_transient",
      "lineno": 542,
      "end_lineno": 549,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "0e5be308984c4ef813cadcfba4834df22a3ab3b5",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME ) : class NAME : pass NAME . NAME . NAME ( NAME , NAME ) NAME = NAME . NAME . NAME ( NAME ) NAME = NAME . NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_register_factory",
      "lineno": 551,
      "end_lineno": 561,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "5d47c97b77d55150e5ade775c19392a4ac818d57",
      "simhash64": 7488215207352116227,
      "normalized": "def NAME ( NAME ) : class NAME : def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME def NAME ( ) -> NAME : return NAME ( LIT ) NAME . NAME . NAME ( NAME , NAME ) NAME = NAME . NAME . NAME ( NAME ) NAME . NAME ( NAME . NAME , LIT )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.ServiceC.__init__",
      "lineno": 553,
      "end_lineno": 554,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, value)",
      "fingerprint": "0f70e91530b827d64534e5f608ec2fe7441857ef",
      "simhash64": 7488109620949853267,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.factory",
      "lineno": 556,
      "end_lineno": 557,
      "is_method": true,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "bdbaab1d714b7d04871810982bee378ab9d9d8a1",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : return NAME ( LIT )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_register_instance",
      "lineno": 563,
      "end_lineno": 570,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "57f989d2d1362df9cadcbcc012ab1b4107c32d91",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME ) : class NAME : pass NAME = NAME ( ) NAME . NAME . NAME ( NAME , NAME ) NAME = NAME . NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_resolve_singleton",
      "lineno": 572,
      "end_lineno": 578,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "9f5035636cc7eb6b51fac9007d8958d897ccd6f2",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME ) : class NAME : pass NAME . NAME . NAME ( NAME , NAME ) NAME = NAME . NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_resolve_transient",
      "lineno": 580,
      "end_lineno": 586,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "9f5035636cc7eb6b51fac9007d8958d897ccd6f2",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME ) : class NAME : pass NAME . NAME . NAME ( NAME , NAME ) NAME = NAME . NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_resolve_factory",
      "lineno": 588,
      "end_lineno": 599,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "502a08856407934dda75f1b9cd428f33e42e983e",
      "simhash64": 7488180022980027395,
      "normalized": "def NAME ( NAME ) : class NAME : def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME def NAME ( ) -> NAME : return NAME ( LIT ) NAME . NAME . NAME ( NAME , NAME ) NAME = NAME . NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME . NAME , LIT )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.ServiceG.__init__",
      "lineno": 590,
      "end_lineno": 591,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, value)",
      "fingerprint": "0f70e91530b827d64534e5f608ec2fe7441857ef",
      "simhash64": 7488109620949853267,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.factory",
      "lineno": 593,
      "end_lineno": 594,
      "is_method": true,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "bdbaab1d714b7d04871810982bee378ab9d9d8a1",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : return NAME ( LIT )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_resolve_instance",
      "lineno": 601,
      "end_lineno": 609,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "0b8c743989698558bee02248a870ba474fa2fe42",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME ) : class NAME : pass NAME = NAME ( ) NAME . NAME . NAME ( NAME , NAME ) NAME = NAME . NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_is_registered",
      "lineno": 611,
      "end_lineno": 617,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "980044e32e5cd809954cb801473fe27b142b738f",
      "simhash64": 8640573766300509187,
      "normalized": "def NAME ( NAME ) : class NAME : pass NAME . NAME ( NAME . NAME . NAME ( NAME ) ) NAME . NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME . NAME . NAME ( NAME ) )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_clear",
      "lineno": 619,
      "end_lineno": 625,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "47f37dd49334b7d024a975df7a440ba1171c760a",
      "simhash64": 8640573766300509187,
      "normalized": "def NAME ( NAME ) : class NAME : pass NAME . NAME . NAME ( NAME , NAME ) NAME . NAME . NAME ( ) NAME . NAME ( NAME . NAME . NAME ( NAME ) )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_get_registration_info",
      "lineno": 627,
      "end_lineno": 633,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "85ee678832c054054c80511926da571672666726",
      "simhash64": 7487617073026610179,
      "normalized": "def NAME ( NAME ) : class NAME : pass NAME . NAME . NAME ( NAME , NAME , LIT ) NAME = NAME . NAME . NAME ( ) NAME . NAME ( LIT , NAME [ LIT ] )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_create_instance",
      "lineno": 635,
      "end_lineno": 642,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "b130779bf63208f63e5341d368337e334f395640",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME ) : class NAME : def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME NAME . NAME . NAME ( NAME , NAME ) NAME = NAME . NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.ServiceL.__init__",
      "lineno": 637,
      "end_lineno": 638,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, value)",
      "fingerprint": "0f70e91530b827d64534e5f608ec2fe7441857ef",
      "simhash64": 7488109620949853267,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_di_resolution_error",
      "lineno": 644,
      "end_lineno": 649,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "c4f10946f2905d9e1e04549267ecd9ffcd43d7df",
      "simhash64": 8641136711958963203,
      "normalized": "def NAME ( NAME ) : class NAME : pass with NAME . NAME ( NAME ) : NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_injectable_class",
      "lineno": 651,
      "end_lineno": 658,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "05a73667009ed5b23b49ee5e1706deda19deda9b",
      "simhash64": 8641136717327672323,
      "normalized": "def NAME ( NAME ) : class NAME ( NAME ) : def NAME ( NAME ) -> None : NAME . NAME = True NAME = NAME ( ) NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME . NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.InjectableService.__init__",
      "lineno": 653,
      "end_lineno": 654,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "c59230bc2dab118a79eb4cdf99fe8ea812c0c6a7",
      "simhash64": 8642192763953513475,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME = True"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_inject_decorator",
      "lineno": 660,
      "end_lineno": 673,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "1413e4f0aee4c1966e4f27e1bcbbac988b8d03d3",
      "simhash64": 7488215207352116227,
      "normalized": "def NAME ( NAME ) : class NAME : def NAME ( NAME ) -> None : NAME . NAME = LIT NAME . NAME . NAME ( NAME , NAME ) @ NAME ( NAME ) def NAME ( ** NAME : NAME ) -> NAME : NAME = NAME . NAME ( LIT ) return NAME . NAME if NAME else LIT NAME = NAME ( ) NAME . NAME ( NAME , LIT )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.InjectedService.__init__",
      "lineno": 662,
      "end_lineno": 663,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "751789f28928c095ea105f32dd8834d2bad13544",
      "simhash64": 8605249168965276675,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME = LIT"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_function",
      "lineno": 668,
      "end_lineno": 670,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(**kwargs)",
      "fingerprint": "1d7d9d8b1b77fd0901dd6544241ce77bad0846b8",
      "simhash64": 7488109654235849795,
      "normalized": "def NAME ( ** NAME : NAME ) -> NAME : NAME = NAME . NAME ( LIT ) return NAME . NAME if NAME else LIT"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_service_registry",
      "lineno": 675,
      "end_lineno": 686,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "e73cf69b4d466c0ea80b9e07020a36d65eecb333",
      "simhash64": 8640573766300509187,
      "normalized": "def NAME ( NAME ) : NAME = NAME . NAME ( LIT ) NAME . NAME ( NAME ) NAME = NAME . NAME ( LIT ) NAME . NAME ( NAME , NAME ) NAME = NAME . NAME ( ) NAME . NAME ( NAME ) NAME . NAME ( LIT ) NAME . NAME ( )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_global_container",
      "lineno": 688,
      "end_lineno": 695,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "f940911a699487347d5a8cec1c5cb5a7680b6d52",
      "simhash64": 7488144843976639515,
      "normalized": "def NAME ( NAME ) : NAME = NAME ( ) NAME = NAME ( ) NAME . NAME ( NAME , NAME ) NAME = NAME ( LIT ) NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_configure_dependencies",
      "lineno": 697,
      "end_lineno": 701,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "7a078d2bdae06b5d9e82583321cff7619d80ec6f",
      "simhash64": 8641136677666326203,
      "normalized": "def NAME ( NAME ) : try : NAME ( ) except NAME as NAME : NAME . NAME ( f\" configure_dependencies raised an exception: { NAME } \" )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_get_service_convenience",
      "lineno": 703,
      "end_lineno": 712,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "9f09c819e0c33e4366b18d9d278c8cef0a60ff02",
      "simhash64": 7488144838607938579,
      "normalized": "def NAME ( NAME ) : class NAME : def NAME ( NAME ) -> None : NAME . NAME = True NAME . NAME . NAME ( NAME , NAME ) NAME = NAME ( NAME ) NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME . NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.ConvenienceService.__init__",
      "lineno": 705,
      "end_lineno": 706,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "c59230bc2dab118a79eb4cdf99fe8ea812c0c6a7",
      "simhash64": 8642192763953513475,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME = True"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_di_scope",
      "lineno": 714,
      "end_lineno": 725,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "0a7d6803d2eea5be923ec265413272f6778549e4",
      "simhash64": 7488144838607938563,
      "normalized": "def NAME ( NAME ) : with NAME ( ) as NAME : class NAME : def NAME ( NAME ) -> None : NAME . NAME = True NAME . NAME ( NAME , NAME ) NAME = NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME . NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.ScopedService.__init__",
      "lineno": 718,
      "end_lineno": 719,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "c59230bc2dab118a79eb4cdf99fe8ea812c0c6a7",
      "simhash64": 8642192763953513475,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME = True"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_container_state_management",
      "lineno": 727,
      "end_lineno": 741,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "a5453aed5370b1e3be9b210066c3a4e4dbd43f26",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME ) : NAME = NAME ( ) class NAME : def NAME ( NAME ) -> None : NAME . NAME = LIT NAME . NAME ( NAME , NAME ) NAME = NAME . NAME ( NAME ) NAME . NAME = LIT NAME = NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME . NAME , LIT )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.StateService.__init__",
      "lineno": 731,
      "end_lineno": 732,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "751789f28928c095ea105f32dd8834d2bad13544",
      "simhash64": 8605249168965276675,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME = LIT"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_type_annotations",
      "lineno": 743,
      "end_lineno": 751,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "bc2a0e9e78f6767d11d8633dc2c81eec05865a90",
      "simhash64": 7488180022980027411,
      "normalized": "def NAME ( NAME ) : import NAME NAME = NAME . NAME ( NAME . NAME ) NAME . NAME ( LIT , NAME . NAME ) NAME . NAME ( LIT , NAME . NAME ) NAME = NAME . NAME ( NAME ) NAME . NAME ( LIT , NAME . NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_imports_and_availability",
      "lineno": 753,
      "end_lineno": 762,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "393a74d05a5d2ad534051128ed3a6fd9f294bedf",
      "simhash64": 8641136716253930579,
      "normalized": "def NAME ( NAME ) : NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME )"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.test_integration",
      "lineno": 764,
      "end_lineno": 790,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 27,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "b92c2b323c173bded0296737dac9a41fdcb9106d",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME ) : NAME = NAME ( ) class NAME : def NAME ( NAME ) -> None : NAME . NAME = { LIT : LIT } class NAME : def NAME ( NAME , NAME : NAME ) : NAME . NAME = NAME NAME . NAME = [ ] class NAME : def NAME ( NAME , NAME : NAME , NAME : NAME ) : NAME . NAME = NAME NAME . NAME = NAME NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME , NAME ) NAME = NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME ) NAME . NAME ( NAME . NAME , NAME ) NAME . NAME ( NAME . NAME , NAME ) NAME . NAME ( NAME . NAME . NAME , NAME . NAME ) # Define all tests"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.ConfigService.__init__",
      "lineno": 768,
      "end_lineno": 769,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "4d0aa66831de08f9a71af4ceb50bae224ed5f345",
      "simhash64": 8606374519108965931,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME = { LIT : LIT }"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.LogService.__init__",
      "lineno": 772,
      "end_lineno": 774,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, config)",
      "fingerprint": "fe12e14121f863e83468bf80f0f23fe046b40e10",
      "simhash64": 7488109654235849815,
      "normalized": "def NAME ( NAME , NAME : NAME ) : NAME . NAME = NAME NAME . NAME = [ ]"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "TestDIContainer.AppService.__init__",
      "lineno": 777,
      "end_lineno": 779,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, log, config)",
      "fingerprint": "045efdf4d5cd52273a8b789c2eb1fea0cce1eec3",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) : NAME . NAME = NAME NAME . NAME = NAME"
    },
    {
      "module_path": "core\\dependency_injection.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 793,
      "end_lineno": 797,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "cb37d137f87d1bd17f79b98e450594486c79e7de",
      "simhash64": 8641136716790801411,
      "normalized": "def NAME ( ) -> None : NAME = NAME . NAME ( ) NAME . NAME ( NAME . NAME ( ) . NAME ( NAME ) ) NAME = NAME . NAME ( ) NAME . NAME ( NAME )"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "ErrorContext.add_error",
      "lineno": 49,
      "end_lineno": 52,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, error)",
      "fingerprint": "684df9fdff855f0f083f55cd0f08d2929b365f40",
      "simhash64": 7488180022980027475,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT NAME . NAME = NAME NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "ErrorContext.should_retry",
      "lineno": 54,
      "end_lineno": 56,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "1157aa74179b8a4db70a8d525fcfec33dea048d4",
      "simhash64": 7488109654235849795,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME < NAME . NAME"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "ErrorContext.get_backoff_delay",
      "lineno": 58,
      "end_lineno": 66,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "randomness",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self, base_delay, max_delay)",
      "fingerprint": "1715e1f8a390bd3d44b1640377abdfec33545a76",
      "simhash64": 7488180022980019235,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , NAME : NAME = LIT ) -> NAME : LIT if NAME . NAME != NAME . NAME : return NAME # Exponential backoff with jitter NAME = NAME ( NAME * ( LIT ** ( NAME . NAME - LIT ) ) , NAME ) NAME = NAME . NAME ( LIT , LIT ) * NAME return NAME + NAME"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "EnhancedErrorRecovery.__init__",
      "lineno": 80,
      "end_lineno": 82,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "22b37eddf96048c1b29d9f20e419d67377129e5e",
      "simhash64": 7453206757123732567,
      "normalized": "def NAME ( NAME ) -> None : NAME . NAME : NAME [ NAME , NAME [ NAME , NAME ] ] = { } NAME . NAME : NAME [ NAME , NAME [ NAME , NAME ] ] = { }"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "EnhancedErrorRecovery.get_recovery_stats",
      "lineno": 84,
      "end_lineno": 91,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self, operation)",
      "fingerprint": "4f3b470b5f24aec2097d7fb9f337c50d1f20027b",
      "simhash64": 7451729014569735211,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT return NAME . NAME . NAME ( NAME , { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } )"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "EnhancedErrorRecovery.update_stats",
      "lineno": 93,
      "end_lineno": 111,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, operation, success, partial)",
      "fingerprint": "728aeda60106b9db19e6cd2fb45a9b7604aeaacd",
      "simhash64": 7452152326605149219,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME , NAME : NAME = False ) -> None : LIT if NAME not in NAME . NAME : NAME . NAME [ NAME ] = { LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME . NAME [ NAME ] NAME [ LIT ] += LIT if NAME : NAME [ LIT ] += LIT elif NAME : NAME [ LIT ] += LIT else : NAME [ LIT ] += LIT"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "EnhancedErrorRecovery.is_circuit_open",
      "lineno": 113,
      "end_lineno": 125,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 13,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self, operation, failure_threshold)",
      "fingerprint": "2d8d089d732fa5f764d8bd4443411292eaa4945a",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME = LIT ) -> NAME : LIT if NAME not in NAME . NAME : return False NAME = NAME . NAME [ NAME ] # Check if circuit should be reset if NAME . NAME ( LIT , NAME . NAME ) < NAME . NAME ( ) : NAME . NAME [ NAME ] = { LIT : LIT , LIT : NAME . NAME } return False return NAME . NAME ( LIT , LIT ) >= NAME"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "EnhancedErrorRecovery.record_failure",
      "lineno": 127,
      "end_lineno": 138,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, operation, recovery_timeout)",
      "fingerprint": "4f791a832716d146cb404f6dad30c4fbfbdea094",
      "simhash64": 7452151226028176403,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME = LIT ) : LIT if NAME not in NAME . NAME : NAME . NAME [ NAME ] = { LIT : LIT , LIT : NAME . NAME } NAME = NAME . NAME [ NAME ] NAME [ LIT ] += LIT # Open circuit if threshold exceeded if NAME [ LIT ] >= LIT : # Default threshold NAME [ LIT ] = NAME . NAME ( ) + NAME ( NAME = NAME ) NAME . NAME ( f\" Circuit breaker opened for { NAME } - cooling down for { NAME } s \" )"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "EnhancedErrorRecovery.record_success",
      "lineno": 140,
      "end_lineno": 143,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(self, operation)",
      "fingerprint": "466d6edc9d802382011ece420836a3ccd3a90656",
      "simhash64": 7452151226028176443,
      "normalized": "def NAME ( NAME , NAME : NAME ) : LIT if NAME in NAME . NAME : NAME . NAME [ NAME ] = { LIT : LIT , LIT : NAME . NAME }"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "_handle_successful_attempt",
      "lineno": 148,
      "end_lineno": 154,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "(operation_name, attempt)",
      "fingerprint": "ee896a8488d08ddba71aa5d6d466ed25ab145043",
      "simhash64": 7488109655309587475,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME = True ) if NAME > LIT : NAME . NAME ( f\" \u2705 { NAME } succeeded after { NAME } attempts \" )"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "_handle_non_retryable_error",
      "lineno": 157,
      "end_lineno": 161,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(operation_name, e)",
      "fingerprint": "9cc3851a1d1eec87f8e2a25489ec948c04ac2d89",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME ) -> None : LIT NAME . NAME ( f\" \u274c Non-retryable error in { NAME } : { NAME } \" ) NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME = False )"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "_handle_partial_success",
      "lineno": 164,
      "end_lineno": 179,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(operation_name, partial_success_handler, context, last_exception)",
      "fingerprint": "b5630543d84af8ee563d23a16983d87dba137571",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] , NAME : LIT , NAME : NAME ) -> NAME : LIT if NAME and NAME . NAME : try : NAME = NAME ( NAME . NAME , NAME ) NAME . NAME ( NAME , NAME = False , NAME = True ) NAME . NAME ( f\" \u26a0\ufe0f { NAME } completed with partial success \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Partial success handler failed: { NAME } \" ) return None"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "_handle_retry_failure",
      "lineno": 182,
      "end_lineno": 199,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 18,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(operation_name, max_attempts, partial_success_handler, context, last_exception)",
      "fingerprint": "8297e2c9d362c493e1b082f7d3b7d7da1b29e4d8",
      "simhash64": 7488109654235845715,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME , NAME : NAME [ NAME ] , NAME : LIT , NAME : NAME ) -> NAME : LIT NAME . NAME ( f\" \u274c { NAME } failed after { NAME } attempts \" ) NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME = False ) # Try partial success handler NAME = NAME ( NAME , NAME , NAME , NAME ) if NAME is not None : return NAME raise NAME"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "with_enhanced_recovery",
      "lineno": 202,
      "end_lineno": 277,
      "is_method": false,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 9,
      "loc": 76,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(max_attempts, base_delay, max_delay, recovery_strategy, retryable_exceptions, partial_success_handler, user_guidance)",
      "fingerprint": "e2085d5692a0dd2cef59c086f5146a21e5225628",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = NAME . NAME , NAME : NAME [ NAME [ NAME ] , ... ] = ( NAME , ) , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME [ NAME [ NAME ] , NAME ] ] = None ) : LIT def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) -> NAME : NAME = f\" { NAME . NAME } . { NAME . NAME } \" NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME ) # Check circuit breaker if NAME . NAME ( NAME ) : raise NAME ( f\" Circuit breaker is open for { NAME } \" ) NAME = None for NAME in NAME ( LIT , NAME + LIT ) : NAME . NAME = NAME try : NAME . NAME ( f\" Attempting { NAME } (attempt { NAME } / { NAME } ) \" ) NAME = NAME ( * NAME , ** NAME ) NAME ( NAME , NAME ) return NAME except NAME as NAME : NAME = NAME NAME . NAME ( NAME ) # Check if this exception is retryable if not NAME ( NAME , NAME ) : NAME ( NAME , NAME ) raise # Log the error with context NAME . NAME ( f\" \u26a0\ufe0f { NAME } failed (attempt { NAME } / { NAME } ): { NAME } \" ) # Provide user guidance if available if NAME and NAME ( NAME ) in NAME : NAME . NAME ( f\" \ud83d\udca1 Suggestion: { NAME [ NAME ( NAME ) ] } \" ) # Check if we should retry if not NAME . NAME ( ) : return NAME ( NAME , NAME , NAME , NAME , NAME ) # Calculate delay for next attempt NAME = NAME . NAME ( NAME , NAME ) NAME . NAME ( f\" Retrying { NAME } in { NAME : .1f } seconds... \" ) NAME . NAME ( NAME ) # This should never be reached, but just in case raise NAME or NAME ( f\" Unknown error in { NAME } \" ) return NAME return NAME"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "decorator",
      "lineno": 223,
      "end_lineno": 276,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 9,
      "loc": 54,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(func)",
      "fingerprint": "eb8b7b7e95c6bb09f13ed372856c440439f3c1f5",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) -> NAME : NAME = f\" { NAME . NAME } . { NAME . NAME } \" NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME ) # Check circuit breaker if NAME . NAME ( NAME ) : raise NAME ( f\" Circuit breaker is open for { NAME } \" ) NAME = None for NAME in NAME ( LIT , NAME + LIT ) : NAME . NAME = NAME try : NAME . NAME ( f\" Attempting { NAME } (attempt { NAME } / { NAME } ) \" ) NAME = NAME ( * NAME , ** NAME ) NAME ( NAME , NAME ) return NAME except NAME as NAME : NAME = NAME NAME . NAME ( NAME ) # Check if this exception is retryable if not NAME ( NAME , NAME ) : NAME ( NAME , NAME ) raise # Log the error with context NAME . NAME ( f\" \u26a0\ufe0f { NAME } failed (attempt { NAME } / { NAME } ): { NAME } \" ) # Provide user guidance if available if NAME and NAME ( NAME ) in NAME : NAME . NAME ( f\" \ud83d\udca1 Suggestion: { NAME [ NAME ( NAME ) ] } \" ) # Check if we should retry if not NAME . NAME ( ) : return NAME ( NAME , NAME , NAME , NAME , NAME ) # Calculate delay for next attempt NAME = NAME . NAME ( NAME , NAME ) NAME . NAME ( f\" Retrying { NAME } in { NAME : .1f } seconds... \" ) NAME . NAME ( NAME ) # This should never be reached, but just in case raise NAME or NAME ( f\" Unknown error in { NAME } \" ) return NAME"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "wrapper",
      "lineno": 225,
      "end_lineno": 274,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 9,
      "loc": 50,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "size:medium"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "acca6bd0d2edbdd653f7d6a8151cf1d008c555b8",
      "simhash64": 7488109654235845651,
      "normalized": "def NAME ( * NAME , ** NAME ) -> NAME : NAME = f\" { NAME . NAME } . { NAME . NAME } \" NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME ) # Check circuit breaker if NAME . NAME ( NAME ) : raise NAME ( f\" Circuit breaker is open for { NAME } \" ) NAME = None for NAME in NAME ( LIT , NAME + LIT ) : NAME . NAME = NAME try : NAME . NAME ( f\" Attempting { NAME } (attempt { NAME } / { NAME } ) \" ) NAME = NAME ( * NAME , ** NAME ) NAME ( NAME , NAME ) return NAME except NAME as NAME : NAME = NAME NAME . NAME ( NAME ) # Check if this exception is retryable if not NAME ( NAME , NAME ) : NAME ( NAME , NAME ) raise # Log the error with context NAME . NAME ( f\" \u26a0\ufe0f { NAME } failed (attempt { NAME } / { NAME } ): { NAME } \" ) # Provide user guidance if available if NAME and NAME ( NAME ) in NAME : NAME . NAME ( f\" \ud83d\udca1 Suggestion: { NAME [ NAME ( NAME ) ] } \" ) # Check if we should retry if not NAME . NAME ( ) : return NAME ( NAME , NAME , NAME , NAME , NAME ) # Calculate delay for next attempt NAME = NAME . NAME ( NAME , NAME ) NAME . NAME ( f\" Retrying { NAME } in { NAME : .1f } seconds... \" ) NAME . NAME ( NAME ) # This should never be reached, but just in case raise NAME or NAME ( f\" Unknown error in { NAME } \" )"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "create_user_guidance",
      "lineno": 279,
      "end_lineno": 289,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "impure",
        "purpose:factory",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "b80cf45bc78efaacb87147421fefb06a4ba1f1ad",
      "simhash64": 5145886005356041259,
      "normalized": "def NAME ( ) -> NAME [ NAME [ NAME ] , NAME ] : LIT return { NAME : LIT , NAME : LIT , NAME : LIT , NAME : LIT , NAME : LIT , NAME : LIT , NAME : LIT , }"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "handle_partial_success",
      "lineno": 291,
      "end_lineno": 297,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(partial_results, error)",
      "fingerprint": "b4ec0611233540eb6ae74e00999dcb700c7f0991",
      "simhash64": 7488109654235845715,
      "normalized": "def NAME ( NAME : NAME [ NAME ] , NAME : NAME ) -> NAME : LIT if not NAME : raise NAME NAME . NAME ( f\" Returning { NAME ( NAME ) } partial results due to: { NAME } \" ) return NAME"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "with_api_recovery",
      "lineno": 300,
      "end_lineno": 308,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(max_attempts, base_delay)",
      "fingerprint": "591462af612cad7c6ad9b75689bd90e2c1991f5e",
      "simhash64": 7488250362734744603,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME = LIT ) : LIT return NAME ( NAME = NAME , NAME = NAME , NAME = LIT , NAME = ( NAME , NAME , NAME ) , NAME = NAME ( ) )"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "with_database_recovery",
      "lineno": 310,
      "end_lineno": 318,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(max_attempts, base_delay)",
      "fingerprint": "6c9fea3a218dd41f9ca464d228a1cd1531a7a453",
      "simhash64": 7488250362734744603,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME = LIT ) : LIT return NAME ( NAME = NAME , NAME = NAME , NAME = LIT , NAME = ( NAME , NAME ) , NAME = NAME ( ) )"
    },
    {
      "module_path": "core\\enhanced_error_recovery.py",
      "qualname": "with_file_recovery",
      "lineno": 320,
      "end_lineno": 328,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(max_attempts, base_delay)",
      "fingerprint": "591462af612cad7c6ad9b75689bd90e2c1991f5e",
      "simhash64": 7488250362734744603,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME = LIT ) : LIT return NAME ( NAME = NAME , NAME = NAME , NAME = LIT , NAME = ( NAME , NAME , NAME ) , NAME = NAME ( ) )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "CircuitBreaker.__init__",
      "lineno": 82,
      "end_lineno": 89,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, name, config)",
      "fingerprint": "a1becb51ce8b1f9fe3fc022958d13e429d14b608",
      "simhash64": 7488109654302962707,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , NAME : NAME [ NAME ] = None ) : NAME . NAME = NAME NAME . NAME = NAME or NAME ( ) NAME . NAME = LIT NAME . NAME = LIT NAME . NAME = None NAME . NAME = NAME . NAME NAME . NAME = NAME . NAME ( )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "CircuitBreaker.call",
      "lineno": 91,
      "end_lineno": 123,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 12,
      "loc": 33,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, func, *args, **kwargs)",
      "fingerprint": "26a14367215a7d778e883933d404f3217554ccbe",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME , NAME : NAME , * NAME , ** NAME ) : LIT with NAME . NAME : if NAME . NAME == NAME . NAME : if ( NAME . NAME and NAME . NAME ( ) - NAME . NAME > NAME . NAME . NAME ) : NAME . NAME = NAME . NAME NAME . NAME = LIT else : raise NAME ( f\" Circuit breaker { NAME . NAME } is OPEN \" ) try : NAME = NAME ( * NAME , ** NAME ) with NAME . NAME : if NAME . NAME == NAME . NAME : NAME . NAME += LIT if NAME . NAME >= NAME . NAME . NAME : NAME . NAME = NAME . NAME NAME . NAME = LIT NAME . NAME = LIT elif NAME . NAME == NAME . NAME : NAME . NAME = LIT # Reset on success return NAME except NAME as NAME : with NAME . NAME : NAME . NAME += LIT NAME . NAME = NAME . NAME ( ) if NAME . NAME >= NAME . NAME . NAME : NAME . NAME = NAME . NAME NAME . NAME = LIT raise NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "CircuitBreaker.reset",
      "lineno": 125,
      "end_lineno": 131,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "0be7d189dcc99ec1a6ce7294a50abe68ff4641af",
      "simhash64": 7488109654302962707,
      "normalized": "def NAME ( NAME ) : LIT with NAME . NAME : NAME . NAME = NAME . NAME NAME . NAME = LIT NAME . NAME = LIT NAME . NAME = None"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "CircuitBreaker.get_stats",
      "lineno": 133,
      "end_lineno": 141,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "f559be00730557da246146f00a8e8f5635d6d08b",
      "simhash64": 7451588276007646211,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME , LIT : NAME . NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , }"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "RetryableError.__init__",
      "lineno": 164,
      "end_lineno": 170,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "daadc8b88d4cc1d3be32a1d886b5b8ed4ea1c55b",
      "simhash64": 7487546704282428435,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , ** NAME ) : NAME ( ) . NAME ( NAME ) NAME . NAME = NAME NAME . NAME = NAME . NAME ( LIT ) NAME . NAME = NAME . NAME ( LIT ) NAME . NAME = NAME . NAME ( LIT , { } ) NAME . NAME = NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "FatalError.__init__",
      "lineno": 176,
      "end_lineno": 180,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "ace230fd887e750dcde957a194926fc169a3d8fe",
      "simhash64": 7487546704282428435,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , ** NAME ) : NAME ( ) . NAME ( NAME ) NAME . NAME = NAME NAME . NAME = NAME . NAME ( LIT , { } ) NAME . NAME = NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "APIRateLimitError.__init__",
      "lineno": 186,
      "end_lineno": 188,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "46158307a49f8bf94489a5032efade490a0fb75b",
      "simhash64": 7487617074100339755,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , ** NAME ) : NAME ( ) . NAME ( NAME , ** NAME ) NAME . NAME = NAME . NAME ( LIT , LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "NetworkTimeoutError.__init__",
      "lineno": 194,
      "end_lineno": 196,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "f119d1114a5a7c707fdd142ad7a410cdfcd82998",
      "simhash64": 7487617074100347939,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , ** NAME ) : NAME ( ) . NAME ( NAME , ** NAME ) NAME . NAME = NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "DatabaseConnectionError.__init__",
      "lineno": 202,
      "end_lineno": 205,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "b642228039778549b99bb3ba5331927901db10f1",
      "simhash64": 7487617074100347907,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , ** NAME ) : NAME ( ) . NAME ( NAME , ** NAME ) NAME . NAME = NAME . NAME ( LIT ) NAME . NAME = NAME . NAME ( LIT , LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "DataValidationError.__init__",
      "lineno": 211,
      "end_lineno": 213,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "6a3e884a74b4af26f92d95a5258b01b22a6d7125",
      "simhash64": 7487617073026606119,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , ** NAME ) : NAME ( ) . NAME ( NAME , ** NAME ) NAME . NAME = NAME . NAME ( LIT , [ ] )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "MissingConfigError.__init__",
      "lineno": 219,
      "end_lineno": 221,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "6a3e884a74b4af26f92d95a5258b01b22a6d7125",
      "simhash64": 7487617073026606119,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , ** NAME ) : NAME ( ) . NAME ( NAME , ** NAME ) NAME . NAME = NAME . NAME ( LIT , [ ] )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "AuthenticationExpiredError.__init__",
      "lineno": 227,
      "end_lineno": 229,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "f119d1114a5a7c707fdd142ad7a410cdfcd82998",
      "simhash64": 7487617074100347939,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , ** NAME ) : NAME ( ) . NAME ( NAME , ** NAME ) NAME . NAME = NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "BrowserSessionError.__init__",
      "lineno": 235,
      "end_lineno": 237,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "f119d1114a5a7c707fdd142ad7a410cdfcd82998",
      "simhash64": 7487617074100347939,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , ** NAME ) : NAME ( ) . NAME ( NAME , ** NAME ) NAME . NAME = NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "MaxApiFailuresExceededError.__init__",
      "lineno": 243,
      "end_lineno": 246,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "16382ccdccbe76e38b3eab58f1c1a9d52be82c3f",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , ** NAME ) : NAME ( ) . NAME ( NAME , ** NAME ) NAME . NAME = NAME . NAME ( LIT , LIT ) NAME . NAME = NAME . NAME ( LIT , LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ConfigurationError.__init__",
      "lineno": 252,
      "end_lineno": 254,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "f119d1114a5a7c707fdd142ad7a410cdfcd82998",
      "simhash64": 7487617074100347939,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , ** NAME ) : NAME ( ) . NAME ( NAME , ** NAME ) NAME . NAME = NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "AppError.__init__",
      "lineno": 294,
      "end_lineno": 314,
      "is_method": true,
      "is_async": false,
      "args_count": 9,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 21,
      "tags": [
        "pure-ish",
        "time",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self, message, category, severity, user_message, technical_details, recovery_suggestion, context, original_exception)",
      "fingerprint": "b13906a33c8e539f03762c07eaac8b7e46601ee3",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME = NAME . NAME , NAME : NAME = NAME . NAME , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME ] = None , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME [ NAME ] = None , ) : NAME ( ) . NAME ( NAME ) NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME or NAME . NAME ( ) NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME or { } NAME . NAME = NAME NAME . NAME = NAME . NAME ( )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "AppError._generate_user_message",
      "lineno": 316,
      "end_lineno": 328,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "impure",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "f1638356bbf134df109bb378e6b5ef2b6039af09",
      "simhash64": 7451729014569735171,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = { NAME . NAME : LIT , NAME . NAME : LIT , NAME . NAME : LIT , NAME . NAME : LIT , NAME . NAME : LIT , NAME . NAME : LIT , NAME . NAME : LIT , NAME . NAME : LIT , } return NAME . NAME ( NAME . NAME , LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "AppError.to_dict",
      "lineno": 330,
      "end_lineno": 344,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "6f77690e3772631e8f1e4b8bb18b9d870478b8c5",
      "simhash64": 7451588276007646211,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT return { LIT : NAME . NAME , LIT : NAME . NAME . NAME , LIT : NAME . NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : ( NAME ( NAME . NAME ) if NAME . NAME else None ) , }"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "AuthenticationError.__init__",
      "lineno": 350,
      "end_lineno": 356,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "ad9619a02a1f0d6a08862832678c6f067c091375",
      "simhash64": 7487546704282428423,
      "normalized": "def NAME ( NAME , NAME : NAME , ** NAME ) : NAME ( ) . NAME ( NAME , NAME = NAME . NAME , NAME = NAME . NAME , ** NAME , )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ValidationError.__init__",
      "lineno": 362,
      "end_lineno": 368,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "ad9619a02a1f0d6a08862832678c6f067c091375",
      "simhash64": 7487546704282428423,
      "normalized": "def NAME ( NAME , NAME : NAME , ** NAME ) : NAME ( ) . NAME ( NAME , NAME = NAME . NAME , NAME = NAME . NAME , ** NAME , )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "DatabaseError.__init__",
      "lineno": 374,
      "end_lineno": 380,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "ad9619a02a1f0d6a08862832678c6f067c091375",
      "simhash64": 7487546704282428423,
      "normalized": "def NAME ( NAME , NAME : NAME , ** NAME ) : NAME ( ) . NAME ( NAME , NAME = NAME . NAME , NAME = NAME . NAME , ** NAME , )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "NetworkError.__init__",
      "lineno": 386,
      "end_lineno": 392,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "ad9619a02a1f0d6a08862832678c6f067c091375",
      "simhash64": 7487546704282428423,
      "normalized": "def NAME ( NAME , NAME : NAME , ** NAME ) : NAME ( ) . NAME ( NAME , NAME = NAME . NAME , NAME = NAME . NAME , ** NAME , )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "BrowserError.__init__",
      "lineno": 398,
      "end_lineno": 404,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "ad9619a02a1f0d6a08862832678c6f067c091375",
      "simhash64": 7487546704282428423,
      "normalized": "def NAME ( NAME , NAME : NAME , ** NAME ) : NAME ( ) . NAME ( NAME , NAME = NAME . NAME , NAME = NAME . NAME , ** NAME , )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "APIError.__init__",
      "lineno": 410,
      "end_lineno": 413,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, message, **kwargs)",
      "fingerprint": "df42f6c45926fb98dd636fe7a6852207c517c293",
      "simhash64": 7488109654235849815,
      "normalized": "def NAME ( NAME , NAME : NAME , ** NAME ) : NAME ( ) . NAME ( NAME , NAME = NAME . NAME , NAME = NAME . NAME , ** NAME )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorHandler.can_handle",
      "lineno": 426,
      "end_lineno": 428,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, error)",
      "fingerprint": "490c70f9d30095620e26bb21da2961c129df3a19",
      "simhash64": 7488320761542644851,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT pass"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorHandler.handle",
      "lineno": 431,
      "end_lineno": 435,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, error, context)",
      "fingerprint": "163e54713c8a6fb77aeed2e46d5cee715ad3ac51",
      "simhash64": 7452151225961591895,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None ) -> NAME : LIT pass"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "DatabaseErrorHandler.can_handle",
      "lineno": 441,
      "end_lineno": 445,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, error)",
      "fingerprint": "b1e72343b851dc6278a2f52e1dfb990fbfcc6e22",
      "simhash64": 7488109654235841555,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : NAME = [ LIT , LIT , LIT , LIT ] NAME = NAME ( NAME ( NAME ) . NAME ) . NAME ( ) NAME = NAME ( NAME ) . NAME ( ) return NAME ( NAME in NAME or NAME in NAME for NAME in NAME )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "DatabaseErrorHandler.handle",
      "lineno": 447,
      "end_lineno": 474,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, error, context)",
      "fingerprint": "e740da50a060e715f6045eb5af9b1d2fbe0101f0",
      "simhash64": 5182407383584773147,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None ) -> NAME : NAME = NAME ( NAME ) if LIT in NAME . NAME ( ) : return NAME ( LIT , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , ) if LIT in NAME . NAME ( ) : return NAME ( LIT , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , ) return NAME ( LIT , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "NetworkErrorHandler.can_handle",
      "lineno": 480,
      "end_lineno": 484,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, error)",
      "fingerprint": "c0c1decea69976355c3379e596d2023884bab46b",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : return NAME ( NAME in NAME ( NAME ( NAME ) . NAME ) . NAME ( ) for NAME in [ LIT , LIT , LIT , LIT , LIT ] )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "NetworkErrorHandler.handle",
      "lineno": 486,
      "end_lineno": 513,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, error, context)",
      "fingerprint": "e740da50a060e715f6045eb5af9b1d2fbe0101f0",
      "simhash64": 5182407383584773147,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None ) -> NAME : NAME = NAME ( NAME ) if LIT in NAME . NAME ( ) : return NAME ( LIT , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , ) if LIT in NAME . NAME ( ) : return NAME ( LIT , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , ) return NAME ( LIT , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "BrowserErrorHandler.can_handle",
      "lineno": 519,
      "end_lineno": 523,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "impure",
        "network",
        "size:tiny"
      ],
      "signature": "(self, error)",
      "fingerprint": "904ba2c86c5b9585484060917833e66f83bfc903",
      "simhash64": 7487617074100343851,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : return NAME ( NAME in NAME ( NAME ( NAME ) . NAME ) . NAME ( ) for NAME in [ LIT , LIT , LIT , LIT ] )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "BrowserErrorHandler.handle",
      "lineno": 525,
      "end_lineno": 552,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 28,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, error, context)",
      "fingerprint": "e740da50a060e715f6045eb5af9b1d2fbe0101f0",
      "simhash64": 5182407383584773147,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None ) -> NAME : NAME = NAME ( NAME ) if LIT in NAME . NAME ( ) : return NAME ( LIT , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , ) if LIT in NAME . NAME ( ) : return NAME ( LIT , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , ) return NAME ( LIT , NAME = NAME , NAME = LIT , NAME = NAME , NAME = NAME , )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorHandlerRegistry.__init__",
      "lineno": 561,
      "end_lineno": 563,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "48fe276c4c7170800a9810ad0b62d67df3601bcf",
      "simhash64": 7488180023047140439,
      "normalized": "def NAME ( NAME ) : NAME . NAME : NAME [ NAME ] = [ ] NAME . NAME ( )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorHandlerRegistry._register_default_handlers",
      "lineno": 565,
      "end_lineno": 569,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "2e984f673bf0363800c4ac28042fd7153b9a26ef",
      "simhash64": 7467386030086063147,
      "normalized": "def NAME ( NAME ) : LIT NAME . NAME . NAME ( [ NAME ( ) , NAME ( ) , NAME ( ) ] )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorHandlerRegistry.register_handler",
      "lineno": 571,
      "end_lineno": 574,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, handler)",
      "fingerprint": "df85382343c94dc4afdc547fae0b0e470d974fe5",
      "simhash64": 7488215207352116243,
      "normalized": "def NAME ( NAME , NAME : NAME ) : LIT NAME . NAME . NAME ( NAME ) NAME . NAME ( f\" Registered error handler: { NAME ( NAME ) . NAME } \" )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorHandlerRegistry.handle_error",
      "lineno": 576,
      "end_lineno": 625,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 7,
      "loc": 50,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, error, context, fallback_category)",
      "fingerprint": "e4743347d561126d626006fc228d30056ff7de47",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME = NAME . NAME , ) -> NAME : LIT # If it's already an AppError, return as-is if NAME ( NAME , NAME ) : return NAME # Try to find a suitable handler for NAME in NAME . NAME : if NAME . NAME ( NAME ) : try : return NAME . NAME ( NAME , NAME ) except NAME as NAME : NAME . NAME ( f\" Error handler { NAME ( NAME ) . NAME } failed: { NAME } \" ) continue # Fallback to generic error NAME = NAME ( NAME ) NAME = NAME ( NAME ) . NAME # Special case for ZeroDivisionError if NAME ( NAME , NAME ) : NAME = f\" { NAME } : division by zero \" elif not NAME : NAME = f\" { NAME } \" else : NAME = f\" { NAME } : { NAME } \" return NAME ( NAME , NAME = NAME , NAME = NAME . NAME , NAME = NAME . NAME ( ) , NAME = NAME , NAME = NAME , )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "handle_error",
      "lineno": 632,
      "end_lineno": 640,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(error, context, fallback_category)",
      "fingerprint": "000598c8f099a10fc023b438d06b9711d0ca20df",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None , NAME : NAME = NAME . NAME , ) -> NAME : LIT return NAME . NAME ( NAME , NAME , NAME )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "register_error_handler",
      "lineno": 643,
      "end_lineno": 645,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(handler)",
      "fingerprint": "413fdd1a8d0346ca8979857c5efb00cde98dc377",
      "simhash64": 7487652258472428579,
      "normalized": "def NAME ( NAME : NAME ) : LIT NAME . NAME ( NAME )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "error_handler",
      "lineno": 648,
      "end_lineno": 704,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 57,
      "tags": [
        "pure-ish",
        "logging",
        "size:medium"
      ],
      "signature": "(category, severity, log_errors, reraise)",
      "fingerprint": "06fc9ce7b3b5af95bc87af812d2f51e4f8ad387c",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME = NAME . NAME , NAME : NAME = NAME . NAME , NAME : NAME = True , NAME : NAME = False , ) : LIT def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : # Create context from function info NAME = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME ( NAME ) , LIT : NAME ( NAME . NAME ( ) ) , } # Handle the error NAME = NAME ( NAME , NAME , NAME ) # Log the error if NAME : NAME = { NAME . NAME : NAME . NAME , NAME . NAME : NAME . NAME , NAME . NAME : NAME . NAME , NAME . NAME : NAME . NAME , } . NAME ( NAME . NAME , NAME . NAME ) NAME . NAME ( NAME , f\" Error in { NAME . NAME } : { NAME . NAME } \" , NAME = { LIT : NAME . NAME ( ) } , ) # Reraise if requested if NAME : raise NAME from None return None return NAME return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "decorator",
      "lineno": 664,
      "end_lineno": 702,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 39,
      "tags": [
        "pure-ish",
        "logging",
        "size:medium"
      ],
      "signature": "(func)",
      "fingerprint": "1fe47d7134ce3920ffec8b51addad7134677f845",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : # Create context from function info NAME = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME ( NAME ) , LIT : NAME ( NAME . NAME ( ) ) , } # Handle the error NAME = NAME ( NAME , NAME , NAME ) # Log the error if NAME : NAME = { NAME . NAME : NAME . NAME , NAME . NAME : NAME . NAME , NAME . NAME : NAME . NAME , NAME . NAME : NAME . NAME , } . NAME ( NAME . NAME , NAME . NAME ) NAME . NAME ( NAME , f\" Error in { NAME . NAME } : { NAME . NAME } \" , NAME = { LIT : NAME . NAME ( ) } , ) # Reraise if requested if NAME : raise NAME from None return None return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "wrapper",
      "lineno": 666,
      "end_lineno": 700,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 35,
      "tags": [
        "pure-ish",
        "logging",
        "size:medium"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "ab474bc5419ad58827bc996c41fb00cd9393eb39",
      "simhash64": 7452080857216889883,
      "normalized": "def NAME ( * NAME , ** NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : # Create context from function info NAME = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME ( NAME ) , LIT : NAME ( NAME . NAME ( ) ) , } # Handle the error NAME = NAME ( NAME , NAME , NAME ) # Log the error if NAME : NAME = { NAME . NAME : NAME . NAME , NAME . NAME : NAME . NAME , NAME . NAME : NAME . NAME , NAME . NAME : NAME . NAME , } . NAME ( NAME . NAME , NAME . NAME ) NAME . NAME ( NAME , f\" Error in { NAME . NAME } : { NAME . NAME } \" , NAME = { LIT : NAME . NAME ( ) } , ) # Reraise if requested if NAME : raise NAME from None return None"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "safe_execute",
      "lineno": 707,
      "end_lineno": 732,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(func, *args, default_return, context, **kwargs)",
      "fingerprint": "6006d21a8abe73c528bc8e70d63e03ad03c43b21",
      "simhash64": 7488180022980031571,
      "normalized": "def NAME ( NAME : NAME , * NAME , NAME : NAME = None , NAME : NAME [ NAME [ NAME , NAME ] ] = None , ** NAME , ) -> NAME : LIT try : return NAME ( * NAME , ** NAME ) except NAME as NAME : NAME = NAME ( NAME , NAME ) NAME . NAME ( f\" Safe execution failed: { NAME . NAME } \" ) return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorContext.__init__",
      "lineno": 740,
      "end_lineno": 751,
      "is_method": true,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self, operation_name, category, severity, log_success)",
      "fingerprint": "4c0113469f658dee7e233aec112f933a00582490",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME = NAME . NAME , NAME : NAME = NAME . NAME , NAME : NAME = True , ) : NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = None"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorContext.__enter__",
      "lineno": 753,
      "end_lineno": 756,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "1cdb4505aa52a526cf595236ae54c013586e59ff",
      "simhash64": 7470130444393428051,
      "normalized": "def NAME ( NAME ) : NAME . NAME = NAME . NAME ( ) NAME . NAME ( f\" Starting operation: { NAME . NAME } \" ) return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorContext.__exit__",
      "lineno": 758,
      "end_lineno": 775,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, exc_type, exc_val, exc_tb)",
      "fingerprint": "45f47059c30c5f8d55c421e6ca07a48b4aa0a36c",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME , NAME , NAME ) : NAME = NAME . NAME ( ) - NAME . NAME if NAME . NAME else LIT if NAME is not None : # Error occurred NAME = { LIT : NAME . NAME , LIT : NAME } NAME = NAME ( NAME , NAME , NAME . NAME ) NAME . NAME ( f\" Operation failed: { NAME . NAME } ( { NAME : .2f } s) - { NAME . NAME } \" ) return False # Don't suppress the exception # Success if NAME . NAME : NAME . NAME ( f\" Operation completed: { NAME . NAME } ( { NAME : .2f } s) \" ) return True"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "get_error_handler",
      "lineno": 778,
      "end_lineno": 817,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 40,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(error_type)",
      "fingerprint": "41f3208efad02b9fb672b79f454d0757b00d3476",
      "simhash64": 7488179989695599659,
      "normalized": "def NAME ( NAME : NAME [ NAME ] ) -> NAME : LIT # Default handler for unknown types class NAME ( NAME ) : def NAME ( NAME , NAME : NAME ) -> NAME : return True # Catch-all for unknown errors def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None ) -> NAME : return NAME ( NAME ( NAME ) , NAME = NAME . NAME , NAME = NAME . NAME , NAME = NAME . NAME ( ) , NAME = NAME , NAME = NAME , ) # Error handlers registry NAME = { LIT : NAME ( ) , LIT : NAME ( ) , LIT : NAME ( ) , } # Find handler by error type return NAME ( ( NAME for NAME , NAME in NAME . NAME ( ) if NAME in NAME ( NAME ) . NAME ( ) ) , NAME ( ) , )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "DefaultHandler.can_handle",
      "lineno": 791,
      "end_lineno": 792,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self, error)",
      "fingerprint": "2bbc57575a32959d45b028f3a0de044591f655c4",
      "simhash64": 7487718177632060531,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : return True # Catch-all for unknown errors"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "DefaultHandler.handle",
      "lineno": 794,
      "end_lineno": 804,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, error, context)",
      "fingerprint": "c24be3dede70288a2720a98a2650bbcca1bda38c",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME [ NAME , NAME ] ] = None ) -> NAME : return NAME ( NAME ( NAME ) , NAME = NAME . NAME , NAME = NAME . NAME , NAME = NAME . NAME ( ) , NAME = NAME , NAME = NAME , )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "error_handling_module_tests",
      "lineno": 825,
      "end_lineno": 895,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 71,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "81f7987130f22b796c6af6cdf346d85cf6727508",
      "simhash64": 5127871576777593899,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import ( NAME , NAME , ) with NAME ( ) : NAME = NAME ( LIT , LIT ) # Run all tests NAME ( LIT ) with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # Generate summary report return NAME . NAME ( )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 898,
      "end_lineno": 900,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorRecoveryManager.__init__",
      "lineno": 908,
      "end_lineno": 911,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "4a0c76be278dbef39b5497be2568302380c5e1ed",
      "simhash64": 7452080857216889879,
      "normalized": "def NAME ( NAME ) : NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME : NAME [ NAME , NAME ] = { } NAME . NAME = NAME . NAME ( )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorRecoveryManager.get_circuit_breaker",
      "lineno": 913,
      "end_lineno": 920,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self, name, config)",
      "fingerprint": "eeeb16e94ce84e6e7c77cb09504ccdc2257fb689",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT with NAME . NAME : if NAME not in NAME . NAME : NAME . NAME [ NAME ] = NAME ( NAME , NAME ) return NAME . NAME [ NAME ]"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorRecoveryManager.register_recovery_strategy",
      "lineno": 922,
      "end_lineno": 925,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, service_name, strategy)",
      "fingerprint": "17cf4509d4a02bce46f6ea9a54666c355b494c79",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) : LIT with NAME . NAME : NAME . NAME [ NAME ] = NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorRecoveryManager.get_health_status",
      "lineno": 927,
      "end_lineno": 932,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "3c8952b41d7f119fc63d352514676b62a39b1c5b",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT with NAME . NAME : return { NAME : NAME . NAME ( ) for NAME , NAME in NAME . NAME . NAME ( ) }"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ErrorRecoveryManager.reset_all_circuit_breakers",
      "lineno": 934,
      "end_lineno": 938,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "a7f7daaaf1d3d92aebec9908c620fe350d5fb4b0",
      "simhash64": 8645077911455835171,
      "normalized": "def NAME ( NAME ) : LIT with NAME . NAME : for NAME in NAME . NAME . NAME ( ) : NAME . NAME ( )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "retry_on_failure",
      "lineno": 947,
      "end_lineno": 986,
      "is_method": false,
      "is_async": false,
      "args_count": 5,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 11,
      "loc": 40,
      "tags": [
        "pure-ish",
        "randomness",
        "time",
        "size:medium"
      ],
      "signature": "(max_attempts, backoff_factor, retry_on, stop_on, jitter)",
      "fingerprint": "10ad65ce8e516559f5fa2c9e081eb62d76656ce0",
      "simhash64": 7488180022980019283,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME [ NAME [ NAME [ NAME ] ] ] = None , NAME : NAME [ NAME [ NAME [ NAME ] ] ] = None , NAME : NAME = True , ) : LIT if NAME is None : NAME = [ NAME ] if NAME is None : NAME = [ NAME ] def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : NAME = None for NAME in NAME ( NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : NAME = NAME # Check if we should stop retrying if NAME ( NAME ( NAME , NAME ) for NAME in NAME ) : raise NAME # Check if we should retry if not NAME ( NAME ( NAME , NAME ) for NAME in NAME ) : raise NAME if NAME < NAME - LIT : # Don't sleep on last attempt NAME = NAME ** NAME if NAME : NAME *= ( LIT + NAME . NAME ( ) * LIT ) # Add jitter NAME . NAME ( NAME ) raise NAME return NAME return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "decorator",
      "lineno": 960,
      "end_lineno": 985,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 9,
      "loc": 26,
      "tags": [
        "pure-ish",
        "randomness",
        "time",
        "size:small"
      ],
      "signature": "(func)",
      "fingerprint": "2b99072fe5204d5925e37381f3b5d65980b7fc76",
      "simhash64": 7488109654235841659,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : NAME = None for NAME in NAME ( NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : NAME = NAME # Check if we should stop retrying if NAME ( NAME ( NAME , NAME ) for NAME in NAME ) : raise NAME # Check if we should retry if not NAME ( NAME ( NAME , NAME ) for NAME in NAME ) : raise NAME if NAME < NAME - LIT : # Don't sleep on last attempt NAME = NAME ** NAME if NAME : NAME *= ( LIT + NAME . NAME ( ) * LIT ) # Add jitter NAME . NAME ( NAME ) raise NAME return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "wrapper",
      "lineno": 962,
      "end_lineno": 984,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 23,
      "tags": [
        "pure-ish",
        "randomness",
        "time",
        "size:small"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "266e413dbbcba817e952d96d2df8528cfd32c7a4",
      "simhash64": 7488109654235841659,
      "normalized": "def NAME ( * NAME , ** NAME ) : NAME = None for NAME in NAME ( NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : NAME = NAME # Check if we should stop retrying if NAME ( NAME ( NAME , NAME ) for NAME in NAME ) : raise NAME # Check if we should retry if not NAME ( NAME ( NAME , NAME ) for NAME in NAME ) : raise NAME if NAME < NAME - LIT : # Don't sleep on last attempt NAME = NAME ** NAME if NAME : NAME *= ( LIT + NAME . NAME ( ) * LIT ) # Add jitter NAME . NAME ( NAME ) raise NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "circuit_breaker",
      "lineno": 989,
      "end_lineno": 1007,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 1,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(failure_threshold, recovery_timeout, success_threshold)",
      "fingerprint": "45ae1fe704ddd992982c7761cdafd1cc6b319a35",
      "simhash64": 7488109655309583379,
      "normalized": "def NAME ( NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT , ) : LIT def NAME ( NAME : NAME ) -> NAME : NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , ) NAME = NAME . NAME ( NAME . NAME , NAME ) @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : return NAME . NAME ( NAME , * NAME , ** NAME ) return NAME return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "decorator",
      "lineno": 995,
      "end_lineno": 1006,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(func)",
      "fingerprint": "35edf775a5a1aac553bb9546249fa5eb868a4344",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : NAME = NAME ( NAME = NAME , NAME = NAME , NAME = NAME , ) NAME = NAME . NAME ( NAME . NAME , NAME ) @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : return NAME . NAME ( NAME , * NAME , ** NAME ) return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "wrapper",
      "lineno": 1004,
      "end_lineno": 1005,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "fb8ba131e969f9364ed73916017c01f3135c26a7",
      "simhash64": 7487546708561134695,
      "normalized": "def NAME ( * NAME , ** NAME ) : return NAME . NAME ( NAME , * NAME , ** NAME )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "timeout_protection",
      "lineno": 1010,
      "end_lineno": 1060,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 6,
      "loc": 51,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(timeout)",
      "fingerprint": "0910afb25d9bef0b9d84d2c2793d2cb10d34c7a4",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME = LIT ) : LIT def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : import NAME import NAME # Use different timeout mechanisms based on platform if NAME . NAME ( ) == LIT : # Windows doesn't support SIGALRM, use threading approach NAME = [ None ] NAME = [ None ] def NAME ( ) : try : NAME [ LIT ] = NAME ( * NAME , ** NAME ) except NAME as NAME : NAME [ LIT ] = NAME NAME = NAME . NAME ( NAME = NAME ) NAME . NAME = True NAME . NAME ( ) NAME . NAME ( NAME ) if NAME . NAME ( ) : # Thread is still running, timeout occurred raise NAME ( f\" Function { NAME . NAME } timed out after { NAME } seconds \" ) if NAME [ LIT ] : raise NAME [ LIT ] from None return NAME [ LIT ] # Unix-like systems can use signal import NAME def NAME ( NAME , NAME ) : raise NAME ( f\" Function { NAME . NAME } timed out after { NAME } seconds \" ) # Set the signal handler and a timeout alarm NAME = NAME . NAME ( NAME . NAME , NAME ) NAME . NAME ( NAME ) try : NAME = NAME ( * NAME , ** NAME ) NAME . NAME ( LIT ) # Disable the alarm return NAME finally : NAME . NAME ( NAME . NAME , NAME ) # Restore old handler return NAME return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "decorator",
      "lineno": 1012,
      "end_lineno": 1059,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 48,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(func)",
      "fingerprint": "50e16382c0ccb78ac8a0de6e6093d37d6d8c8119",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : import NAME import NAME # Use different timeout mechanisms based on platform if NAME . NAME ( ) == LIT : # Windows doesn't support SIGALRM, use threading approach NAME = [ None ] NAME = [ None ] def NAME ( ) : try : NAME [ LIT ] = NAME ( * NAME , ** NAME ) except NAME as NAME : NAME [ LIT ] = NAME NAME = NAME . NAME ( NAME = NAME ) NAME . NAME = True NAME . NAME ( ) NAME . NAME ( NAME ) if NAME . NAME ( ) : # Thread is still running, timeout occurred raise NAME ( f\" Function { NAME . NAME } timed out after { NAME } seconds \" ) if NAME [ LIT ] : raise NAME [ LIT ] from None return NAME [ LIT ] # Unix-like systems can use signal import NAME def NAME ( NAME , NAME ) : raise NAME ( f\" Function { NAME . NAME } timed out after { NAME } seconds \" ) # Set the signal handler and a timeout alarm NAME = NAME . NAME ( NAME . NAME , NAME ) NAME . NAME ( NAME ) try : NAME = NAME ( * NAME , ** NAME ) NAME . NAME ( LIT ) # Disable the alarm return NAME finally : NAME . NAME ( NAME . NAME , NAME ) # Restore old handler return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "wrapper",
      "lineno": 1014,
      "end_lineno": 1058,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 6,
      "loc": 45,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "29915b0f26496fefd14bbf2aae70e67569c92c1b",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( * NAME , ** NAME ) : import NAME import NAME # Use different timeout mechanisms based on platform if NAME . NAME ( ) == LIT : # Windows doesn't support SIGALRM, use threading approach NAME = [ None ] NAME = [ None ] def NAME ( ) : try : NAME [ LIT ] = NAME ( * NAME , ** NAME ) except NAME as NAME : NAME [ LIT ] = NAME NAME = NAME . NAME ( NAME = NAME ) NAME . NAME = True NAME . NAME ( ) NAME . NAME ( NAME ) if NAME . NAME ( ) : # Thread is still running, timeout occurred raise NAME ( f\" Function { NAME . NAME } timed out after { NAME } seconds \" ) if NAME [ LIT ] : raise NAME [ LIT ] from None return NAME [ LIT ] # Unix-like systems can use signal import NAME def NAME ( NAME , NAME ) : raise NAME ( f\" Function { NAME . NAME } timed out after { NAME } seconds \" ) # Set the signal handler and a timeout alarm NAME = NAME . NAME ( NAME . NAME , NAME ) NAME . NAME ( NAME ) try : NAME = NAME ( * NAME , ** NAME ) NAME . NAME ( LIT ) # Disable the alarm return NAME finally : NAME . NAME ( NAME . NAME , NAME ) # Restore old handler"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "target",
      "lineno": 1024,
      "end_lineno": 1028,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "e4ae4ec132655014b45a8f6fabce62eb140a7cc5",
      "simhash64": 7452151226028176447,
      "normalized": "def NAME ( ) : try : NAME [ LIT ] = NAME ( * NAME , ** NAME ) except NAME as NAME : NAME [ LIT ] = NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "timeout_handler",
      "lineno": 1046,
      "end_lineno": 1047,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(signum, frame)",
      "fingerprint": "786106d7261075f0f93ab3ac39b661aa0721e7ae",
      "simhash64": 7470130445467161723,
      "normalized": "def NAME ( NAME , NAME ) : raise NAME ( f\" Function { NAME . NAME } timed out after { NAME } seconds \" )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "graceful_degradation",
      "lineno": 1063,
      "end_lineno": 1078,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(fallback_value, fallback_func)",
      "fingerprint": "657df837d74cd2109f53370c60ba1a92a6a9d9af",
      "simhash64": 7488109654235841539,
      "normalized": "def NAME ( NAME : NAME = None , NAME : NAME [ NAME ] = None ) : LIT def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : NAME . NAME ( f\" Function { NAME . NAME } failed: { NAME } , using fallback \" ) if NAME : return NAME ( * NAME , ** NAME ) return NAME return NAME return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "decorator",
      "lineno": 1067,
      "end_lineno": 1077,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 3,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(func)",
      "fingerprint": "4623b7bbf5f366f7225e7c0d18902dcf00d52d2d",
      "simhash64": 7488109654235841635,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : NAME . NAME ( f\" Function { NAME . NAME } failed: { NAME } , using fallback \" ) if NAME : return NAME ( * NAME , ** NAME ) return NAME return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "wrapper",
      "lineno": 1069,
      "end_lineno": 1076,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "82109dae7485da496322c529504540f48199e541",
      "simhash64": 7488180022980027507,
      "normalized": "def NAME ( * NAME , ** NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : NAME . NAME ( f\" Function { NAME . NAME } failed: { NAME } , using fallback \" ) if NAME : return NAME ( * NAME , ** NAME ) return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "error_context",
      "lineno": 1081,
      "end_lineno": 1095,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(context_name, **kwargs)",
      "fingerprint": "131c4a011cd837f8bffbd6e539fb840dcf02791c",
      "simhash64": 7488109654235849827,
      "normalized": "def NAME ( NAME : NAME = LIT , ** NAME ) : LIT def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : if NAME ( NAME , NAME ) : if NAME : NAME [ LIT ] = NAME NAME . NAME . NAME ( NAME ) raise NAME return NAME return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "decorator",
      "lineno": 1083,
      "end_lineno": 1094,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(func)",
      "fingerprint": "5d0bc9dabac6c4d57ecf3265c6fc7a27380df7d6",
      "simhash64": 7488180022980027491,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : if NAME ( NAME , NAME ) : if NAME : NAME [ LIT ] = NAME NAME . NAME . NAME ( NAME ) raise NAME return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "wrapper",
      "lineno": 1085,
      "end_lineno": 1093,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "977abaedf00f3f9f623aa9c28e15e990fdb311ba",
      "simhash64": 7488180022980027491,
      "normalized": "def NAME ( * NAME , ** NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : if NAME ( NAME , NAME ) : if NAME : NAME [ LIT ] = NAME NAME . NAME . NAME ( NAME ) raise NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "with_circuit_breaker",
      "lineno": 1098,
      "end_lineno": 1109,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 1,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(service_name, config)",
      "fingerprint": "9c784b120b46cf1abba60dd7420bd36e8170ccd8",
      "simhash64": 7488109654236365891,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] = None ) : LIT def NAME ( NAME : NAME ) -> NAME : NAME = NAME . NAME ( NAME , NAME ) @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : return NAME . NAME ( NAME , * NAME , ** NAME ) return NAME return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "decorator",
      "lineno": 1102,
      "end_lineno": 1108,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 1,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(func)",
      "fingerprint": "cef95ffc94155313da748b527498625ba2e446a5",
      "simhash64": 7488109654236374083,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : NAME = NAME . NAME ( NAME , NAME ) @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : return NAME . NAME ( NAME , * NAME , ** NAME ) return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "wrapper",
      "lineno": 1106,
      "end_lineno": 1107,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "fb8ba131e969f9364ed73916017c01f3135c26a7",
      "simhash64": 7487546708561134695,
      "normalized": "def NAME ( * NAME , ** NAME ) : return NAME . NAME ( NAME , * NAME , ** NAME )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "with_recovery",
      "lineno": 1112,
      "end_lineno": 1123,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(recovery_strategy)",
      "fingerprint": "0ee81b9fcaa0904a2fd1622056e6364adf5a1a21",
      "simhash64": 7488109654235841635,
      "normalized": "def NAME ( NAME : NAME ) : LIT def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : NAME . NAME ( f\" Function { NAME . NAME } failed: { NAME } , attempting recovery \" ) return NAME ( * NAME , ** NAME ) return NAME return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "decorator",
      "lineno": 1114,
      "end_lineno": 1122,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 9,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(func)",
      "fingerprint": "c43c5be704bddcbf771e25d4a56f46d822915096",
      "simhash64": 7488109654235841635,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : @ NAME ( NAME ) def NAME ( * NAME , ** NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : NAME . NAME ( f\" Function { NAME . NAME } failed: { NAME } , attempting recovery \" ) return NAME ( * NAME , ** NAME ) return NAME"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "wrapper",
      "lineno": 1116,
      "end_lineno": 1121,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "93ba59d775f5c9cb5868a2fabb0e2d33fa379d7a",
      "simhash64": 7488109658514031723,
      "normalized": "def NAME ( * NAME , ** NAME ) : try : return NAME ( * NAME , ** NAME ) except NAME as NAME : NAME . NAME ( f\" Function { NAME . NAME } failed: { NAME } , attempting recovery \" ) return NAME ( * NAME , ** NAME )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ancestry_session_recovery",
      "lineno": 1128,
      "end_lineno": 1130,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "79245e227264b9b4bdde91913a4b0bf6ea6d6795",
      "simhash64": 7451579480988877859,
      "normalized": "def NAME ( * NAME , ** NAME ) -> None : LIT NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ancestry_api_recovery",
      "lineno": 1134,
      "end_lineno": 1136,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "79245e227264b9b4bdde91913a4b0bf6ea6d6795",
      "simhash64": 7451579480988877859,
      "normalized": "def NAME ( * NAME , ** NAME ) -> None : LIT NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "ancestry_database_recovery",
      "lineno": 1140,
      "end_lineno": 1142,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "79245e227264b9b4bdde91913a4b0bf6ea6d6795",
      "simhash64": 7451579480988877859,
      "normalized": "def NAME ( * NAME , ** NAME ) -> None : LIT NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "test_function_availability",
      "lineno": 1147,
      "end_lineno": 1179,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 8,
      "loc": 33,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "8dc7c5284cf2cdcbca8ac2614910ba13e6000488",
      "simhash64": 7452291964523680811,
      "normalized": "def NAME ( ) -> None : LIT NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , ] NAME = LIT for NAME in NAME : if NAME in NAME ( ) : assert NAME ( NAME ( ) [ NAME ] ) or NAME ( NAME ( ) [ NAME ] , NAME ) , f\" Function { NAME } should be available \" NAME += LIT # Ensure we have at least 80% of required functions available NAME = NAME / NAME ( NAME ) assert NAME >= LIT , f\" Only { NAME : .1% } of required functions available \" # Test that error categories and severities are available if LIT in NAME ( ) : NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME ( NAME ( ) [ LIT ] , NAME ) , f\" ErrorCategory. { NAME } should be available \" if LIT in NAME ( ) : NAME = [ LIT , LIT , LIT , LIT ] for NAME in NAME : assert NAME ( NAME ( ) [ LIT ] , NAME ) , f\" ErrorSeverity. { NAME } should be available \""
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "test_error_handling",
      "lineno": 1182,
      "end_lineno": 1211,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "0243d3107be9f4284bb0b2be2f764d50ef5e2afe",
      "simhash64": 5146448920950249003,
      "normalized": "def NAME ( ) -> None : LIT # Test safe_execute with simple function def NAME ( ) : return LIT def NAME ( ) : raise NAME ( LIT ) if LIT in NAME ( ) : # Test successful execution NAME = NAME ( NAME , NAME = LIT ) assert NAME == LIT , LIT # Test error handling with default return NAME = NAME ( NAME , NAME = LIT ) assert NAME == LIT , LIT # Test with context NAME = NAME ( NAME , NAME = LIT , NAME = { LIT : LIT } ) assert NAME == LIT , LIT # Test handle_error function if LIT in NAME ( ) : try : raise NAME ( LIT ) except NAME as NAME : NAME = NAME ( NAME ) assert NAME ( NAME , LIT ) , LIT"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "safe_func",
      "lineno": 1186,
      "end_lineno": 1187,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "88196c13a4ec3b7a1dbe2535ac0e0e678a85a55d",
      "simhash64": 5760372770364887083,
      "normalized": "def NAME ( ) : return LIT"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "failing_func",
      "lineno": 1189,
      "end_lineno": 1190,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "49d0d0e75e4661eae84ab2825c7082a05f8e6a31",
      "simhash64": 9221670576702002731,
      "normalized": "def NAME ( ) : raise NAME ( LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "test_error_types",
      "lineno": 1214,
      "end_lineno": 1247,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 34,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "aac6ef2e2c3dc4567dd124904e41e1a9f3b0d2c5",
      "simhash64": 7452291964590265387,
      "normalized": "def NAME ( ) -> None : LIT # Test AppError creation if LIT in NAME ( ) : NAME = NAME ( LIT ) assert NAME ( NAME ) == LIT , LIT # Test AppError with category and severity if LIT in NAME ( ) and LIT in NAME ( ) : NAME = NAME ( LIT , NAME = NAME ( ) [ LIT ] . NAME , NAME = NAME ( ) [ LIT ] . NAME ) assert NAME . NAME == LIT assert NAME . NAME == NAME ( ) [ LIT ] . NAME assert NAME . NAME == NAME ( ) [ LIT ] . NAME # Test specific error types NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] for NAME in NAME : if NAME in NAME ( ) : try : NAME = NAME ( ) [ NAME ] NAME = NAME ( LIT ) assert NAME ( NAME , LIT ) , f\" { NAME } should have message attribute \" assert NAME ( NAME , LIT ) , f\" { NAME } should have category attribute \" assert NAME ( NAME , LIT ) , f\" { NAME } should have severity attribute \" except NAME : pass # Some error types might require specific parameters"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "test_error_recovery",
      "lineno": 1250,
      "end_lineno": 1282,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 33,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "9c7d0450e69622da1f90014f89a40e442ac38acc",
      "simhash64": 5146484109685462575,
      "normalized": "def NAME ( ) -> None : LIT # Test error recovery with failing function def NAME ( ) : raise NAME ( LIT ) def NAME ( ) : return LIT if LIT in NAME ( ) : # Test basic error recovery NAME = NAME ( NAME , NAME = LIT ) assert NAME == LIT , LIT # Test successful execution doesn't trigger recovery NAME = NAME ( NAME , NAME = LIT ) assert NAME == LIT , LIT # Test with different error types def NAME ( ) : raise NAME ( LIT ) NAME = NAME ( NAME , NAME = LIT ) assert NAME == LIT , LIT # Test ErrorRecoveryManager if available if LIT in NAME ( ) : try : NAME = NAME ( ) [ LIT ] ( ) assert NAME is not None , LIT except NAME : pass # Manager might require specific setup"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "failing_func",
      "lineno": 1254,
      "end_lineno": 1255,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "49d0d0e75e4661eae84ab2825c7082a05f8e6a31",
      "simhash64": 9221670576702002731,
      "normalized": "def NAME ( ) : raise NAME ( LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "successful_func",
      "lineno": 1257,
      "end_lineno": 1258,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "88196c13a4ec3b7a1dbe2535ac0e0e678a85a55d",
      "simhash64": 5760372770364887083,
      "normalized": "def NAME ( ) : return LIT"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "network_error_func",
      "lineno": 1270,
      "end_lineno": 1271,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "49d0d0e75e4661eae84ab2825c7082a05f8e6a31",
      "simhash64": 9221670576702002731,
      "normalized": "def NAME ( ) : raise NAME ( LIT )"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "test_circuit_breaker",
      "lineno": 1285,
      "end_lineno": 1319,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 10,
      "loc": 35,
      "tags": [
        "impure",
        "filesystem",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "1eea658ae421cf4c72bc9d8f451b1f4b00395381",
      "simhash64": 6299370459984991279,
      "normalized": "def NAME ( ) -> None : LIT if LIT in NAME ( ) : try : NAME = NAME ( NAME = LIT , NAME = LIT ) assert NAME is not None , LIT # Test initial state if NAME ( NAME , LIT ) : NAME = NAME . NAME assert NAME is not None , LIT # Test failure recording if NAME ( NAME , LIT ) : for NAME in NAME ( LIT ) : # Record some failures but not enough to open NAME . NAME ( ) # Test that circuit breaker tracks failures if NAME ( NAME , LIT ) : assert NAME . NAME >= LIT , LIT # Test success recording if NAME ( NAME , LIT ) : NAME . NAME ( ) except NAME : pass # Circuit breaker might require specific setup # Test circuit breaker configuration if LIT in NAME ( ) : try : NAME = NAME ( ) [ LIT ] ( NAME = LIT , NAME = LIT ) assert NAME is not None , LIT except NAME : pass"
    },
    {
      "module_path": "core\\error_handling.py",
      "qualname": "test_error_context",
      "lineno": 1322,
      "end_lineno": 1355,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 9,
      "loc": 34,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "8782d72ecf31e8b3a90b4e9e6e7e97097c31541d",
      "simhash64": 7451729014636844587,
      "normalized": "def NAME ( ) -> None : LIT if LIT in NAME ( ) : try : NAME = NAME ( LIT ) assert NAME is not None , LIT # Test context properties if NAME ( NAME , LIT ) : assert NAME . NAME == LIT , LIT except NAME : pass # Error context might require specific setup # Test error context in AppError if LIT in NAME ( ) : NAME = { LIT : LIT , LIT : LIT , LIT : LIT } NAME = NAME ( LIT , NAME = NAME ) if NAME ( NAME , LIT ) : assert NAME . NAME == NAME , LIT assert NAME . NAME . NAME ( LIT ) == LIT , LIT assert NAME . NAME . NAME ( LIT ) == LIT , LIT # Test context propagation through error handling if LIT in NAME ( ) : try : raise NAME ( LIT ) except NAME as NAME : NAME = { LIT : LIT , LIT : LIT } NAME = NAME ( NAME , NAME = NAME ) if NAME ( NAME , LIT ) : assert NAME . NAME . NAME ( LIT ) == LIT , LIT"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "get_logger",
      "lineno": 34,
      "end_lineno": 72,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 39,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(name)",
      "fingerprint": "500e258f2504c0048a302bc28cdb5e289624f9a2",
      "simhash64": 7488109654235853907,
      "normalized": "def NAME ( NAME : NAME [ NAME ] = None ) -> NAME . NAME : LIT global NAME # Try to use centralized logging config first try : from NAME import NAME as NAME , NAME # Initialize centralized logging if not already done if not NAME : NAME ( ) NAME = True # If no specific name requested, return the central logger if NAME is None : return NAME # Return a child logger that inherits from central config return NAME . NAME ( NAME ) except NAME : # Fallback to standard logging if logging_config is not available if NAME is None : import NAME NAME = NAME . NAME ( ) NAME = NAME . NAME . NAME . NAME ( LIT , LIT ) if NAME and NAME . NAME else LIT return NAME . NAME ( NAME )"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "ensure_no_duplicate_handlers",
      "lineno": 75,
      "end_lineno": 96,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 22,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "(logger_instance)",
      "fingerprint": "75ec94b02c44e2d476ef78ea115e997c6d573cd9",
      "simhash64": 8641101527586874387,
      "normalized": "def NAME ( NAME : NAME . NAME ) -> None : LIT NAME = NAME ( ) NAME = [ ] for NAME in NAME . NAME : NAME = ( NAME ( NAME ) . NAME , NAME ( NAME , LIT , None ) ) if NAME in NAME : NAME . NAME ( NAME ) else : NAME . NAME ( NAME ) for NAME in NAME : NAME . NAME ( NAME )"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "suppress_external_loggers",
      "lineno": 99,
      "end_lineno": 121,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 23,
      "tags": [
        "impure",
        "network",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "9def2c523f8f485533ebb4d887a7b83460fb9d3c",
      "simhash64": 7451588277081379843,
      "normalized": "def NAME ( ) -> None : LIT NAME = { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , } for NAME , NAME in NAME . NAME ( ) : NAME = NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME = False"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "get_app_logger",
      "lineno": 125,
      "end_lineno": 127,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "b961353012ce7b7eab04f77cd0035142f949eedd",
      "simhash64": 8645218654783181859,
      "normalized": "def NAME ( ) -> NAME . NAME : LIT return NAME ( )"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "debug_if_enabled",
      "lineno": 137,
      "end_lineno": 149,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 2,
      "loc": 13,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "(logger)",
      "fingerprint": "be7b4a6650b96628e61bfceb45f843f89d9c4b20",
      "simhash64": 7488180022980551779,
      "normalized": "def NAME ( NAME : NAME . NAME ) : LIT def NAME ( NAME : NAME [ ... , NAME ] ) -> NAME [ ... , NAME ] : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : if NAME . NAME ( NAME . NAME ) : return NAME ( * NAME , ** NAME ) return None return NAME return NAME"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "decorator",
      "lineno": 142,
      "end_lineno": 148,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "(func)",
      "fingerprint": "bfb1e1130abe4566543310b9a8d829020f2da9f6",
      "simhash64": 7488180022980551779,
      "normalized": "def NAME ( NAME : NAME [ ... , NAME ] ) -> NAME [ ... , NAME ] : @ NAME ( NAME ) def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : if NAME . NAME ( NAME . NAME ) : return NAME ( * NAME , ** NAME ) return None return NAME"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "wrapper",
      "lineno": 144,
      "end_lineno": 147,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 4,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "0e2116984beb6f3e7670a9dd8c81b902ab569cba",
      "simhash64": 7488180022980551779,
      "normalized": "def NAME ( * NAME : NAME , ** NAME : NAME ) -> NAME : if NAME . NAME ( NAME . NAME ) : return NAME ( * NAME , ** NAME ) return None"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "OptimizedLogger.__init__",
      "lineno": 158,
      "end_lineno": 159,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, logger)",
      "fingerprint": "924693cfeaa9bf41d3ec316c27984c012df1e766",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME . NAME ) : NAME . NAME = NAME"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "OptimizedLogger.logger",
      "lineno": 162,
      "end_lineno": 164,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "logging",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "e00b91a9b08ca1abc091b83b9992f3443703fef6",
      "simhash64": 7488109654235849795,
      "normalized": "def NAME ( NAME ) -> NAME . NAME : LIT return NAME . NAME"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "OptimizedLogger.debug_lazy",
      "lineno": 166,
      "end_lineno": 177,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "(self, msg_func)",
      "fingerprint": "eb1b20eea59de6089cab6ee7426244da63e65353",
      "simhash64": 7470165624470549507,
      "normalized": "def NAME ( NAME , NAME : NAME [ [ ] , NAME ] ) -> None : LIT if NAME . NAME . NAME ( NAME . NAME ) : NAME . NAME . NAME ( NAME ( ) )"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "OptimizedLogger.__getattr__",
      "lineno": 179,
      "end_lineno": 181,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self, name)",
      "fingerprint": "73eb515283f9c05ddbf46f46cbf4749d4e8b4902",
      "simhash64": 7488180024053769315,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT return NAME ( NAME . NAME , NAME )"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 188,
      "end_lineno": 479,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 21,
      "yield_count": 0,
      "complexity": 14,
      "loc": 292,
      "tags": [
        "impure",
        "network",
        "filesystem",
        "logging",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "2bffeafc9438bea91b7125dde5423e1070fbcd60",
      "simhash64": 7487617073026602019,
      "normalized": "def NAME ( ) -> NAME : LIT try : from NAME import NAME NAME = NAME ( LIT , NAME ) NAME . NAME ( ) def NAME ( ) : LIT try : # Test without name parameter NAME = NAME ( ) assert NAME is not None assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Test with specific name NAME = NAME ( LIT ) assert NAME is not None assert NAME . NAME . NAME ( LIT ) # Test that loggers are properly configured assert NAME ( NAME , LIT ) return True except NAME : return False def NAME ( ) : LIT try : import NAME # Create test logger NAME = NAME . NAME ( LIT ) # Add duplicate handlers manually NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) # Same type, should be detected as duplicate # Use proper logs directory for test.log import NAME from NAME import NAME NAME = NAME ( NAME . NAME ( LIT , LIT ) ) if not NAME . NAME ( ) : NAME = ( NAME ( NAME ) . NAME . NAME . NAME ( ) / NAME ) . NAME ( ) NAME . NAME ( NAME = True , NAME = True ) NAME = NAME / LIT NAME = NAME . NAME ( NAME ( NAME ) ) if NAME ( NAME , LIT ) else NAME . NAME ( ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME = NAME ( NAME . NAME ) # Run duplicate removal NAME ( NAME ) # Should have fewer handlers now NAME = NAME ( NAME . NAME ) assert NAME <= NAME # Clean up NAME . NAME . NAME ( ) return True except NAME : return False def NAME ( ) : LIT try : # Run suppression NAME ( ) # Check that external loggers are properly configured NAME = [ LIT , LIT , LIT ] for NAME in NAME : NAME = NAME . NAME ( NAME ) # Should have a level set (not NOTSET) assert NAME . NAME != NAME . NAME # Should not propagate to reduce noise assert not NAME . NAME return True except NAME : return False def NAME ( ) : LIT try : NAME = NAME ( ) assert NAME is not None assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Should be equivalent to get_logger() NAME ( ) # They should be related (same or parent/child relationship) return True except NAME : return False def NAME ( ) : LIT try : NAME = NAME ( LIT ) # Create a test function with decorator @ NAME ( NAME ) def NAME ( ) : return LIT # Test that decorator is callable assert NAME ( NAME ) # Test execution (result depends on debug level) NAME = NAME ( ) # Should either return the result or None based on debug level assert NAME is None or NAME == LIT return True except NAME : return False def NAME ( ) : LIT try : NAME = NAME ( LIT ) NAME = NAME ( NAME ) # Test logger property access assert NAME . NAME is NAME # Test delegation of standard methods assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Test debug_lazy method assert NAME ( NAME , LIT ) assert NAME ( NAME . NAME ) # Test debug_lazy execution NAME = LIT def NAME ( ) : nonlocal NAME NAME += LIT return LIT NAME . NAME ( NAME ) # Execution count depends on debug level, but should not error return True except NAME : return False def NAME ( ) : LIT try : global NAME NAME = NAME # Reset setup flag NAME = False # Get logger should trigger setup NAME = NAME ( LIT ) # Should have attempted setup (flag may or may not change based on imports) assert NAME is not None # Restore original state NAME = NAME return True except NAME : return False def NAME ( ) : LIT try : # Test that get_logger works even with import failures # This is hard to test directly, but we can test that # get_logger handles various scenarios gracefully NAME = NAME ( LIT ) assert NAME is not None assert NAME ( NAME , LIT ) return True except NAME : return False # Run all tests NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT ) return NAME . NAME ( ) except NAME : NAME ( LIT ) # Basic fallback tests try : NAME = NAME ( ) assert NAME is not None NAME = NAME ( ) assert NAME is not None NAME ( ) NAME = NAME ( NAME ) assert NAME is not None NAME ( LIT ) return True except NAME as NAME : NAME ( f\" \u274c Basic logging_utils validation failed: { NAME } \" ) return False"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "test_get_logger_functionality",
      "lineno": 204,
      "end_lineno": 223,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 20,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5c858b12b448a278a8dbeac0c839f9ca4293d49b",
      "simhash64": 8641277415624971827,
      "normalized": "def NAME ( ) : LIT try : # Test without name parameter NAME = NAME ( ) assert NAME is not None assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Test with specific name NAME = NAME ( LIT ) assert NAME is not None assert NAME . NAME . NAME ( LIT ) # Test that loggers are properly configured assert NAME ( NAME , LIT ) return True except NAME : return False"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "test_duplicate_handler_prevention",
      "lineno": 225,
      "end_lineno": 264,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 40,
      "tags": [
        "impure",
        "filesystem",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "ee7cab4eda90601e0f9402f55f6b4744a8537ced",
      "simhash64": 8641066343214785555,
      "normalized": "def NAME ( ) : LIT try : import NAME # Create test logger NAME = NAME . NAME ( LIT ) # Add duplicate handlers manually NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) # Same type, should be detected as duplicate # Use proper logs directory for test.log import NAME from NAME import NAME NAME = NAME ( NAME . NAME ( LIT , LIT ) ) if not NAME . NAME ( ) : NAME = ( NAME ( NAME ) . NAME . NAME . NAME ( ) / NAME ) . NAME ( ) NAME . NAME ( NAME = True , NAME = True ) NAME = NAME / LIT NAME = NAME . NAME ( NAME ( NAME ) ) if NAME ( NAME , LIT ) else NAME . NAME ( ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME . NAME ( NAME ) NAME = NAME ( NAME . NAME ) # Run duplicate removal NAME ( NAME ) # Should have fewer handlers now NAME = NAME ( NAME . NAME ) assert NAME <= NAME # Clean up NAME . NAME . NAME ( ) return True except NAME : return False"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "test_external_logger_suppression",
      "lineno": 266,
      "end_lineno": 283,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 18,
      "tags": [
        "impure",
        "network",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "1b21feaf2b6a4ba404e85d483fd13c89de8db8b4",
      "simhash64": 7488145938119562355,
      "normalized": "def NAME ( ) : LIT try : # Run suppression NAME ( ) # Check that external loggers are properly configured NAME = [ LIT , LIT , LIT ] for NAME in NAME : NAME = NAME . NAME ( NAME ) # Should have a level set (not NOTSET) assert NAME . NAME != NAME . NAME # Should not propagate to reduce noise assert not NAME . NAME return True except NAME : return False"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "test_app_logger_convenience",
      "lineno": 285,
      "end_lineno": 300,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "ae936c5c252b4e0f88813e3f1729a5e72b62835e",
      "simhash64": 8641277415624971811,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME ( ) assert NAME is not None assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Should be equivalent to get_logger() NAME ( ) # They should be related (same or parent/child relationship) return True except NAME : return False"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "test_debug_decorator",
      "lineno": 302,
      "end_lineno": 322,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "d1bace2f8a7092afd3054f1a658988165a074259",
      "simhash64": 6335355245860656739,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME ( LIT ) # Create a test function with decorator @ NAME ( NAME ) def NAME ( ) : return LIT # Test that decorator is callable assert NAME ( NAME ) # Test execution (result depends on debug level) NAME = NAME ( ) # Should either return the result or None based on debug level assert NAME is None or NAME == LIT return True except NAME : return False"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "test_debug_function",
      "lineno": 309,
      "end_lineno": 310,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "88196c13a4ec3b7a1dbe2535ac0e0e678a85a55d",
      "simhash64": 5760372770364887083,
      "normalized": "def NAME ( ) : return LIT"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "test_optimized_logger_functionality",
      "lineno": 324,
      "end_lineno": 353,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 2,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "5f4b1bb45dc8568897bc58ab8f48c10cce522679",
      "simhash64": 7488355910480729187,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME ( LIT ) NAME = NAME ( NAME ) # Test logger property access assert NAME . NAME is NAME # Test delegation of standard methods assert NAME ( NAME , LIT ) assert NAME ( NAME , LIT ) # Test debug_lazy method assert NAME ( NAME , LIT ) assert NAME ( NAME . NAME ) # Test debug_lazy execution NAME = LIT def NAME ( ) : nonlocal NAME NAME += LIT return LIT NAME . NAME ( NAME ) # Execution count depends on debug level, but should not error return True except NAME : return False"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "test_msg_func",
      "lineno": 343,
      "end_lineno": 346,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "2a9f4d66b4577e5fc6f2e10e6d7f8fd6bf117ca8",
      "simhash64": 17292683680332289131,
      "normalized": "def NAME ( ) : nonlocal NAME NAME += LIT return LIT"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "test_centralized_logging_setup",
      "lineno": 355,
      "end_lineno": 375,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 21,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "c54469d8c990ed69132a117e4ea16a070b53f3c4",
      "simhash64": 8605029815321810003,
      "normalized": "def NAME ( ) : LIT try : global NAME NAME = NAME # Reset setup flag NAME = False # Get logger should trigger setup NAME = NAME ( LIT ) # Should have attempted setup (flag may or may not change based on imports) assert NAME is not None # Restore original state NAME = NAME return True except NAME : return False"
    },
    {
      "module_path": "core\\logging_utils.py",
      "qualname": "test_logging_import_fallback",
      "lineno": 377,
      "end_lineno": 390,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "4e5e8e5b7b5426f47999606e8b33575f43c81813",
      "simhash64": 6335390408748471923,
      "normalized": "def NAME ( ) : LIT try : # Test that get_logger works even with import failures # This is hard to test directly, but we can test that # get_logger handles various scenarios gracefully NAME = NAME ( LIT ) assert NAME is not None assert NAME ( NAME , LIT ) return True except NAME : return False"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "ProgressStats.elapsed_seconds",
      "lineno": 35,
      "end_lineno": 37,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "time",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "1df0b94e60586a5649ba04229a155da3fa841a54",
      "simhash64": 8640573767911113731,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return ( NAME . NAME ( ) - NAME . NAME ) . NAME ( )"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "ProgressStats.items_per_second",
      "lineno": 39,
      "end_lineno": 42,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "9522cd57491c4b54b9ffb75501784ac2b03768d1",
      "simhash64": 7488109654302962691,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) return NAME . NAME / NAME if NAME > LIT else LIT"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "ProgressStats.eta_seconds",
      "lineno": 44,
      "end_lineno": 54,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 11,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "c0f14468aea329b4109a8ada38a0e7ed7b558ad6",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT if not NAME . NAME or NAME . NAME == LIT : return None NAME = NAME . NAME ( ) if NAME <= LIT : return None NAME = NAME . NAME - NAME . NAME return NAME / NAME"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "ProgressStats.memory_usage_mb",
      "lineno": 56,
      "end_lineno": 62,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "d8deb837a760a36c8f17376fa3361b339b21fab5",
      "simhash64": 8645077361700017155,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : NAME = NAME . NAME ( ) return NAME . NAME ( ) . NAME / LIT / LIT except NAME : return LIT"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "ProgressIndicator.__init__",
      "lineno": 76,
      "end_lineno": 102,
      "is_method": true,
      "is_async": false,
      "args_count": 11,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 27,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:small"
      ],
      "signature": "(self, description, total, unit, show_memory, show_rate, update_interval, show_bar, log_start, log_finish, leave)",
      "fingerprint": "498eba2604ca3f17793c8d25ec4a3ba1e8853200",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME [ NAME ] = None , NAME : NAME = LIT , NAME : NAME = True , NAME : NAME = True , NAME : NAME = LIT , NAME : NAME = True , NAME : NAME = True , NAME : NAME = True , NAME : NAME = True , ) : NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME NAME . NAME = NAME ( NAME = NAME ) NAME . NAME : NAME [ NAME ] = None NAME . NAME = LIT NAME . NAME = NAME . NAME ( )"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "ProgressIndicator.__enter__",
      "lineno": 104,
      "end_lineno": 107,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "f89abb163a9eb991e7df8f4565a8ea6df85d4c6b",
      "simhash64": 7492296595588158499,
      "normalized": "def NAME ( NAME ) -> LIT : LIT NAME . NAME ( ) return NAME"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "ProgressIndicator.__exit__",
      "lineno": 109,
      "end_lineno": 111,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, exc_type, exc_val, exc_tb)",
      "fingerprint": "38f618e3c8eaaf0316c2ec850d5a63b17dd4b220",
      "simhash64": 7488320731478922275,
      "normalized": "def NAME ( NAME , NAME , NAME , NAME ) -> None : LIT NAME . NAME ( )"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "ProgressIndicator.start",
      "lineno": 113,
      "end_lineno": 127,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 15,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "c42e6f377ba545b2eb397fe714108a27b80b5ae4",
      "simhash64": 7451588276007646211,
      "normalized": "def NAME ( NAME ) -> None : LIT if NAME . NAME : NAME = { LIT : NAME . NAME , LIT : NAME . NAME . NAME , LIT : NAME . NAME , LIT : True , LIT : NAME . NAME , LIT : LIT } NAME . NAME = NAME ( ** NAME ) NAME . NAME . NAME = NAME . NAME ( ) if NAME . NAME : NAME . NAME ( f\" Started progress tracking: { NAME . NAME } \" )"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "ProgressIndicator.update",
      "lineno": 129,
      "end_lineno": 154,
      "is_method": true,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 26,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, increment, errors, warnings, api_calls, cache_hits, custom_status)",
      "fingerprint": "590222348494d1ca2c1db6b8eca2958a345e7dc3",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME = LIT , NAME : NAME [ NAME ] = None ) -> None : LIT with NAME . NAME : NAME . NAME . NAME += NAME NAME . NAME . NAME += NAME NAME . NAME . NAME += NAME NAME . NAME . NAME += NAME NAME . NAME . NAME += NAME # Update memory usage if NAME . NAME : NAME . NAME . NAME = NAME . NAME . NAME ( ) # Update progress bar if enough time has passed NAME = NAME . NAME ( ) if NAME - NAME . NAME >= NAME . NAME : NAME . NAME ( NAME ) NAME . NAME = NAME"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "ProgressIndicator._update_display",
      "lineno": 156,
      "end_lineno": 193,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 10,
      "loc": 38,
      "tags": [
        "pure-ish",
        "purpose:formatting",
        "size:medium"
      ],
      "signature": "(self, custom_status)",
      "fingerprint": "ba5122b96e1e57d681060808edf621dac962b5c7",
      "simhash64": 7488215207352120339,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) -> None : LIT if NAME . NAME is None : return # Update progress bar position NAME . NAME . NAME = NAME . NAME . NAME # Build status message NAME = [ ] if NAME : NAME . NAME ( NAME ) if NAME . NAME and NAME . NAME . NAME > LIT : NAME = NAME . NAME . NAME ( ) NAME . NAME ( f\" { NAME : .1f } { NAME . NAME } /s \" ) if NAME . NAME : NAME . NAME ( f\" { NAME . NAME . NAME : .1f } MB \" ) if NAME . NAME . NAME > LIT : NAME . NAME ( f\" { NAME . NAME . NAME } errors \" ) if NAME . NAME . NAME > LIT : NAME = ( NAME . NAME . NAME / NAME . NAME . NAME * LIT ) if NAME . NAME . NAME > LIT else LIT NAME . NAME ( f\" Cache: { NAME : .1f } % \" ) # Add ETA if available NAME = NAME . NAME . NAME ( ) if NAME : NAME = NAME ( NAME ( NAME = NAME ( NAME ) ) ) NAME . NAME ( f\" ETA: { NAME } \" ) if NAME : NAME . NAME . NAME ( LIT . NAME ( NAME ) ) NAME . NAME . NAME ( )"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "ProgressIndicator.set_total",
      "lineno": 195,
      "end_lineno": 201,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, total)",
      "fingerprint": "cd9dc54e0c1efd1c5d9ac67494fabfd11df55170",
      "simhash64": 8641031158842696723,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT with NAME . NAME : NAME . NAME . NAME = NAME if NAME . NAME is not None : NAME . NAME . NAME = NAME NAME . NAME . NAME ( )"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "ProgressIndicator.log_milestone",
      "lineno": 203,
      "end_lineno": 218,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 16,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "(self, message, level)",
      "fingerprint": "3c80e59dc073667cb0d11a4ab7b93271e5d2107c",
      "simhash64": 7488144838607942675,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME = NAME . NAME ) -> None : LIT NAME = NAME . NAME . NAME ( ) NAME = NAME . NAME . NAME ( ) NAME = ( f\" { NAME } | \" f\" Processed: { NAME . NAME . NAME } | \" f\" Rate: { NAME : .1f } { NAME . NAME } /s | \" f\" Elapsed: { NAME ( NAME = NAME ( NAME ) ) } \" ) if NAME . NAME . NAME > LIT : NAME += f\" | Errors: { NAME . NAME . NAME } \" NAME . NAME ( NAME , NAME )"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "ProgressIndicator.finish",
      "lineno": 220,
      "end_lineno": 256,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 37,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, final_message)",
      "fingerprint": "45d09b5d16ab0c044d2e3a592278b02367a49132",
      "simhash64": 7488144838607942675,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) -> None : LIT if NAME . NAME is not None : # Ensure progress bar shows completion if NAME . NAME . NAME : NAME . NAME . NAME = NAME . NAME . NAME else : NAME . NAME . NAME = NAME . NAME . NAME NAME . NAME . NAME = NAME . NAME . NAME NAME . NAME . NAME ( LIT ) NAME . NAME . NAME ( ) NAME . NAME . NAME ( ) NAME . NAME = None # Log final summary NAME = NAME . NAME . NAME ( ) NAME = NAME . NAME . NAME ( ) NAME = ( f\" Completed { NAME . NAME } : \" f\" { NAME . NAME . NAME } { NAME . NAME } processed | \" f\" Rate: { NAME : .1f } { NAME . NAME } /s | \" f\" Total time: { NAME ( NAME = NAME ( NAME ) ) } \" ) if NAME . NAME . NAME > LIT : NAME += f\" | Errors: { NAME . NAME . NAME } \" if NAME : NAME += f\" | { NAME } \" # Only log completion when explicitly requested if NAME . NAME : NAME . NAME ( NAME ) # Add a blank line below the completion summary for readability (per user preference) NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "create_progress_indicator",
      "lineno": 258,
      "end_lineno": 270,
      "is_method": false,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:small"
      ],
      "signature": "(description, total, unit, **kwargs)",
      "fingerprint": "5a83b3a72886ef79fef3bb81b552fa5946750b00",
      "simhash64": 7452080858292196371,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME [ NAME ] = None , NAME : NAME = LIT , ** NAME ) -> NAME : LIT return NAME ( NAME = NAME , NAME = NAME , NAME = NAME , ** NAME )"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "with_progress",
      "lineno": 273,
      "end_lineno": 302,
      "is_method": false,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 30,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(description, unit, extract_total)",
      "fingerprint": "21addfe4e2d9640b96bf10365b0d4c4ce54ffa34",
      "simhash64": 7488109654237426803,
      "normalized": "def NAME ( NAME : NAME , NAME : NAME = LIT , NAME : NAME [ NAME ] = None ) : LIT def NAME ( NAME : NAME ) -> NAME : def NAME ( * NAME , ** NAME ) -> NAME : # Extract total if function provided NAME = None if NAME : try : NAME = NAME ( * NAME , ** NAME ) except NAME as NAME : NAME . NAME ( f\" Failed to extract total for progress tracking: { NAME } \" ) with NAME ( NAME , NAME , NAME ) as NAME : # Add progress to kwargs for function to use NAME [ LIT ] = NAME return NAME ( * NAME , ** NAME ) return NAME return NAME"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "decorator",
      "lineno": 286,
      "end_lineno": 301,
      "is_method": false,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 16,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(func)",
      "fingerprint": "009863a1a6a2f0e43b89ff9f7fe7548cc9c5e4d6",
      "simhash64": 7488109654237426803,
      "normalized": "def NAME ( NAME : NAME ) -> NAME : def NAME ( * NAME , ** NAME ) -> NAME : # Extract total if function provided NAME = None if NAME : try : NAME = NAME ( * NAME , ** NAME ) except NAME as NAME : NAME . NAME ( f\" Failed to extract total for progress tracking: { NAME } \" ) with NAME ( NAME , NAME , NAME ) as NAME : # Add progress to kwargs for function to use NAME [ LIT ] = NAME return NAME ( * NAME , ** NAME ) return NAME"
    },
    {
      "module_path": "core\\progress_indicators.py",
      "qualname": "wrapper",
      "lineno": 287,
      "end_lineno": 299,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 13,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(*args, **kwargs)",
      "fingerprint": "71a831c23958d4550c9dc2274850c4b430757877",
      "simhash64": 7452080857218462843,
      "normalized": "def NAME ( * NAME , ** NAME ) -> NAME : # Extract total if function provided NAME = None if NAME : try : NAME = NAME ( * NAME , ** NAME ) except NAME as NAME : NAME . NAME ( f\" Failed to extract total for progress tracking: { NAME } \" ) with NAME ( NAME , NAME , NAME ) as NAME : # Add progress to kwargs for function to use NAME [ LIT ] = NAME return NAME ( * NAME , ** NAME )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "cached_api_manager",
      "lineno": 66,
      "end_lineno": 67,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "172ac1bbf9c52467536a702d853b37503d29d5c1",
      "simhash64": 9219418776879928363,
      "normalized": "def NAME ( ) : return NAME ( LIT )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "cached_browser_manager",
      "lineno": 69,
      "end_lineno": 70,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "172ac1bbf9c52467536a702d853b37503d29d5c1",
      "simhash64": 9219418776879928363,
      "normalized": "def NAME ( ) : return NAME ( LIT )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "cached_database_manager",
      "lineno": 72,
      "end_lineno": 73,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "172ac1bbf9c52467536a702d853b37503d29d5c1",
      "simhash64": 9219418776879928363,
      "normalized": "def NAME ( ) : return NAME ( LIT )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "cached_session_validator",
      "lineno": 75,
      "end_lineno": 76,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:delegation",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "172ac1bbf9c52467536a702d853b37503d29d5c1",
      "simhash64": 9219418776879928363,
      "normalized": "def NAME ( ) : return NAME ( LIT )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "clear_session_cache",
      "lineno": 78,
      "end_lineno": 85,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "9369a892ebd219d6f6691f361cfce24837ba0a8a",
      "simhash64": 8645218614584980483,
      "normalized": "def NAME ( ) : LIT try : NAME = NAME ( ) # Clear session cache by warming it (resets state) return NAME . NAME . NAME ( ) except NAME : return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.__init__",
      "lineno": 149,
      "end_lineno": 352,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 6,
      "loc": 204,
      "tags": [
        "impure",
        "network",
        "filesystem",
        "logging",
        "time",
        "purpose:initialization",
        "size:large"
      ],
      "signature": "(self, db_path)",
      "fingerprint": "d22b5e8b793bd33f1f32c9fdc631275d8b124449",
      "simhash64": 7452151226028168195,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) : LIT NAME = NAME . NAME ( ) NAME . NAME ( LIT ) # PHASE 5.1: Use cached component managers for dramatic performance improvement NAME . NAME = NAME . NAME ( NAME ) NAME . NAME = NAME . NAME ( ) NAME . NAME = NAME . NAME ( ) NAME . NAME = NAME . NAME ( ) # Session state NAME . NAME : NAME = False NAME . NAME : NAME [ NAME ] = None # PHASE 5.1: Session state caching for performance NAME . NAME : NAME [ NAME ] = None NAME . NAME : NAME [ NAME , NAME ] = { } # \u26a1 OPTIMIZATION 1: Pre-cached CSRF token for Action 6 performance NAME . NAME : NAME [ NAME ] = None NAME . NAME : NAME = LIT NAME . NAME : NAME = LIT # 5-minute cache # Configuration (cached access) NAME . NAME : NAME = NAME . NAME . NAME NAME . NAME : NAME = NAME . NAME . NAME # Database state tracking (from old SessionManager) NAME . NAME : NAME = False NAME . NAME : NAME = False # Identifier logging flags (from old SessionManager) NAME . NAME : NAME = False NAME . NAME : NAME = False NAME . NAME : NAME = False NAME . NAME : NAME = False # Add dynamic rate limiter for AI calls (matches utils.py SessionManager) try : from NAME import NAME NAME . NAME = NAME ( ) except NAME : NAME . NAME = None # Reliable processing state (merged from ReliableSessionManager) NAME . NAME = { LIT : NAME ( NAME . NAME ( LIT , LIT ) ) , LIT : NAME ( NAME . NAME ( LIT , LIT ) ) , LIT : LIT , LIT : LIT , LIT : LIT , LIT : LIT , LIT : NAME . NAME ( ) , } # === PHASE 2: Enhanced Reliability State === # Early warning (multi-window) and intervention history NAME . NAME = { LIT : { LIT : LIT , LIT : [ ] } , LIT : { LIT : LIT , LIT : [ ] } , LIT : { LIT : LIT , LIT : [ ] } , } NAME . NAME = [ ] # [{timestamp, category, action, page_num}] NAME . NAME = None # Network resilience NAME . NAME = LIT NAME . NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME . NAME = [ LIT , LIT , LIT , ] # Auth monitoring NAME . NAME = LIT NAME . NAME = NAME ( NAME . NAME ( LIT , LIT ) ) NAME . NAME = LIT NAME . NAME = LIT NAME . NAME = LIT # UNIVERSAL SESSION HEALTH MONITORING (moved from action6-specific to universal) NAME . NAME = { LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) , LIT : LIT , # Check every 30 seconds LIT : NAME . NAME ( ) , LIT : None , LIT : LIT , LIT : LIT , # PROACTIVE SESSION REFRESH ADDITIONS LIT : NAME . NAME ( ) , LIT : LIT , # 40 minutes (before 45min expiry) LIT : NAME . NAME ( ) , LIT : NAME ( NAME , LIT , LIT ) , # default 30 min LIT : NAME . NAME ( ) } # OPTION C: BROWSER HEALTH MONITORING ADDITIONS NAME . NAME = { LIT : NAME . NAME ( ) , LIT : LIT , # 30 minutes before proactive refresh LIT : NAME . NAME ( ) , LIT : LIT , # 30 minutes LIT : LIT , LIT : LIT , # Refresh every 30 pages LIT : NAME . NAME ( ) , LIT : LIT , LIT : NAME . NAME ( ) } NAME . NAME [ LIT ] . NAME ( ) # Initially alive # === HEALTH MONITORING INTEGRATION === # Initialize comprehensive health monitoring try : from NAME import NAME , NAME NAME . NAME = NAME ( ) NAME ( NAME ) NAME . NAME ( LIT ) except NAME : NAME . NAME ( LIT ) NAME . NAME = None # Session death detection tracking NAME . NAME = LIT # === PHASE 11.1: ADAPTIVE RATE LIMITING === try : from NAME import NAME , NAME # Initialize adaptive rate limiter with OPTIMIZED settings for Action 6 NAME = NAME ( NAME , LIT , None ) if NAME : NAME = NAME ( NAME , LIT , LIT ) NAME = NAME ( NAME , LIT , LIT ) else : NAME = LIT NAME = LIT # OPTIMIZATION: More aggressive adaptive settings based on log analysis # Log analysis showed 96.3% cache hit rate and very stable performance NAME . NAME = NAME ( NAME = NAME ( LIT , NAME ) , # SAFE OPTIMIZATION: Start higher to match new config (0.6 \u2192 0.7) NAME = LIT , # SAFE OPTIMIZATION: Slightly higher minimum (0.3 \u2192 0.35) to match new baseline NAME = LIT , # Keep same maximum - already optimized NAME = NAME , NAME = LIT , # Keep same - already optimized NAME = LIT , # Keep same - already optimized NAME = LIT , # Keep same - already optimized NAME = LIT , # Keep same - already optimized NAME = LIT # Keep same - already optimized ) NAME . NAME ( LIT ) # Initialize smart batch processor NAME = NAME ( NAME , LIT , LIT ) NAME . NAME = NAME ( NAME = NAME ( NAME , LIT ) , NAME = LIT , NAME = LIT ) except NAME as NAME : NAME . NAME ( f\" Adaptive rate limiting not available: { NAME } \" ) NAME . NAME = None NAME . NAME = None # === ENHANCED SESSION CAPABILITIES === # JavaScript error monitoring NAME . NAME : NAME = NAME . NAME ( NAME . NAME ) # CSRF token caching for performance optimization NAME . NAME : NAME [ NAME ] = None NAME . NAME : NAME = LIT NAME . NAME : NAME = LIT # 5 minutes # === THREAD SAFETY MOVED TO BROWSER MANAGER === # Thread safety now handled by unified master lock in BrowserManager NAME . NAME ( LIT ) # Initialize enhanced requests session with advanced configuration NAME . NAME ( ) # Initialize CloudScraper for anti-bot protection NAME . NAME ( ) # PHASE 5.1: Only initialize database if not already cached and ready if not NAME . NAME . NAME : NAME . NAME . NAME ( ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Optimized SessionManager created in { NAME : .3f } s: ID= { NAME ( NAME ) } \" )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._get_cached_database_manager",
      "lineno": 355,
      "end_lineno": 360,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self, db_path)",
      "fingerprint": "1f4611016b84a123702bedc814009c30612079bf",
      "simhash64": 7488180024053765155,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) -> LIT : LIT NAME . NAME ( LIT ) return NAME ( NAME )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._get_cached_browser_manager",
      "lineno": 363,
      "end_lineno": 366,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "3d1cbc7bb6d58a05c1fd539b116ab7b5e56a1275",
      "simhash64": 7492287799495136299,
      "normalized": "def NAME ( NAME ) -> LIT : LIT NAME . NAME ( LIT ) return NAME ( )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._get_cached_api_manager",
      "lineno": 369,
      "end_lineno": 372,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "3d1cbc7bb6d58a05c1fd539b116ab7b5e56a1275",
      "simhash64": 7492287799495136299,
      "normalized": "def NAME ( NAME ) -> LIT : LIT NAME . NAME ( LIT ) return NAME ( )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._get_cached_session_validator",
      "lineno": 375,
      "end_lineno": 378,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "3d1cbc7bb6d58a05c1fd539b116ab7b5e56a1275",
      "simhash64": 7492287799495136299,
      "normalized": "def NAME ( NAME ) -> LIT : LIT NAME . NAME ( LIT ) return NAME ( )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._initialize_enhanced_requests_session",
      "lineno": 380,
      "end_lineno": 412,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 33,
      "tags": [
        "impure",
        "network",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "62cc297e26baaab27ca1d4368c041e29e6708b2d",
      "simhash64": 7487617077321569291,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME ( LIT ) # Enhanced retry strategy with more comprehensive status codes NAME = NAME ( NAME = LIT , NAME = LIT , NAME = [ LIT , LIT , LIT , LIT , LIT ] , NAME = [ LIT , LIT , LIT , LIT ] ) # Advanced HTTPAdapter with connection pooling NAME = NAME ( NAME = LIT , NAME = LIT , NAME = NAME ) # Apply adapter to API manager's requests session if NAME ( NAME . NAME , LIT ) : NAME . NAME . NAME . NAME ( LIT , NAME ) NAME . NAME . NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) # Create fallback session if APIManager doesn't have one NAME . NAME . NAME = NAME . NAME ( ) NAME . NAME . NAME . NAME ( LIT , NAME ) NAME . NAME . NAME . NAME ( LIT , NAME )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._initialize_cloudscraper",
      "lineno": 414,
      "end_lineno": 453,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 40,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "6134f0979d37b77eb1af41a6190fe629c2ba051d",
      "simhash64": 5145886009718117387,
      "normalized": "def NAME ( NAME ) -> None : LIT if NAME is None : NAME . NAME ( LIT ) NAME . NAME = None return NAME . NAME ( LIT ) try : # Create CloudScraper with browser fingerprinting NAME . NAME = NAME . NAME ( NAME = { LIT : LIT , LIT : LIT , LIT : True } , NAME = LIT , ) # Enhanced retry strategy for CloudScraper NAME = NAME ( NAME = LIT , NAME = LIT , NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] , NAME = [ LIT , LIT , LIT , LIT ] , ) # Apply retry adapter to CloudScraper NAME = NAME ( NAME = NAME ) NAME . NAME . NAME ( LIT , NAME ) NAME . NAME . NAME ( LIT , NAME ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Failed to initialize CloudScraper: { NAME } \" , NAME = True , ) NAME . NAME = None"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.ensure_db_ready",
      "lineno": 455,
      "end_lineno": 462,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "acdbe680b38da357be64dd3404bac91a19507fbf",
      "simhash64": 7487652257398694915,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME . NAME ( )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.start_browser",
      "lineno": 464,
      "end_lineno": 476,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 13,
      "tags": [
        "pure-ish",
        "logging",
        "size:small"
      ],
      "signature": "(self, action_name)",
      "fingerprint": "13913946a626e7612f4bde051dab23e53635c188",
      "simhash64": 7488180572803474435,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT # Reset logged flags when starting browser NAME . NAME ( ) return NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.close_browser",
      "lineno": 478,
      "end_lineno": 480,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "e858e9379b930a6c015e3f0ae1bc5c489214e129",
      "simhash64": 8641137267687470115,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME . NAME ( )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.start_sess",
      "lineno": 482,
      "end_lineno": 509,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 5,
      "loc": 28,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:small"
      ],
      "signature": "(self, action_name)",
      "fingerprint": "331bf88b3494d78b84e30ff5bd52dc38d3dd1acf",
      "simhash64": 7488215207419229187,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT NAME . NAME ( f\" Starting session for: { NAME or LIT } \" ) # Ensure database is ready if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False # Start browser if needed if NAME . NAME . NAME : NAME = NAME . NAME ( NAME ) if not NAME : NAME . NAME ( LIT ) return False # Mark session as started NAME . NAME = NAME . NAME ( ) return True"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.ensure_session_ready",
      "lineno": 514,
      "end_lineno": 609,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 17,
      "loc": 96,
      "tags": [
        "pure-ish",
        "logging",
        "time",
        "size:medium"
      ],
      "signature": "(self, action_name, skip_csrf)",
      "fingerprint": "9d2b4bda0df44ea40028fa1c0c93a4cdf1c0c02e",
      "simhash64": 7488109654302962707,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None , NAME : NAME = False ) -> NAME : LIT NAME = NAME . NAME ( ) # Removed duplicate logging - browser_manager will log the action # MINIMAL FIX: Set browser_needed to True for session operations NAME . NAME . NAME = True # PHASE 5.1: Check cached session state first f\" { NAME ( NAME ) } _ { NAME or LIT } \" # Try to use cached readiness state, but validate driver is still live if NAME . NAME is not None : NAME = NAME . NAME ( ) - NAME . NAME NAME = LIT # Use consistent 60-second cache for all actions if NAME < NAME and NAME . NAME : # Validate that the cached state is still accurate if NAME . NAME . NAME : if not NAME . NAME . NAME ( ) : NAME . NAME ( f\" Cached session readiness invalid - driver session expired (age: { NAME : .1f } s) \" ) NAME . NAME = False NAME . NAME = None else : NAME . NAME ( f\" Using cached session readiness (age: { NAME : .1f } s, action: { NAME } ) \" ) return True else : NAME . NAME ( f\" Using cached session readiness (age: { NAME : .1f } s, action: { NAME } ) \" ) return True # Ensure driver is live if browser is needed (with optimization) if NAME . NAME . NAME and not NAME . NAME . NAME ( NAME ) : NAME . NAME ( LIT ) NAME . NAME = False return False # PHASE 5.1: Optimized readiness checks with circuit breaker pattern try : NAME = NAME . NAME . NAME ( NAME . NAME , NAME . NAME , NAME , NAME , NAME = NAME ) if not NAME : NAME . NAME ( LIT ) NAME . NAME = False return False except NAME as NAME : NAME . NAME ( f\" Exception in readiness checks: { NAME } \" , NAME = True ) NAME . NAME = False return False # PHASE 5.1: Optimized identifier retrieval with caching NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) # Retrieve tree owner if configured (with caching) NAME = True if NAME . NAME . NAME : NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) # \u26a1 OPTIMIZATION 1: Pre-cache CSRF token during session setup if NAME and NAME : NAME . NAME ( ) # Set session ready status NAME . NAME = NAME and NAME and NAME # PHASE 5.1: Cache the readiness check result NAME . NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" Session readiness check completed in { NAME : .3f } s, status: { NAME . NAME } \" ) return NAME . NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.verify_sess",
      "lineno": 611,
      "end_lineno": 635,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 25,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "c2c5c2aa42980d4bea20bba35633b9c06b2b8a4c",
      "simhash64": 7488180022980023299,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME . NAME ( LIT ) try : # Import login_status locally to avoid circular imports from NAME import NAME NAME = NAME ( NAME , NAME = False ) if NAME is True : NAME . NAME ( LIT ) return True if NAME is False : NAME . NAME ( LIT ) return False # login_ok is None NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" Unexpected error during session verification: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.is_sess_valid",
      "lineno": 637,
      "end_lineno": 667,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 5,
      "loc": 31,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "131d381f1fac0ae347b03033013ce749686436ee",
      "simhash64": 7487652258002678787,
      "normalized": "def NAME ( NAME ) -> NAME : LIT # Simple check - verify driver exists if NAME . NAME is None : return False # Enhanced check - verify driver is responsive try : # Quick responsiveness test NAME = NAME . NAME . NAME return True except NAME as NAME : NAME . NAME ( f\" \ud83d\udd0c WebDriver session appears invalid: { NAME } \" ) # Attempt session recovery for long-running operations if NAME . NAME ( ) : NAME . NAME ( LIT ) if NAME . NAME ( ) : NAME . NAME ( LIT ) return True NAME . NAME ( LIT ) else : NAME . NAME ( LIT ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._should_attempt_recovery",
      "lineno": 669,
      "end_lineno": 680,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "time",
        "regex",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "542de73cf78435231d251979d62f211cda67f4f8",
      "simhash64": 7487546704617972851,
      "normalized": "def NAME ( NAME ) -> NAME : LIT # Only attempt recovery if session was previously working # and we're in a long-running operation return NAME ( NAME . NAME and NAME . NAME and NAME . NAME ( ) - NAME . NAME > LIT ) # 5 minutes"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._attempt_session_recovery",
      "lineno": 682,
      "end_lineno": 707,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 26,
      "tags": [
        "pure-ish",
        "regex",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "8c96b5b52b9dd5671d6a12f589f9f1330741c3a8",
      "simhash64": 7487652257398699051,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : NAME . NAME ( LIT ) NAME . NAME ( ) NAME . NAME ( LIT ) if NAME . NAME ( LIT ) : NAME . NAME ( LIT ) # Re-authenticate if needed from NAME import NAME if NAME ( NAME , NAME = False ) : NAME . NAME ( LIT ) return True NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Session recovery failed: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.check_session_health",
      "lineno": 710,
      "end_lineno": 756,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 8,
      "loc": 47,
      "tags": [
        "pure-ish",
        "time",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "e21e9a4086bf948a38a1294d2cf6bfd754afdaa3",
      "simhash64": 7470165624537658375,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : # CRITICAL FIX: Check for session death cascade first if NAME . NAME ( ) : NAME = NAME . NAME . NAME ( LIT , LIT ) if NAME >= LIT : # Lower threshold for health check NAME . NAME ( f\" \ud83d\udea8 SESSION HEALTH CHECK: Death cascade count { NAME } \" f\" exceeds health check threshold. Session is unhealthy. \" ) return False # Quick session validation (avoid flagging death during controlled refresh) if not NAME . NAME ( ) : if not NAME . NAME . NAME ( LIT , NAME . NAME ( ) ) . NAME ( ) : if not NAME . NAME [ LIT ] . NAME ( ) : NAME . NAME [ LIT ] . NAME ( ) NAME . NAME [ LIT ] . NAME ( ) NAME . NAME [ LIT ] = NAME . NAME ( ) NAME . NAME ( f\" \ud83d\udea8 SESSION DEATH DETECTED at { NAME . NAME ( LIT ) } \" f\" - Universal session health monitoring triggered \" ) else : NAME . NAME ( LIT ) return False # Update heartbeat if session is alive NAME . NAME [ LIT ] = NAME . NAME ( ) return True except NAME as NAME : NAME . NAME ( f\" Session health check failed: { NAME } \" ) # Assume session is dead on health check failure if not NAME . NAME [ LIT ] . NAME ( ) : NAME . NAME [ LIT ] . NAME ( ) NAME . NAME [ LIT ] . NAME ( ) NAME . NAME [ LIT ] = NAME . NAME ( ) NAME . NAME ( LIT ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.is_session_death_cascade",
      "lineno": 758,
      "end_lineno": 760,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "regex",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "86a9ef410f6a948be8e490a53bc2b560c322d531",
      "simhash64": 7488180023047140387,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME [ LIT ] . NAME ( )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.validate_system_health",
      "lineno": 763,
      "end_lineno": 816,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 10,
      "loc": 54,
      "tags": [
        "impure",
        "db",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, action_name)",
      "fingerprint": "243b0af4b10de39fb1a44098f0afbaaa7cbef65a",
      "simhash64": 8641136711960008251,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) -> NAME : LIT try : # Check 1: Session death cascade detection if NAME . NAME ( ) : NAME = NAME . NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" \ud83d\udea8 { NAME } : Session death cascade detected (# { NAME } ). \" f\" System is not safe for operations. \" ) return False # Check 2: Database connectivity try : with NAME . NAME ( ) as NAME : if not NAME : NAME . NAME ( f\" \ud83d\udea8 { NAME } : Failed to get database session \" ) return False # Test database connectivity with timeout from NAME import NAME NAME = NAME . NAME ( NAME ( LIT ) ) . NAME ( ) if NAME != LIT : NAME . NAME ( f\" \ud83d\udea8 { NAME } : Database query returned unexpected result \" ) return False except NAME as NAME : NAME . NAME ( f\" \ud83d\udea8 { NAME } : Database connectivity error: { NAME } \" ) return False # Check 3: Browser session validity (if available) try : if NAME ( NAME , LIT ) and not NAME . NAME ( ) : NAME . NAME ( f\" \u26a0\ufe0f { NAME } : Browser session invalid - may affect operations \" ) # Don't fail hard on browser issues for API-only operations except NAME as NAME : NAME . NAME ( f\" { NAME } : Browser health check failed (non-critical): { NAME } \" ) NAME . NAME ( f\" \u2705 { NAME } : System health check passed - all components validated \" ) return True except NAME as NAME : NAME . NAME ( f\" \ud83d\udea8 { NAME } : System health validation failed: { NAME } \" ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.check_cascade_before_operation",
      "lineno": 818,
      "end_lineno": 837,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 20,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self, action_name, operation_name)",
      "fingerprint": "eace80ebb1635a411f2a6573e4e7804961ff925a",
      "simhash64": 8605107914941043739,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> None : LIT if NAME . NAME ( ) : NAME = NAME . NAME . NAME ( LIT , LIT ) NAME . NAME ( f\" \ud83d\udea8 { NAME } : CASCADE DETECTED before { NAME } : \" f\" Session death cascade # { NAME } - halting operation \" ) raise NAME ( f\" Session death cascade detected before { NAME } (# { NAME } ) \" )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.should_halt_operations",
      "lineno": 839,
      "end_lineno": 879,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 6,
      "loc": 41,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "a2908cad4ad6a420423e7aa2be34ee450bf8d065",
      "simhash64": 7452186410391868859,
      "normalized": "def NAME ( NAME ) -> NAME : LIT # Check if emergency shutdown already triggered if NAME . NAME ( ) : return True if NAME . NAME ( ) : NAME = NAME . NAME . NAME ( LIT , LIT ) + LIT # Prevent cascade count from going beyond emergency threshold if NAME > LIT : return True # Already in emergency shutdown, don't increment further NAME . NAME [ LIT ] = NAME # IMMEDIATE HALT: No recovery attempts, reduced threshold if NAME >= LIT : # Reduced from 20 to 3 NAME . NAME ( f\" \ud83d\udea8 IMMEDIATE EMERGENCY SHUTDOWN: Cascade # { NAME } exceeds limit (3). \" f\" No recovery attempted - preventing infinite loops. \" ) NAME . NAME ( f\" Session death cascade # { NAME } - immediate shutdown to prevent infinite loop \" ) return True # Even for first few cascades, log and halt immediately NAME . NAME ( f\" \ud83d\udea8 SESSION DEATH CASCADE # { NAME } : Immediate halt - no recovery attempts. \" f\" Will trigger emergency shutdown at cascade #3. \" ) # SIMPLIFIED: Always halt on session death, no recovery if NAME >= LIT : # Halt immediately on any cascade NAME . NAME ( f\" \ud83d\udea8 HALTING IMMEDIATELY: Session death detected (cascade # { NAME } ) \" ) return True return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.emergency_shutdown",
      "lineno": 881,
      "end_lineno": 904,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, reason)",
      "fingerprint": "530231d71e72dfd9424c91b37ed61f5a487144b0",
      "simhash64": 7452151226028176387,
      "normalized": "def NAME ( NAME , NAME : NAME = LIT ) -> None : LIT NAME . NAME ( f\" \ud83d\udea8 EMERGENCY SHUTDOWN: { NAME } \" ) # Set emergency shutdown flag NAME . NAME [ LIT ] = True NAME . NAME [ LIT ] . NAME ( ) NAME . NAME [ LIT ] . NAME ( ) # Force cascade count to maximum to prevent any recovery attempts NAME . NAME [ LIT ] = LIT # Close browser if it exists try : if NAME . NAME : NAME . NAME . NAME ( ) NAME . NAME = None except NAME as NAME : NAME . NAME ( f\" Error closing driver during emergency shutdown: { NAME } \" ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.is_emergency_shutdown",
      "lineno": 906,
      "end_lineno": 908,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5548ebe1da28c17f21cf97c91f09f3c69c6150f6",
      "simhash64": 7492155858099803171,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME . NAME ( LIT , False )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.cancel_all_operations",
      "lineno": 910,
      "end_lineno": 917,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 8,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "bb90c6f0cda43b2b41033077c7a3dc9bc30cfdfb",
      "simhash64": 8605072730635023403,
      "normalized": "def NAME ( NAME ) -> None : LIT try : # Set a flag that other operations can check NAME . NAME [ LIT ] = True NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Error cancelling operations: { NAME } \" )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.attempt_cascade_recovery",
      "lineno": 919,
      "end_lineno": 964,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 5,
      "loc": 46,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "e8ec586126bdac1f88ab1862b8901ed53bbf5fa7",
      "simhash64": 7488180572802954295,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : NAME . NAME ( LIT ) # CRITICAL FIX: Don't reset death detection flags during cascade # This was causing infinite cascade loops because the death state # was being cleared, allowing the cascade to restart indefinitely # Only clear flags if recovery is truly successful # Clear all caches and force fresh session first NAME . NAME ( ) # Attempt to establish new session NAME = NAME . NAME ( LIT ) if NAME : # Only reset death detection flags if recovery actually worked NAME . NAME [ LIT ] . NAME ( ) NAME . NAME [ LIT ] . NAME ( ) # Reset timers for new session NAME = NAME . NAME ( ) NAME . NAME [ LIT ] = NAME NAME . NAME [ LIT ] = NAME NAME . NAME [ LIT ] = NAME NAME . NAME [ LIT ] = None NAME . NAME ( LIT ) return True NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" \u274c Session cascade recovery failed with exception: { NAME } \" ) # If clear_session_caches doesn't exist, try alternative cleanup if LIT in NAME ( NAME ) : NAME . NAME ( LIT ) try : # Reset session readiness flags NAME . NAME = False NAME . NAME = False return True except NAME as NAME : NAME . NAME ( f\" Alternative cleanup also failed: { NAME } \" ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.reset_session_health_monitoring",
      "lineno": 966,
      "end_lineno": 990,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 25,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "84dc07ea0892001c8ed5443d10ce0ae00cc268d3",
      "simhash64": 7452151226028176401,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME = NAME . NAME ( ) NAME . NAME [ LIT ] . NAME ( ) NAME . NAME [ LIT ] . NAME ( ) NAME . NAME [ LIT ] = NAME NAME . NAME [ LIT ] = None NAME . NAME [ LIT ] = LIT NAME . NAME [ LIT ] = LIT # Reset proactive refresh timers NAME . NAME [ LIT ] = NAME NAME . NAME [ LIT ] = NAME NAME . NAME [ LIT ] . NAME ( ) # Reset browser health monitoring NAME . NAME [ LIT ] = NAME NAME . NAME [ LIT ] = NAME NAME = NAME . NAME [ LIT ] NAME . NAME [ LIT ] = LIT NAME . NAME ( f\" \ud83d\udd04 Browser page count RESET: { NAME } \u2192 0 (reset_session_health_monitoring) \" ) NAME . NAME [ LIT ] . NAME ( ) NAME . NAME [ LIT ] = LIT NAME . NAME [ LIT ] = NAME NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.should_proactive_refresh",
      "lineno": 992,
      "end_lineno": 1017,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 5,
      "loc": 26,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "1a56b52a1ff72aa4560b4fbf9f826850629db424",
      "simhash64": 5182337013833446451,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) # Don't refresh if already in progress if NAME . NAME [ LIT ] . NAME ( ) : return False # Cooldown: if we refreshed very recently, skip proactive refresh to avoid per-page loops NAME = NAME - NAME . NAME [ LIT ] NAME = NAME ( NAME , LIT , LIT ) if NAME < NAME : return False # Check if session is approaching max age NAME = NAME - NAME . NAME [ LIT ] if NAME >= NAME . NAME [ LIT ] : NAME . NAME ( f\" \ud83d\udd04 Session age ( { NAME : .0f } s) approaching limit - proactive refresh needed \" ) return True # Check if enough time has passed since last proactive refresh if NAME >= NAME . NAME [ LIT ] : NAME . NAME ( f\" \ud83d\udd04 Time since last refresh ( { NAME : .0f } s) - proactive refresh needed \" ) return True return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.perform_proactive_refresh",
      "lineno": 1019,
      "end_lineno": 1127,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 14,
      "loc": 109,
      "tags": [
        "pure-ish",
        "time",
        "regex",
        "size:large"
      ],
      "signature": "(self)",
      "fingerprint": "6033ce787499ba19820502935f3f83f68bd8d3ba",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if NAME . NAME [ LIT ] . NAME ( ) : NAME . NAME ( LIT ) return True NAME = NAME . NAME ( ) NAME . NAME ( f\" \ud83d\udd04 Starting ENHANCED proactive session refresh at { NAME . NAME ( LIT ) } \" ) try : NAME . NAME [ LIT ] . NAME ( ) # Record the start time as the last proactive refresh to avoid immediate re-triggering NAME . NAME [ LIT ] = NAME # STEP 1: Pre-refresh verification NAME . NAME ( LIT ) NAME = NAME . NAME ( ) NAME . NAME ( f\" Pre-refresh session valid: { NAME } \" ) # STEP 2: Clear session caches with error handling NAME . NAME ( LIT ) try : if NAME ( NAME , LIT ) : NAME . NAME ( ) NAME . NAME ( LIT ) else : # Alternative cache clearing NAME . NAME = False NAME . NAME = False NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" \u26a0\ufe0f Cache clearing failed: { NAME } , continuing with alternative method \" ) NAME . NAME = False NAME . NAME = False # STEP 3: Enhanced session refresh with multiple attempts NAME . NAME ( LIT ) NAME = LIT NAME = False for NAME in NAME ( LIT , NAME + LIT ) : NAME . NAME ( f\" Refresh attempt { NAME } / { NAME } ... \" ) try : NAME = NAME . NAME ( f\" Proactive Refresh - Attempt { NAME } \" ) if NAME : NAME . NAME ( f\" \u2705 Session refresh successful on attempt { NAME } \" ) break NAME . NAME ( f\" \u274c Session refresh failed on attempt { NAME } \" ) if NAME < NAME : NAME . NAME ( f\" Waiting 2s before attempt { NAME + LIT } ... \" ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" \u274c Session refresh attempt { NAME } exception: { NAME } \" ) if NAME < NAME : NAME . NAME ( f\" Waiting 3s before attempt { NAME + LIT } ... \" ) NAME . NAME ( LIT ) # STEP 4: Post-refresh verification if NAME : NAME . NAME ( LIT ) NAME = NAME . NAME ( ) NAME . NAME ( f\" Post-refresh session valid: { NAME } \" ) if NAME : # Update health monitoring timestamps NAME = NAME . NAME ( ) NAME . NAME [ LIT ] = NAME NAME . NAME [ LIT ] = NAME # Reset browser health monitoring if NAME ( NAME , LIT ) : NAME . NAME [ LIT ] = NAME NAME . NAME [ LIT ] = NAME NAME . NAME [ LIT ] = LIT NAME . NAME [ LIT ] = LIT NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" \u2705 ENHANCED proactive session refresh completed successfully in { NAME : .1f } s \" ) # VERIFICATION: Test a simple API call to confirm session works try : NAME . NAME ( LIT ) # This will be caught by health monitoring if it fails NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" \u26a0\ufe0f Post-refresh API test failed: { NAME } \" ) return True NAME . NAME ( LIT ) # Minimal guard: still update last_proactive_refresh to prevent immediate re-trigger NAME . NAME [ LIT ] = NAME . NAME ( ) return False NAME . NAME ( LIT ) # Minimal guard: update last_proactive_refresh so next page doesn't immediately re-trigger NAME . NAME [ LIT ] = NAME . NAME ( ) return False except NAME as NAME : NAME . NAME ( f\" \u274c Enhanced proactive session refresh failed with exception: { NAME } \" ) NAME . NAME ( f\" Exception type: { NAME ( NAME ) . NAME } \" ) NAME . NAME ( f\" Exception details: { NAME ! NAME } \" ) return False finally : NAME . NAME [ LIT ] . NAME ( ) NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" \ud83d\udd04 Proactive refresh completed in { NAME : .1f } s \" )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.should_proactive_browser_refresh",
      "lineno": 1129,
      "end_lineno": 1169,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 7,
      "yield_count": 0,
      "complexity": 7,
      "loc": 41,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "ea9a206ddf7f6b448cce8cd59b0f643b35169da2",
      "simhash64": 7488180023047140355,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) # Don't refresh if already in progress if NAME . NAME [ LIT ] . NAME ( ) : return False # ENHANCEMENT: Perform browser health pre-check first NAME = NAME . NAME ( ) if NAME == LIT : NAME . NAME ( LIT ) return True if NAME == LIT : NAME . NAME ( LIT ) return False # If \"healthy_allow_refresh\", continue with normal time/page-based checks # Check if browser is approaching max age NAME = NAME - NAME . NAME [ LIT ] if NAME >= NAME . NAME [ LIT ] : NAME . NAME ( f\" \ud83d\udd04 Browser age ( { NAME : .0f } s) approaching limit - proactive browser refresh needed \" ) return True # Check if enough time has passed since last browser refresh NAME = NAME - NAME . NAME [ LIT ] if NAME >= NAME . NAME [ LIT ] : NAME . NAME ( f\" \ud83d\udd04 Time since last browser refresh ( { NAME : .0f } s) - proactive refresh needed \" ) return True # Check if too many pages processed since last refresh NAME = NAME . NAME [ LIT ] if NAME >= NAME . NAME [ LIT ] : NAME . NAME ( f\" \ud83d\udd04 Pages since last refresh ( { NAME } ) - proactive browser refresh needed \" ) return True return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._browser_health_precheck",
      "lineno": 1171,
      "end_lineno": 1250,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 12,
      "yield_count": 0,
      "complexity": 19,
      "loc": 80,
      "tags": [
        "pure-ish",
        "time",
        "regex",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "09f5945ce2b6750080e4c233f23aa92caba85a53",
      "simhash64": 8641101527578489859,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : # Check 1: Basic browser session validity if not NAME . NAME . NAME ( ) : NAME . NAME ( LIT ) return LIT # Check 2: Test basic browser responsiveness try : NAME = NAME . NAME . NAME if not NAME or LIT in NAME : NAME . NAME ( LIT ) return LIT except NAME as NAME : NAME . NAME ( f\" \ud83d\udd0d Browser health check: URL access failed - immediate refresh needed: { NAME } \" ) return LIT # Check 3: Test cookie access (this was the failing operation in the error logs) try : NAME = NAME . NAME . NAME ( ) if not NAME ( NAME , NAME ) : NAME . NAME ( LIT ) return LIT except NAME as NAME : NAME . NAME ( f\" \ud83d\udd0d Browser health check: Cookie retrieval failed - immediate refresh needed: { NAME } \" ) return LIT # Check 4: Verify we're on the correct domain try : NAME = NAME . NAME . NAME if NAME and not NAME . NAME ( NAME ) : NAME . NAME ( f\" \ud83d\udd0d Browser health check: Wrong domain ( { NAME } ) - refresh needed \" ) return LIT except NAME : pass # Non-critical check # Check 5: Test JavaScript execution capability try : NAME = NAME . NAME . NAME ( LIT ) if NAME != LIT : NAME . NAME ( f\" \ud83d\udd0d Browser health check: Page not ready ( { NAME } ) - refresh needed \" ) return LIT except NAME as NAME : NAME . NAME ( f\" \ud83d\udd0d Browser health check: JavaScript execution failed - refresh needed: { NAME } \" ) return LIT # Check 6: Verify browser process is still running (if possible) try : if NAME ( NAME . NAME , LIT ) and NAME ( NAME . NAME . NAME , LIT ) : if not NAME . NAME . NAME . NAME ( ) : NAME . NAME ( LIT ) return LIT except NAME : pass # Non-critical check # Check 7: Assess if browser is very healthy and refresh can be skipped NAME = NAME . NAME ( ) NAME = NAME - NAME . NAME [ LIT ] NAME = NAME . NAME [ LIT ] # If browser is very young and hasn't processed many pages, skip refresh if NAME < LIT and NAME < LIT : # Less than 10 minutes and 10 pages NAME . NAME ( LIT ) return LIT # All health checks passed - browser is healthy but allow refresh based on other criteria NAME . NAME ( LIT ) return LIT except NAME as NAME : NAME . NAME ( f\" \ud83d\udd0d Browser health check failed with exception - immediate refresh needed: { NAME } \" ) return LIT"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.perform_proactive_browser_refresh",
      "lineno": 1252,
      "end_lineno": 1339,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 13,
      "loc": 88,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "064541f53673b20e471dd6dbfb31f7f05353e46a",
      "simhash64": 7452151225961067539,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if NAME . NAME [ LIT ] . NAME ( ) : NAME . NAME ( LIT ) return True NAME = LIT NAME = NAME . NAME ( ) # Thread safety now handled by BrowserManager master lock try : NAME . NAME [ LIT ] . NAME ( ) # Also mark session-level refresh to suppress transient death detection if LIT in NAME . NAME : NAME . NAME [ LIT ] . NAME ( ) NAME . NAME ( LIT ) for NAME in NAME ( LIT , NAME + LIT ) : NAME . NAME ( f\" \ud83d\udd04 Browser refresh attempt { NAME } / { NAME } ... \" ) try : # CRITICAL FIX: Use atomic browser replacement instead of close\u2192sleep\u2192start NAME . NAME ( f\" \ud83d\udd04 Attempting atomic browser replacement (attempt { NAME } ) \" ) NAME = NAME . NAME ( f\" Proactive Refresh - Attempt { NAME } \" ) if NAME : # Warm-up sequence to ensure cookies and CSRF are populated try : from NAME import NAME NAME ( NAME . NAME . NAME , NAME . NAME . NAME ) # Prefer built-in CSRF retrieval/precache to avoid attribute errors NAME = NAME . NAME ( ) NAME = NAME . NAME ( ) NAME ( NAME . NAME . NAME , f\" { NAME . NAME . NAME } family-tree/trees \" ) except NAME as NAME : NAME . NAME ( f\" Warm-up sequence encountered a non-fatal issue: { NAME } \" ) # Perform full session readiness check (validator will relax cookie rule during refresh) NAME = NAME . NAME ( f\" Browser Refresh Verification - Attempt { NAME } \" ) if NAME : # Update browser health tracking NAME = NAME . NAME ( ) NAME . NAME [ LIT ] = NAME NAME . NAME [ LIT ] = NAME NAME = NAME . NAME [ LIT ] NAME . NAME [ LIT ] = LIT NAME = NAME - NAME NAME . NAME ( f\" \ud83d\udd04 Browser page count RESET: { NAME } \u2192 0 (atomic_browser_replacement) \" ) NAME . NAME ( f\" \u2705 Proactive browser refresh completed successfully in { NAME : .1f } s (attempt { NAME } ) \" ) # Clear refresh flag on success if LIT in NAME . NAME : NAME . NAME [ LIT ] . NAME ( ) return True NAME . NAME ( f\" \u274c Browser refresh attempt { NAME } : Session readiness check failed \" ) else : NAME . NAME ( f\" \u274c Browser refresh attempt { NAME } : Atomic browser replacement failed \" ) except NAME as NAME : NAME . NAME ( f\" \u274c Browser refresh attempt { NAME } exception: { NAME } \" ) finally : # Ensure flag is cleared if we exit attempts without success if NAME == NAME : if LIT in NAME . NAME : NAME . NAME [ LIT ] . NAME ( ) # Wait before next attempt (except on last attempt) if NAME < NAME : NAME = NAME * LIT # Progressive backoff: 2s, 4s NAME . NAME ( f\" \u23f3 Waiting { NAME } s before attempt { NAME + LIT } ... \" ) NAME . NAME ( NAME ) # All attempts failed NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" \u274c All { NAME } browser refresh attempts failed after { NAME : .1f } s \" ) return False except NAME as NAME : NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" \u274c Proactive browser refresh failed with exception after { NAME : .1f } s: { NAME } \" ) return False finally : NAME . NAME [ LIT ] . NAME ( )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._atomic_browser_replacement",
      "lineno": 1341,
      "end_lineno": 1421,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 9,
      "loc": 81,
      "tags": [
        "pure-ish",
        "logging",
        "size:medium"
      ],
      "signature": "(self, action_name)",
      "fingerprint": "e2ac57c52d418e454165a6b5dabab0f40a4b3054",
      "simhash64": 7488144838607942675,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME : LIT NAME . NAME ( f\" \ud83d\udd04 Starting TRUE atomic browser replacement for: { NAME } \" ) # Use master browser lock to ensure atomic operation with NAME . NAME . NAME : # Step 1: Backup current browser state for rollback NAME = NAME . NAME NAME = NAME . NAME ( ) # Step 2: Check memory usage before creating new browser if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False # Step 3: Create new browser manager instance from NAME . NAME import NAME NAME = NAME ( ) try : # Step 4: Initialize new browser NAME . NAME ( LIT ) NAME = NAME . NAME ( NAME ) if not NAME : NAME . NAME ( LIT ) return False # Step 5: Comprehensive session continuity verification if not NAME . NAME ( NAME , NAME ) : NAME . NAME ( LIT ) NAME . NAME ( ) return False # Step 6: Atomically replace old browser with new one NAME . NAME ( LIT ) # CRITICAL: This is the only point where the browser reference changes # All validation must be complete before this line NAME . NAME = NAME # Step 7: Verify replacement was successful with final validation if not NAME . NAME ( ) : NAME . NAME ( LIT ) # This is a critical failure - we can't rollback safely at this point # Log extensively for debugging NAME . NAME ( LIT ) return False # Step 8: Clean up old browser safely (only after successful replacement) try : NAME . NAME ( ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" \u26a0\ufe0f Error closing old browser (non-critical): { NAME } \" ) NAME . NAME ( f\" \u2705 TRUE atomic browser replacement completed successfully for: { NAME } \" ) return True except NAME as NAME : NAME . NAME ( f\" \u274c Atomic browser replacement failed: { NAME } \" ) # ROLLBACK: Restore original browser state NAME . NAME ( LIT ) NAME . NAME = NAME NAME . NAME ( NAME ) # Clean up new browser if something went wrong with NAME . NAME ( NAME ) : NAME . NAME ( ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._capture_session_state",
      "lineno": 1423,
      "end_lineno": 1437,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "db139fb0befd473218830211387b53762bb3b93a",
      "simhash64": 7456232614197105707,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : NAME = { LIT : NAME . NAME . NAME ( LIT ) , LIT : NAME . NAME . NAME ( LIT ) , LIT : NAME . NAME . NAME ( LIT ) , LIT : NAME ( NAME , LIT , False ) , LIT : NAME ( NAME , LIT , LIT ) , } NAME . NAME ( LIT ) return NAME except NAME as NAME : NAME . NAME ( f\" Failed to capture session state: { NAME } \" ) return { }"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._restore_session_state",
      "lineno": 1439,
      "end_lineno": 1450,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 12,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self, state)",
      "fingerprint": "62f38d120ef6a0460d99b07ad2d3feb7a290ecff",
      "simhash64": 7451588276074755075,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT try : if NAME : NAME . NAME [ LIT ] = NAME . NAME ( LIT , NAME . NAME ( ) ) NAME . NAME [ LIT ] = NAME . NAME ( LIT , LIT ) NAME . NAME [ LIT ] = NAME . NAME ( LIT , NAME . NAME ( ) ) NAME . NAME = NAME . NAME ( LIT , False ) NAME . NAME = NAME . NAME ( LIT , LIT ) NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" Failed to restore session state: { NAME } \" )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._check_memory_availability",
      "lineno": 1452,
      "end_lineno": 1471,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 3,
      "loc": 20,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "f368b0e469c10894322b31bbf46ae70fcef44446",
      "simhash64": 7488355944840467995,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : import NAME NAME = NAME . NAME ( ) NAME = NAME . NAME / ( LIT * LIT ) # Require at least 500MB available memory for browser replacement if NAME < LIT : NAME . NAME ( f\" Low memory: { NAME : .1f } MB available, need 500MB minimum \" ) return False NAME . NAME ( f\" Memory check passed: { NAME : .1f } MB available \" ) return True except NAME : NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" Memory check failed: { NAME } \" ) return True # Allow operation if check fails"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._verify_session_continuity",
      "lineno": 1473,
      "end_lineno": 1531,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 10,
      "yield_count": 0,
      "complexity": 13,
      "loc": 59,
      "tags": [
        "pure-ish",
        "regex",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, new_browser_manager, old_browser_manager)",
      "fingerprint": "6554e8b0850d37e77695e7affa5f406c2c0775b3",
      "simhash64": 7488215207352120323,
      "normalized": "def NAME ( NAME , NAME , NAME ) -> NAME : LIT try : NAME . NAME ( LIT ) # Test 1: Basic browser functionality if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False # Test 2: Navigation capability try : from NAME import NAME NAME = NAME . NAME . NAME if NAME : NAME = NAME ( NAME . NAME , NAME ) if not NAME : NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" \u274c Navigation test failed: { NAME } \" ) return False # Test 3: Cookie access (the original failing operation) try : NAME = NAME . NAME . NAME ( ) if not NAME ( NAME , NAME ) : NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" \u274c Cookie access test failed: { NAME } \" ) return False # Test 4: JavaScript execution try : NAME = NAME . NAME . NAME ( LIT ) if NAME != LIT : NAME . NAME ( f\" \u274c JavaScript execution test failed: { NAME } \" ) return False except NAME as NAME : NAME . NAME ( f\" \u274c JavaScript test failed: { NAME } \" ) return False # Test 5: Authentication state verification (if possible) try : # Check if we're on the correct domain and not redirected to login NAME = NAME . NAME . NAME if NAME and LIT in NAME . NAME ( ) : NAME . NAME ( LIT ) return False except NAME : pass # Non-critical test NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" \u274c Session continuity verification failed: { NAME } \" ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._verify_replacement_success",
      "lineno": 1533,
      "end_lineno": 1563,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 6,
      "loc": 31,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "bbc72727f3e18af10d2d0741be97752b9c8b3532",
      "simhash64": 7487652257398699011,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : NAME . NAME ( LIT ) # Verify the new browser manager is properly assigned if not NAME . NAME : NAME . NAME ( LIT ) return False # Verify the browser is still valid if not NAME . NAME . NAME ( ) : NAME . NAME ( LIT ) return False # Test critical operation that was originally failing try : NAME = NAME . NAME . NAME . NAME ( ) if not NAME ( NAME , NAME ) : NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" \u274c Post-replacement cookie test failed: { NAME } \" ) return False NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" \u274c Replacement success verification failed: { NAME } \" ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.check_automatic_intervention",
      "lineno": 1565,
      "end_lineno": 1627,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 6,
      "loc": 63,
      "tags": [
        "pure-ish",
        "time",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "31f3fae80f6b5fe43fc3b1b003f6ebe71d82d8b9",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : # Get health monitor instance from NAME import NAME NAME = NAME ( ) # Check for emergency halt if NAME . NAME ( ) : NAME = NAME . NAME ( ) NAME = NAME [ LIT ] NAME . NAME ( LIT ) NAME . NAME ( f\" Reason: { NAME [ LIT ] } \" ) NAME . NAME ( f\" Triggered: { NAME . NAME ( NAME [ LIT ] ) } \" ) # Set session death flag to halt all operations NAME . NAME [ LIT ] . NAME ( ) NAME . NAME [ LIT ] = NAME . NAME ( ) NAME . NAME [ LIT ] = f\" Automatic Emergency Halt: { NAME [ LIT ] } \" return True # Check for immediate intervention if NAME . NAME ( ) : NAME = NAME . NAME ( ) NAME = NAME [ LIT ] NAME . NAME ( LIT ) NAME . NAME ( f\" Reason: { NAME [ LIT ] } \" ) NAME . NAME ( f\" Triggered: { NAME . NAME ( NAME [ LIT ] ) } \" ) NAME . NAME ( LIT ) # Attempt proactive browser refresh NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) # Escalate to emergency halt NAME . NAME [ LIT ] . NAME ( ) NAME . NAME [ LIT ] = NAME . NAME ( ) NAME . NAME [ LIT ] = f\" Failed Recovery: { NAME [ LIT ] } \" return True NAME . NAME ( LIT ) # Reset immediate intervention flag after successful recovery NAME . NAME = False return False # Check for enhanced monitoring if NAME . NAME ( ) : NAME = NAME . NAME ( ) NAME = NAME [ LIT ] NAME . NAME ( f\" \ud83d\udcca Enhanced monitoring active: { NAME [ LIT ] } \" ) # Enhanced monitoring doesn't halt processing, just increases surveillance return False return False except NAME as NAME : NAME . NAME ( f\" Failed to check automatic intervention: { NAME } \" ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.increment_page_count",
      "lineno": 1629,
      "end_lineno": 1634,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5f825bbf24dcb12bca48e9591f308080b6167e75",
      "simhash64": 7452151225961067539,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME = NAME . NAME [ LIT ] NAME . NAME [ LIT ] += LIT NAME = NAME . NAME [ LIT ] NAME . NAME ( f\" \ud83d\udd22 Page count incremented: { NAME } \u2192 { NAME } \" )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.check_browser_health",
      "lineno": 1636,
      "end_lineno": 1651,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 16,
      "tags": [
        "pure-ish",
        "time",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "82da3b4b5f84a20582ba1f3c6d31898c22e91660",
      "simhash64": 7488180023047140355,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) NAME . NAME [ LIT ] = NAME # Check if browser is needed if not NAME . NAME . NAME : return True # Check if driver exists and is responsive if not NAME . NAME . NAME ( ) : NAME . NAME [ LIT ] += LIT NAME . NAME ( f\" \ud83d\udea8 Browser death detected (count: { NAME . NAME [ LIT ] } ) \" ) return False return True"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.attempt_browser_recovery",
      "lineno": 1653,
      "end_lineno": 1682,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 30,
      "tags": [
        "pure-ish",
        "time",
        "regex",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "49bc3fdd881c6b03f3554712712800a130e0d763",
      "simhash64": 7488180023047140355,
      "normalized": "def NAME ( NAME ) -> NAME : LIT try : NAME . NAME ( LIT ) # Use atomic browser replacement for recovery NAME = NAME . NAME ( LIT ) if NAME : # Re-authenticate if needed from NAME import NAME NAME = NAME ( NAME , NAME = False ) if NAME : # Reset browser health timers NAME = NAME . NAME ( ) NAME . NAME [ LIT ] = NAME NAME . NAME [ LIT ] = NAME NAME . NAME [ LIT ] = LIT NAME . NAME ( LIT ) return True NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" \u274c Browser recovery failed with exception: { NAME } \" ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._reset_logged_flags",
      "lineno": 1684,
      "end_lineno": 1689,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 6,
      "tags": [
        "pure-ish",
        "logging",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "bb7eac9a9ab8db6e41c5bf96300a9124f51dc59f",
      "simhash64": 16675489727778305107,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = False NAME . NAME = False NAME . NAME = False NAME . NAME = False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._retrieve_identifiers",
      "lineno": 1691,
      "end_lineno": 1732,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 10,
      "loc": 42,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "e2ec74d7d4673c3b3eba8db0fa1f39e00f14b51a",
      "simhash64": 8623122313449485331,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False NAME = True # Get Profile ID if not NAME . NAME : NAME . NAME ( LIT ) NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) NAME = False # Get UUID if not NAME . NAME : NAME . NAME ( LIT ) NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( LIT ) NAME = False # Get Tree ID (only if TREE_NAME is configured) if NAME . NAME . NAME and not NAME . NAME : NAME . NAME ( f\" Retrieving tree ID for tree name: ' { NAME . NAME . NAME } '... \" ) try : NAME = NAME . NAME ( ) if not NAME : NAME . NAME ( f\" TREE_NAME ' { NAME . NAME . NAME } ' configured, but failed to get corresponding tree ID. \" ) NAME = False except NAME as NAME : NAME . NAME ( f\" Failed to retrieve tree ID due to import error: { NAME } \" ) NAME = False return NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._retrieve_tree_owner",
      "lineno": 1734,
      "end_lineno": 1759,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 6,
      "loc": 26,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "1582f5cc18094ec99c0341f0e065fafc7c193dbd",
      "simhash64": 8640538577633453059,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False if not NAME . NAME : NAME . NAME ( LIT ) return False # Only retrieve if not already present if NAME . NAME and NAME . NAME : return True NAME . NAME ( LIT ) try : NAME = NAME . NAME ( NAME . NAME ) return NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Failed to retrieve tree owner due to import error: { NAME } \" ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.get_cookies",
      "lineno": 1761,
      "end_lineno": 1852,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 17,
      "loc": 92,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self, cookie_names, timeout)",
      "fingerprint": "0b64174aa9b52426ef6521f62ddacd312ede052b",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] , NAME : NAME = LIT ) -> NAME : LIT if not NAME . NAME : NAME . NAME ( LIT ) return False # Skip is_sess_valid() check here to prevent circular recursion NAME = NAME . NAME ( ) NAME . NAME ( f\" Waiting up to { NAME } s for cookies: { NAME } ... \" ) NAME = { NAME . NAME ( ) for NAME in NAME } NAME = LIT NAME = LIT while NAME . NAME ( ) - NAME < NAME : try : # Basic driver check (avoid is_sess_valid() to prevent recursion) if not NAME . NAME : NAME . NAME ( LIT ) return False NAME = NAME . NAME . NAME ( ) NAME = { NAME [ LIT ] . NAME ( ) for NAME in NAME if NAME ( NAME , NAME ) and LIT in NAME } NAME = NAME - NAME if not NAME : NAME . NAME ( f\" All required cookies found: { NAME } . \" ) # Skip automatic cookie sync to prevent recursion # Cookie syncing will be handled elsewhere when needed return True # Log missing cookies only if the set changes NAME = LIT . NAME ( NAME ( NAME ) ) if NAME != NAME : NAME . NAME ( f\" Still missing cookies: { NAME } \" ) NAME = NAME NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" WebDriverException while retrieving cookies: { NAME } \" ) # Check if session died due to the exception if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False # If session still valid, wait a bit longer before next try NAME . NAME ( NAME * LIT ) except NAME as NAME : NAME . NAME ( f\" Unexpected error during cookie retrieval: { NAME } \" ) NAME . NAME ( NAME * LIT ) # Final check after timeout NAME = [ ] try : if NAME . NAME ( ) : NAME = NAME . NAME . NAME ( ) NAME = { NAME [ LIT ] . NAME ( ) for NAME in NAME if NAME ( NAME , NAME ) and LIT in NAME } NAME = [ NAME for NAME in NAME if NAME . NAME ( ) not in NAME ] else : NAME = NAME except NAME : NAME = NAME if NAME : NAME . NAME ( f\" Timeout waiting for cookies. Missing: { NAME } . \" ) return False NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._sync_cookies_to_requests",
      "lineno": 1854,
      "end_lineno": 1887,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 9,
      "loc": 34,
      "tags": [
        "impure",
        "network",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "c768fbb73d8e12b3aa21db916cdf7fe21be3d2b8",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME ) -> None : LIT if not NAME . NAME or not NAME ( NAME . NAME , LIT ) : return # Check if already synced for this session if NAME ( NAME , LIT ) and NAME . NAME : return try : # Get cookies from WebDriver NAME = NAME . NAME . NAME ( ) # Clear existing cookies in requests session NAME . NAME . NAME . NAME . NAME ( ) # Sync cookies from driver to requests session NAME = LIT for NAME in NAME : if NAME ( NAME , NAME ) and LIT in NAME and LIT in NAME : NAME . NAME . NAME . NAME . NAME ( NAME [ LIT ] , NAME [ LIT ] , NAME = NAME . NAME ( LIT ) , NAME = NAME . NAME ( LIT , LIT ) ) NAME += LIT NAME . NAME = True NAME . NAME ( f\" Synced { NAME } cookies from WebDriver to requests session (once per session) \" ) except NAME as NAME : NAME . NAME ( f\" Failed to sync cookies to requests session: { NAME } \" )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.force_cookie_resync",
      "lineno": 1889,
      "end_lineno": 1894,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 6,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "d12a4ae31872aed34e3663c5061a3d062252242e",
      "simhash64": 8640714504863650859,
      "normalized": "def NAME ( NAME ) -> None : LIT if NAME ( NAME , LIT ) : NAME ( NAME , LIT ) NAME . NAME ( ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._sync_cookies",
      "lineno": 1896,
      "end_lineno": 1947,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 13,
      "loc": 52,
      "tags": [
        "impure",
        "network",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "4adb030244b56494ca600ed1211161c5cbe4823d",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME ) -> None : LIT # Recursion guard to prevent infinite loops if NAME ( NAME , LIT ) and NAME . NAME : NAME . NAME ( LIT ) return if not NAME . NAME : return if not NAME ( NAME . NAME , LIT ) or not NAME . NAME . NAME : return try : # Set recursion guard NAME . NAME = True # Simple cookie retrieval without any validation NAME = NAME . NAME . NAME ( ) if not NAME : return # Clear and sync cookies NAME . NAME . NAME . NAME . NAME ( ) NAME = LIT for NAME in NAME : if NAME ( NAME , NAME ) and LIT in NAME and LIT in NAME : try : NAME . NAME . NAME . NAME . NAME ( NAME [ LIT ] , NAME [ LIT ] , NAME = NAME . NAME ( LIT ) , NAME = NAME . NAME ( LIT , LIT ) ) NAME += LIT except NAME : continue # Skip problematic cookies silently NAME . NAME ( f\" Synced { NAME } cookies to requests session \" ) except NAME as NAME : NAME . NAME ( f\" Cookie sync failed: { NAME } \" ) return finally : # Clear recursion guard if NAME ( NAME , LIT ) : NAME . NAME = False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.check_js_errors",
      "lineno": 1951,
      "end_lineno": 2004,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 10,
      "loc": 54,
      "tags": [
        "pure-ish",
        "time",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "b9141472d61afc54ccf5430c270dff1c53549af2",
      "simhash64": 7452151226028176419,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME [ NAME , NAME ] ] : LIT if not NAME . NAME or not NAME . NAME : return [ ] try : # Get browser logs (if available) if NAME ( NAME . NAME , LIT ) : # Type: ignore to handle dynamic method availability NAME = NAME . NAME . NAME ( LIT ) # type: ignore else : NAME . NAME ( LIT ) return [ ] # Filter for errors that occurred after last check NAME = NAME . NAME ( NAME . NAME ) NAME = [ ] for NAME in NAME : # Check if this is a JavaScript error if NAME . NAME ( LIT ) in [ LIT , LIT ] : # Parse timestamp (browser logs use milliseconds since epoch) NAME = NAME . NAME ( NAME . NAME ( LIT , LIT ) / LIT , NAME = NAME . NAME ) # Only include errors since last check if NAME > NAME . NAME : NAME . NAME ( { LIT : NAME , LIT : NAME . NAME ( LIT ) , LIT : NAME . NAME ( LIT , LIT ) , LIT : NAME . NAME ( LIT , LIT ) } ) # Update last check time NAME . NAME = NAME if NAME : NAME . NAME ( f\" Found { NAME ( NAME ) } JavaScript errors since last check \" ) for NAME in NAME : NAME . NAME ( f\" JS Error: { NAME [ LIT ] } \" ) return NAME except NAME as NAME : NAME . NAME ( f\" Failed to check JavaScript errors: { NAME } \" ) return [ ]"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.monitor_js_errors",
      "lineno": 2006,
      "end_lineno": 2027,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 22,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "7a8a2ca15a4ed6a8d09c4b8d3bbbf11d9ab5738b",
      "simhash64": 7488180023047140411,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME ( ) # Count critical errors (those that might affect functionality) NAME = [ NAME for NAME in NAME if NAME ( NAME in NAME [ LIT ] . NAME ( ) for NAME in [ LIT , LIT , LIT , LIT ] ) ] if NAME : NAME . NAME ( f\" Found { NAME ( NAME ) } critical JavaScript errors \" ) return False return True"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.restart_sess",
      "lineno": 2029,
      "end_lineno": 2073,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 7,
      "loc": 45,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, url)",
      "fingerprint": "6e871bca4946bc4dfb6c0196b6896e6204681208",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME : NAME [ NAME ] = None ) -> NAME : LIT NAME . NAME ( LIT ) # Close current session NAME . NAME ( NAME = True ) # Start new session if not NAME . NAME ( LIT ) : NAME . NAME ( LIT ) return False # Ensure session is ready if not NAME . NAME ( LIT ) : NAME . NAME ( LIT ) NAME . NAME ( NAME = True ) return False # Navigate to URL if provided if NAME and NAME . NAME . NAME : NAME . NAME ( f\" Navigating to: { NAME } \" ) try : from NAME import NAME NAME = NAME ( NAME . NAME . NAME , NAME , NAME = LIT , NAME = NAME , # type: ignore ) if not NAME : NAME . NAME ( f\" Failed to navigate to { NAME } after restart. \" ) else : NAME . NAME ( f\" Successfully navigated to { NAME } . \" ) except NAME as NAME : NAME . NAME ( f\" Error navigating to { NAME } after restart: { NAME } \" ) NAME . NAME ( LIT ) return True"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.close_sess",
      "lineno": 2075,
      "end_lineno": 2098,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 24,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "(self, keep_db)",
      "fingerprint": "797978c6d5b4180b45c17bd436d29cb2476d372f",
      "simhash64": 7488215207419229203,
      "normalized": "def NAME ( NAME , NAME : NAME = False ) : LIT NAME . NAME ( f\" Closing session (keep_db= { NAME } ) \" ) # Close browser NAME . NAME ( ) # Close database connections if requested if not NAME : NAME . NAME . NAME ( NAME = True ) # Clear API identifiers NAME . NAME . NAME ( ) # Reset session state NAME . NAME = False NAME . NAME = None NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.get_csrf",
      "lineno": 2103,
      "end_lineno": 2150,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 8,
      "loc": 48,
      "tags": [
        "impure",
        "network",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "a102fba8f2a880e563d8f4ed9b09dd0668f7dde7",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT if not NAME . NAME ( ) : NAME . NAME ( LIT ) return None from NAME . NAME import NAME NAME = NAME ( NAME . NAME . NAME , LIT ) NAME . NAME ( f\" Attempting to fetch fresh CSRF token from: { NAME } \" ) # Check essential cookies NAME = [ LIT , LIT ] if not NAME . NAME ( NAME , NAME = LIT ) : NAME . NAME ( f\" Essential cookies { NAME } NOT found before CSRF token API call. \" ) try : # Import _api_req locally to avoid circular imports from NAME import NAME NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = False , NAME = LIT , NAME = True , ) if NAME and NAME ( NAME , NAME ) : NAME = NAME . NAME ( ) if NAME and NAME ( NAME ) > LIT : NAME . NAME ( f\" CSRF token successfully retrieved (Length: { NAME ( NAME ) } ). \" ) NAME . NAME . NAME = NAME return NAME NAME . NAME ( f\" CSRF token API returned empty or invalid string: ' { NAME } ' \" ) return None NAME . NAME ( LIT ) return None except NAME as NAME : NAME . NAME ( f\" Unexpected error in get_csrf: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.get_my_profile_id",
      "lineno": 2153,
      "end_lineno": 2202,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 9,
      "loc": 50,
      "tags": [
        "impure",
        "network",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "d0de4b992c61f867de1fed1f8f59085d78c4e884",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT if not NAME . NAME ( ) : NAME . NAME ( LIT ) return None from NAME . NAME import NAME NAME = NAME ( NAME . NAME . NAME , LIT ) NAME . NAME ( LIT ) try : from NAME import NAME NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = False , NAME = LIT , ) if not NAME : NAME . NAME ( LIT ) return None if NAME ( NAME , NAME ) and LIT in NAME : NAME = NAME [ LIT ] if NAME ( NAME , NAME ) and LIT in NAME : NAME = NAME ( NAME [ LIT ] ) . NAME ( ) NAME . NAME ( f\" Successfully retrieved profile_id: { NAME } \" ) # Store in API manager NAME . NAME . NAME = NAME if not NAME . NAME : NAME . NAME ( f\" My profile id: { NAME } \" ) NAME . NAME = True return NAME NAME . NAME ( LIT ) return None NAME . NAME ( f\" Unexpected response format for profile_id API: { NAME ( NAME ) } \" ) return None except NAME as NAME : NAME . NAME ( f\" Unexpected error in get_my_profileId: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.get_my_uuid",
      "lineno": 2205,
      "end_lineno": 2252,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 9,
      "loc": 48,
      "tags": [
        "impure",
        "network",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "959c0958c9c6ce7161fce716b7456542b608b7e0",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT if not NAME . NAME ( ) : # Reduce log spam during shutdown - only log once per minute if not NAME ( NAME , LIT ) or NAME . NAME ( ) - NAME . NAME > LIT : NAME . NAME ( LIT ) NAME . NAME = NAME . NAME ( ) return None from NAME . NAME import NAME NAME = NAME ( NAME . NAME . NAME , LIT ) NAME . NAME ( LIT ) try : from NAME import NAME NAME = NAME ( NAME = NAME , NAME = NAME . NAME , NAME = NAME , NAME = LIT , NAME = False , NAME = LIT , ) if NAME and NAME ( NAME , NAME ) : if LIT in NAME : NAME = NAME ( NAME [ LIT ] ) . NAME ( ) NAME . NAME ( f\" Successfully retrieved UUID: { NAME } \" ) # Store in API manager NAME . NAME . NAME = NAME if not NAME . NAME : NAME . NAME ( f\" My uuid: { NAME } \" ) NAME . NAME = True return NAME NAME . NAME ( LIT ) return None NAME . NAME ( LIT ) return None except NAME as NAME : NAME . NAME ( f\" Unexpected error in get_my_uuid: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.get_my_tree_id",
      "lineno": 2255,
      "end_lineno": 2293,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 7,
      "loc": 39,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "a415546c6999b6f40218db3569371b63858e2164",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT try : import NAME as NAME except NAME as NAME : NAME . NAME ( f\" get_my_tree_id: Failed to import api_utils: { NAME } \" ) raise NAME ( f\" api_utils module failed to import: { NAME } \" ) NAME = NAME . NAME . NAME if not NAME : NAME . NAME ( LIT ) return None if not NAME . NAME ( ) : NAME . NAME ( LIT ) return None NAME . NAME ( f\" Delegating tree ID fetch for TREE_NAME=' { NAME } ' to api_utils... \" ) try : NAME = NAME . NAME ( NAME , NAME ) if NAME : # Store in API manager NAME . NAME . NAME = NAME if not NAME . NAME : NAME . NAME ( f\" My tree id: { NAME } \" ) NAME . NAME = True return NAME NAME . NAME ( LIT ) return None except NAME as NAME : NAME . NAME ( f\" Error calling api_utils.call_header_trees_api_for_tree_id: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.get_tree_owner",
      "lineno": 2296,
      "end_lineno": 2338,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 8,
      "loc": 43,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:medium"
      ],
      "signature": "(self, tree_id)",
      "fingerprint": "2df6ba1cc69be1c65097557cb723b9d80c5f45ef",
      "simhash64": 7488180022980023315,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME ] : LIT try : import NAME as NAME except NAME as NAME : NAME . NAME ( f\" get_tree_owner: Failed to import api_utils: { NAME } \" ) raise NAME ( f\" api_utils module failed to import: { NAME } \" ) if not NAME : NAME . NAME ( LIT ) return None if not NAME ( NAME , NAME ) : NAME . NAME ( f\" Invalid tree_id type provided: { NAME ( NAME ) } . Expected string. \" ) return None if not NAME . NAME ( ) : NAME . NAME ( LIT ) return None NAME . NAME ( f\" Delegating tree owner fetch for tree ID { NAME } to api_utils... \" ) try : NAME = NAME . NAME ( NAME , NAME ) if NAME : # Store in API manager NAME . NAME . NAME = NAME if not NAME . NAME : NAME . NAME ( f\" Tree owner name: { NAME } \\n \" ) NAME . NAME = True return NAME NAME . NAME ( LIT ) return None except NAME as NAME : NAME . NAME ( f\" Error calling api_utils.call_tree_owner_api: { NAME } \" , NAME = True ) return None"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.get_db_conn",
      "lineno": 2341,
      "end_lineno": 2343,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "acdbe680b38da357be64dd3404bac91a19507fbf",
      "simhash64": 7487652257398694915,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME . NAME ( )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.return_session",
      "lineno": 2345,
      "end_lineno": 2347,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self, session)",
      "fingerprint": "c2664991185302329ef95477bb2bd28562c3caf0",
      "simhash64": 7488180024053769219,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : LIT NAME . NAME . NAME ( NAME )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.get_db_conn_context",
      "lineno": 2349,
      "end_lineno": 2351,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "acdbe680b38da357be64dd3404bac91a19507fbf",
      "simhash64": 7487652257398694915,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME . NAME ( )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.cls_db_conn",
      "lineno": 2353,
      "end_lineno": 2357,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, keep_db)",
      "fingerprint": "b92184da1bb560f5db11a90c977778a3078ca595",
      "simhash64": 7488144838607938643,
      "normalized": "def NAME ( NAME , NAME : NAME = True ) : LIT NAME . NAME . NAME ( NAME = not NAME ) # Browser delegation methods"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.invalidate_csrf_cache",
      "lineno": 2359,
      "end_lineno": 2362,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "3b76e55079b1bb5815598c4ad099489b8c4a9fdd",
      "simhash64": 8605214018952926211,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME = None NAME . NAME = LIT"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.driver",
      "lineno": 2365,
      "end_lineno": 2367,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "23f651e723d9d74d757c722c84c02b731819d537",
      "simhash64": 7488109654235849795,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME . NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.driver_live",
      "lineno": 2370,
      "end_lineno": 2372,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "23f651e723d9d74d757c722c84c02b731819d537",
      "simhash64": 7488109654235849795,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME . NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.make_tab",
      "lineno": 2374,
      "end_lineno": 2376,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "f198af67333f955db36da5c2c8e02b33f9cc3edd",
      "simhash64": 7492155861321024515,
      "normalized": "def NAME ( NAME ) : LIT return NAME . NAME . NAME ( )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.my_profile_id",
      "lineno": 2380,
      "end_lineno": 2386,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "69df6eae3820c20491c27fa581edd05a5c1cd3d2",
      "simhash64": 8641066347778188375,
      "normalized": "def NAME ( NAME ) : LIT # Try to get from API manager first, then retrieve if needed NAME = NAME . NAME . NAME if not NAME : NAME = NAME . NAME ( ) return NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.my_uuid",
      "lineno": 2389,
      "end_lineno": 2395,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "ff719f9aadd58b91ae02562a1a97664ad3c0e117",
      "simhash64": 7488144843171341399,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT # Try to get from API manager first, then retrieve if needed NAME = NAME . NAME . NAME if not NAME : NAME = NAME . NAME ( ) return NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.my_tree_id",
      "lineno": 2398,
      "end_lineno": 2404,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 7,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5432fd2fab132750554cab4b13e19c8f38687022",
      "simhash64": 7488109654504285267,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT # Try to get from API manager first, then retrieve if needed NAME = NAME . NAME . NAME if not NAME and NAME . NAME . NAME : NAME = NAME . NAME ( ) return NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.csrf_token",
      "lineno": 2407,
      "end_lineno": 2416,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 10,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "603badab2d0ed940197f2dbd28e6b206877353b3",
      "simhash64": 7488180022980031569,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT # \u26a1 OPTIMIZATION 1: Check pre-cached CSRF token first if NAME . NAME and NAME . NAME : NAME = NAME . NAME ( ) - NAME . NAME if NAME < NAME . NAME : return NAME . NAME # Return cached token from API manager if available return NAME . NAME . NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._precache_csrf_token",
      "lineno": 2418,
      "end_lineno": 2461,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 10,
      "loc": 44,
      "tags": [
        "impure",
        "network",
        "time",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "9e3387b36813b08ac07ec68d4894cf4f2340c238",
      "simhash64": 7488180023047140371,
      "normalized": "def NAME ( NAME ) -> None : LIT try : if not NAME . NAME or not NAME . NAME . NAME : NAME . NAME ( LIT ) return # Try to get CSRF token from cookies NAME = NAME . NAME . NAME NAME = [ LIT , LIT ] NAME = NAME . NAME ( ) NAME = { NAME [ LIT ] : NAME [ LIT ] for NAME in NAME if NAME ( NAME , NAME ) and LIT in NAME and LIT in NAME } for NAME in NAME : if NAME . NAME ( NAME ) : from NAME . NAME import NAME # CRITICAL FIX: Handle both ^| and | separators in CSRF token NAME = NAME ( NAME [ NAME ] ) if LIT in NAME : NAME = NAME . NAME ( LIT ) [ LIT ] elif LIT in NAME : NAME = NAME . NAME ( LIT ) [ LIT ] else : NAME = NAME # Cache the token NAME . NAME = NAME NAME . NAME = NAME . NAME ( ) NAME . NAME ( f\" \u26a1 Pre-cached CSRF token ' { NAME } ' during session setup (performance optimization) \" ) return NAME . NAME ( LIT ) except NAME as NAME : NAME . NAME ( f\" \u26a1 CSRF pre-cache: Error pre-caching CSRF token: { NAME } \" )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._is_csrf_token_valid",
      "lineno": 2463,
      "end_lineno": 2471,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "8351e8c5d1f32bdaa1b9514f75aec6d5d803a373",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( NAME ) -> NAME : LIT if not NAME . NAME or not NAME . NAME : return False NAME = NAME . NAME ( ) - NAME . NAME return NAME < NAME . NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.tree_owner_name",
      "lineno": 2475,
      "end_lineno": 2477,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "a69226c9413f1c8e2e87c0cd138e693f14b785f6",
      "simhash64": 7488180022980031571,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT return NAME . NAME . NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.requests_session",
      "lineno": 2480,
      "end_lineno": 2482,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "impure",
        "network",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "23f651e723d9d74d757c722c84c02b731819d537",
      "simhash64": 7488109654235849795,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME . NAME . NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.scraper",
      "lineno": 2486,
      "end_lineno": 2488,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "250e8ccd3d2dc8f0d0e4737835f4f73f0f5cb3f7",
      "simhash64": 5181914772311807019,
      "normalized": "def NAME ( NAME ) : LIT return NAME ( NAME , LIT , None )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.scraper",
      "lineno": 2491,
      "end_lineno": 2493,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, value)",
      "fingerprint": "de40b9d25eaac3f272ea79df7a25daa24260907c",
      "simhash64": 7488109655309591635,
      "normalized": "def NAME ( NAME , NAME ) : LIT NAME . NAME = NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.browser_needed",
      "lineno": 2497,
      "end_lineno": 2499,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5483d9bb6555e5399efed966eb5d00ebb98023d5",
      "simhash64": 7492050303909798915,
      "normalized": "def NAME ( NAME ) : LIT return NAME . NAME . NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.browser_needed",
      "lineno": 2502,
      "end_lineno": 2504,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, value)",
      "fingerprint": "0e964fc1c2aa9bdf0276b3f93cc1b69ab3ae6741",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME , NAME : NAME ) : LIT NAME . NAME . NAME = NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._requests_session",
      "lineno": 2509,
      "end_lineno": 2511,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "impure",
        "network",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "5483d9bb6555e5399efed966eb5d00ebb98023d5",
      "simhash64": 7492050303909798915,
      "normalized": "def NAME ( NAME ) : LIT return NAME . NAME . NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.is_ready",
      "lineno": 2514,
      "end_lineno": 2522,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 9,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "e132199a9555d841b29c52d4c583c72673d1ebd5",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( NAME ) -> NAME : LIT NAME = NAME . NAME . NAME NAME = ( not NAME . NAME . NAME or NAME . NAME . NAME ) NAME = NAME . NAME . NAME return NAME and NAME and NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.session_age_seconds",
      "lineno": 2525,
      "end_lineno": 2529,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 2,
      "loc": 5,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "d4ca27f99315e98706854dce312871b9f28fd42f",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME ] : LIT if NAME . NAME : return NAME . NAME ( ) - NAME . NAME return None"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.get_session_performance_stats",
      "lineno": 2532,
      "end_lineno": 2553,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 22,
      "tags": [
        "pure-ish",
        "time",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "d372e95e09c0a2b3dc32c10d14e969ab159e1566",
      "simhash64": 7487617073026610179,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT NAME = NAME ( ) NAME . NAME ( { LIT : NAME . NAME , LIT : NAME . NAME , LIT : ( NAME . NAME ( ) - NAME . NAME if NAME . NAME else None ) , LIT : ( NAME . NAME . NAME if NAME ( NAME . NAME , LIT ) else False ) , LIT : NAME . NAME . NAME , LIT : NAME . NAME . NAME , } ) return NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.process_pages",
      "lineno": 2556,
      "end_lineno": 2630,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 9,
      "yield_count": 0,
      "complexity": 16,
      "loc": 75,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, start_page, end_page)",
      "fingerprint": "23f3aee387c0846eeb0c53e65677205662040b18",
      "simhash64": 7487617073026610179,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME : LIT NAME . NAME ( f\" \ud83d\udcca Starting page processing: { NAME } to { NAME } \" ) NAME = NAME . NAME ( ) try : # Ensure session ready before starting if not NAME . NAME ( LIT , NAME = True ) : NAME . NAME ( LIT ) return False for NAME in NAME ( NAME , NAME + LIT ) : NAME . NAME [ LIT ] = NAME # Check session duration NAME = ( NAME . NAME ( ) - NAME . NAME [ LIT ] ) / LIT if NAME >= NAME . NAME [ LIT ] : NAME . NAME ( LIT ) if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False # Reset timer NAME . NAME [ LIT ] = NAME . NAME ( ) # Proactive browser refresh based on pages if ( NAME . NAME [ LIT ] > LIT and NAME . NAME [ LIT ] % NAME . NAME [ LIT ] == LIT ) : NAME . NAME ( f\" \ud83d\udd04 Restart interval reached at page { NAME } - proactive browser refresh \" ) if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False NAME . NAME [ LIT ] += LIT # Health check before page if not NAME . NAME ( ) : NAME . NAME ( LIT ) if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False # Phase 2: Network and auth pre-checks if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False if not NAME . NAME ( ) : NAME . NAME ( LIT ) if not NAME . NAME ( LIT , NAME ) : NAME . NAME ( LIT ) return False try : NAME = NAME . NAME ( NAME ) NAME . NAME [ LIT ] += LIT NAME . NAME ( f\" \u2705 Page { NAME } processed: { NAME } \" ) except NAME as NAME : NAME . NAME [ LIT ] += LIT NAME , NAME = NAME . NAME ( NAME ) NAME . NAME ( NAME , NAME ) NAME . NAME . NAME ( { LIT : NAME . NAME ( ) , LIT : NAME , LIT : NAME , LIT : NAME } ) NAME . NAME ( f\" \u274c Error processing page { NAME } ( { NAME } ) \u2192 action: { NAME } : { NAME } \" ) if not NAME . NAME ( NAME , NAME ) : NAME . NAME ( LIT ) return False # continue after recovery return True except NAME as NAME : # Record as unknown error for early warning NAME . NAME ( LIT , NAME ) NAME . NAME ( f\" \u274c Unexpected error in page processing: { NAME } \" ) return False finally : NAME = NAME . NAME ( ) - NAME NAME . NAME ( f\" \ud83d\udcca Page processing finished in { NAME : .1f } s \" )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._process_single_page",
      "lineno": 2632,
      "end_lineno": 2636,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 5,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(self, page_num)",
      "fingerprint": "7a3652e04be70489265ddb6e89cd5579439b7b74",
      "simhash64": 7488180024053765219,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : LIT raise NAME ( LIT )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.get_session_summary",
      "lineno": 2638,
      "end_lineno": 2658,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 7,
      "loc": 21,
      "tags": [
        "pure-ish",
        "purpose:factory",
        "purpose:getter",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "5b62892ba171d88f07f807c28f063c0954eb679b",
      "simhash64": 7451588276074755115,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : LIT # Memory/process health via existing methods NAME . NAME ( ) try : import NAME NAME = NAME . NAME ( ) { LIT : LIT if NAME . NAME > LIT * LIT * LIT else LIT , LIT : NAME . NAME / ( LIT * LIT ) , } # Count browser processes NAME = LIT for NAME in NAME . NAME ( [ LIT ] ) : try : if NAME . NAME . NAME ( LIT ) and NAME ( NAME in NAME . NAME [ LIT ] . NAME ( ) for NAME in [ LIT , LIT , LIT ] ) : NAME += LIT except NAME : continue except NAME : pass"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._p2_record_error",
      "lineno": 2660,
      "end_lineno": 2667,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(self, category, error)",
      "fingerprint": "d65c3065bcc229cca73a1fc1f2dfb90509756406",
      "simhash64": 7452151226028176403,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME | None = None ) -> None : NAME = NAME . NAME ( ) NAME = { LIT : NAME , LIT : NAME , LIT : NAME ( NAME ) if NAME else LIT } for NAME in NAME . NAME . NAME ( ) : NAME [ LIT ] . NAME ( NAME ) # prune old NAME = NAME - NAME [ LIT ] NAME [ LIT ] = [ NAME for NAME in NAME [ LIT ] if NAME [ LIT ] >= NAME ]"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._p2_error_rates",
      "lineno": 2669,
      "end_lineno": 2676,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 8,
      "tags": [
        "pure-ish",
        "time",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "2c9b08533ebc82389ce433026c6e84db3496b60c",
      "simhash64": 7488109654302962707,
      "normalized": "def NAME ( NAME ) -> NAME [ NAME , NAME ] : NAME = NAME . NAME ( ) NAME = { } for NAME , NAME in NAME . NAME . NAME ( ) : NAME = NAME - NAME [ LIT ] NAME = NAME ( LIT for NAME in NAME [ LIT ] if NAME [ LIT ] >= NAME ) NAME [ NAME ] = NAME / ( NAME [ LIT ] / LIT ) # per minute return NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._p2_analyze_error",
      "lineno": 2678,
      "end_lineno": 2694,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 4,
      "loc": 17,
      "tags": [
        "impure",
        "network",
        "size:small"
      ],
      "signature": "(self, exc)",
      "fingerprint": "bcdb9bd44e6518a302102ffdb7a595ceb59ead1c",
      "simhash64": 5125619772737623087,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> NAME [ NAME , NAME ] : NAME = NAME ( NAME ) . NAME ( ) # 8 categories mapping NAME : NAME [ NAME [ NAME , NAME [ NAME ] , NAME ] ] = [ ( LIT , [ LIT , LIT , LIT , LIT ] , LIT ) , ( LIT , [ LIT , LIT , LIT ] , LIT ) , ( LIT , [ LIT , LIT , LIT , LIT , LIT ] , LIT ) , ( LIT , [ LIT , LIT , LIT , LIT , LIT ] , LIT ) , ( LIT , [ LIT , LIT , LIT ] , LIT ) , ( LIT , [ LIT , LIT , LIT , LIT , LIT , LIT , LIT ] , LIT ) , ( LIT , [ LIT , LIT , LIT , LIT , LIT ] , LIT ) , ( LIT , [ LIT , LIT , LIT , LIT ] , LIT ) , ] for NAME , NAME , NAME in NAME : if NAME ( NAME in NAME for NAME in NAME ) : return NAME , NAME return LIT , LIT"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._p2_apply_action",
      "lineno": 2696,
      "end_lineno": 2734,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 13,
      "yield_count": 0,
      "complexity": 15,
      "loc": 39,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "(self, action, page_num)",
      "fingerprint": "fdaaed0ad36141e637206ac0243f8f24f93b6870",
      "simhash64": 7487617073026610179,
      "normalized": "def NAME ( NAME , NAME : NAME , NAME : NAME ) -> NAME : if NAME == LIT : NAME . NAME ( LIT ) return True if NAME == LIT : NAME . NAME ( LIT ) return True if NAME == LIT : NAME = NAME ( LIT , LIT + NAME . NAME [ LIT ] * LIT ) NAME . NAME ( NAME ) return True if NAME == LIT : return NAME . NAME ( ) if NAME == LIT : NAME . NAME ( LIT ) return True if NAME == LIT : try : return NAME . NAME ( ) except NAME : return False if NAME == LIT : try : if NAME . NAME and NAME . NAME . NAME : NAME . NAME . NAME . NAME ( ) return True except NAME : return False if NAME == LIT : try : # attempt login refresh from NAME import NAME , NAME NAME = NAME ( NAME , NAME = False ) if NAME is True : return True return NAME ( NAME ) except NAME : return False return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._p2_network_resilience_wait",
      "lineno": 2736,
      "end_lineno": 2752,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 6,
      "loc": 17,
      "tags": [
        "impure",
        "network",
        "time",
        "size:small"
      ],
      "signature": "(self)",
      "fingerprint": "d6eaf1b0b48ae110e22767b2c34e6f20af098b6b",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME ) -> NAME : # Probe multiple endpoints with backoff for NAME in NAME ( LIT , LIT ) : for NAME in NAME . NAME : try : import NAME NAME = NAME . NAME ( NAME , NAME = LIT + NAME ) if NAME . NAME < LIT : NAME . NAME = LIT return True except NAME : continue NAME . NAME += LIT NAME . NAME ( NAME * LIT ) if NAME . NAME >= NAME . NAME : return False return True"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager._p2_check_auth_if_needed",
      "lineno": 2754,
      "end_lineno": 2816,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 7,
      "loc": 63,
      "tags": [
        "impure",
        "filesystem",
        "time",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self)",
      "fingerprint": "8c921f5f92a044dc3a2525c88a4aa9a738c96230",
      "simhash64": 7451588277148488747,
      "normalized": "def NAME ( NAME ) -> NAME : NAME = NAME . NAME ( ) if NAME - NAME . NAME < NAME . NAME : return True NAME . NAME = NAME try : from NAME import NAME NAME = NAME ( NAME , NAME = False ) if NAME : # On consecutive successes, gently widen check interval up to max NAME . NAME = NAME ( NAME . NAME + LIT , LIT ) if NAME . NAME < NAME . NAME and NAME . NAME >= LIT : NAME . NAME = NAME ( NAME . NAME * LIT , NAME . NAME ) else : # On failure, reset to minimum interval NAME . NAME = LIT NAME . NAME = NAME ( NAME . NAME , NAME ( NAME . NAME ( LIT , LIT ) ) ) return NAME ( NAME ) except NAME : # On exception, also reset to minimum interval NAME . NAME = LIT NAME . NAME = NAME ( NAME . NAME , NAME ( NAME . NAME ( LIT , LIT ) ) ) return False # Provide minimal safe defaults if local health snapshots are not set NAME = True NAME : NAME = { } NAME : NAME = [ ] return { LIT : { LIT : NAME . NAME [ LIT ] , LIT : NAME . NAME [ LIT ] , LIT : NAME . NAME [ LIT ] , LIT : NAME . NAME [ LIT ] , LIT : ( NAME . NAME ( ) - NAME . NAME [ LIT ] ) / LIT } , LIT : { LIT : LIT if NAME else LIT , LIT : NAME , LIT : NAME , } , LIT : { LIT : NAME . NAME [ LIT ] , LIT : NAME . NAME ( ) , LIT : NAME . NAME [ - LIT : ] , } , LIT : { LIT : LIT if NAME ( NAME > LIT for NAME in NAME . NAME ( ) . NAME ( ) ) else LIT , LIT : NAME . NAME , } , LIT : { LIT : NAME . NAME , LIT : NAME . NAME , LIT : NAME . NAME , } , LIT : { LIT : True } }"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.cleanup",
      "lineno": 2818,
      "end_lineno": 2824,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 4,
      "loc": 7,
      "tags": [
        "pure-ish",
        "pattern:error_wrapper",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "f864134677f3a732dca81c741688053a32b43131",
      "simhash64": 8641277450588173347,
      "normalized": "def NAME ( NAME ) -> None : LIT try : if NAME ( NAME , LIT ) and NAME . NAME : NAME . NAME . NAME ( ) except NAME : pass"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "SessionManager.clear_session_caches",
      "lineno": 2828,
      "end_lineno": 2830,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "(cls)",
      "fingerprint": "878a676e24ed16e25ea0228c32e65c1cf9dbd4db",
      "simhash64": 7487784165508547619,
      "normalized": "def NAME ( NAME ) -> NAME : LIT return NAME ( )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "_test_session_manager_initialization",
      "lineno": 2834,
      "end_lineno": 2878,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 5,
      "loc": 45,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "86dc681b4daa99d0ca40bbcee4e16d00080f2731",
      "simhash64": 7488180024054813755,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = [ ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ] NAME ( LIT ) NAME ( LIT ) try : NAME = NAME ( ) NAME ( f\" \u2705 SessionManager created successfully (ID: { NAME ( NAME ) } ) \" ) # Test component availability NAME = [ ] for NAME , NAME in NAME : NAME = NAME ( NAME , NAME ) NAME = NAME ( NAME , NAME , None ) NAME = NAME is not None NAME = LIT if NAME and NAME else LIT NAME ( f\" { NAME } { NAME } : { NAME } \" ) NAME ( f\" Has attribute: { NAME } , Not None: { NAME } \" ) NAME . NAME ( NAME and NAME ) assert NAME , f\" Should have { NAME } \" assert NAME , f\" { NAME } should not be None \" # Test initial state NAME = NAME . NAME NAME ( f\" \u2705 Initial session_ready state: { NAME } (Expected: False) \" ) NAME . NAME ( not NAME ) assert not NAME , LIT NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } initialization checks passed \" ) return True except NAME as NAME : NAME ( f\" \u274c SessionManager initialization failed: { NAME } \" ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "_test_component_manager_availability",
      "lineno": 2881,
      "end_lineno": 2917,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 37,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "d2143bb5801d7ec1ba31d8f3cb9497346fc11389",
      "simhash64": 7451729014570783803,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = [ ( LIT , LIT , LIT ) , ( LIT , LIT , LIT , ) , ( LIT , LIT , LIT ) , ( LIT , LIT , LIT ) , ] NAME ( LIT ) try : NAME = NAME ( ) NAME = [ ] for NAME , NAME , NAME in NAME : NAME = NAME ( NAME , NAME , None ) NAME = NAME is not None NAME = NAME ( NAME ) . NAME if NAME else LIT NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } : { NAME } \" ) NAME ( f\" Type: { NAME } , Available: { NAME } \" ) NAME . NAME ( NAME ) assert NAME , f\" { NAME } should be created \" NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } component managers available \" ) return True except NAME as NAME : NAME ( f\" \u274c Component manager availability test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "_test_database_operations",
      "lineno": 2920,
      "end_lineno": 2986,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 8,
      "loc": 67,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "e6fda23c30bd5f985a1ac9ecb76b65233d2ea03a",
      "simhash64": 8641101528661661211,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = [ ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ] NAME ( LIT ) try : NAME = NAME ( ) NAME = [ ] for NAME , NAME in NAME : try : if NAME == LIT : NAME = NAME . NAME ( ) NAME = NAME ( NAME , NAME ) NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } : { NAME } \" ) NAME ( f\" Result: { NAME } (Type: { NAME ( NAME ) . NAME } ) \" ) NAME . NAME ( NAME ) assert NAME , f\" { NAME } should return bool \" elif NAME == LIT : NAME = NAME . NAME ( ) NAME = NAME is not None NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } : { NAME } \" ) NAME ( f\" Connection: { NAME ( NAME ) . NAME if NAME else LIT } \" ) NAME . NAME ( True ) # Just test it doesn't crash # Return the connection if we got one if NAME : NAME . NAME ( NAME ) elif NAME == LIT : NAME = NAME . NAME ( ) NAME = NAME is not None NAME = LIT if NAME else LIT NAME ( f\" { NAME } { NAME } : { NAME } \" ) NAME ( f\" Context: { NAME ( NAME ) . NAME if NAME else LIT } \" ) NAME . NAME ( True ) # Just test it doesn't crash except NAME as NAME : NAME ( f\" \u274c { NAME } : Exception { NAME } \" ) NAME . NAME ( False ) NAME ( f\" \ud83d\udcca Results: { NAME ( NAME ) } / { NAME ( NAME ) } database operations successful \" ) return True except NAME as NAME : NAME ( f\" \u274c Database operations test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "_test_browser_operations",
      "lineno": 2989,
      "end_lineno": 3026,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 4,
      "loc": 38,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "203548a5d9887ab19d7255eb383496331bf688e3",
      "simhash64": 8641136711958967843,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( ) try : # Test browser operations with timeout protection import NAME def NAME ( NAME , NAME ) : raise NAME ( LIT ) # Set a 30-second timeout for browser operations NAME . NAME ( NAME . NAME , NAME ) NAME . NAME ( LIT ) try : NAME = NAME . NAME ( LIT ) assert NAME ( NAME , NAME ) , LIT NAME . NAME ( ) NAME . NAME ( LIT ) # Cancel the alarm return True except NAME : NAME ( LIT ) NAME . NAME ( LIT ) # Cancel the alarm return True # Consider timeout as acceptable in tests except NAME as NAME : NAME . NAME ( LIT ) # Cancel the alarm NAME ( f\" \u26a0\ufe0f Browser operation failed: { NAME } - this is acceptable in test environment \" ) return True # Consider failures as acceptable in tests except NAME : # If signal handling fails (e.g., on Windows), just try the operation try : NAME = NAME . NAME ( LIT ) assert NAME ( NAME , NAME ) , LIT NAME . NAME ( ) return True except NAME as NAME : NAME ( f\" \u26a0\ufe0f Browser operation failed: { NAME } - this is acceptable in test environment \" ) return True # Consider failures as acceptable in tests"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "timeout_handler",
      "lineno": 2996,
      "end_lineno": 2997,
      "is_method": false,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "(signum, frame)",
      "fingerprint": "6a9d1d0e5fc340aa1c5e582e9cfb067af4194c7f",
      "simhash64": 7487617044035568683,
      "normalized": "def NAME ( NAME , NAME ) : raise NAME ( LIT )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "_test_property_access",
      "lineno": 3029,
      "end_lineno": 3043,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 15,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "cc3a957c91356bcc44b6bc348e3c6869447e5989",
      "simhash64": 5145885970993157163,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME ( ) NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME ( NAME , NAME ) , f\" Property { NAME } should exist \" return True"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "_test_component_delegation",
      "lineno": 3046,
      "end_lineno": 3064,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 2,
      "yield_count": 0,
      "complexity": 3,
      "loc": 19,
      "tags": [
        "impure",
        "logging",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5a78b8f9df139e235c1e34610d02053661c35983",
      "simhash64": 8641136677599229491,
      "normalized": "def NAME ( ) -> NAME : LIT NAME = NAME ( ) try : NAME = NAME . NAME ( ) assert NAME ( NAME , NAME ) , LIT # Browser operations can fail in test environments, handle gracefully try : NAME = NAME . NAME ( LIT ) assert NAME ( NAME , NAME ) , LIT NAME . NAME ( ) except NAME as NAME : NAME ( f\" \u26a0\ufe0f Browser delegation test failed: { NAME } - this is acceptable in test environment \" ) return True except NAME as NAME : NAME ( f\" \u26a0\ufe0f Component delegation test failed: { NAME } \" ) return False"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "_test_initialization_performance",
      "lineno": 3067,
      "end_lineno": 3084,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 4,
      "loc": 18,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "21bce0132c3f5804ec6c57924f0502b7b224a19f",
      "simhash64": 7488144838607930387,
      "normalized": "def NAME ( ) -> NAME : import NAME NAME = [ ] NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME = NAME ( ) NAME . NAME ( NAME ) NAME = NAME . NAME ( ) NAME = NAME - NAME NAME = LIT assert ( NAME < NAME ) , f\" 3 optimized initializations took { NAME : .3f } s, should be under { NAME } s \" for NAME in NAME : with NAME . NAME ( NAME ) : NAME . NAME ( NAME = True ) return True"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "_test_error_handling",
      "lineno": 3087,
      "end_lineno": 3097,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 11,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "5eb28a90811234c5933bdfd058ef6bdca566ec39",
      "simhash64": 8641066343214785555,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME ( ) try : NAME . NAME ( ) NAME . NAME ( LIT ) NAME . NAME ( ) NAME = NAME . NAME NAME = NAME . NAME except NAME as NAME : raise NAME ( f\" SessionManager should handle operations gracefully: { NAME } \" ) return True"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "_test_regression_prevention_csrf_optimization",
      "lineno": 3100,
      "end_lineno": 3164,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 9,
      "loc": 65,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "d20166310207b2690a22f706b7b0795be3fc3a2f",
      "simhash64": 8640573728786650155,
      "normalized": "def NAME ( ) -> NAME : LIT NAME ( LIT ) NAME = [ ] try : NAME = NAME ( ) # Test 1: Verify CSRF caching attributes exist if NAME ( NAME , LIT ) : NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) if NAME ( NAME , LIT ) : NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) # Test 2: Verify CSRF validation method exists if NAME ( NAME , LIT ) : NAME ( LIT ) # Test that it returns a boolean try : NAME = NAME . NAME ( ) if NAME ( NAME , NAME ) : NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) except NAME as NAME : NAME ( f\" \u26a0\ufe0f  _is_csrf_token_valid method error: { NAME } \" ) NAME . NAME ( False ) else : NAME ( LIT ) NAME . NAME ( False ) # Test 3: Verify pre-cache method exists if NAME ( NAME , LIT ) : NAME ( LIT ) NAME . NAME ( True ) else : NAME ( LIT ) NAME . NAME ( False ) except NAME as NAME : NAME ( f\" \u274c SessionManager CSRF optimization test failed: { NAME } \" ) NAME . NAME ( False ) NAME = NAME ( NAME ) if NAME : NAME ( LIT ) return NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "_test_regression_prevention_property_access",
      "lineno": 3167,
      "end_lineno": 3209,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 43,
      "tags": [
        "impure",
        "network",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "b85afcaf8637f8529d195387b3035b6a71fbba5f",
      "simhash64": 7469637859963999275,
      "normalized": "def NAME ( ) -> NAME : LIT NAME ( LIT ) NAME = [ ] try : NAME = NAME ( ) # Test key properties that had duplicate definition issues NAME = [ ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) , ( LIT , LIT ) ] for NAME , NAME in NAME : try : NAME ( NAME , NAME ) NAME ( f\" \u2705 Property ' { NAME } ' accessible ( { NAME } ) \" ) NAME . NAME ( True ) except NAME : NAME ( f\" \u26a0\ufe0f  Property ' { NAME } ' not found (may be intended) \" ) NAME . NAME ( True ) # Not finding is OK, crashing is not except NAME as NAME : NAME ( f\" \u274c Property ' { NAME } ' error: { NAME } \" ) NAME . NAME ( False ) except NAME as NAME : NAME ( f\" \u274c SessionManager property access test failed: { NAME } \" ) NAME . NAME ( False ) NAME = NAME ( NAME ) if NAME : NAME ( LIT ) return NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "_test_regression_prevention_initialization_stability",
      "lineno": 3212,
      "end_lineno": 3250,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 5,
      "loc": 39,
      "tags": [
        "impure",
        "logging",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "51aa64c5fb0c2f0cf543c6214a5215759f6c1c6d",
      "simhash64": 7487652258472432699,
      "normalized": "def NAME ( ) -> NAME : LIT NAME ( LIT ) NAME = [ ] try : # Test multiple initialization attempts for NAME in NAME ( LIT ) : try : NAME = NAME ( ) NAME ( f\" \u2705 Initialization attempt { NAME + LIT } successful \" ) NAME . NAME ( True ) # Test basic attribute access NAME = NAME ( NAME , LIT ) NAME = NAME ( NAME , LIT ) NAME = NAME ( NAME , LIT ) NAME ( f\" \u2705 Basic attribute access { NAME + LIT } successful \" ) NAME . NAME ( True ) except NAME as NAME : NAME ( f\" \u274c Initialization attempt { NAME + LIT } failed: { NAME } \" ) NAME . NAME ( False ) break except NAME as NAME : NAME ( f\" \u274c SessionManager initialization stability test failed: { NAME } \" ) NAME . NAME ( False ) NAME = NAME ( NAME ) if NAME : NAME ( LIT ) return NAME"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 3253,
      "end_lineno": 3569,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 16,
      "loc": 317,
      "tags": [
        "pure-ish",
        "time",
        "regex",
        "purpose:test_runner",
        "size:large"
      ],
      "signature": "()",
      "fingerprint": "bcf76b99c5f3a4ef668760d1f02810b3d5263ad3",
      "simhash64": 7451588276007638059,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME with NAME ( ) : NAME = NAME ( LIT , LIT ) NAME . NAME ( ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # \ud83d\udee1\ufe0f REGRESSION PREVENTION TESTS - These would have caught the optimization and stability issues NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) # === PHASE 4: LOAD SIMULATION FRAMEWORK === def NAME ( ) : LIT import NAME from NAME . NAME import NAME , NAME # Create mock session manager NAME = NAME ( ) NAME . NAME = { LIT : LIT , LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) } NAME . NAME = { LIT : NAME ( ) , LIT : LIT , LIT : LIT } # Add the methods we're testing NAME . NAME = NAME . NAME . NAME ( NAME ) NAME . NAME = NAME ( NAME = True ) # Simulate processing 724 pages with realistic error patterns NAME = LIT NAME = LIT NAME = LIT # Mock health monitor for load simulation with NAME ( LIT ) as NAME : NAME = NAME ( ) NAME . NAME . NAME = False NAME . NAME . NAME = False NAME . NAME . NAME = False NAME . NAME = [ ] # Simulate realistic error injection pattern # Expect ~100-200 errors over 724 pages (13-27% error rate) NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] # Pages where errors cluster for NAME in NAME ( LIT , LIT ) : # 724 pages NAME += LIT # Inject realistic error patterns if NAME in NAME : # Simulate error cluster (12-15 errors to reach thresholds) for NAME in NAME ( LIT ) : NAME += LIT NAME . NAME . NAME ( NAME . NAME ( ) - ( NAME * LIT ) ) # Check if this triggers intervention (only count once per threshold) if NAME >= LIT and NAME == LIT : # Enhanced monitoring threshold (count once) NAME . NAME . NAME = True NAME += LIT if NAME >= LIT and NAME == LIT : # Immediate intervention threshold (count once) NAME . NAME . NAME = True NAME += LIT NAME . NAME = NAME # Test intervention check (should not halt for realistic error rates) NAME = NAME . NAME ( ) # For realistic error rates, should not halt if NAME < LIT : # Below emergency threshold assert not NAME , f\" Should not halt at page { NAME } with { NAME } errors \" # Simulate browser refresh every 50 pages if NAME % LIT == LIT : NAME . NAME [ LIT ] = LIT NAME . NAME [ LIT ] = NAME . NAME ( ) # Verify load simulation results assert NAME == LIT , f\" Should process 724 pages, processed { NAME } \" assert NAME >= LIT , f\" Should inject realistic errors, got { NAME } \" assert NAME <= LIT , f\" Should not inject excessive errors, got { NAME } \" assert NAME >= LIT , f\" Should trigger some interventions, got { NAME } \" NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) def NAME ( ) : LIT from NAME . NAME import NAME , NAME # Test memory availability check under pressure NAME = NAME ( ) NAME . NAME = NAME . NAME . NAME ( NAME ) # Simulate low memory condition with NAME ( LIT ) as NAME : # Test insufficient memory (400MB available) NAME . NAME . NAME = LIT * LIT * LIT NAME = NAME . NAME ( ) assert not NAME , LIT # Test sufficient memory (1GB available) NAME . NAME . NAME = LIT * LIT * LIT NAME = NAME . NAME ( ) assert NAME , LIT def NAME ( ) : LIT import NAME from NAME . NAME import NAME , NAME # Create mock session manager NAME = NAME ( ) NAME . NAME = NAME ( ) NAME . NAME = { LIT : NAME . NAME ( ) } # Add the methods we're testing NAME . NAME = NAME . NAME . NAME ( NAME ) # Create mock browser managers NAME = NAME ( ) NAME = NAME ( ) # Simulate network instability during session continuity verification with NAME ( LIT ) as NAME : with NAME ( LIT ) as NAME : NAME . NAME . NAME . NAME . NAME . NAME = LIT # Test 1: Network failure during navigation NAME . NAME = False # Navigation fails NAME . NAME . NAME = True NAME = NAME . NAME ( NAME , NAME ) assert not NAME , LIT # Test 2: Successful navigation under good conditions NAME . NAME = True # Navigation succeeds NAME . NAME . NAME . NAME = [ { LIT : LIT , LIT : LIT } ] NAME . NAME . NAME . NAME = LIT NAME . NAME . NAME = LIT NAME = NAME . NAME ( NAME , NAME ) assert NAME , LIT def NAME ( ) : LIT import NAME from NAME . NAME import NAME , NAME # Create mock session manager NAME = NAME ( ) NAME . NAME = { LIT : NAME ( ) , LIT : LIT , LIT : LIT } NAME . NAME = NAME ( NAME = True ) NAME . NAME = NAME . NAME . NAME ( NAME ) # Test cascade failure detection and recovery with NAME ( LIT ) as NAME : NAME = NAME ( ) # Test 1: Emergency halt scenario NAME . NAME . NAME = True NAME . NAME . NAME = False NAME . NAME . NAME = False NAME . NAME . NAME = { LIT : { LIT : True , LIT : LIT , LIT : NAME . NAME ( ) } } NAME . NAME = NAME # Should trigger emergency halt NAME = NAME . NAME ( ) assert NAME , LIT NAME . NAME [ LIT ] . NAME . NAME ( ) # Test 2: Immediate intervention with successful recovery NAME . NAME [ LIT ] . NAME ( ) NAME . NAME . NAME = False NAME . NAME . NAME = True NAME . NAME . NAME = { LIT : { LIT : True , LIT : LIT , LIT : NAME . NAME ( ) } } # Should attempt recovery NAME = NAME . NAME ( ) assert not NAME , LIT NAME . NAME . NAME ( ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "test_724_page_workload_simulation",
      "lineno": 3347,
      "end_lineno": 3423,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 11,
      "loc": 77,
      "tags": [
        "pure-ish",
        "time",
        "regex",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "7775b53fe5b6bd1bc9792dfaaa5615275d839cb1",
      "simhash64": 7452186410333156371,
      "normalized": "def NAME ( ) : LIT import NAME from NAME . NAME import NAME , NAME # Create mock session manager NAME = NAME ( ) NAME . NAME = { LIT : LIT , LIT : NAME . NAME ( ) , LIT : NAME . NAME ( ) } NAME . NAME = { LIT : NAME ( ) , LIT : LIT , LIT : LIT } # Add the methods we're testing NAME . NAME = NAME . NAME . NAME ( NAME ) NAME . NAME = NAME ( NAME = True ) # Simulate processing 724 pages with realistic error patterns NAME = LIT NAME = LIT NAME = LIT # Mock health monitor for load simulation with NAME ( LIT ) as NAME : NAME = NAME ( ) NAME . NAME . NAME = False NAME . NAME . NAME = False NAME . NAME . NAME = False NAME . NAME = [ ] # Simulate realistic error injection pattern # Expect ~100-200 errors over 724 pages (13-27% error rate) NAME = [ LIT , LIT , LIT , LIT , LIT , LIT ] # Pages where errors cluster for NAME in NAME ( LIT , LIT ) : # 724 pages NAME += LIT # Inject realistic error patterns if NAME in NAME : # Simulate error cluster (12-15 errors to reach thresholds) for NAME in NAME ( LIT ) : NAME += LIT NAME . NAME . NAME ( NAME . NAME ( ) - ( NAME * LIT ) ) # Check if this triggers intervention (only count once per threshold) if NAME >= LIT and NAME == LIT : # Enhanced monitoring threshold (count once) NAME . NAME . NAME = True NAME += LIT if NAME >= LIT and NAME == LIT : # Immediate intervention threshold (count once) NAME . NAME . NAME = True NAME += LIT NAME . NAME = NAME # Test intervention check (should not halt for realistic error rates) NAME = NAME . NAME ( ) # For realistic error rates, should not halt if NAME < LIT : # Below emergency threshold assert not NAME , f\" Should not halt at page { NAME } with { NAME } errors \" # Simulate browser refresh every 50 pages if NAME % LIT == LIT : NAME . NAME [ LIT ] = LIT NAME . NAME [ LIT ] = NAME . NAME ( ) # Verify load simulation results assert NAME == LIT , f\" Should process 724 pages, processed { NAME } \" assert NAME >= LIT , f\" Should inject realistic errors, got { NAME } \" assert NAME <= LIT , f\" Should not inject excessive errors, got { NAME } \" assert NAME >= LIT , f\" Should trigger some interventions, got { NAME } \""
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "test_memory_pressure_simulation",
      "lineno": 3433,
      "end_lineno": 3451,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 19,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "f39e0cc894a760c21535712a8cd6e93506cfe15b",
      "simhash64": 7452152325539800131,
      "normalized": "def NAME ( ) : LIT from NAME . NAME import NAME , NAME # Test memory availability check under pressure NAME = NAME ( ) NAME . NAME = NAME . NAME . NAME ( NAME ) # Simulate low memory condition with NAME ( LIT ) as NAME : # Test insufficient memory (400MB available) NAME . NAME . NAME = LIT * LIT * LIT NAME = NAME . NAME ( ) assert not NAME , LIT # Test sufficient memory (1GB available) NAME . NAME . NAME = LIT * LIT * LIT NAME = NAME . NAME ( ) assert NAME , LIT"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "test_network_instability_simulation",
      "lineno": 3453,
      "end_lineno": 3489,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 3,
      "loc": 37,
      "tags": [
        "pure-ish",
        "time",
        "regex",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "53145435620fe8844eb2f551560430d9eeef5057",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( ) : LIT import NAME from NAME . NAME import NAME , NAME # Create mock session manager NAME = NAME ( ) NAME . NAME = NAME ( ) NAME . NAME = { LIT : NAME . NAME ( ) } # Add the methods we're testing NAME . NAME = NAME . NAME . NAME ( NAME ) # Create mock browser managers NAME = NAME ( ) NAME = NAME ( ) # Simulate network instability during session continuity verification with NAME ( LIT ) as NAME : with NAME ( LIT ) as NAME : NAME . NAME . NAME . NAME . NAME . NAME = LIT # Test 1: Network failure during navigation NAME . NAME = False # Navigation fails NAME . NAME . NAME = True NAME = NAME . NAME ( NAME , NAME ) assert not NAME , LIT # Test 2: Successful navigation under good conditions NAME . NAME = True # Navigation succeeds NAME . NAME . NAME . NAME = [ { LIT : LIT , LIT : LIT } ] NAME . NAME . NAME . NAME = LIT NAME . NAME . NAME = LIT NAME = NAME . NAME ( NAME , NAME ) assert NAME , LIT"
    },
    {
      "module_path": "core\\session_manager.py",
      "qualname": "test_cascade_failure_recovery",
      "lineno": 3491,
      "end_lineno": 3543,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 53,
      "tags": [
        "pure-ish",
        "time",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "2de5781bde8569795d6d6a40660bec3413d47159",
      "simhash64": 7451553091635557379,
      "normalized": "def NAME ( ) : LIT import NAME from NAME . NAME import NAME , NAME # Create mock session manager NAME = NAME ( ) NAME . NAME = { LIT : NAME ( ) , LIT : LIT , LIT : LIT } NAME . NAME = NAME ( NAME = True ) NAME . NAME = NAME . NAME . NAME ( NAME ) # Test cascade failure detection and recovery with NAME ( LIT ) as NAME : NAME = NAME ( ) # Test 1: Emergency halt scenario NAME . NAME . NAME = True NAME . NAME . NAME = False NAME . NAME . NAME = False NAME . NAME . NAME = { LIT : { LIT : True , LIT : LIT , LIT : NAME . NAME ( ) } } NAME . NAME = NAME # Should trigger emergency halt NAME = NAME . NAME ( ) assert NAME , LIT NAME . NAME [ LIT ] . NAME . NAME ( ) # Test 2: Immediate intervention with successful recovery NAME . NAME [ LIT ] . NAME ( ) NAME . NAME . NAME = False NAME . NAME . NAME = True NAME . NAME . NAME = { LIT : { LIT : True , LIT : LIT , LIT : NAME . NAME ( ) } } # Should attempt recovery NAME = NAME . NAME ( ) assert not NAME , LIT NAME . NAME . NAME ( )"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "SessionValidator.__init__",
      "lineno": 50,
      "end_lineno": 53,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 4,
      "tags": [
        "pure-ish",
        "time",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "0944ea39aed428f79be360cbe5429d1041132760",
      "simhash64": 8641136711958963203,
      "normalized": "def NAME ( NAME ) -> None : LIT NAME . NAME : NAME = NAME . NAME ( NAME . NAME ) NAME . NAME ( LIT )"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "SessionValidator.perform_readiness_checks",
      "lineno": 55,
      "end_lineno": 161,
      "is_method": true,
      "is_async": false,
      "args_count": 7,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 12,
      "loc": 107,
      "tags": [
        "impure",
        "network",
        "logging",
        "time",
        "purpose:validation",
        "size:large"
      ],
      "signature": "(self, browser_manager, api_manager, session_manager, action_name, max_attempts, skip_csrf)",
      "fingerprint": "a8a1f5813362dd866a0a0c454e95776f94cc77ff",
      "simhash64": 7488109654235845659,
      "normalized": "def NAME ( NAME , NAME , NAME , NAME , NAME : NAME [ NAME ] = None , NAME : NAME = LIT , NAME : NAME = False , ) -> NAME : LIT NAME . NAME ( f\" Starting readiness checks for: { NAME or LIT } \" ) NAME = LIT for NAME in NAME ( LIT , NAME + LIT ) : NAME . NAME ( f\" Readiness check attempt { NAME } of { NAME } \" ) try : # Check login status and attempt relogin if needed NAME , NAME = NAME . NAME ( NAME , NAME , NAME ) if not NAME : NAME = NAME continue # Check and handle current URL if not NAME . NAME ( NAME ) : NAME . NAME ( LIT ) NAME = LIT continue NAME . NAME ( LIT ) # Check essential cookies NAME , NAME = NAME . NAME ( NAME , NAME ) if not NAME : NAME = NAME continue # Sync cookies to requests session NAME , NAME = NAME . NAME ( NAME , NAME ) if not NAME : NAME = NAME continue # Check CSRF token (skip if not needed) if not NAME : NAME , NAME = NAME . NAME ( NAME ) if not NAME : NAME = NAME continue else : NAME . NAME ( LIT ) # All checks passed NAME . NAME ( f\" Readiness checks PASSED on attempt { NAME } . \" ) return True except NAME as NAME : NAME . NAME ( f\" WebDriverException during readiness check attempt { NAME } : { NAME } \" , NAME = False , ) NAME = f\" WebDriverException: { NAME } \" if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" Unexpected exception during readiness check attempt { NAME } : { NAME } \" , NAME = True , ) NAME = f\" Exception: { NAME } \" # Wait before next attempt (except on last attempt) if NAME < NAME : import NAME NAME . NAME ( LIT ) # Increased from 2 to 5 seconds for better stability NAME . NAME ( f\" All { NAME } readiness check attempts failed. Last Error: { NAME } \" ) return False"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "SessionValidator._check_login_and_attempt_relogin",
      "lineno": 163,
      "end_lineno": 214,
      "is_method": true,
      "is_async": false,
      "args_count": 4,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 6,
      "yield_count": 0,
      "complexity": 6,
      "loc": 52,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, browser_manager, session_manager, attempt)",
      "fingerprint": "a15b91729186c819fbff607583af7b4f3c05c7cf",
      "simhash64": 7488180022980023299,
      "normalized": "def NAME ( NAME , NAME , NAME , NAME : NAME ) -> NAME [ NAME , NAME [ NAME ] ] : LIT try : # Import login_status here to avoid circular imports from NAME import NAME NAME . NAME ( f\" Checking login status (attempt { NAME } )... \" ) # Use the session manager parameter directly if not NAME : NAME . NAME ( LIT ) return False , LIT NAME = NAME ( NAME , NAME = True ) # Use API-only check if NAME is True : NAME . NAME ( LIT ) return True , None if NAME is False : NAME . NAME ( LIT ) # Attempt relogin NAME = NAME . NAME ( NAME , NAME ) if NAME : NAME . NAME ( LIT ) return True , None NAME = LIT NAME . NAME ( NAME ) return False , NAME # login_ok is None NAME = LIT NAME . NAME ( NAME ) return False , NAME except NAME as NAME : NAME = f\" Exception during login check: { NAME } \" NAME . NAME ( NAME , NAME = True ) return False , NAME"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "SessionValidator._attempt_relogin",
      "lineno": 216,
      "end_lineno": 247,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 32,
      "tags": [
        "pure-ish",
        "size:medium"
      ],
      "signature": "(self, browser_manager, session_manager)",
      "fingerprint": "68d16af4154cab60ff4e0a73b09a47e773d220ca",
      "simhash64": 7488215207352120371,
      "normalized": "def NAME ( NAME , NAME , NAME ) -> NAME : LIT try : # Import log_in function here to avoid circular imports from NAME import NAME NAME . NAME ( LIT ) # Use the session manager parameter directly if not NAME : NAME . NAME ( LIT ) return False NAME = NAME ( NAME ) # Pass session manager if NAME == LIT : NAME . NAME ( LIT ) return True NAME . NAME ( f\" Relogin failed: { NAME } \" ) return False except NAME as NAME : NAME . NAME ( f\" Exception during relogin attempt: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "SessionValidator._check_and_handle_url",
      "lineno": 249,
      "end_lineno": 295,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 5,
      "yield_count": 0,
      "complexity": 7,
      "loc": 47,
      "tags": [
        "pure-ish",
        "regex",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, browser_manager)",
      "fingerprint": "6b0ed01dbfc8365b7cd001304096390325ce3658",
      "simhash64": 7488109654235853843,
      "normalized": "def NAME ( NAME , NAME ) -> NAME : LIT if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False try : NAME = NAME . NAME . NAME NAME . NAME ( f\" Current URL: { NAME } \" ) # Check if we're on a valid Ancestry page NAME = NAME . NAME . NAME or LIT if not NAME or not NAME . NAME ( NAME ) : NAME . NAME ( LIT ) # Import nav_to_page here to avoid circular imports from NAME import NAME NAME = NAME ( NAME . NAME , NAME , NAME = LIT , NAME = NAME ( NAME , LIT , None ) , ) if not NAME : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) return True except NAME as NAME : NAME . NAME ( f\" WebDriverException checking URL: { NAME } \" ) return False except NAME as NAME : NAME . NAME ( f\" Unexpected error checking URL: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "SessionValidator._check_essential_cookies",
      "lineno": 297,
      "end_lineno": 363,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 10,
      "yield_count": 0,
      "complexity": 19,
      "loc": 67,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, browser_manager, action_name)",
      "fingerprint": "41c3e8103342acef2c55871596390a9b5a789087",
      "simhash64": 7487617075241194531,
      "normalized": "def NAME ( NAME , NAME , NAME : NAME [ NAME ] = None ) -> NAME [ NAME , NAME [ NAME ] ] : LIT NAME = [ LIT , LIT ] # Add more as needed # For Action 6 (DNA match gathering), cookies may not be available until visiting the matches page # Skip cookie check for Action 6 since it will navigate to the correct page later if NAME and LIT in NAME : NAME . NAME ( LIT ) return True , None # For Action 7 (Search Inbox), cookies may not be immediately available but login verification works # Skip cookie check for Action 7 since API login verification is sufficient if NAME and LIT in NAME : NAME . NAME ( LIT ) return True , None # For Action 8 (Send Messages), cookies may not be immediately available but login verification works # Skip cookie check for Action 8 since API login verification is sufficient if NAME and LIT in NAME : NAME . NAME ( LIT ) return True , None # For Action 9 (Process Productive Messages), cookies may not be immediately available but login verification works # Skip cookie check for Action 9 since API login verification is sufficient if NAME and LIT in NAME : NAME . NAME ( LIT ) return True , None # For Action 10 (GEDCOM Report), this is a local file operation that doesn't require cookies # Skip cookie check for Action 10 since it works with local GEDCOM files if NAME and ( LIT in NAME or LIT in NAME . NAME ( ) ) : NAME . NAME ( LIT ) return True , None # For Action 11 (API Report), this is an API-based operation that doesn't require browser cookies # Skip cookie check for Action 11 since it uses API calls for data retrieval if NAME and ( LIT in NAME or LIT in NAME . NAME ( ) ) : NAME . NAME ( LIT ) return True , None # During browser refresh verification, relax the essential cookie requirement if NAME and ( LIT in NAME . NAME ( ) ) : NAME . NAME ( LIT ) return True , None try : if not NAME . NAME ( NAME ) : NAME = f\" Essential cookies not found: { NAME } \" NAME . NAME ( NAME ) return False , NAME NAME . NAME ( LIT ) return True , None except NAME as NAME : NAME = f\" Exception checking essential cookies: { NAME } \" NAME . NAME ( NAME , NAME = True ) return False , NAME"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "SessionValidator._sync_cookies_to_requests",
      "lineno": 365,
      "end_lineno": 391,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 27,
      "tags": [
        "impure",
        "network",
        "size:small"
      ],
      "signature": "(self, browser_manager, api_manager)",
      "fingerprint": "124a2770b96e20c84f2831c7547ada4f93963f3d",
      "simhash64": 7488180022980031507,
      "normalized": "def NAME ( NAME , NAME , NAME ) -> NAME [ NAME , NAME [ NAME ] ] : LIT try : NAME = NAME . NAME ( NAME ) if not NAME : NAME = LIT NAME . NAME ( NAME ) return False , NAME NAME . NAME ( LIT ) return True , None except NAME as NAME : NAME = f\" Exception syncing cookies: { NAME } \" NAME . NAME ( NAME , NAME = True ) return False , NAME"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "SessionValidator._check_csrf_token",
      "lineno": 393,
      "end_lineno": 423,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 4,
      "loc": 31,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, api_manager)",
      "fingerprint": "f213859efb72a74977b04a8fe94f779cbb5dcd83",
      "simhash64": 7488180023047132179,
      "normalized": "def NAME ( NAME , NAME ) -> NAME [ NAME , NAME [ NAME ] ] : LIT try : if not NAME . NAME : NAME . NAME ( LIT ) NAME = NAME . NAME ( ) if not NAME : # CSRF token failure is non-critical for some operations NAME . NAME ( LIT ) return True , None # Continue anyway NAME . NAME ( LIT ) # No need to log \"already available\" - reduces noise return True , None except NAME as NAME : NAME = f\" Exception checking CSRF token: { NAME } \" NAME . NAME ( NAME , NAME = True ) # CSRF token errors are non-critical return True , None"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "SessionValidator.validate_session_cookies",
      "lineno": 425,
      "end_lineno": 445,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 3,
      "yield_count": 0,
      "complexity": 3,
      "loc": 21,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "(self, browser_manager, required_cookies)",
      "fingerprint": "3e4c008a2279466beee1ef1a4450581a939531e2",
      "simhash64": 7488180022980031491,
      "normalized": "def NAME ( NAME , NAME , NAME : NAME [ NAME ] ) -> NAME : LIT try : if not NAME . NAME ( ) : NAME . NAME ( LIT ) return False return NAME . NAME ( NAME ) except NAME as NAME : NAME . NAME ( f\" Error validating session cookies: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "SessionValidator.verify_login_status",
      "lineno": 447,
      "end_lineno": 479,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 4,
      "yield_count": 0,
      "complexity": 4,
      "loc": 33,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:medium"
      ],
      "signature": "(self, api_manager, session_manager)",
      "fingerprint": "6b974647c0d6dd108beb1bc7b5c5323e77d3b07b",
      "simhash64": 8641136712026067971,
      "normalized": "def NAME ( NAME , NAME , NAME = None ) -> NAME : LIT NAME . NAME ( LIT ) try : # Try API-based verification first (with cookie syncing if session_manager provided) NAME = NAME . NAME ( NAME ) if NAME is True : NAME . NAME ( LIT ) return True if NAME is False : NAME . NAME ( LIT ) return False NAME . NAME ( LIT ) return False except NAME as NAME : NAME . NAME ( f\" Unexpected error during login verification: { NAME } \" , NAME = True ) return False"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "_test_session_validator_initialization",
      "lineno": 483,
      "end_lineno": 497,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 15,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "7ebc30e226eb6ec1510c3e178b6d25366ea20853",
      "simhash64": 7488179989694026787,
      "normalized": "def NAME ( ) -> NAME : NAME = NAME ( ) assert NAME is not None , LIT assert NAME ( NAME , LIT ) , LIT assert ( NAME . NAME is not None ) , LIT from NAME import NAME assert NAME ( NAME . NAME , NAME ) , LIT return True"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "_test_readiness_checks_success",
      "lineno": 500,
      "end_lineno": 523,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 24,
      "tags": [
        "pure-ish",
        "purpose:validation",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "970be2d15b41c1c294e4915ff61b464051ef5f2a",
      "simhash64": 7488742943943988267,
      "normalized": "def NAME ( ) -> NAME : from NAME . NAME import NAME , NAME NAME = NAME ( ) NAME = NAME ( ) NAME = NAME ( ) with NAME . NAME ( NAME , LIT , NAME = ( True , None ) ) , NAME . NAME ( NAME , LIT , NAME = True ) , NAME . NAME ( NAME , LIT , NAME = ( True , None ) ) , NAME . NAME ( NAME , LIT , NAME = ( True , None ) ) , NAME . NAME ( NAME , LIT , NAME = ( True , None ) ) : NAME = NAME . NAME ( NAME , NAME , LIT ) assert ( NAME is True ) , LIT return True"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "_test_login_verification",
      "lineno": 526,
      "end_lineno": 535,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 10,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "3e2fb79e1c4f22fbba04297a1506a69f0b1f1243",
      "simhash64": 7488144842902905875,
      "normalized": "def NAME ( ) -> NAME : from NAME . NAME import NAME NAME = NAME ( ) NAME = NAME ( ) NAME . NAME . NAME = True NAME = NAME . NAME ( NAME ) assert NAME is True , LIT NAME . NAME . NAME ( ) return True"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "_test_invalid_browser_session",
      "lineno": 538,
      "end_lineno": 546,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "a10da025a3b6eabde72ff06fddca8bd4d5830c0d",
      "simhash64": 7488109654235849811,
      "normalized": "def NAME ( ) -> NAME : from NAME . NAME import NAME NAME = NAME ( ) NAME = NAME ( ) NAME . NAME . NAME = False NAME = NAME . NAME ( NAME , [ LIT ] ) assert NAME is False , LIT return True"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "_test_login_verification_failure",
      "lineno": 549,
      "end_lineno": 557,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "4597f4ffb2c4a5612316f8eec6c5d4f83f2c64a2",
      "simhash64": 7488144838607938643,
      "normalized": "def NAME ( ) -> NAME : from NAME . NAME import NAME NAME = NAME ( ) NAME = NAME ( ) NAME . NAME . NAME = False NAME = NAME . NAME ( NAME ) assert NAME is False , LIT return True"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "_test_full_validation_workflow",
      "lineno": 560,
      "end_lineno": 573,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 14,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "249dc023fc18bc97aca43d176508ddf676ef5264",
      "simhash64": 7488109658530817043,
      "normalized": "def NAME ( ) -> NAME : from NAME . NAME import NAME NAME = NAME ( ) NAME = NAME ( ) NAME = NAME ( ) NAME . NAME . NAME = True NAME . NAME . NAME = True NAME . NAME . NAME = True NAME = NAME . NAME ( NAME , [ LIT ] ) assert NAME is True , LIT NAME = NAME . NAME ( NAME ) assert NAME is True , LIT return True"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "_test_initialization_performance",
      "lineno": 576,
      "end_lineno": 587,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 12,
      "tags": [
        "pure-ish",
        "time",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "74311ff360f6d4e2163fd8112f39b26e67872d13",
      "simhash64": 7488215212721865755,
      "normalized": "def NAME ( ) -> NAME : import NAME NAME = NAME . NAME ( ) for NAME in NAME ( LIT ) : NAME ( ) NAME = NAME . NAME ( ) NAME = NAME - NAME assert ( NAME < LIT ) , f\" 100 initializations took { NAME : .3f } s, should be under 1s \" return True"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "_test_webdriver_exception_handling",
      "lineno": 590,
      "end_lineno": 606,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 17,
      "tags": [
        "impure",
        "network",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "66db530535361ab12b7710eb6863f8fd5d880eee",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( ) -> NAME : from NAME . NAME import NAME , NAME from NAME . NAME . NAME import NAME NAME = NAME ( ) NAME = NAME ( ) NAME = NAME ( ) NAME = NAME ( ) with NAME . NAME ( NAME , LIT ) as NAME : NAME . NAME = NAME ( LIT ) NAME . NAME . NAME = True NAME = NAME . NAME ( NAME , NAME , NAME , NAME = LIT ) assert NAME is False , LIT return True"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "_test_general_exception_handling",
      "lineno": 609,
      "end_lineno": 617,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 9,
      "tags": [
        "pure-ish",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "1071353f997284635f244d1aee49c4735ca28e7e",
      "simhash64": 7488109654235849747,
      "normalized": "def NAME ( ) -> NAME : from NAME . NAME import NAME NAME = NAME ( ) NAME = NAME ( ) NAME . NAME . NAME = NAME ( LIT ) NAME = NAME . NAME ( NAME , [ LIT ] ) assert NAME is False , LIT return True"
    },
    {
      "module_path": "core\\session_validator.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 620,
      "end_lineno": 694,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 2,
      "loc": 75,
      "tags": [
        "pure-ish",
        "time",
        "purpose:test_runner",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "d1ca587b8bfb7cd7418dfd5d8067ccdbe40c8742",
      "simhash64": 5127871611137332267,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME with NAME ( ) : NAME = NAME ( LIT , LIT ) NAME . NAME ( ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "core\\__init__.py",
      "qualname": "DummyComponent.__init__",
      "lineno": 67,
      "end_lineno": 68,
      "is_method": true,
      "is_async": false,
      "args_count": 2,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:initialization",
        "size:tiny"
      ],
      "signature": "(self, name)",
      "fingerprint": "0f70e91530b827d64534e5f608ec2fe7441857ef",
      "simhash64": 7488109620949853267,
      "normalized": "def NAME ( NAME , NAME : NAME ) -> None : NAME . NAME = NAME"
    },
    {
      "module_path": "core\\__init__.py",
      "qualname": "DummyComponent.__call__",
      "lineno": 70,
      "end_lineno": 71,
      "is_method": true,
      "is_async": false,
      "args_count": 3,
      "has_varargs": true,
      "has_kwargs": true,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self, *args, **kwargs)",
      "fingerprint": "6cde59dbb4d4f7e061e59a0c5518c8ff17be44f2",
      "simhash64": 7488320761542640739,
      "normalized": "def NAME ( NAME , * NAME : NAME , ** NAME : NAME ) -> LIT : return NAME"
    },
    {
      "module_path": "core\\__init__.py",
      "qualname": "DummyComponent.__repr__",
      "lineno": 73,
      "end_lineno": 74,
      "is_method": true,
      "is_async": false,
      "args_count": 1,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 2,
      "tags": [
        "pure-ish",
        "purpose:getter",
        "purpose:stub",
        "pattern:simple_return",
        "size:tiny"
      ],
      "signature": "(self)",
      "fingerprint": "f64e0d3bae435c6a0ed7747f5a2b88b92704466c",
      "simhash64": 7492648438235313267,
      "normalized": "def NAME ( NAME ) -> NAME : return f\" <DummyComponent: { NAME . NAME } > \""
    },
    {
      "module_path": "core\\__init__.py",
      "qualname": "core_package_module_tests",
      "lineno": 134,
      "end_lineno": 226,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 3,
      "loc": 93,
      "tags": [
        "pure-ish",
        "regex",
        "size:medium"
      ],
      "signature": "()",
      "fingerprint": "d06ab809259cbcc793d50c829bd611dc6e76ad93",
      "simhash64": 5145885970992108587,
      "normalized": "def NAME ( ) -> NAME : LIT from NAME import NAME , NAME NAME = NAME ( LIT , LIT ) NAME . NAME ( ) def NAME ( ) : LIT # Test version information assert NAME == LIT , f\" Expected version 2.0.0, got { NAME } \" # Test __all__ list exists and has expected components assert LIT in NAME ( ) , LIT assert NAME ( NAME ) > LIT , LIT # Test key components are in __all__ NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME in NAME , f\" Component { NAME } should be in __all__ \" def NAME ( ) : LIT # Test core managers (use globals since they're already imported) assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT def NAME ( ) : LIT # Test using globals since they're already imported assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT def NAME ( ) : LIT # Test using globals since they're already imported assert NAME ( NAME ) , LIT assert NAME is not None , LIT assert NAME is not None , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT with NAME ( ) : NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) NAME . NAME ( LIT , NAME , LIT , LIT , LIT , ) return NAME . NAME ( )"
    },
    {
      "module_path": "core\\__init__.py",
      "qualname": "test_package_structure",
      "lineno": 144,
      "end_lineno": 164,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 2,
      "loc": 21,
      "tags": [
        "pure-ish",
        "size:small"
      ],
      "signature": "()",
      "fingerprint": "6c18236a4bbd54f64b243c2aca5fa1cdffd19bae",
      "simhash64": 7452010455183038011,
      "normalized": "def NAME ( ) : LIT # Test version information assert NAME == LIT , f\" Expected version 2.0.0, got { NAME } \" # Test __all__ list exists and has expected components assert LIT in NAME ( ) , LIT assert NAME ( NAME ) > LIT , LIT # Test key components are in __all__ NAME = [ LIT , LIT , LIT , LIT , LIT , LIT , LIT , ] for NAME in NAME : assert NAME in NAME , f\" Component { NAME } should be in __all__ \""
    },
    {
      "module_path": "core\\__init__.py",
      "qualname": "test_component_imports",
      "lineno": 166,
      "end_lineno": 173,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "regex",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "0f6ac7c891c0879ecd81c858434f03ceacddb004",
      "simhash64": 8602398685003158571,
      "normalized": "def NAME ( ) : LIT # Test core managers (use globals since they're already imported) assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT"
    },
    {
      "module_path": "core\\__init__.py",
      "qualname": "test_dependency_injection_imports",
      "lineno": 175,
      "end_lineno": 182,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "regex",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "3dc7808a45ec2f4722b1c0d831a6e929d21e73bc",
      "simhash64": 7485505977411081259,
      "normalized": "def NAME ( ) : LIT # Test using globals since they're already imported assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT"
    },
    {
      "module_path": "core\\__init__.py",
      "qualname": "test_error_handling_imports",
      "lineno": 184,
      "end_lineno": 191,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 0,
      "yield_count": 0,
      "complexity": 1,
      "loc": 8,
      "tags": [
        "pure-ish",
        "regex",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "5493699d4eb654765f222b79721cb9990d7f4357",
      "simhash64": 6299361629463548979,
      "normalized": "def NAME ( ) : LIT # Test using globals since they're already imported assert NAME ( NAME ) , LIT assert NAME is not None , LIT assert NAME is not None , LIT assert NAME ( NAME ) , LIT assert NAME ( NAME ) , LIT"
    },
    {
      "module_path": "core\\__init__.py",
      "qualname": "run_comprehensive_tests",
      "lineno": 229,
      "end_lineno": 231,
      "is_method": false,
      "is_async": false,
      "args_count": 0,
      "has_varargs": false,
      "has_kwargs": false,
      "returns_count": 1,
      "yield_count": 0,
      "complexity": 1,
      "loc": 3,
      "tags": [
        "pure-ish",
        "purpose:test_runner",
        "purpose:getter",
        "pattern:delegation",
        "size:tiny"
      ],
      "signature": "()",
      "fingerprint": "d8e5d8b01a071a7633567786f1371a52d4e75d70",
      "simhash64": 8645209824331469867,
      "normalized": "def NAME ( ) -> NAME : LIT return NAME ( )"
    }
  ],
  "similar_pairs": [
    {
      "a_idx": 3,
      "b_idx": 637,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.20",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 3,
      "b_idx": 638,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.20",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 3,
      "b_idx": 674,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.22",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 3,
      "b_idx": 1053,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.24",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 12,
      "b_idx": 1998,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.42",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 109,
      "b_idx": 1631,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.20",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 124,
      "b_idx": 367,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 124,
      "b_idx": 1933,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 124,
      "b_idx": 1934,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.18",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 124,
      "b_idx": 2177,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 124,
      "b_idx": 2183,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 124,
      "b_idx": 2190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 125,
      "b_idx": 126,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 207,
      "b_idx": 240,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 324,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 410,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 449,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 468,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 507,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 530,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 596,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 653,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 710,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 855,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 902,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 935,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 207,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 324,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 410,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 449,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 468,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 507,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 530,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 596,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 653,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 710,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 855,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 902,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 935,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 240,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 278,
      "b_idx": 1220,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.30",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 278,
      "b_idx": 1992,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.37",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 316,
      "b_idx": 984,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.36",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 316,
      "b_idx": 1888,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.48",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 319,
      "b_idx": 322,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 410,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 449,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 468,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 507,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 530,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 596,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 653,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 710,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 855,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 902,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 935,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 324,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 329,
      "b_idx": 332,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.56",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 7
    },
    {
      "a_idx": 367,
      "b_idx": 1933,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 367,
      "b_idx": 1934,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.18",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 367,
      "b_idx": 2177,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 367,
      "b_idx": 2183,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 367,
      "b_idx": 2190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 398,
      "b_idx": 2195,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 398,
      "b_idx": 2205,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 410,
      "b_idx": 449,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 468,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 507,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 530,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 596,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 653,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 710,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 855,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 902,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 935,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 410,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 416,
      "b_idx": 426,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.48",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 416,
      "b_idx": 1211,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.17",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 416,
      "b_idx": 1212,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.28",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 416,
      "b_idx": 1213,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.23",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 416,
      "b_idx": 2137,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.48",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 426,
      "b_idx": 1211,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.15",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 426,
      "b_idx": 1212,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.25",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 426,
      "b_idx": 1213,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.08",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 426,
      "b_idx": 2137,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.53",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 468,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 507,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 530,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 596,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 653,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 710,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 855,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 902,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 935,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 449,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 507,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 530,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 596,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 653,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 710,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 855,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 902,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 935,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 468,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 530,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 596,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 653,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 710,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 855,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 902,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 935,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 507,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 596,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 653,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 710,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 855,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 902,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 935,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 530,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 531,
      "b_idx": 537,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 531,
      "b_idx": 539,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 532,
      "b_idx": 536,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 7
    },
    {
      "a_idx": 532,
      "b_idx": 538,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 7
    },
    {
      "a_idx": 532,
      "b_idx": 540,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 7
    },
    {
      "a_idx": 533,
      "b_idx": 545,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 5
    },
    {
      "a_idx": 536,
      "b_idx": 538,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 7
    },
    {
      "a_idx": 536,
      "b_idx": 540,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 7
    },
    {
      "a_idx": 537,
      "b_idx": 539,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 538,
      "b_idx": 540,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 7
    },
    {
      "a_idx": 596,
      "b_idx": 653,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 710,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 855,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 902,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 935,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 596,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 597,
      "b_idx": 601,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.69",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 598,
      "b_idx": 599,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.44",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 598,
      "b_idx": 600,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.30",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 599,
      "b_idx": 600,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.21",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 605,
      "b_idx": 673,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 637,
      "b_idx": 638,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.46",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 637,
      "b_idx": 674,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.60",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 637,
      "b_idx": 1053,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.44",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 638,
      "b_idx": 674,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.53",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 638,
      "b_idx": 1053,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.52",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 710,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 855,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 902,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 935,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 653,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 664,
      "b_idx": 669,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 674,
      "b_idx": 1053,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.51",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 675,
      "b_idx": 676,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.81",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 675,
      "b_idx": 677,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.80",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 676,
      "b_idx": 677,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.78",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 678,
      "b_idx": 999,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.55",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 678,
      "b_idx": 1000,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.69",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 678,
      "b_idx": 1496,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.25",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 678,
      "b_idx": 1498,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.10",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 678,
      "b_idx": 2115,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.35",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 855,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 902,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 935,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 710,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 809,
      "b_idx": 816,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.67",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 809,
      "b_idx": 818,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.57",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 809,
      "b_idx": 1782,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 809,
      "b_idx": 1786,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.50",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 809,
      "b_idx": 1792,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.64",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 816,
      "b_idx": 818,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.64",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 816,
      "b_idx": 1782,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.67",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 816,
      "b_idx": 1786,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.67",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 816,
      "b_idx": 1792,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.55",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 817,
      "b_idx": 819,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.67",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 818,
      "b_idx": 1782,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.57",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 818,
      "b_idx": 1786,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.47",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 818,
      "b_idx": 1792,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.44",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 855,
      "b_idx": 902,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 935,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 855,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 858,
      "b_idx": 859,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 935,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 902,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 915,
      "b_idx": 1029,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 8
    },
    {
      "a_idx": 916,
      "b_idx": 917,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.84",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 4
    },
    {
      "a_idx": 916,
      "b_idx": 918,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.82",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 4
    },
    {
      "a_idx": 916,
      "b_idx": 919,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.67",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 4
    },
    {
      "a_idx": 917,
      "b_idx": 918,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.67",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 4
    },
    {
      "a_idx": 917,
      "b_idx": 919,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.82",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 4
    },
    {
      "a_idx": 918,
      "b_idx": 919,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.85",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 4
    },
    {
      "a_idx": 935,
      "b_idx": 980,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 935,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 963,
      "b_idx": 964,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.64",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 4
    },
    {
      "a_idx": 980,
      "b_idx": 1017,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 980,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 984,
      "b_idx": 1888,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.30",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 998,
      "b_idx": 1001,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.80",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 998,
      "b_idx": 1497,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.26",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 998,
      "b_idx": 1499,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.31",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 999,
      "b_idx": 1000,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.86",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 999,
      "b_idx": 1496,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.28",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 999,
      "b_idx": 1498,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.23",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 999,
      "b_idx": 2115,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.27",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1000,
      "b_idx": 1496,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.29",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1000,
      "b_idx": 1498,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.14",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1000,
      "b_idx": 2115,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.28",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1001,
      "b_idx": 1497,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.26",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1001,
      "b_idx": 1499,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.31",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1051,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1017,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1018,
      "b_idx": 1662,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 5
    },
    {
      "a_idx": 1031,
      "b_idx": 1032,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.67",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 7
    },
    {
      "a_idx": 1031,
      "b_idx": 1033,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.82",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 7
    },
    {
      "a_idx": 1032,
      "b_idx": 1033,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.85",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 7
    },
    {
      "a_idx": 1034,
      "b_idx": 1035,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.84",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 1062,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1051,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1062,
      "b_idx": 1122,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1062,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1062,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1062,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1062,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1062,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1062,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1062,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1062,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1062,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1062,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1062,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1062,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1122,
      "b_idx": 1190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1122,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1122,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1122,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1122,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1122,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1122,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1122,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1122,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1122,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1122,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1122,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1190,
      "b_idx": 1266,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1190,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1190,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1190,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1190,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1190,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1190,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1190,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1190,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1190,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1190,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1211,
      "b_idx": 1212,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.52",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1211,
      "b_idx": 1213,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.20",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1211,
      "b_idx": 2137,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.25",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1212,
      "b_idx": 1213,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.38",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1212,
      "b_idx": 2137,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.20",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1213,
      "b_idx": 2137,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.10",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1220,
      "b_idx": 1992,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.17",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1266,
      "b_idx": 1375,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1266,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1266,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1266,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1266,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1266,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1266,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1266,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1266,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1266,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1346,
      "b_idx": 1347,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.58",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 7
    },
    {
      "a_idx": 1348,
      "b_idx": 1349,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.34",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1348,
      "b_idx": 1350,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.50",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1348,
      "b_idx": 1352,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.29",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1348,
      "b_idx": 1353,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.45",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1349,
      "b_idx": 1350,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.39",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1349,
      "b_idx": 1352,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.56",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1349,
      "b_idx": 1353,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.28",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1350,
      "b_idx": 1352,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.35",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1350,
      "b_idx": 1353,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.81",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1352,
      "b_idx": 1353,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.35",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1375,
      "b_idx": 1387,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1375,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1375,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1375,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1375,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1375,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1375,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1375,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1375,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1387,
      "b_idx": 1389,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1387,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1387,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1387,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1387,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1387,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1387,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1387,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1389,
      "b_idx": 1440,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1389,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1389,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1389,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1389,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1389,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1389,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1440,
      "b_idx": 1463,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1440,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1440,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1440,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1440,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1440,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1463,
      "b_idx": 1603,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1463,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1463,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1463,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1463,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1479,
      "b_idx": 1480,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.31",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1496,
      "b_idx": 1498,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.36",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1496,
      "b_idx": 2115,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.32",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1497,
      "b_idx": 1499,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.38",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1498,
      "b_idx": 2115,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.32",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1561,
      "b_idx": 1567,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1603,
      "b_idx": 1706,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1603,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1603,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1603,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1675,
      "b_idx": 1676,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.33",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 4
    },
    {
      "a_idx": 1706,
      "b_idx": 1829,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1706,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1706,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1746,
      "b_idx": 1756,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.57",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 5
    },
    {
      "a_idx": 1760,
      "b_idx": 1766,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 5
    },
    {
      "a_idx": 1782,
      "b_idx": 1786,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.50",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1782,
      "b_idx": 1792,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.64",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1786,
      "b_idx": 1792,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.79",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1794,
      "b_idx": 1795,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.50",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1794,
      "b_idx": 1796,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.18",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1794,
      "b_idx": 1797,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.22",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1794,
      "b_idx": 1798,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.50",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1794,
      "b_idx": 1799,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.22",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1794,
      "b_idx": 1800,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.20",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1794,
      "b_idx": 1801,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.44",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1794,
      "b_idx": 1802,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1794,
      "b_idx": 1803,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.29",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1795,
      "b_idx": 1796,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.22",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1795,
      "b_idx": 1797,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.29",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1795,
      "b_idx": 1798,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.20",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1795,
      "b_idx": 1799,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1795,
      "b_idx": 1800,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.25",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1795,
      "b_idx": 1801,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.29",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1795,
      "b_idx": 1802,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.29",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1795,
      "b_idx": 1803,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.33",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1796,
      "b_idx": 1797,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.20",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1796,
      "b_idx": 1798,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.15",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1796,
      "b_idx": 1799,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.20",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1796,
      "b_idx": 1800,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.18",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1796,
      "b_idx": 1801,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.20",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1796,
      "b_idx": 1802,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.20",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1796,
      "b_idx": 1803,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.27",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1797,
      "b_idx": 1798,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.18",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1797,
      "b_idx": 1799,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1797,
      "b_idx": 1800,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.22",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1797,
      "b_idx": 1801,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1797,
      "b_idx": 1802,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.50",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1797,
      "b_idx": 1803,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.31",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1798,
      "b_idx": 1799,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.36",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1798,
      "b_idx": 1800,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.17",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1798,
      "b_idx": 1801,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.18",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1798,
      "b_idx": 1802,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1798,
      "b_idx": 1803,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.25",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1799,
      "b_idx": 1800,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1799,
      "b_idx": 1801,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.25",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1799,
      "b_idx": 1802,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1799,
      "b_idx": 1803,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.15",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1800,
      "b_idx": 1801,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1800,
      "b_idx": 1802,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1800,
      "b_idx": 1803,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.29",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1801,
      "b_idx": 1802,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1801,
      "b_idx": 1803,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.15",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1802,
      "b_idx": 1803,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.15",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1829,
      "b_idx": 1938,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1829,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1835,
      "b_idx": 1836,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1835,
      "b_idx": 1837,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.17",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1835,
      "b_idx": 1838,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.20",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1835,
      "b_idx": 1839,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1836,
      "b_idx": 1837,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.36",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1836,
      "b_idx": 1838,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.22",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1836,
      "b_idx": 1839,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.17",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1837,
      "b_idx": 1838,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.17",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1837,
      "b_idx": 1839,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.13",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1838,
      "b_idx": 1839,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.15",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1847,
      "b_idx": 1848,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.79",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 4
    },
    {
      "a_idx": 1933,
      "b_idx": 1934,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.18",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1933,
      "b_idx": 2177,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1933,
      "b_idx": 2183,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1933,
      "b_idx": 2190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1934,
      "b_idx": 2177,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.18",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1934,
      "b_idx": 2183,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.18",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1934,
      "b_idx": 2190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.18",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1938,
      "b_idx": 2139,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1974,
      "b_idx": 1976,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.73",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1974,
      "b_idx": 1977,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.59",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1974,
      "b_idx": 1978,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.74",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1974,
      "b_idx": 1979,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.68",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1976,
      "b_idx": 1977,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.75",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1976,
      "b_idx": 1978,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.80",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1976,
      "b_idx": 1979,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.73",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1977,
      "b_idx": 1978,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.65",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1977,
      "b_idx": 1979,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.65",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1978,
      "b_idx": 1979,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.69",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 2174,
      "b_idx": 2175,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.78",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 8
    },
    {
      "a_idx": 2177,
      "b_idx": 2183,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 2177,
      "b_idx": 2190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 2178,
      "b_idx": 2184,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 2180,
      "b_idx": 2181,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.77",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 7
    },
    {
      "a_idx": 2183,
      "b_idx": 2190,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 2193,
      "b_idx": 2201,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 2193,
      "b_idx": 2203,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 2195,
      "b_idx": 2205,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 2201,
      "b_idx": 2203,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 534,
      "b_idx": 546,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 11
    },
    {
      "a_idx": 542,
      "b_idx": 544,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 10
    },
    {
      "a_idx": 928,
      "b_idx": 1043,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.62",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 11
    },
    {
      "a_idx": 928,
      "b_idx": 1045,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.70",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 11
    },
    {
      "a_idx": 1010,
      "b_idx": 1011,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.57",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 12
    },
    {
      "a_idx": 1043,
      "b_idx": 1045,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.62",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 11
    },
    {
      "a_idx": 1445,
      "b_idx": 1446,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.71",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 13
    },
    {
      "a_idx": 1445,
      "b_idx": 1447,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.64",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 13
    },
    {
      "a_idx": 1445,
      "b_idx": 1448,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.73",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 13
    },
    {
      "a_idx": 1446,
      "b_idx": 1447,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.46",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 13
    },
    {
      "a_idx": 1446,
      "b_idx": 1448,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.65",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 13
    },
    {
      "a_idx": 1447,
      "b_idx": 1448,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.39",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 13
    },
    {
      "a_idx": 934,
      "b_idx": 979,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.67",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 48
    },
    {
      "a_idx": 1095,
      "b_idx": 1635,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 38
    },
    {
      "a_idx": 1096,
      "b_idx": 1634,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "merge",
      "estimated_loc_savings": 37
    },
    {
      "a_idx": 1374,
      "b_idx": 1462,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.54",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 41
    },
    {
      "a_idx": 1374,
      "b_idx": 1705,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.75",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 41
    },
    {
      "a_idx": 1462,
      "b_idx": 1705,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.54",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 41
    },
    {
      "a_idx": 1950,
      "b_idx": 1951,
      "score": 1.0,
      "hamming": 0,
      "reason": "sequence_match=1.00, simhash_hamming=0, name_sim=0.94",
      "consolidation_potential": "high",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 45,
      "b_idx": 46,
      "score": 0.9889908256880734,
      "hamming": 0,
      "reason": "sequence_match=0.99, simhash_hamming=0, name_sim=0.86",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 18
    },
    {
      "a_idx": 1269,
      "b_idx": 1275,
      "score": 0.985981308411215,
      "hamming": 1,
      "reason": "sequence_match=0.99, simhash_hamming=1, name_sim=0.62",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 12
    },
    {
      "a_idx": 1515,
      "b_idx": 1558,
      "score": 0.9791183294663574,
      "hamming": 1,
      "reason": "sequence_match=0.98, simhash_hamming=1, name_sim=1.00",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 13
    },
    {
      "a_idx": 1870,
      "b_idx": 1871,
      "score": 0.9779552161083145,
      "hamming": 1,
      "reason": "sequence_match=0.98, simhash_hamming=1, name_sim=0.38",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 54
    },
    {
      "a_idx": 608,
      "b_idx": 609,
      "score": 0.9756357816112395,
      "hamming": 0,
      "reason": "sequence_match=0.98, simhash_hamming=0, name_sim=0.38",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 46
    },
    {
      "a_idx": 2227,
      "b_idx": 2228,
      "score": 0.9748703629836458,
      "hamming": 0,
      "reason": "sequence_match=0.97, simhash_hamming=0, name_sim=0.38",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 25
    },
    {
      "a_idx": 754,
      "b_idx": 755,
      "score": 0.972972972972973,
      "hamming": 1,
      "reason": "sequence_match=0.97, simhash_hamming=1, name_sim=0.87",
      "consolidation_potential": "medium",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 1
    },
    {
      "a_idx": 786,
      "b_idx": 787,
      "score": 0.9721115537848606,
      "hamming": 0,
      "reason": "sequence_match=0.97, simhash_hamming=0, name_sim=0.67",
      "consolidation_potential": "medium",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1076,
      "b_idx": 1078,
      "score": 0.971900826446281,
      "hamming": 1,
      "reason": "sequence_match=0.97, simhash_hamming=1, name_sim=0.46",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 8
    },
    {
      "a_idx": 1091,
      "b_idx": 1092,
      "score": 0.9715447154471545,
      "hamming": 0,
      "reason": "sequence_match=0.97, simhash_hamming=0, name_sim=0.83",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 15
    },
    {
      "a_idx": 2296,
      "b_idx": 2297,
      "score": 0.970846830171217,
      "hamming": 0,
      "reason": "sequence_match=0.97, simhash_hamming=0, name_sim=0.38",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 22
    },
    {
      "a_idx": 1153,
      "b_idx": 1589,
      "score": 0.9695652173913043,
      "hamming": 3,
      "reason": "sequence_match=0.97, simhash_hamming=3, name_sim=1.00",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 6
    },
    {
      "a_idx": 620,
      "b_idx": 621,
      "score": 0.9687344913151364,
      "hamming": 0,
      "reason": "sequence_match=0.97, simhash_hamming=0, name_sim=0.38",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 17
    },
    {
      "a_idx": 131,
      "b_idx": 132,
      "score": 0.9681093394077449,
      "hamming": 2,
      "reason": "sequence_match=0.97, simhash_hamming=2, name_sim=0.38",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 16
    },
    {
      "a_idx": 664,
      "b_idx": 675,
      "score": 0.9664429530201343,
      "hamming": 1,
      "reason": "sequence_match=0.97, simhash_hamming=1, name_sim=0.56",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 664,
      "b_idx": 676,
      "score": 0.9664429530201343,
      "hamming": 1,
      "reason": "sequence_match=0.97, simhash_hamming=1, name_sim=0.64",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 664,
      "b_idx": 677,
      "score": 0.9664429530201343,
      "hamming": 1,
      "reason": "sequence_match=0.97, simhash_hamming=1, name_sim=0.58",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 669,
      "b_idx": 675,
      "score": 0.9664429530201343,
      "hamming": 1,
      "reason": "sequence_match=0.97, simhash_hamming=1, name_sim=0.56",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 669,
      "b_idx": 676,
      "score": 0.9664429530201343,
      "hamming": 1,
      "reason": "sequence_match=0.97, simhash_hamming=1, name_sim=0.64",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 669,
      "b_idx": 677,
      "score": 0.9664429530201343,
      "hamming": 1,
      "reason": "sequence_match=0.97, simhash_hamming=1, name_sim=0.58",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 130,
      "b_idx": 131,
      "score": 0.9664,
      "hamming": 1,
      "reason": "sequence_match=0.97, simhash_hamming=1, name_sim=0.11",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 17
    },
    {
      "a_idx": 1975,
      "b_idx": 2442,
      "score": 0.9661016949152542,
      "hamming": 4,
      "reason": "sequence_match=0.97, simhash_hamming=4, name_sim=0.46",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 1867,
      "b_idx": 1868,
      "score": 0.9658703071672355,
      "hamming": 0,
      "reason": "sequence_match=0.97, simhash_hamming=0, name_sim=0.38",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 20
    },
    {
      "a_idx": 1178,
      "b_idx": 1179,
      "score": 0.9653179190751445,
      "hamming": 2,
      "reason": "sequence_match=0.97, simhash_hamming=2, name_sim=0.93",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 9
    },
    {
      "a_idx": 1419,
      "b_idx": 1420,
      "score": 0.9632224168126094,
      "hamming": 0,
      "reason": "sequence_match=0.96, simhash_hamming=0, name_sim=0.38",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 15
    },
    {
      "a_idx": 1948,
      "b_idx": 1949,
      "score": 0.9619047619047619,
      "hamming": 2,
      "reason": "sequence_match=0.96, simhash_hamming=2, name_sim=0.44",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 534,
      "b_idx": 542,
      "score": 0.96,
      "hamming": 2,
      "reason": "sequence_match=0.96, simhash_hamming=2, name_sim=1.00",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 5
    },
    {
      "a_idx": 534,
      "b_idx": 544,
      "score": 0.96,
      "hamming": 2,
      "reason": "sequence_match=0.96, simhash_hamming=2, name_sim=1.00",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 5
    },
    {
      "a_idx": 542,
      "b_idx": 546,
      "score": 0.96,
      "hamming": 2,
      "reason": "sequence_match=0.96, simhash_hamming=2, name_sim=1.00",
      "consolidation_potential": "medium",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 5
    },
    {
      "a_idx": 544,
      "b_idx": 546,
      "score": 0.96,
      "hamming": 2,
      "reason": "sequence_match=0.96, simhash_hamming=2, name_sim=1.00",
      "consolidation_potential": "medium",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 5
    },
    {
      "a_idx": 128,
      "b_idx": 129,
      "score": 0.958904109589041,
      "hamming": 2,
      "reason": "sequence_match=0.96, simhash_hamming=2, name_sim=0.15",
      "consolidation_potential": "medium",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1413,
      "b_idx": 1414,
      "score": 0.9574209245742092,
      "hamming": 0,
      "reason": "sequence_match=0.96, simhash_hamming=0, name_sim=0.34",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 17
    },
    {
      "a_idx": 1418,
      "b_idx": 1419,
      "score": 0.9574123989218328,
      "hamming": 0,
      "reason": "sequence_match=0.96, simhash_hamming=0, name_sim=0.19",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 17
    },
    {
      "a_idx": 1471,
      "b_idx": 1472,
      "score": 0.9572854291417165,
      "hamming": 0,
      "reason": "sequence_match=0.96, simhash_hamming=0, name_sim=0.17",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 34
    },
    {
      "a_idx": 78,
      "b_idx": 115,
      "score": 0.9551282051282052,
      "hamming": 1,
      "reason": "sequence_match=0.96, simhash_hamming=1, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 2273,
      "b_idx": 2274,
      "score": 0.9536423841059603,
      "hamming": 2,
      "reason": "sequence_match=0.95, simhash_hamming=2, name_sim=0.38",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 17
    },
    {
      "a_idx": 208,
      "b_idx": 209,
      "score": 0.9516129032258065,
      "hamming": 2,
      "reason": "sequence_match=0.95, simhash_hamming=2, name_sim=0.68",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 6
    },
    {
      "a_idx": 448,
      "b_idx": 1374,
      "score": 0.9515418502202643,
      "hamming": 1,
      "reason": "sequence_match=0.95, simhash_hamming=1, name_sim=0.49",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 20
    },
    {
      "a_idx": 448,
      "b_idx": 1462,
      "score": 0.9515418502202643,
      "hamming": 1,
      "reason": "sequence_match=0.95, simhash_hamming=1, name_sim=0.50",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 20
    },
    {
      "a_idx": 448,
      "b_idx": 1705,
      "score": 0.9515418502202643,
      "hamming": 1,
      "reason": "sequence_match=0.95, simhash_hamming=1, name_sim=0.57",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 20
    },
    {
      "a_idx": 981,
      "b_idx": 2210,
      "score": 0.950354609929078,
      "hamming": 1,
      "reason": "sequence_match=0.95, simhash_hamming=1, name_sim=1.00",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 3
    },
    {
      "a_idx": 418,
      "b_idx": 419,
      "score": 0.950354609929078,
      "hamming": 3,
      "reason": "sequence_match=0.95, simhash_hamming=3, name_sim=0.86",
      "consolidation_potential": "medium",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 928,
      "b_idx": 1044,
      "score": 0.95,
      "hamming": 0,
      "reason": "sequence_match=0.95, simhash_hamming=0, name_sim=1.00",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 5
    },
    {
      "a_idx": 1043,
      "b_idx": 1044,
      "score": 0.95,
      "hamming": 0,
      "reason": "sequence_match=0.95, simhash_hamming=0, name_sim=0.62",
      "consolidation_potential": "medium",
      "refactoring_strategy": "extract_utility",
      "estimated_loc_savings": 5
    },
    {
      "a_idx": 1044,
      "b_idx": 1045,
      "score": 0.95,
      "hamming": 0,
      "reason": "sequence_match=0.95, simhash_hamming=0, name_sim=0.70",
      "consolidation_potential": "medium",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 5
    },
    {
      "a_idx": 109,
      "b_idx": 2178,
      "score": 0.95,
      "hamming": 4,
      "reason": "sequence_match=0.95, simhash_hamming=4, name_sim=0.14",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 109,
      "b_idx": 2184,
      "score": 0.95,
      "hamming": 4,
      "reason": "sequence_match=0.95, simhash_hamming=4, name_sim=0.14",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1631,
      "b_idx": 2178,
      "score": 0.95,
      "hamming": 4,
      "reason": "sequence_match=0.95, simhash_hamming=4, name_sim=0.07",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 2
    },
    {
      "a_idx": 1631,
      "b_idx": 2184,
      "score": 0.95,
      "hamming": 4,
      "reason": "sequence_match=0.95, simhash_hamming=4, name_sim=0.07",
      "consolidation_potential": "high",
      "refactoring_strategy": "parameterize",
      "estimated_loc_savings": 2
    }
  ],
  "clusters": [
    [
      3,
      1053,
      637,
      638,
      674
    ],
    [
      1029,
      915
    ],
    [
      1031,
      1032,
      1033
    ],
    [
      1034,
      1035
    ],
    [
      12,
      1998
    ],
    [
      530,
      1051,
      1062,
      1603,
      596,
      2139,
      1122,
      653,
      1190,
      1706,
      710,
      207,
      240,
      1266,
      1829,
      324,
      855,
      1375,
      1387,
      1389,
      902,
      1938,
      410,
      1440,
      935,
      1463,
      449,
      468,
      980,
      1017,
      507
    ],
    [
      531,
      537,
      539
    ],
    [
      532,
      536,
      538,
      540
    ],
    [
      533,
      545
    ],
    [
      534,
      542,
      544,
      546
    ],
    [
      1043,
      1044,
      1045,
      928
    ],
    [
      1561,
      1567
    ],
    [
      45,
      46
    ],
    [
      1076,
      1078
    ],
    [
      1589,
      1153
    ],
    [
      1091,
      1092
    ],
    [
      2115,
      678,
      1496,
      1498,
      999,
      1000
    ],
    [
      1095,
      1635
    ],
    [
      1096,
      1634
    ],
    [
      78,
      115
    ],
    [
      597,
      601
    ],
    [
      598,
      599,
      600
    ],
    [
      2137,
      1211,
      1212,
      1213,
      416,
      426
    ],
    [
      605,
      673
    ],
    [
      1631,
      109,
      2178,
      2184
    ],
    [
      608,
      609
    ],
    [
      620,
      621
    ],
    [
      126,
      125
    ],
    [
      124,
      2177,
      2183,
      2190,
      367,
      1933,
      1934
    ],
    [
      2174,
      2175
    ],
    [
      2180,
      2181
    ],
    [
      131,
      130,
      132
    ],
    [
      128,
      129
    ],
    [
      1675,
      1676
    ],
    [
      2193,
      2201,
      2203
    ],
    [
      2195,
      2205,
      398
    ],
    [
      664,
      669,
      675,
      676,
      677
    ],
    [
      1178,
      1179
    ],
    [
      1558,
      1515
    ],
    [
      2210,
      981
    ],
    [
      1705,
      1374,
      1462,
      448
    ],
    [
      1662,
      1018
    ],
    [
      2227,
      2228
    ],
    [
      1220,
      278,
      1992
    ],
    [
      208,
      209
    ],
    [
      1746,
      1756
    ],
    [
      1760,
      1766
    ],
    [
      2273,
      2274
    ],
    [
      754,
      755
    ],
    [
      1269,
      1275
    ],
    [
      1782,
      1786,
      1792,
      809,
      816,
      818
    ],
    [
      2296,
      2297
    ],
    [
      1794,
      1795,
      1796,
      1797,
      1798,
      1799,
      1800,
      1801,
      1802,
      1803
    ],
    [
      786,
      787
    ],
    [
      1835,
      1836,
      1837,
      1838,
      1839
    ],
    [
      817,
      819
    ],
    [
      1847,
      1848
    ],
    [
      316,
      1888,
      984
    ],
    [
      319,
      322
    ],
    [
      1346,
      1347
    ],
    [
      1348,
      1349,
      1350,
      1352,
      1353
    ],
    [
      329,
      332
    ],
    [
      1867,
      1868
    ],
    [
      1870,
      1871
    ],
    [
      858,
      859
    ],
    [
      1413,
      1414
    ],
    [
      1418,
      1419,
      1420
    ],
    [
      2442,
      1975
    ],
    [
      916,
      917,
      918,
      919
    ],
    [
      1948,
      1949
    ],
    [
      1950,
      1951
    ],
    [
      418,
      419
    ],
    [
      1445,
      1446,
      1447,
      1448
    ],
    [
      934,
      979
    ],
    [
      1974,
      1976,
      1977,
      1978,
      1979
    ],
    [
      1471,
      1472
    ],
    [
      963,
      964
    ],
    [
      1479,
      1480
    ],
    [
      1497,
      1499,
      998,
      1001
    ],
    [
      1010,
      1011
    ]
  ],
  "consolidation_clusters": [
    {
      "function_indices": [
        530,
        1051,
        1062,
        1603,
        596,
        2139,
        1122,
        653,
        1190,
        1706,
        710,
        207,
        240,
        1266,
        1829,
        324,
        855,
        1375,
        1387,
        1389,
        902,
        1938,
        410,
        1440,
        935,
        1463,
        449,
        468,
        980,
        1017,
        507
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "extract_common_test_utility",
      "estimated_savings": 83,
      "priority_score": 7719.0
    },
    {
      "function_indices": [
        1705,
        1374,
        1462,
        448
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 56,
      "priority_score": 224
    },
    {
      "function_indices": [
        1870,
        1871
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 74,
      "priority_score": 148
    },
    {
      "function_indices": [
        608,
        609
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 63,
      "priority_score": 126
    },
    {
      "function_indices": [
        1794,
        1795,
        1796,
        1797,
        1798,
        1799,
        1800,
        1801,
        1802,
        1803
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 10,
      "priority_score": 120.0
    },
    {
      "function_indices": [
        1418,
        1419,
        1420
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 37,
      "priority_score": 111
    },
    {
      "function_indices": [
        131,
        130,
        132
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 35,
      "priority_score": 105
    },
    {
      "function_indices": [
        1782,
        1786,
        1792,
        809,
        816,
        818
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "single_utility_function",
      "estimated_savings": 9,
      "priority_score": 97.2
    },
    {
      "function_indices": [
        1471,
        1472
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 48,
      "priority_score": 96
    },
    {
      "function_indices": [
        124,
        2177,
        2183,
        2190,
        367,
        1933,
        1934
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "common_base_class",
      "estimated_savings": 9,
      "priority_score": 75.6
    },
    {
      "function_indices": [
        2227,
        2228
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 34,
      "priority_score": 68
    },
    {
      "function_indices": [
        1445,
        1446,
        1447,
        1448
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 17,
      "priority_score": 68
    },
    {
      "function_indices": [
        934,
        979
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 32,
      "priority_score": 64
    },
    {
      "function_indices": [
        2296,
        2297
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 31,
      "priority_score": 62
    },
    {
      "function_indices": [
        1631,
        109,
        2178,
        2184
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "single_utility_function",
      "estimated_savings": 5,
      "priority_score": 60.0
    },
    {
      "function_indices": [
        534,
        542,
        544,
        546
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 14,
      "priority_score": 56
    },
    {
      "function_indices": [
        1043,
        1044,
        1045,
        928
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 14,
      "priority_score": 56
    },
    {
      "function_indices": [
        1867,
        1868
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 28,
      "priority_score": 56
    },
    {
      "function_indices": [
        1095,
        1635
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 25,
      "priority_score": 50
    },
    {
      "function_indices": [
        1413,
        1414
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 25,
      "priority_score": 50
    },
    {
      "function_indices": [
        1096,
        1634
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 24,
      "priority_score": 48
    },
    {
      "function_indices": [
        620,
        621
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 24,
      "priority_score": 48
    },
    {
      "function_indices": [
        2273,
        2274
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 24,
      "priority_score": 48
    },
    {
      "function_indices": [
        2115,
        678,
        1496,
        1498,
        999,
        1000
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 6,
      "priority_score": 43.199999999999996
    },
    {
      "function_indices": [
        2137,
        1211,
        1212,
        1213,
        416,
        426
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 6,
      "priority_score": 43.199999999999996
    },
    {
      "function_indices": [
        1091,
        1092
      ],
      "cluster_type": "template",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 20,
      "priority_score": 40
    },
    {
      "function_indices": [
        532,
        536,
        538,
        540
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 9,
      "priority_score": 36
    },
    {
      "function_indices": [
        1558,
        1515
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 17,
      "priority_score": 34
    },
    {
      "function_indices": [
        1269,
        1275
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 16,
      "priority_score": 32
    },
    {
      "function_indices": [
        3,
        1053,
        637,
        638,
        674
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 5,
      "priority_score": 25
    },
    {
      "function_indices": [
        664,
        669,
        675,
        676,
        677
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 5,
      "priority_score": 25
    },
    {
      "function_indices": [
        1835,
        1836,
        1837,
        1838,
        1839
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 5,
      "priority_score": 25
    },
    {
      "function_indices": [
        1348,
        1349,
        1350,
        1352,
        1353
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 5,
      "priority_score": 25
    },
    {
      "function_indices": [
        1974,
        1976,
        1977,
        1978,
        1979
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 5,
      "priority_score": 25
    },
    {
      "function_indices": [
        45,
        46
      ],
      "cluster_type": "template",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 12,
      "priority_score": 24
    },
    {
      "function_indices": [
        1178,
        1179
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 12,
      "priority_score": 24
    },
    {
      "function_indices": [
        1031,
        1032,
        1033
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 7,
      "priority_score": 21
    },
    {
      "function_indices": [
        1076,
        1078
      ],
      "cluster_type": "template",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 10,
      "priority_score": 20
    },
    {
      "function_indices": [
        916,
        917,
        918,
        919
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 5,
      "priority_score": 20
    },
    {
      "function_indices": [
        1589,
        1153
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 9,
      "priority_score": 18
    },
    {
      "function_indices": [
        208,
        209
      ],
      "cluster_type": "template",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 8,
      "priority_score": 16
    },
    {
      "function_indices": [
        1497,
        1499,
        998,
        1001
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 4,
      "priority_score": 16
    },
    {
      "function_indices": [
        1010,
        1011
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 8,
      "priority_score": 16
    },
    {
      "function_indices": [
        316,
        1888,
        984
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "single_utility_function",
      "estimated_savings": 3,
      "priority_score": 13.5
    },
    {
      "function_indices": [
        1029,
        915
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 5,
      "priority_score": 10
    },
    {
      "function_indices": [
        2174,
        2175
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 5,
      "priority_score": 10
    },
    {
      "function_indices": [
        531,
        537,
        539
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 3,
      "priority_score": 9
    },
    {
      "function_indices": [
        598,
        599,
        600
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 3,
      "priority_score": 9
    },
    {
      "function_indices": [
        1220,
        278,
        1992
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 3,
      "priority_score": 9
    },
    {
      "function_indices": [
        2180,
        2181
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 4,
      "priority_score": 8
    },
    {
      "function_indices": [
        786,
        787
      ],
      "cluster_type": "template",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 4,
      "priority_score": 8
    },
    {
      "function_indices": [
        1346,
        1347
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 4,
      "priority_score": 8
    },
    {
      "function_indices": [
        329,
        332
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 4,
      "priority_score": 8
    },
    {
      "function_indices": [
        533,
        545
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 3,
      "priority_score": 6
    },
    {
      "function_indices": [
        128,
        129
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 3,
      "priority_score": 6
    },
    {
      "function_indices": [
        2193,
        2201,
        2203
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 6
    },
    {
      "function_indices": [
        2195,
        2205,
        398
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 6
    },
    {
      "function_indices": [
        1662,
        1018
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 3,
      "priority_score": 6
    },
    {
      "function_indices": [
        1746,
        1756
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 3,
      "priority_score": 6
    },
    {
      "function_indices": [
        1760,
        1766
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 3,
      "priority_score": 6
    },
    {
      "function_indices": [
        1034,
        1035
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        12,
        1998
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        78,
        115
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        597,
        601
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        605,
        673
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        1675,
        1676
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        2210,
        981
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        754,
        755
      ],
      "cluster_type": "template",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        1847,
        1848
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        319,
        322
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        858,
        859
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        2442,
        1975
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        418,
        419
      ],
      "cluster_type": "template",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        963,
        964
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        1479,
        1480
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 2,
      "priority_score": 4
    },
    {
      "function_indices": [
        1561,
        1567
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "single_utility_function",
      "estimated_savings": 1,
      "priority_score": 3.0
    },
    {
      "function_indices": [
        1948,
        1949
      ],
      "cluster_type": "similar_structure",
      "consolidation_strategy": "single_utility_function",
      "estimated_savings": 1,
      "priority_score": 3.0
    },
    {
      "function_indices": [
        1950,
        1951
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "single_utility_function",
      "estimated_savings": 1,
      "priority_score": 3.0
    },
    {
      "function_indices": [
        126,
        125
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 1,
      "priority_score": 2
    },
    {
      "function_indices": [
        817,
        819
      ],
      "cluster_type": "identical",
      "consolidation_strategy": "merge_similar_functions",
      "estimated_savings": 1,
      "priority_score": 2
    }
  ],
  "consolidation_summary": {
    "total_estimated_savings": 987,
    "high_priority_clusters": 7,
    "total_clusters": 80,
    "top_recommendations": [
      {
        "cluster_type": "identical",
        "strategy": "extract_common_test_utility",
        "functions": [
          "run_comprehensive_tests",
          "run_comprehensive_tests",
          "run_comprehensive_tests",
          "run_comprehensive_tests",
          "run_comprehensive_tests",
          "... and 26 more"
        ],
        "estimated_savings": 83,
        "priority_score": 7719.0
      },
      {
        "cluster_type": "similar_structure",
        "strategy": "merge_similar_functions",
        "functions": [
          "research_prioritization_module_tests",
          "message_personalization_module_tests",
          "performance_dashboard_module_tests",
          "adaptive_rate_limiter_module_tests"
        ],
        "estimated_savings": 56,
        "priority_score": 224
      },
      {
        "cluster_type": "similar_structure",
        "strategy": "merge_similar_functions",
        "functions": [
          "decorator",
          "wrapper"
        ],
        "estimated_savings": 74,
        "priority_score": 148
      },
      {
        "cluster_type": "similar_structure",
        "strategy": "merge_similar_functions",
        "functions": [
          "decorator",
          "wrapper"
        ],
        "estimated_savings": 63,
        "priority_score": 126
      },
      {
        "cluster_type": "identical",
        "strategy": "merge_similar_functions",
        "functions": [
          "Colors.green",
          "Colors.red",
          "Colors.yellow",
          "Colors.blue",
          "Colors.magenta",
          "... and 5 more"
        ],
        "estimated_savings": 10,
        "priority_score": 120.0
      },
      {
        "cluster_type": "similar_structure",
        "strategy": "merge_similar_functions",
        "functions": [
          "progressive_processing",
          "decorator",
          "wrapper"
        ],
        "estimated_savings": 37,
        "priority_score": 111
      },
      {
        "cluster_type": "similar_structure",
        "strategy": "merge_similar_functions",
        "functions": [
          "decorator",
          "api_cache",
          "wrapper"
        ],
        "estimated_savings": 35,
        "priority_score": 105
      },
      {
        "cluster_type": "identical",
        "strategy": "single_utility_function",
        "functions": [
          "test_func",
          "sample_function",
          "temp_function",
          "test_func",
          "safe_func",
          "... and 1 more"
        ],
        "estimated_savings": 9,
        "priority_score": 97.2
      },
      {
        "cluster_type": "similar_structure",
        "strategy": "merge_similar_functions",
        "functions": [
          "PerformanceMonitor.profile_function",
          "PerformanceMonitor.wrapper"
        ],
        "estimated_savings": 48,
        "priority_score": 96
      },
      {
        "cluster_type": "identical",
        "strategy": "common_base_class",
        "functions": [
          "ColorLogger.__init__",
          "TestDIContainer.ServiceC.__init__",
          "TestDIContainer.ServiceG.__init__",
          "TestDIContainer.ServiceL.__init__",
          "BatchCommitManager.__init__",
          "... and 2 more"
        ],
        "estimated_savings": 9,
        "priority_score": 75.6
      }
    ]
  }
}