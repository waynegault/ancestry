<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Code Graph Viewer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/vis-network@9.1.6/dist/vis-network.min.js"></script>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #0b1223;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --accent: #22d3ee;
      --accent-2: #f59e0b;
      --border: rgba(255, 255, 255, 0.08);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: 'Space Grotesk', sans-serif;
      background: linear-gradient(135deg, var(--bg) 0%, #0a0f1d 60%, #0b1223 100%);
      color: var(--text);
      min-height: 100vh;
    }

    .app {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    header h1 {
      margin: 0 0 8px 0;
      font-size: 24px;
      color: var(--accent);
    }

    .subtitle {
      color: var(--muted);
      margin: 0 0 16px 0;
      font-size: 14px;
    }

    .controls {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      align-items: center;
    }

    .controls input,
    .controls select {
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
    }

    .controls input { flex: 1; min-width: 200px; }

    .controls input:focus,
    .controls select:focus {
      border-color: var(--accent);
    }

    .toggle-group {
      display: flex;
      gap: 4px;
    }

    .toggle-group button {
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--muted);
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
    }

    .toggle-group button.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }

    .badges {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }

    .badge {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
    }

    .badge-label {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .badge-value {
      font-size: 16px;
      font-weight: 600;
      color: var(--accent);
    }

    .status {
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 12px;
    }

    #graphContainer {
      width: 100%;
      height: 70vh;
      min-height: 500px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--panel-2);
    }

    #listContainer {
      display: none;
    }

    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 12px;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .card-name {
      font-weight: 600;
      color: var(--text);
    }

    .card-type {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 4px;
      background: var(--accent);
      color: var(--bg);
    }

    .card-type.file { background: var(--accent-2); }
    .card-type.class { background: #a855f7; }
    .card-type.method { background: #ec4899; }

    .card-path {
      font-size: 12px;
      color: var(--muted);
      word-break: break-all;
    }

    .card-summary {
      font-size: 13px;
      color: var(--muted);
      margin-top: 8px;
    }

    .empty {
      text-align: center;
      padding: 40px;
      color: var(--muted);
    }

    .legend {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-bottom: 12px;
      font-size: 13px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Code Graph Viewer</h1>
      <p class="subtitle">Interactive visualization of <code>docs/code_graph.json</code></p>
    </header>

    <div class="controls">
      <input type="text" id="search" placeholder="Search by name, path, or summary..." />
      <select id="typeFilter">
        <option value="">All types</option>
      </select>
      <select id="areaFilter">
        <option value="">All areas</option>
      </select>
      <div class="toggle-group">
        <button id="graphViewBtn" class="active">Graph View</button>
        <button id="listViewBtn">List View</button>
      </div>
    </div>

    <div class="badges">
      <div class="badge">
        <div class="badge-label">Total Nodes</div>
        <div class="badge-value" id="countNodes">-</div>
      </div>
      <div class="badge">
        <div class="badge-label">Total Links</div>
        <div class="badge-value" id="countLinks">-</div>
      </div>
      <div class="badge">
        <div class="badge-label">Last Updated</div>
        <div class="badge-value" id="lastUpdated">-</div>
      </div>
      <div class="badge">
        <div class="badge-label">Scope</div>
        <div class="badge-value" id="scope" style="font-size: 12px; line-height: 1.4;">-</div>
      </div>
    </div>

    <div class="legend">
      <div class="legend-item"><div class="legend-dot" style="background: #f59e0b;"></div> File</div>
      <div class="legend-item"><div class="legend-dot" style="background: #a855f7;"></div> Class</div>
      <div class="legend-item"><div class="legend-dot" style="background: #22d3ee;"></div> Function</div>
      <div class="legend-item"><div class="legend-dot" style="background: #ec4899;"></div> Method</div>
      <div class="legend-item"><div class="legend-dot" style="background: #94a3b8;"></div> Other</div>
    </div>

    <div id="status" class="status">Loading graph data...</div>
    <div id="graphContainer"></div>
    <div id="listContainer">
      <div class="card-grid" id="cardGrid"></div>
    </div>
  </div>

  <script>
    const state = {
      nodes: [],
      links: [],
      filters: { search: '', type: '', area: '' },
      network: null,
    };

    const searchInput = document.getElementById('search');
    const typeFilter = document.getElementById('typeFilter');
    const areaFilter = document.getElementById('areaFilter');
    const statusEl = document.getElementById('status');
    const graphContainer = document.getElementById('graphContainer');
    const listContainer = document.getElementById('listContainer');
    const cardGrid = document.getElementById('cardGrid');

    function getNodeColor(type) {
      const colors = {
        file: '#f59e0b',
        class: '#a855f7',
        function: '#22d3ee',
        method: '#ec4899',
      };
      return colors[type] || '#94a3b8';
    }

    function getNodeShape(type) {
      return type === 'file' ? 'diamond' : 'dot';
    }

    function dedupe(arr) {
      return [...new Set(arr)].sort();
    }

    function populateFilters() {
      const types = dedupe(state.nodes.map(n => n.type || 'unknown'));
      typeFilter.innerHTML = '<option value="">All types</option>' +
        types.map(t => `<option value="${t}">${t}</option>`).join('');

      const areas = dedupe(state.nodes.map(n => (n.path || '').split('/')[0] || '').filter(Boolean));
      areaFilter.innerHTML = '<option value="">All areas</option>' +
        areas.map(a => `<option value="${a}">${a}</option>`).join('');
    }

    function applyFilters() {
      const term = state.filters.search.toLowerCase();
      const type = state.filters.type;
      const area = state.filters.area;

      return state.nodes.filter(node => {
        if (type && node.type !== type) return false;
        if (area && !(node.path || '').startsWith(area)) return false;
        if (term) {
          const haystack = `${node.name || ''} ${node.summary || ''} ${node.path || ''}`.toLowerCase();
          if (!haystack.includes(term)) return false;
        }
        return true;
      });
    }

    function renderGraph(filteredNodes) {
      const nodeIds = new Set(filteredNodes.map(n => n.id));

      // Smart node selection: prioritize files (hubs) and their connections
      const maxNodes = 500;
      let limitedNodes;

      if (filteredNodes.length > maxNodes) {
        // Start with file nodes (these are the hubs with many connections)
        const fileNodes = filteredNodes.filter(n => n.type === 'file');
        const fileIds = new Set(fileNodes.map(n => n.id));

        // Find nodes connected to files
        const connectedIds = new Set();
        for (const link of state.links) {
          if (fileIds.has(link.source) && nodeIds.has(link.target)) {
            connectedIds.add(link.target);
          }
          if (fileIds.has(link.target) && nodeIds.has(link.source)) {
            connectedIds.add(link.source);
          }
        }

        // Build priority list: files first, then connected nodes, then others
        const connectedNodes = filteredNodes.filter(n => connectedIds.has(n.id) && !fileIds.has(n.id));
        const otherNodes = filteredNodes.filter(n => !connectedIds.has(n.id) && !fileIds.has(n.id));

        // Take files + connected nodes up to maxNodes
        const prioritized = [...fileNodes, ...connectedNodes, ...otherNodes];
        limitedNodes = prioritized.slice(0, maxNodes);
      } else {
        limitedNodes = filteredNodes;
      }

      const limitedNodeIds = new Set(limitedNodes.map(n => n.id));

      // Build vis.js dataset
      const visNodes = new vis.DataSet(limitedNodes.map(n => ({
        id: n.id,
        label: n.name || n.id.split(':').pop() || n.id,
        title: `${n.name || n.id}\n${n.path || ''}\n${n.summary || ''}`,
        color: {
          background: getNodeColor(n.type),
          border: getNodeColor(n.type),
          highlight: { background: '#fff', border: getNodeColor(n.type) },
        },
        shape: getNodeShape(n.type),
        size: n.type === 'file' ? 20 : 12,
        font: { color: '#e5e7eb', size: 10 },
      })));

      // Filter links to only include visible nodes
      const visEdges = new vis.DataSet(
        state.links
          .filter(l => limitedNodeIds.has(l.source) && limitedNodeIds.has(l.target))
          .map((l, i) => ({
            id: i,
            from: l.source,
            to: l.target,
            arrows: 'to',
            color: { color: 'rgba(148, 163, 184, 0.3)', highlight: '#22d3ee' },
            title: l.kind || 'relates to',
          }))
      );

      const options = {
        nodes: {
          borderWidth: 2,
          shadow: true,
        },
        edges: {
          width: 1,
          smooth: { type: 'continuous' },
        },
        physics: {
          enabled: true,
          solver: 'forceAtlas2Based',
          forceAtlas2Based: {
            gravitationalConstant: -50,
            centralGravity: 0.01,
            springLength: 100,
            springConstant: 0.08,
          },
          stabilization: {
            enabled: true,
            iterations: 200,
            updateInterval: 25,
          },
        },
        interaction: {
          hover: true,
          tooltipDelay: 100,
          zoomView: true,
          dragView: true,
        },
      };

      if (state.network) {
        state.network.destroy();
      }

      state.network = new vis.Network(graphContainer, { nodes: visNodes, edges: visEdges }, options);

      const edgeCount = visEdges.length;
      let statusText;
      if (filteredNodes.length > maxNodes) {
        statusText = `Showing ${maxNodes} of ${filteredNodes.length} nodes (${edgeCount} edges). Filter by area to see connections.`;
      } else {
        statusText = `Showing ${limitedNodes.length} nodes, ${edgeCount} edges.`;
      }
      if (edgeCount === 0 && limitedNodes.length > 0) {
        statusText += ' Try selecting an area filter to see connections.';
      }
      statusEl.textContent = statusText;
    }

    function renderList(filteredNodes) {
      cardGrid.innerHTML = '';
      const maxCards = 200;
      const limited = filteredNodes.slice(0, maxCards);

      if (!limited.length) {
        cardGrid.innerHTML = '<div class="empty">No nodes match your filters.</div>';
        return;
      }

      for (const node of limited) {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
          <div class="card-header">
            <span class="card-name">${node.name || node.id}</span>
            <span class="card-type ${node.type || ''}">${node.type || 'unknown'}</span>
          </div>
          <div class="card-path">${node.path || ''}</div>
          ${node.summary ? `<div class="card-summary">${node.summary}</div>` : ''}
        `;
        cardGrid.appendChild(card);
      }

      if (filteredNodes.length > maxCards) {
        statusEl.textContent = `Showing ${maxCards} of ${filteredNodes.length} results.`;
      } else {
        statusEl.textContent = `Showing ${limited.length} results.`;
      }
    }

    function update() {
      const filtered = applyFilters();
      if (graphContainer.style.display !== 'none') {
        renderGraph(filtered);
      } else {
        renderList(filtered);
      }
    }

    async function loadGraph() {
      const paths = ['code_graph.json', '/docs/code_graph.json'];
      let data = null;

      for (const path of paths) {
        try {
          const res = await fetch(path);
          if (res.ok) {
            data = await res.json();
            break;
          }
        } catch (e) {
          console.warn(`Failed to load ${path}:`, e);
        }
      }

      if (!data) {
        statusEl.textContent = 'Failed to load code_graph.json';
        graphContainer.innerHTML = '<div class="empty">Could not load graph data.</div>';
        return;
      }

      state.nodes = data.nodes || [];
      state.links = data.links || [];

      document.getElementById('countNodes').textContent = state.nodes.length.toLocaleString();
      document.getElementById('countLinks').textContent = state.links.length.toLocaleString();
      document.getElementById('lastUpdated').textContent = data.metadata?.lastUpdated?.split('T')[0] || 'Unknown';
      document.getElementById('scope').textContent = data.metadata?.scope || 'Not specified';

      populateFilters();
      update();
    }

    // Event listeners
    searchInput.addEventListener('input', e => {
      state.filters.search = e.target.value;
      update();
    });

    typeFilter.addEventListener('change', e => {
      state.filters.type = e.target.value;
      update();
    });

    areaFilter.addEventListener('change', e => {
      state.filters.area = e.target.value;
      update();
    });

    document.getElementById('graphViewBtn').addEventListener('click', function() {
      this.classList.add('active');
      document.getElementById('listViewBtn').classList.remove('active');
      graphContainer.style.display = '';
      listContainer.style.display = 'none';
      update();
    });

    document.getElementById('listViewBtn').addEventListener('click', function() {
      this.classList.add('active');
      document.getElementById('graphViewBtn').classList.remove('active');
      graphContainer.style.display = 'none';
      listContainer.style.display = '';
      update();
    });

    loadGraph();
  </script>
</body>
</html>
