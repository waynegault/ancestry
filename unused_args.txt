action11.py:1549:44: ARG001 Unused function argument: `event_type`
     |
1549 | def _select_best_event(events: List[Dict], event_type: str) -> Optional[Dict]:
     |                                            ^^^^^^^^^^ ARG001
1550 |     """Select best event from list based on alternate status and place detail."""
1551 |     if not events:
     |

action6_gather.py:614:38: ARG001 Unused function argument: `config_schema_arg`
    |
612 | @error_context("DNA match gathering coordination")
613 | def coord(  # type: ignore
614 |     session_manager: SessionManager, config_schema_arg: "ConfigSchema", start: int = 1
    |                                      ^^^^^^^^^^^^^^^^^ ARG001
615 | ) -> bool:  # Uses config schema
616 |     """
    |

action6_gather.py:1321:5: ARG001 Unused function argument: `session`
     |
1320 | def _prepare_bulk_db_data(
1321 |     session: SqlAlchemySession,
     |     ^^^^^^^ ARG001
1322 |     session_manager: SessionManager,
1323 |     matches_to_process: List[Dict[str, Any]],
     |

action6_gather.py:3069:5: ARG001 Unused function argument: `config_schema_arg`
     |
3067 |     prefetched_combined_details: Optional[Dict[str, Any]],
3068 |     prefetched_tree_data: Optional[Dict[str, Any]],
3069 |     config_schema_arg: "ConfigSchema",
     |     ^^^^^^^^^^^^^^^^^ ARG001
3070 |     logger_instance: logging.Logger,
3071 | ) -> Tuple[
     |

action7_inbox.py:1400:9: ARG002 Unused method argument: `error`
     |
1398 |         person_updates: dict[int, PersonStatusEnum],
1399 |         exception_type: str,
1400 |         error: Exception,
     |         ^^^^^ ARG002
1401 |     ) -> tuple[int, int]:
1402 |         """Handle exception and attempt final save."""
     |

action8_messaging.py:1811:27: ARG001 Unused function argument: `person`
     |
1811 | def _handle_desist_status(person: Person, log_prefix: str, latest_out_log: Optional[ConversationLog], message_type_map: dict[str, int]) -> tuple[Optional[str], str]:
     |                           ^^^^^^ ARG001
1812 |     """Handle DESIST status and return message key and reason if ACK needed."""
1813 |     logger.debug(f"{log_prefix}: Status is DESIST. Checking if Desist ACK needed.")
     |

action8_messaging.py:2713:5: ARG001 Unused function argument: `resource_manager`
     |
2711 |     session_manager: SessionManager,
2712 |     message_type_map: dict,
2713 |     resource_manager: Any,
     |     ^^^^^^^^^^^^^^^^ ARG001
2714 |     error_categorizer: Any,
2715 |     max_messages_to_send_this_run: int,
     |

adaptive_rate_limiter.py:832:9: ARG002 Unused method argument: `system_metrics`
    |
830 |         rate_limiter_stats: RateLimitingStats,
831 |         batch_processor_summary: dict[str, Any],
832 |         system_metrics: Optional[dict[str, Any]] = None
    |         ^^^^^^^^^^^^^^ ARG002
833 |     ) -> dict[str, Any]:
834 |         """
    |

cache.py:1118:50: ARG002 Unused method argument: `session_manager`
     |
1116 |         return False
1117 | 
1118 |     def _warm_profile_data(self, cache_key: str, session_manager: Optional[Any] = None) -> bool:
     |                                                  ^^^^^^^^^^^^^^^ ARG002
1119 |         """Warm profile-related cache data."""
1120 |         try:
     |

chromedriver.py:337:17: ARG001 Unused function argument: `attach_attempt`
    |
337 | def init_webdvr(attach_attempt=False) -> Optional[WebDriver]:
    |                 ^^^^^^^^^^^^^^ ARG001
338 |     """
339 |     V2.0 MODERNIZED: Uses standard Selenium WebDriver with automatic ChromeDriver management.
    |

config\credential_manager.py:501:43: ARG002 Unused method argument: `module`
    |
500 |         class TestSuite:
501 |             def __init__(self, name: str, module: Any = None):
    |                                           ^^^^^^ ARG002
502 |                 self.name = name
503 |                 self.tests_passed = 0
    |

config\credential_manager.py:510:50: ARG002 Unused method argument: `description`
    |
509 |             def run_test(
510 |                 self, name: str, func: Callable, description: str = ""
    |                                                  ^^^^^^^^^^^ ARG002
511 |             ) -> None:
512 |                 try:
    |

core\__init__.py:70:29: ARG002 Unused method argument: `args`
   |
68 |             self.name = name
69 | 
70 |         def __call__(self, *args: Any, **kwargs: Any) -> 'DummyComponent':
   |                             ^^^^ ARG002
71 |             return self
   |

core\__init__.py:70:42: ARG002 Unused method argument: `kwargs`
   |
68 |             self.name = name
69 | 
70 |         def __call__(self, *args: Any, **kwargs: Any) -> 'DummyComponent':
   |                                          ^^^^^^ ARG002
71 |             return self
   |

core\api_manager.py:364:39: ARG002 Unused method argument: `session_manager`
    |
362 |         return all_ok
363 | 
364 |     def verify_api_login_status(self, session_manager=None) -> Optional[bool]:
    |                                       ^^^^^^^^^^^^^^^ ARG002
365 |         """
366 |         Verify login status via API using comprehensive verification with fallbacks.
    |

core\database_manager.py:482:59: ARG001 Unused function argument: `connection_record`
    |
480 |         """Attach event listener for SQLite PRAGMA settings."""
481 |         @event.listens_for(self.engine, "connect")
482 |         def enable_sqlite_settings(dbapi_connection: Any, connection_record: Any) -> None:
    |                                                           ^^^^^^^^^^^^^^^^^ ARG001
483 |             cursor = dbapi_connection.cursor()
484 |             try:
    |

core\error_handling.py:651:5: ARG001 Unused function argument: `severity`
    |
649 | def error_handler(
650 |     category: ErrorCategory = ErrorCategory.SYSTEM,
651 |     severity: ErrorSeverity = ErrorSeverity.MEDIUM,
    |     ^^^^^^^^ ARG001
652 |     log_errors: bool = True,
653 |     reraise: bool = False,
    |

core\error_handling.py:792:30: ARG002 Unused method argument: `error`
    |
790 |     # Default handler for unknown types
791 |     class DefaultHandler(ErrorHandler):
792 |         def can_handle(self, error: Exception) -> bool:
    |                              ^^^^^ ARG002
793 |             return True  # Catch-all for unknown errors
    |

core\error_handling.py:1046:33: ARG001 Unused function argument: `signum`
     |
1044 |             import signal
1045 | 
1046 |             def timeout_handler(signum: int, frame: Any) -> None:
     |                                 ^^^^^^ ARG001
1047 |                 raise TimeoutError(f"Function {func.__name__} timed out after {timeout} seconds")
     |

core\error_handling.py:1046:46: ARG001 Unused function argument: `frame`
     |
1044 |             import signal
1045 | 
1046 |             def timeout_handler(signum: int, frame: Any) -> None:
     |                                              ^^^^^ ARG001
1047 |                 raise TimeoutError(f"Function {func.__name__} timed out after {timeout} seconds")
     |

core\error_handling.py:1128:32: ARG001 Unused function argument: `args`
     |
1126 | # === RECOVERY STRATEGIES ===
1127 | 
1128 | def ancestry_session_recovery(*args, **kwargs) -> None:
     |                                ^^^^ ARG001
1129 |     """Recovery strategy for session-related failures."""
1130 |     logger.info("Attempting session recovery...")
     |

core\error_handling.py:1128:40: ARG001 Unused function argument: `kwargs`
     |
1126 | # === RECOVERY STRATEGIES ===
1127 | 
1128 | def ancestry_session_recovery(*args, **kwargs) -> None:
     |                                        ^^^^^^ ARG001
1129 |     """Recovery strategy for session-related failures."""
1130 |     logger.info("Attempting session recovery...")
     |

core\error_handling.py:1134:28: ARG001 Unused function argument: `args`
     |
1134 | def ancestry_api_recovery(*args, **kwargs) -> None:
     |                            ^^^^ ARG001
1135 |     """Recovery strategy for API-related failures."""
1136 |     logger.info("Attempting API recovery...")
     |

core\error_handling.py:1134:36: ARG001 Unused function argument: `kwargs`
     |
1134 | def ancestry_api_recovery(*args, **kwargs) -> None:
     |                                    ^^^^^^ ARG001
1135 |     """Recovery strategy for API-related failures."""
1136 |     logger.info("Attempting API recovery...")
     |

core\error_handling.py:1140:33: ARG001 Unused function argument: `args`
     |
1140 | def ancestry_database_recovery(*args, **kwargs) -> None:
     |                                 ^^^^ ARG001
1141 |     """Recovery strategy for database-related failures."""
1142 |     logger.info("Attempting database recovery...")
     |

core\error_handling.py:1140:41: ARG001 Unused function argument: `kwargs`
     |
1140 | def ancestry_database_recovery(*args, **kwargs) -> None:
     |                                         ^^^^^^ ARG001
1141 |     """Recovery strategy for database-related failures."""
1142 |     logger.info("Attempting database recovery...")
     |

core\session_validator.py:245:32: ARG002 Unused method argument: `browser_manager`
    |
243 |             return False, error_msg
244 | 
245 |     def _attempt_relogin(self, browser_manager, session_manager) -> bool:
    |                                ^^^^^^^^^^^^^^^ ARG002
246 |         """
247 |         Attempt to relogin the user.
    |

credentials.py:1011:54: ARG002 Unused method argument: `description`
     |
1009 |             )
1010 | 
1011 |     def _save_credential(self, key: str, value: str, description: str) -> bool:
     |                                                      ^^^^^^^^^^^ ARG002
1012 |         """Save a credential to the secure store.
     |

database.py:965:32: ARG001 Unused function argument: `key`
    |
965 | def _validate_optional_numeric(key: str, value: Any, allow_float: bool = False) -> Optional[Union[int, float]]:
    |                                ^^^ ARG001
966 |     """Validate optional numeric field."""
967 |     if value is None:
    |

database.py:1856:78: ARG001 Unused function argument: `log_prefix`
     |
1856 | def _prepare_person_update_data(person_updates: dict[int, PersonStatusEnum], log_prefix: str) -> list[dict[str, Any]]:
     |                                                                              ^^^^^^^^^^ ARG001
1857 |     """Prepare and validate person update data for bulk update."""
1858 |     person_update_mappings = []
     |

dna_gedcom_crossref.py:400:48: ARG002 Unused method argument: `dna_matches`
    |
398 |         return suggestions[:5]  # Limit to top 5 suggestions
399 | 
400 |     def _identify_relationship_conflicts(self, dna_matches: list[DNAMatch], gedcom_people: list[GedcomPerson]):
    |                                                ^^^^^^^^^^^ ARG002
401 |         """Identify conflicts between DNA evidence and GEDCOM relationships."""
402 |         # This would implement conflict detection logic
    |

dna_gedcom_crossref.py:400:77: ARG002 Unused method argument: `gedcom_people`
    |
398 |         return suggestions[:5]  # Limit to top 5 suggestions
399 | 
400 |     def _identify_relationship_conflicts(self, dna_matches: list[DNAMatch], gedcom_people: list[GedcomPerson]):
    |                                                                             ^^^^^^^^^^^^^ ARG002
401 |         """Identify conflicts between DNA evidence and GEDCOM relationships."""
402 |         # This would implement conflict detection logic
    |

dna_gedcom_crossref.py:452:35: ARG002 Unused method argument: `person_record`
    |
450 |             return "Unknown Name"
451 | 
452 |     def _extract_birth_year(self, person_record) -> Optional[int]:
    |                                   ^^^^^^^^^^^^^ ARG002
453 |         """Extract birth year from GEDCOM record."""
454 |         # Placeholder implementation
    |

dna_gedcom_crossref.py:457:35: ARG002 Unused method argument: `person_record`
    |
455 |         return None
456 | 
457 |     def _extract_death_year(self, person_record) -> Optional[int]:
    |                                   ^^^^^^^^^^^^^ ARG002
458 |         """Extract death year from GEDCOM record."""
459 |         # Placeholder implementation
    |

dna_gedcom_crossref.py:462:36: ARG002 Unused method argument: `person_record`
    |
460 |         return None
461 | 
462 |     def _extract_birth_place(self, person_record) -> Optional[str]:
    |                                    ^^^^^^^^^^^^^ ARG002
463 |         """Extract birth place from GEDCOM record."""
464 |         # Placeholder implementation
    |

dna_gedcom_crossref.py:467:36: ARG002 Unused method argument: `person_record`
    |
465 |         return None
466 | 
467 |     def _extract_death_place(self, person_record) -> Optional[str]:
    |                                    ^^^^^^^^^^^^^ ARG002
468 |         """Extract death place from GEDCOM record."""
469 |         # Placeholder implementation
    |

dna_gedcom_crossref.py:492:48: ARG002 Unused method argument: `dna_match`
    |
490 |         return None
491 | 
492 |     def _is_plausible_relationship_match(self, dna_match: DNAMatch, gedcom_person: GedcomPerson, relationship_distance: int) -> bool:
    |                                                ^^^^^^^^^ ARG002
493 |         """Check if a relationship match is plausible."""
494 |         # Placeholder implementation
    |

dna_gedcom_crossref.py:492:69: ARG002 Unused method argument: `gedcom_person`
    |
490 |         return None
491 | 
492 |     def _is_plausible_relationship_match(self, dna_match: DNAMatch, gedcom_person: GedcomPerson, relationship_distance: int) -> bool:
    |                                                                     ^^^^^^^^^^^^^ ARG002
493 |         """Check if a relationship match is plausible."""
494 |         # Placeholder implementation
    |

dna_gedcom_crossref.py:492:98: ARG002 Unused method argument: `relationship_distance`
    |
490 |         return None
491 | 
492 |     def _is_plausible_relationship_match(self, dna_match: DNAMatch, gedcom_person: GedcomPerson, relationship_distance: int) -> bool:
    |                                                                                                  ^^^^^^^^^^^^^^^^^^^^^ ARG002
493 |         """Check if a relationship match is plausible."""
494 |         # Placeholder implementation
    |

extraction_quality.py:96:47: ARG001 Unused function argument: `lower`
   |
94 | _SPECIFIC_PATTERN_RE = re.compile(r"\b(census|manifest|marriage|birth|death|baptism|immigration|naturalization|military|obituary|probate|newspaper|ship|passenger|DNA|chromosome)\b", re.IGNORECASE)
95 | 
96 | def _calculate_positive_task_score(text: str, lower: str, words: set[str]) -> float:
   |                                               ^^^^^ ARG001
97 |     """Calculate positive scoring components for a task."""
98 |     score = 0.0
   |

gedcom_ai_integration.py:423:69: ARG002 Unused method argument: `extracted_data`
    |
421 |         return tasks
422 | 
423 |     def _fallback_research_tasks(self, person_data: dict[str, Any], extracted_data: dict[str, Any]) -> list[dict[str, Any]]:
    |                                                                     ^^^^^^^^^^^^^^ ARG002
424 |         """Generate fallback research tasks when GEDCOM AI is not available."""
425 |         return [
    |

gedcom_ai_integration.py:451:42: ARG002 Unused method argument: `person_identifier`
    |
449 |         return [opp for opp in opportunities if person_identifier in opp.get("target_people", [])]
450 | 
451 |     def _get_person_family_context(self, person_identifier: str, gedcom_data: Any) -> dict[str, Any]:
    |                                          ^^^^^^^^^^^^^^^^^ ARG002
452 |         """Get family context for a specific person."""
453 |         # This would extract family relationships and context
    |

gedcom_ai_integration.py:451:66: ARG002 Unused method argument: `gedcom_data`
    |
449 |         return [opp for opp in opportunities if person_identifier in opp.get("target_people", [])]
450 | 
451 |     def _get_person_family_context(self, person_identifier: str, gedcom_data: Any) -> dict[str, Any]:
    |                                                                  ^^^^^^^^^^^ ARG002
452 |         """Get family context for a specific person."""
453 |         # This would extract family relationships and context
    |

gedcom_ai_integration.py:456:70: ARG002 Unused method argument: `analysis`
    |
454 |         return {"family_context": "Analysis not yet implemented"}
455 | 
456 |     def _get_person_ai_recommendations(self, person_identifier: str, analysis: dict[str, Any]) -> list[str]:
    |                                                                      ^^^^^^^^ ARG002
457 |         """Get AI recommendations for a specific person."""
458 |         return [
    |

gedcom_intelligence.py:469:35: ARG002 Unused method argument: `person_record`
    |
467 |             return "Unknown Name"
468 | 
469 |     def _extract_birth_year(self, person_record) -> Optional[int]:
    |                                   ^^^^^^^^^^^^^ ARG002
470 |         """Extract birth year from GEDCOM record."""
471 |         try:
    |

gedcom_intelligence.py:478:35: ARG002 Unused method argument: `person_record`
    |
476 |             return None
477 | 
478 |     def _extract_death_year(self, person_record) -> Optional[int]:
    |                                   ^^^^^^^^^^^^^ ARG002
479 |         """Extract death year from GEDCOM record."""
480 |         try:
    |

gedcom_intelligence.py:486:36: ARG002 Unused method argument: `person_record`
    |
484 |             return None
485 | 
486 |     def _extract_birth_place(self, person_record) -> Optional[str]:
    |                                    ^^^^^^^^^^^^^ ARG002
487 |         """Extract birth place from GEDCOM record."""
488 |         try:
    |

gedcom_intelligence.py:494:36: ARG002 Unused method argument: `person_record`
    |
492 |             return None
493 | 
494 |     def _extract_death_place(self, person_record) -> Optional[str]:
    |                                    ^^^^^^^^^^^^^ ARG002
495 |         """Extract death place from GEDCOM record."""
496 |         try:
    |

gedcom_intelligence.py:553:41: ARG002 Unused method argument: `gedcom_data`
    |
551 |         return [surname for surname, count in sorted_surnames[:5]]
552 | 
553 |     def _find_geographic_patterns(self, gedcom_data: Any) -> list[str]:
    |                                         ^^^^^^^^^^^ ARG002
554 |         """Find geographic patterns in the family tree."""
555 |         # Placeholder implementation
    |

gedcom_intelligence.py:558:38: ARG002 Unused method argument: `gedcom_data`
    |
556 |         return ["Pattern analysis not yet implemented"]
557 | 
558 |     def _analyze_time_coverage(self, gedcom_data: Any) -> dict[str, Any]:
    |                                      ^^^^^^^^^^^ ARG002
559 |         """Analyze time period coverage of the family tree."""
560 |         # Placeholder implementation
    |

performance_orchestrator.py:534:28: ARG001 Unused function argument: `memory_threshold`
    |
532 | # ==============================================
533 | 
534 | def optimize_on_high_usage(memory_threshold: float = 85.0):
    |                            ^^^^^^^^^^^^^^^^ ARG001
535 |     """Decorator to automatically optimize performance when resource usage is high."""
536 |     def decorator(func: Callable) -> Callable:
    |

person_search.py:92:5: ARG001 Unused function argument: `gedcom_path`
   |
90 |     search_criteria: Optional[dict[str, Any]],
91 |     max_results: int = 10,
92 |     gedcom_path: Optional[str] = None,
   |     ^^^^^^^^^^^ ARG001
93 | ) -> list[dict[str, Any]]:
94 |     """
   |

person_search.py:165:5: ARG001 Unused function argument: `session_manager`
    |
163 |     person_id: Optional[str],
164 |     source: str = "auto",
165 |     session_manager: Optional[SessionManager] = None,
    |     ^^^^^^^^^^^^^^^ ARG001
166 |     gedcom_path: Optional[str] = None,
167 | ) -> dict[str, Any]:
    |

person_search.py:166:5: ARG001 Unused function argument: `gedcom_path`
    |
164 |     source: str = "auto",
165 |     session_manager: Optional[SessionManager] = None,
166 |     gedcom_path: Optional[str] = None,
    |     ^^^^^^^^^^^ ARG001
167 | ) -> dict[str, Any]:
168 |     """
    |

person_search.py:202:5: ARG001 Unused function argument: `source`
    |
200 |     person_id: Optional[str],
201 |     reference_id: Optional[str] = None,
202 |     source: str = "auto",
    |     ^^^^^^ ARG001
203 |     session_manager: Optional[SessionManager] = None,
204 |     gedcom_path: Optional[str] = None,
    |

person_search.py:203:5: ARG001 Unused function argument: `session_manager`
    |
201 |     reference_id: Optional[str] = None,
202 |     source: str = "auto",
203 |     session_manager: Optional[SessionManager] = None,
    |     ^^^^^^^^^^^^^^^ ARG001
204 |     gedcom_path: Optional[str] = None,
205 | ) -> str:
    |

person_search.py:204:5: ARG001 Unused function argument: `gedcom_path`
    |
202 |     source: str = "auto",
203 |     session_manager: Optional[SessionManager] = None,
204 |     gedcom_path: Optional[str] = None,
    |     ^^^^^^^^^^^ ARG001
205 | ) -> str:
206 |     """
    |

research_prioritization.py:496:56: ARG002 Unused method argument: `gedcom_analysis`
    |
494 |         ]
495 | 
496 |     def _identify_priority_targets(self, surname: str, gedcom_analysis: dict[str, Any]) -> list[str]:
    |                                                        ^^^^^^^^^^^^^^^ ARG002
497 |         """Identify priority research targets for this family line."""
498 |         return [
    |

research_prioritization.py:553:62: ARG002 Unused method argument: `items`
    |
551 |         return min(1.0, base_score + location_bonus)
552 | 
553 |     def _generate_cluster_research_plan(self, location: str, items: list[dict[str, Any]]) -> list[str]:
    |                                                              ^^^^^ ARG002
554 |         """Generate research plan for a location cluster."""
555 |         return [
    |

universal_scoring.py:171:5: ARG001 Unused function argument: `search_criteria`
    |
169 | def format_scoring_breakdown(
170 |     result: dict[str, Any],
171 |     search_criteria: dict[str, Any],
    |     ^^^^^^^^^^^^^^^ ARG001
172 |     title: str = "Scoring Breakdown"
173 | ) -> str:
    |

universal_scoring.py:231:28: ARG001 Unused function argument: `field_key`
    |
231 | def _get_field_description(field_key: str, score: float) -> str:
    |                            ^^^^^^^^^ ARG001
232 |     """Get description for a field score."""
233 |     if score >= 25:
    |

utils.py:482:5: ARG001 Unused function argument: `response`
    |
481 | def _handle_status_code_retry(
482 |     response: Any,
    |     ^^^^^^^^ ARG001
483 |     status_code: int,
484 |     retries: int,
    |

utils.py:2132:26: ARG001 Unused function argument: `driver`
     |
2130 | # Helper functions for handle_twoFA
2131 | 
2132 | def _wait_for_2fa_header(driver: WebDriver, element_wait: WebDriverWait, session_manager: SessionManager) -> bool:  # type: ignore
     |                          ^^^^^^ ARG001
2133 |     """Wait for 2FA page header to appear."""
2134 |     try:
     |

utils.py:3179:5: ARG001 Unused function argument: `attempt`
     |
3177 |     driver: WebDriver,  # type: ignore
3178 |     session_manager: SessionManagerType,
3179 |     attempt: int,
     |     ^^^^^^^ ARG001
3180 | ) -> Tuple[str, Optional[WebDriver]]:  # type: ignore
3181 |     """Handle WebDriver exception. Returns (action, driver) where action is 'continue' or 'fail'."""
     |

Found 64 errors.
