# --- START OF FILE action10.py ---

# action10.py
"""
Action 10: Find GEDCOM Matches and Relationship Path

Applies a hardcoded filter (OR logic) to the GEDCOM data (using pre-processed
cache), calculates a score for each filtered individual based on specific criteria,
displays the top 3 highest-scoring individuals (simplified format), identifies the
best match, and displays their relatives and relationship path to the reference person.
V.20240503.Refactored

Example output:
--------------
--- Top 3 Highest Scoring Matches ---
ID               | Name                           | Sex    | Birth Date        | Birth Place                     | Death Date        | Death Place                     | Total Score
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@I123@           | John Smith                     | M      | 1 JAN 1850        | New York, NY, USA               | 12 DEC 1910       | Boston, MA, USA                 | 95
@I456@           | Jonathan Smith                 | M      | 15 MAR 1848       | Albany, NY, USA                 | 23 NOV 1915       | Chicago, IL, USA               | 82
@I789@           | John Smithson                  | M      | 22 FEB 1855       | Brooklyn, NY, USA               | 30 JUL 1922       | Philadelphia, PA, USA          | 73
"""

# --- Standard library imports ---
import logging
import sys
import time
import argparse
from pathlib import Path
from typing import Optional, Dict, Any, List, Tuple, Union
from datetime import datetime, timezone

# --- Setup Fallback Logger FIRST ---
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger("action10_initial")

# --- Default Configuration ---
DEFAULT_CONFIG = {
    "DATE_FLEXIBILITY": {"year_match_range": 10},
    "COMMON_SCORING_WEIGHTS": {
        "first_name": 2.0,
        "surname": 3.0,
        "gender": 1.0,
        "birth_year": 2.0,
        "birth_place": 1.5,
        "death_year": 1.0,
        "death_place": 1.0,
    },
    "MAX_DISPLAY_RESULTS": 3,
}

# --- Local application imports ---
try:
    from config import config_instance
    from logging_config import setup_logging

    log_filename = "action10.log"
    if hasattr(config_instance, "LOG_DIR") and config_instance.LOG_DIR:
        log_filename = config_instance.LOG_DIR / "action10.log"
    else:
        log_filename = Path(__file__).parent / "action10.log"

    logger = setup_logging(log_file=str(log_filename), log_level="INFO")
    logger.info("Logging configured via setup_logging (Level: INFO).")

except ImportError as e:
    logger.critical(f"Failed to import configuration or logging setup: {e}")
    logger.warning("Continuing with basic logging configuration.")
    config_instance = None
except Exception as e:
    logger.critical(f"Unexpected error during logging setup: {e}", exc_info=True)
    logger.warning("Continuing with basic logging configuration.")
    config_instance = None

# Import GEDCOM utilities
try:
    from gedcom_utils import (
        GedcomData,
        _get_full_name,
        format_relative_info,
        calculate_match_score,
        _normalize_id,
    )
except ImportError as e:
    logger.critical(f"Failed to import gedcom_utils: {e}. Script cannot run.")
    sys.exit(1)
except Exception as e:
    logger.critical(f"Unexpected error importing gedcom_utils: {e}", exc_info=True)
    sys.exit(1)


# --- Helper Functions ---
def sanitize_input(value: str) -> Optional[str]:
    """Basic sanitization of user input."""
    if not value:
        return None
    # Remove leading/trailing whitespace
    sanitized = value.strip()
    return sanitized if sanitized else None


def get_validated_year_input(
    prompt: str, default: Optional[int] = None
) -> Optional[int]:
    """Get and validate a year input with optional default."""
    display_default = f" [{default}]" if default else " [YYYY]"
    value = input(f"{prompt}{display_default}: ").strip()

    if not value and default:
        return default

    if value.isdigit() and 1000 <= int(value) <= 2100:  # Reasonable year range
        return int(value)
    elif value:
        logger.warning(f"Invalid year input '{value}', ignoring.")

    return None


def parse_command_line_args() -> argparse.Namespace:
    """Parse command line arguments for the script."""
    parser = argparse.ArgumentParser(description="GEDCOM matching and analysis")
    parser.add_argument("--auto-input", nargs="+", help="Automated inputs for testing")
    parser.add_argument("--reference-id", help="Override reference person ID")
    parser.add_argument("--gedcom-file", help="Path to GEDCOM file")
    parser.add_argument(
        "--max-results", type=int, default=3, help="Maximum results to display"
    )
    return parser.parse_args()


def get_config_value(key: str, default_value: Any = None) -> Any:
    """Safely retrieve a configuration value with fallback."""
    if not config_instance:
        return default_value
    return getattr(config_instance, key, default_value)


def validate_config() -> Tuple[
    Optional[Path],
    Optional[str],
    Optional[str],
    Dict[str, Any],
    Dict[str, Any],
    int,
]:
    """Validate configuration and return essential values."""
    # Get and validate GEDCOM file path
    gedcom_file_path_config = get_config_value("GEDCOM_FILE_PATH")

    if (
        not gedcom_file_path_config
        or not isinstance(gedcom_file_path_config, Path)
        or not gedcom_file_path_config.is_file()
    ):
        logger.critical(
            f"GEDCOM file path missing or invalid: {gedcom_file_path_config}"
        )
        sys.exit(1)

    # Get reference person info
    reference_person_id_raw = get_config_value("REFERENCE_PERSON_ID")
    reference_person_name = get_config_value(
        "REFERENCE_PERSON_NAME", "Reference Person"
    )

    # Get scoring and date flexibility settings
    date_flex = get_config_value("DATE_FLEXIBILITY", DEFAULT_CONFIG["DATE_FLEXIBILITY"])
    scoring_weights = get_config_value(
        "COMMON_SCORING_WEIGHTS", DEFAULT_CONFIG["COMMON_SCORING_WEIGHTS"]
    )
    max_display_results = get_config_value(
        "MAX_DISPLAY_RESULTS", DEFAULT_CONFIG["MAX_DISPLAY_RESULTS"]
    )

    # Log configuration
    logger.info(
        f"Configured TREE_OWNER_NAME: {get_config_value('TREE_OWNER_NAME', 'Not Set')}"
    )
    logger.info(f"Configured REFERENCE_PERSON_ID: {reference_person_id_raw}")
    logger.info(f"Configured REFERENCE_PERSON_NAME: {reference_person_name}")
    logger.info(f"Using GEDCOM file: {gedcom_file_path_config.name}")

    return (
        gedcom_file_path_config,
        reference_person_id_raw,
        reference_person_name,
        date_flex,
        scoring_weights,
        max_display_results,
    )


def load_gedcom_data(gedcom_path: Path) -> GedcomData:
    """Load, parse, and pre-process GEDCOM data."""
    try:
        logger.info("Loading, parsing, and pre-processing GEDCOM data...")
        load_start_time = time.time()
        gedcom_data = GedcomData(gedcom_path)
        load_end_time = time.time()

        logger.info(
            f"GEDCOM data loaded & processed successfully in {load_end_time - load_start_time:.2f}s."
        )
        logger.info(f"  Index size: {len(getattr(gedcom_data, 'indi_index', {}))}")
        logger.info(
            f"  Pre-processed cache size: {len(getattr(gedcom_data, 'processed_data_cache', {}))}"
        )
        logger.info(
            f"  Build Times: Index={gedcom_data.indi_index_build_time:.2f}s, Maps={gedcom_data.family_maps_build_time:.2f}s, PreProcess={gedcom_data.data_processing_time:.2f}s"
        )

        if not gedcom_data.processed_data_cache or not gedcom_data.indi_index:
            logger.critical(
                "GEDCOM data object/cache/index is empty after loading attempt."
            )
            sys.exit(1)

        return gedcom_data

    except Exception as e:
        logger.critical(
            f"Failed to load or process GEDCOM file {gedcom_path.name}: {e}",
            exc_info=True,
        )
        sys.exit(1)


def get_user_criteria(
    args: Optional[argparse.Namespace] = None,
) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    """Get search criteria from user input or automated input args."""
    logger.info("\n--- Enter Search Criteria (Press Enter to skip optional fields) ---")

    # Use automated inputs if provided
    auto_inputs = getattr(args, "auto_input", None) if args else None
    auto_index = 0

    def get_input(prompt: str) -> str:
        """Get input from user or automated inputs."""
        nonlocal auto_index
        if auto_inputs and auto_index < len(auto_inputs):
            value = auto_inputs[auto_index]
            auto_index += 1
            logger.info(f"{prompt} {value}")
            return value
        return input(prompt).strip()

    # Get input with proper validation
    input_fname = sanitize_input(get_input("  First Name Contains:"))
    input_sname = sanitize_input(get_input("  Surname Contains:"))

    input_gender = sanitize_input(get_input("  Gender (M/F):"))
    gender_crit = (
        input_gender[0].lower()
        if input_gender and input_gender[0].lower() in ["m", "f"]
        else None
    )

    input_byear_str = get_input("  Birth Year (YYYY):")
    birth_year_crit = int(input_byear_str) if input_byear_str.isdigit() else None

    input_bplace = sanitize_input(get_input("  Birth Place Contains:"))

    input_dyear_str = get_input("  Death Year (YYYY) [Optional]:")
    death_year_crit = int(input_dyear_str) if input_dyear_str.isdigit() else None

    input_dplace = sanitize_input(get_input("  Death Place Contains [Optional]:"))

    # Create date objects based on year
    birth_date_obj_crit: Optional[datetime] = None
    if birth_year_crit:
        try:
            birth_date_obj_crit = datetime(birth_year_crit, 1, 1, tzinfo=timezone.utc)
        except ValueError:
            logger.warning(
                f"Cannot create date object for birth year {birth_year_crit}."
            )
            birth_year_crit = None

    death_date_obj_crit: Optional[datetime] = None
    if death_year_crit:
        try:
            death_date_obj_crit = datetime(death_year_crit, 1, 1, tzinfo=timezone.utc)
        except ValueError:
            logger.warning(
                f"Cannot create date object for death year {death_year_crit}."
            )
            death_year_crit = None

    # Build criteria dictionaries
    scoring_criteria = {
        "first_name": input_fname,
        "surname": input_sname,
        "gender": gender_crit,
        "birth_year": birth_year_crit,
        "birth_place": input_bplace,
        "birth_date_obj": birth_date_obj_crit,
        "death_year": death_year_crit,
        "death_place": input_dplace,
        "death_date_obj": death_date_obj_crit,
    }

    # Filter criteria often mirrors scoring, but could be different
    filter_criteria = {
        "first_name": scoring_criteria.get("first_name"),
        "surname": scoring_criteria.get("surname"),
        "gender": scoring_criteria.get("gender"),
        "birth_year": scoring_criteria.get("birth_year"),
        "birth_place": scoring_criteria.get("birth_place"),
    }

    return scoring_criteria, filter_criteria


def log_criteria_summary(
    scoring_criteria: Dict[str, Any], date_flex: Dict[str, Any]
) -> None:
    """Log summary of criteria to be used."""
    logger.info("\n--- Final Scoring Criteria Used ---")
    for k, v in scoring_criteria.items():
        if v is not None and k not in ["birth_date_obj", "death_date_obj"]:
            logger.info(f"  {k.replace('_',' ').title()}: '{v}'")

    year_range = date_flex.get("year_match_range", 10)
    logger.info(f"\n--- OR Filter Logic (Year Range: +/- {year_range}) ---")
    logger.info(f"  Individuals will be scored if ANY filter criteria met or if alive.")


def matches_criterion(
    criterion_name: str, filter_criteria: Dict[str, Any], candidate_value: Any
) -> bool:
    """Check if a candidate value matches a criterion."""
    criterion = filter_criteria.get(criterion_name)
    return bool(criterion and candidate_value and criterion in candidate_value)


def matches_year_criterion(
    criterion_name: str,
    filter_criteria: Dict[str, Any],
    candidate_value: Optional[int],
    year_range: int,
) -> bool:
    """Check if a candidate year matches a year criterion within range."""
    criterion = filter_criteria.get(criterion_name)
    return bool(
        criterion and candidate_value and abs(candidate_value - criterion) <= year_range
    )


def calculate_match_score_cached(
    search_criteria: Dict[str, Any],
    candidate_data: Dict[str, Any],
    scoring_weights: Dict[str, float],
    date_flex: Dict[str, Any],
    cache: Dict[Tuple, Any] = {},
) -> Tuple[float, Dict[str, float], Dict[str, Any]]:
    """Calculate match score with caching for performance."""
    # Create a hash key from the relevant parts of the inputs
    # We use a tuple of immutable representations of the data
    criterion_hash = tuple(
        sorted((k, str(v)) for k, v in search_criteria.items() if v is not None)
    )
    candidate_hash = tuple(
        sorted((k, str(v)) for k, v in candidate_data.items() if k in search_criteria)
    )
    cache_key = (criterion_hash, candidate_hash)

    if cache_key not in cache:
        cache[cache_key] = calculate_match_score(
            search_criteria=search_criteria,
            candidate_processed_data=candidate_data,
            scoring_weights=scoring_weights,
            date_flexibility=date_flex,
        )

    return cache[cache_key]


def filter_and_score_individuals(
    gedcom_data: GedcomData,
    filter_criteria: Dict[str, Any],
    scoring_criteria: Dict[str, Any],
    scoring_weights: Dict[str, Any],
    date_flex: Dict[str, Any],
) -> List[Dict[str, Any]]:
    """Filter and score individuals based on criteria."""
    logger.info(
        "\n--- Filtering and Scoring Individuals (using pre-processed data) ---"
    )
    processing_start_time = time.time()

    # Get the year range for matching from configuration
    year_range = date_flex.get("year_match_range", 10)

    # For caching match scores
    score_cache = {}
    scored_matches: List[Dict[str, Any]] = []

    # For progress tracking
    total_records = len(gedcom_data.processed_data_cache)
    processed = 0
    progress_interval = max(1, total_records // 10)  # Update every 10%

    logger.info(f"Processing {total_records} individuals from cache...")

    for indi_id_norm, indi_data in gedcom_data.processed_data_cache.items():
        processed += 1

        # Show progress updates
        if processed % progress_interval == 0:
            percent_done = (processed / total_records) * 100
            logger.info(
                f"Processing: {percent_done:.1f}% complete ({processed}/{total_records})"
            )

        try:
            # Extract needed values for filtering
            givn_lower = indi_data.get("first_name", "").lower()
            surn_lower = indi_data.get("surname", "").lower()
            sex_lower = indi_data.get("gender_norm")
            birth_year = indi_data.get("birth_year")
            birth_place_lower = (
                indi_data.get("birth_place_disp", "").lower()
                if indi_data.get("birth_place_disp")
                else None
            )
            death_date_obj = indi_data.get("death_date_obj")

            # Evaluate OR Filter
            fn_match_filter = matches_criterion(
                "first_name", filter_criteria, givn_lower
            )
            sn_match_filter = matches_criterion("surname", filter_criteria, surn_lower)
            gender_match_filter = bool(
                filter_criteria.get("gender")
                and sex_lower
                and filter_criteria["gender"] == sex_lower
            )
            bp_match_filter = matches_criterion(
                "birth_place", filter_criteria, birth_place_lower
            )
            by_match_filter = matches_year_criterion(
                "birth_year", filter_criteria, birth_year, year_range
            )
            alive_match = death_date_obj is None

            passes_or_filter = (
                fn_match_filter
                or sn_match_filter
                or gender_match_filter
                or bp_match_filter
                or by_match_filter
                or alive_match
            )

            if passes_or_filter:
                # Calculate match score with caching for performance
                total_score, _, _ = calculate_match_score_cached(
                    search_criteria=scoring_criteria,
                    candidate_data=indi_data,
                    scoring_weights=scoring_weights,
                    date_flex=date_flex,
                    cache=score_cache,
                )

                # Store results needed for display and analysis
                match_data = {
                    "id": indi_id_norm,
                    "display_id": indi_data.get("display_id", indi_id_norm),
                    "full_name_disp": indi_data.get("full_name_disp", "N/A"),
                    "total_score": total_score,
                    "gender": indi_data.get("gender_raw", "N/A"),
                    "birth_date": indi_data.get("birth_date_disp", "N/A"),
                    "birth_place": indi_data.get("birth_place_disp"),
                    "death_date": indi_data.get("death_date_disp"),
                    "death_place": indi_data.get("death_place_disp"),
                }
                scored_matches.append(match_data)

        except ValueError as ve:
            logger.error(f"Value error processing individual {indi_id_norm}: {ve}")
        except KeyError as ke:
            logger.error(f"Missing key for individual {indi_id_norm}: {ke}")
        except Exception as ex:
            logger.error(
                f"Error processing individual {indi_id_norm}: {ex}", exc_info=True
            )

    processing_duration = time.time() - processing_start_time
    logger.info(f"Filtering & Scoring completed in {processing_duration:.2f}s.")
    logger.info(
        f"Found {len(scored_matches)} individual(s) matching OR criteria and scored."
    )

    return sorted(scored_matches, key=lambda x: x["total_score"], reverse=True)


def format_display_value(value: Any, max_width: int) -> str:
    """Format a value for display, truncating if necessary."""
    if value is None:
        display = "N/A"
    elif isinstance(value, (int, float)):
        display = f"{value:.0f}"
    else:
        display = str(value)

    if len(display) > max_width:
        display = display[: max_width - 3] + "..."

    return display


def display_top_matches(
    scored_matches: List[Dict[str, Any]], max_results: int
) -> Optional[Dict[str, Any]]:
    """Display top matching results and return the top match."""
    logger.info(f"\n--- Top {max_results} Highest Scoring Matches ---")

    if not scored_matches:
        logger.info("No individuals matched the filter criteria or scored > 0.")
        return None

    display_matches = scored_matches[:max_results]
    logger.info(
        f"Displaying top {len(display_matches)} of {len(scored_matches)} scored matches:"
    )

    # Column Width Calculation - calculate once for all rows
    id_w = max(
        max((len(m.get("display_id", "")) for m in display_matches), default=15), 15
    )
    name_w = max(
        max((len(m.get("full_name_disp", "")) for m in display_matches), default=30), 30
    )
    gender_w = 6
    bdate_w = 18
    ddate_w = 18
    total_score_w = 11
    bplace_w = max(
        max((len(m.get("birth_place", "") or "") for m in display_matches), default=30),
        30,
    )
    dplace_w = max(
        max((len(m.get("death_place", "") or "") for m in display_matches), default=30),
        30,
    )

    # Header
    header = (
        f"{'ID':<{id_w}} | "
        f"{'Name':<{name_w}} | "
        f"{'Sex':<{gender_w}} | "
        f"{'Birth Date':<{bdate_w}} | "
        f"{'Birth Place':<{bplace_w}} | "
        f"{'Death Date':<{ddate_w}} | "
        f"{'Death Place':<{dplace_w}} | "
        f"{'Total Score':<{total_score_w}}"
    )
    logger.info(header)
    logger.info("-" * len(header))

    # Display rows
    for match in display_matches:
        name_disp = format_display_value(match.get("full_name_disp"), name_w)
        bplace_disp = format_display_value(match.get("birth_place"), bplace_w)
        dplace_disp = format_display_value(match.get("death_place"), dplace_w)

        total_score_val = match.get("total_score", "N/A")
        if isinstance(total_score_val, (int, float)):
            total_score_disp = f"{total_score_val:.0f}"
        else:
            total_score_disp = "N/A"

        row = (
            f"{match.get('display_id', 'N/A'):<{id_w}} | "
            f"{name_disp:<{name_w}} | "
            f"{match.get('gender', 'N/A'):<{gender_w}} | "
            f"{match.get('birth_date', 'N/A'):<{bdate_w}} | "
            f"{bplace_disp:<{bplace_w}} | "
            f"{match.get('death_date', 'N/A'):<{ddate_w}} | "
            f"{dplace_disp:<{dplace_w}} | "
            f"{total_score_disp:<{total_score_w}}"
        )
        logger.info(row)

    if len(scored_matches) > len(display_matches):
        logger.info(
            f"... and {len(scored_matches) - len(display_matches)} more matches not shown."
        )

    return scored_matches[0] if scored_matches else None


def display_relatives(gedcom_data: GedcomData, individual: Any) -> None:
    """Display relatives of the given individual."""
    relatives_data = {
        "Parents": gedcom_data.get_related_individuals(individual, "parents"),
        "Siblings": gedcom_data.get_related_individuals(individual, "siblings"),
        "Spouses": gedcom_data.get_related_individuals(individual, "spouses"),
        "Children": gedcom_data.get_related_individuals(individual, "children"),
    }

    for relation_type, relatives in relatives_data.items():
        if relatives:
            logger.info(f"    {relation_type}:")
            for relative in relatives:
                logger.info(format_relative_info(relative))
        else:
            logger.info(f"    {relation_type}: None found.")


def analyze_top_match(
    gedcom_data: GedcomData,
    top_match: Dict[str, Any],
    reference_person_id_norm: Optional[str],
    reference_person_name: str,
) -> None:
    """Analyze top match and find relationship path."""
    logger.info("\n--- Analysis of Top Match ---")

    top_match_norm_id = top_match.get("id")
    top_match_display_id = top_match.get("display_id", top_match_norm_id)
    top_match_indi = gedcom_data.find_individual_by_id(top_match_norm_id)

    if not top_match_indi:
        logger.error(
            f"Could not retrieve Individual record for top match ID: {top_match_norm_id}"
        )
        return

    logger.info(
        f"Best Match: {top_match.get('full_name_disp', 'N/A')} "
        f"(ID: {top_match_display_id}, Score: {top_match['total_score']:.0f})"
    )

    # Display relatives
    logger.info("\n  Relatives:")
    display_relatives(gedcom_data, top_match_indi)

    # Check for relationship path
    if not reference_person_id_norm:
        logger.warning(
            "REFERENCE_PERSON_ID not configured. Cannot calculate relationship path."
        )
        return

    if top_match_norm_id == reference_person_id_norm:
        logger.info(
            f"\n  Relationship Path: Top match is the reference person ({reference_person_name})."
        )
    else:
        logger.info(
            f"\n  Relationship Path to {reference_person_name} ({reference_person_id_norm}):"
        )
        relationship_explanation = gedcom_data.get_relationship_path(
            top_match_norm_id, reference_person_id_norm
        )
        for line in relationship_explanation.splitlines():
            logger.info(f"    {line}")


def main() -> None:
    """Main function to drive the action."""
    logger.info("--- Starting Action 10: User Input -> Filter -> Score -> Analyze ---")

    # Parse command line arguments
    args = parse_command_line_args()

    # 1. Validate configuration
    (
        gedcom_path,
        reference_person_id_raw,
        reference_person_name,
        date_flex,
        scoring_weights,
        max_display_results,
    ) = validate_config()

    # Override with command line arguments if provided
    if args.reference_id:
        reference_person_id_raw = args.reference_id
        logger.info(f"Overriding reference person ID with: {reference_person_id_raw}")

    if args.max_results:
        max_display_results = args.max_results
        logger.info(f"Overriding max display results with: {max_display_results}")

    if args.gedcom_file:
        gedcom_path = Path(args.gedcom_file)
        if not gedcom_path.is_file():
            logger.critical(f"Specified GEDCOM file not found: {gedcom_path}")
            sys.exit(1)
        logger.info(f"Overriding GEDCOM file with: {gedcom_path}")

    # 2. Load GEDCOM Data
    gedcom_data = load_gedcom_data(gedcom_path)

    # 3. Get search criteria from user
    scoring_criteria, filter_criteria = get_user_criteria(args)

    # 4. Log criteria summary
    log_criteria_summary(scoring_criteria, date_flex)

    # 5. Filter and score individuals
    scored_matches = filter_and_score_individuals(
        gedcom_data, filter_criteria, scoring_criteria, scoring_weights, date_flex
    )

    # 6. Display top results
    top_match = display_top_matches(scored_matches, max_display_results)

    # 7. Analyze top match if found
    if top_match:
        # Normalize reference ID
        reference_person_id_norm = (
            _normalize_id(reference_person_id_raw) if reference_person_id_raw else None
        )
        analyze_top_match(
            gedcom_data, top_match, reference_person_id_norm, reference_person_name
        )
    else:
        logger.info("\n--- No matches found to analyze. ---")

    logger.info("\n--- Action 10 Finished ---")


if __name__ == "__main__":
    main()
# End of action10.py
